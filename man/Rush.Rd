% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Rush.R
\name{Rush}
\alias{Rush}
\title{Rush Controller}
\description{
\link{Rush} is the controller in a centralized rush network.
The controller starts and stops the workers, pushes tasks to the workers and fetches results.
}
\section{Local Workers}{

A local worker runs on the same machine as the controller.
Local workers are are spawned with the \verb{$start_workers() method via the }processx` package.
}

\section{Remote Workers}{

A remote worker runs on a different machine than the controller.
Remote workers are started manually with the \verb{$create_worker_script()} method.
Remote workers can be started on any system as long as the system has access to Redis and all required packages are installed.
Only a heartbeat process can kill remote workers.
The heartbeat process also monitors the remote workers for crashes.
}

\section{Stopping Workers}{

Local and remote workers can be terminated with the \verb{$stop_workers(type = "terminate")} method.
The workers evaluate the currently running task and then terminate.
The option \code{type = "kill"} stops the workers immediately.
Killing a local worker is done with the \code{tools::pskill()} function.
Remote workers are killed by pushing a kill signal to the heartbeat process.
Without a heartbeat process a remote worker cannot be killed (see section heartbeat).
}

\section{Heartbeat}{

The heartbeat process periodically signals that a worker is still alive.
This is implemented by setting a \href{https://redis.io/commands/expire/}{timeout} on the heartbeat key.
Furthermore, the heartbeat process can kill the worker.
}

\section{Data Structure}{

Rush writes a task and its result and additional meta information into a Redis \href{https://redis.io/docs/data-types/hashes/}{hash}.

\if{html}{\out{<div class="sourceCode">}}\preformatted{key : xs | ys | extra | state
}\if{html}{\out{</div>}}

The key of the hash identifies the task in Rush.
The fields are written by different methods, e.g. \verb{$push_result()} writes \code{ys} when the result is available.
The value of a field is a serialized list e.g. unserializing \code{xs} gives \code{list(x1 = 1, x2 = 2)}.
This data structure allows to quickly convert a hash into a row and to join multiple hashes into a table.
For example, three hashes from the above example are converted to the following table.

\if{html}{\out{<div class="sourceCode">}}\preformatted{| key | x1 | x2 | y | timestamp | state   |
| 1.. |  3 |  4 | 7 |  12:04:11 | finished |
| 2.. |  1 |  4 | 5 |  12:04:12 | finished |
| 3.. |  1 |  1 | 2 |  12:04:13 | finished |
}\if{html}{\out{</div>}}

Notice that a value of a field can store multiple columns of the table.

The methods \verb{$push_tasks()} and \verb{$push_results()} write into multiple hashes.
For example, \verb{$push_tasks(xss = list(list(x1 = 1, x2 = 2), list(x1 = 2, x2 = 2))} writes \code{xs} in two hashes.
}

\section{Task States}{

A task can go through four states \code{"queued"}, \code{"running"}, \code{"finished"} or \code{"failed"}.
Internally, the keys of the tasks are pushed through Redis \href{https://redis.io/docs/data-types/lists/}{lists} and \href{https://redis.io/docs/data-types/sets/}{sets} to keep track of their state.
Queued tasks are waiting to be evaluated.
A worker pops a task from the queue and changes the state to \code{"running"} while evaluating the task.
When the task is finished, the state is changed to \verb{"finished" and the result is written to the data base. If the task fails, the state is changed to }"failed"\verb{instead of}"finished"`.
}

\section{Queues}{

Rush uses a shared queue and a queue for each worker.
The shared queue is used to push tasks to the workers.
The first worker that pops a task from the shared queue evaluates the task.
The worker queues are used to push tasks to specific workers.
}

\section{Fetch Tasks and Results}{

The \verb{$fetch_*()} methods retrieve data from the Redis database.
A matching method is defined for each task state e.g. \verb{$fetch_running_tasks()} and \verb{$fetch_finished_tasks()}.
If only the result of the function evaluation is needed, \verb{$fetch_results()} and \verb{$fetch_latest_results()} are faster.
The methods \verb{$fetch_results()} and \verb{$fetch_finished_tasks()} cache the already queried data.
The \verb{$block_*()} variants wait until a new result is available.
}

\section{Error Handling}{

When evaluating tasks in a distributed system, many things can go wrong.
Simple R errors in the worker loop are caught and written to the archive.
The task is marked as \code{"failed"}.
If the connection to a worker is lost, it looks like a task is \code{"running"} forever.
The methods \verb{$detect_lost_workers()} and \verb{$detect_lost_tasks()} detect lost workers.
Running these methods periodically adds a small overhead.
}

\section{Logging}{

The worker logs all messages written with the \code{lgr} package to the data base.
The \code{lgr_thresholds} argument defines the logging level for each logger e.g. \code{c(rush = "debug")}.
Saving log messages adds a small overhead but is useful for debugging.
By default, no log messages are stored.
}

\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{network_id}}{(\code{character(1)})\cr
Identifier of the rush network.}

\item{\code{config}}{(\link[redux:redis_config]{redux::redis_config})\cr
Redis configuration options.}

\item{\code{connector}}{(\link[redux:redis_api]{redux::redis_api})\cr
Returns a connection to Redis.}

\item{\code{processes}}{(\link[processx:process]{processx::process})\cr
List of processes started with \verb{$start_workers()}.}
}
\if{html}{\out{</div>}}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{n_workers}}{(\code{integer(1)})\cr
Number of workers.}

\item{\code{n_running_workers}}{(\code{integer(1)})\cr
Number of running workers.}

\item{\code{worker_ids}}{(\code{character()})\cr
Ids of workers.}

\item{\code{running_worker_ids}}{(\code{character()})\cr
Ids of running workers.}

\item{\code{terminated_worker_ids}}{(\code{character()})\cr
Ids of terminated workers.}

\item{\code{killed_worker_ids}}{(\code{character()})\cr
Ids of killed workers.}

\item{\code{lost_worker_ids}}{(\code{character()})\cr
Ids of lost workers.}

\item{\code{tasks}}{(\code{character()})\cr
Keys of all tasks.}

\item{\code{queued_tasks}}{(\code{character()})\cr
Keys of queued tasks.}

\item{\code{running_tasks}}{(\code{character()})\cr
Keys of running tasks.}

\item{\code{finished_tasks}}{(\code{character()})\cr
Keys of finished tasks.}

\item{\code{failed_tasks}}{(\code{character()})\cr
Keys of failed tasks.}

\item{\code{n_queued_tasks}}{(\code{integer(1)})\cr
Number of queued tasks.}

\item{\code{n_queued_priority_tasks}}{(\code{integer(1)})\cr
Number of queued priority tasks.}

\item{\code{n_running_tasks}}{(\code{integer(1)})\cr
Number of running tasks.}

\item{\code{n_finished_tasks}}{(\code{integer(1)})\cr
Number of finished tasks.}

\item{\code{n_failed_tasks}}{(\code{integer(1)})\cr
Number of failed tasks.}

\item{\code{n_tasks}}{(\code{integer(1)})\cr
Number of all tasks.}

\item{\code{data}}{(\link[data.table:data.table]{data.table::data.table})\cr
Contains all performed function calls.}

\item{\code{worker_info}}{(\code{\link[data.table:data.table]{data.table::data.table()}})\cr
Contains information about the workers.}

\item{\code{worker_states}}{(\code{\link[data.table:data.table]{data.table::data.table()}})\cr
Contains the states of the workers.}

\item{\code{priority_info}}{(\link[data.table:data.table]{data.table::data.table})\cr
Contains the number of tasks in the priority queues.}

\item{\code{snapshot_schedule}}{(\code{character()})\cr
Set a snapshot schedule to periodically save the data base on disk.
For example, \code{c(60, 1000)} saves the data base every 60 seconds if there are at least 1000 changes.
Overwrites the redis configuration file.
Set to \code{NULL} to disable snapshots.
For more details see \href{https://redis.io/docs/management/persistence/#snapshotting}{redis.io}.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-Rush-new}{\code{Rush$new()}}
\item \href{#method-Rush-format}{\code{Rush$format()}}
\item \href{#method-Rush-print}{\code{Rush$print()}}
\item \href{#method-Rush-start_workers}{\code{Rush$start_workers()}}
\item \href{#method-Rush-restart_workers}{\code{Rush$restart_workers()}}
\item \href{#method-Rush-create_worker_script}{\code{Rush$create_worker_script()}}
\item \href{#method-Rush-wait_for_workers}{\code{Rush$wait_for_workers()}}
\item \href{#method-Rush-stop_workers}{\code{Rush$stop_workers()}}
\item \href{#method-Rush-detect_lost_workers}{\code{Rush$detect_lost_workers()}}
\item \href{#method-Rush-reset}{\code{Rush$reset()}}
\item \href{#method-Rush-read_log}{\code{Rush$read_log()}}
\item \href{#method-Rush-push_tasks}{\code{Rush$push_tasks()}}
\item \href{#method-Rush-push_priority_tasks}{\code{Rush$push_priority_tasks()}}
\item \href{#method-Rush-fetch_latest_results}{\code{Rush$fetch_latest_results()}}
\item \href{#method-Rush-wait_for_latest_results}{\code{Rush$wait_for_latest_results()}}
\item \href{#method-Rush-fetch_results}{\code{Rush$fetch_results()}}
\item \href{#method-Rush-fetch_queued_tasks}{\code{Rush$fetch_queued_tasks()}}
\item \href{#method-Rush-fetch_priority_tasks}{\code{Rush$fetch_priority_tasks()}}
\item \href{#method-Rush-fetch_running_tasks}{\code{Rush$fetch_running_tasks()}}
\item \href{#method-Rush-fetch_finished_tasks}{\code{Rush$fetch_finished_tasks()}}
\item \href{#method-Rush-wait_for_finished_tasks}{\code{Rush$wait_for_finished_tasks()}}
\item \href{#method-Rush-fetch_failed_tasks}{\code{Rush$fetch_failed_tasks()}}
\item \href{#method-Rush-fetch_tasks}{\code{Rush$fetch_tasks()}}
\item \href{#method-Rush-wait_for_tasks}{\code{Rush$wait_for_tasks()}}
\item \href{#method-Rush-write_hashes}{\code{Rush$write_hashes()}}
\item \href{#method-Rush-read_hashes}{\code{Rush$read_hashes()}}
\item \href{#method-Rush-n_tries}{\code{Rush$n_tries()}}
\item \href{#method-Rush-clone}{\code{Rush$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Rush-new"></a>}}
\if{latex}{\out{\hypertarget{method-Rush-new}{}}}
\subsection{Method \code{new()}}{
Creates a new instance of this \link[R6:R6Class]{R6} class.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Rush$new(network_id = NULL, config = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{network_id}}{(\code{character(1)})\cr
Identifier of the rush network.
Controller and workers must have the same instance id.
Keys in Redis are prefixed with the instance id.}

\item{\code{config}}{(\link[redux:redis_config]{redux::redis_config})\cr
Redis configuration options.
If \code{NULL}, configuration set by \code{\link[=rush_plan]{rush_plan()}} is used.
If \code{rush_plan()} has not been called, the \code{REDIS_URL} environment variable is parsed.
If \code{REDIS_URL} is not set, a default configuration is used.
See \link[redux:redis_config]{redux::redis_config} for details.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Rush-format"></a>}}
\if{latex}{\out{\hypertarget{method-Rush-format}{}}}
\subsection{Method \code{format()}}{
Helper for print outputs.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Rush$format(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{(ignored).}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
(\code{character()}).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Rush-print"></a>}}
\if{latex}{\out{\hypertarget{method-Rush-print}{}}}
\subsection{Method \code{print()}}{
Print method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Rush$print()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
(\code{character()}).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Rush-start_workers"></a>}}
\if{latex}{\out{\hypertarget{method-Rush-start_workers}{}}}
\subsection{Method \code{start_workers()}}{
Start workers locally with \code{processx}.
The \link[processx:process]{processx::process} are stored in \verb{$processes}.
Alternatively, use \verb{$create_worker_script()} to create a script for starting workers on remote machines.
By default, \code{\link[=worker_loop_default]{worker_loop_default()}} is used as worker loop.
This function takes the arguments \code{fun} and optionally \code{constants} which are passed in \code{...}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Rush$start_workers(
  n_workers = NULL,
  wait_for_workers = TRUE,
  globals = NULL,
  packages = NULL,
  heartbeat_period = NULL,
  heartbeat_expire = NULL,
  lgr_thresholds = NULL,
  lgr_buffer_size = 0,
  max_tries = 0,
  seed = NULL,
  supervise = TRUE,
  worker_loop = worker_loop_default,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n_workers}}{(\code{integer(1)})\cr
Number of workers to be started.}

\item{\code{wait_for_workers}}{(\code{logical(1)})\cr
Whether to wait until all workers are available.}

\item{\code{globals}}{(\code{character()})\cr
Global variables to be loaded to the workers global environment.}

\item{\code{packages}}{(\code{character()})\cr
Packages to be loaded by the workers.}

\item{\code{heartbeat_period}}{(\code{integer(1)})\cr
Period of the heartbeat in seconds.}

\item{\code{heartbeat_expire}}{(\code{integer(1)})\cr
Time to live of the heartbeat in seconds.}

\item{\code{lgr_thresholds}}{(named \code{character()} | named \code{numeric()})\cr
Logger threshold on the workers e.g. \code{c(rush = "debug")}.}

\item{\code{lgr_buffer_size}}{(\code{integer(1)})\cr
By default (\code{lgr_buffer_size = 0}), the log messages are directly saved in the Redis data store.
If \code{lgr_buffer_size > 0}, the log messages are buffered and saved in the Redis data store when the buffer is full.
This improves the performance of the logging.}

\item{\code{max_tries}}{(\code{integer(1)})\cr
Maximum number of tries for a task before it is considered failed.}

\item{\code{seed}}{(\code{integer(1)})\cr
Seed for the random number generator.}

\item{\code{supervise}}{(\code{logical(1)})\cr
Whether to kill the workers when the main R process is shut down.}

\item{\code{worker_loop}}{(\code{function})\cr
Loop run on the workers.
Defaults to \link{worker_loop_default} which is called with \code{fun}.
Pass \code{fun} in \code{...}.}

\item{\code{...}}{(\code{any})\cr
Arguments passed to \code{worker_loop}.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Rush-restart_workers"></a>}}
\if{latex}{\out{\hypertarget{method-Rush-restart_workers}{}}}
\subsection{Method \code{restart_workers()}}{
Restart workers.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Rush$restart_workers(worker_ids)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{worker_ids}}{(\code{character()})\cr
Worker ids to be restarted.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Rush-create_worker_script"></a>}}
\if{latex}{\out{\hypertarget{method-Rush-create_worker_script}{}}}
\subsection{Method \code{create_worker_script()}}{
Create script to start workers.
The worker is started with \code{\link[=start_worker]{start_worker()}}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Rush$create_worker_script(
  globals = NULL,
  packages = NULL,
  heartbeat_period = NULL,
  heartbeat_expire = NULL,
  lgr_thresholds = NULL,
  lgr_buffer_size = 0,
  worker_loop = worker_loop_default,
  ...
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{globals}}{(\code{character()})\cr
Global variables to be loaded to the workers global environment.}

\item{\code{packages}}{(\code{character()})\cr
Packages to be loaded by the workers.}

\item{\code{heartbeat_period}}{(\code{integer(1)})\cr
Period of the heartbeat in seconds.}

\item{\code{heartbeat_expire}}{(\code{integer(1)})\cr
Time to live of the heartbeat in seconds.}

\item{\code{lgr_thresholds}}{(named \code{character()} | named \code{numeric()})\cr
Logger threshold on the workers e.g. \code{c(rush = "debug")}.}

\item{\code{lgr_buffer_size}}{(\code{integer(1)})\cr
By default (\code{lgr_buffer_size = 0}), the log messages are directly saved in the Redis data store.
If \code{lgr_buffer_size > 0}, the log messages are buffered and saved in the Redis data store when the buffer is full.
This improves the performance of the logging.}

\item{\code{worker_loop}}{(\code{function})\cr
Loop run on the workers.
Defaults to \link{worker_loop_default} which is called with \code{fun}.
Pass \code{fun} in \code{...}.}

\item{\code{...}}{(\code{any})\cr
Arguments passed to \code{worker_loop}.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Rush-wait_for_workers"></a>}}
\if{latex}{\out{\hypertarget{method-Rush-wait_for_workers}{}}}
\subsection{Method \code{wait_for_workers()}}{
Wait until \code{n} workers are available.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Rush$wait_for_workers(n)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n}}{(\code{integer(1)})\cr
Number of workers to wait for.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Rush-stop_workers"></a>}}
\if{latex}{\out{\hypertarget{method-Rush-stop_workers}{}}}
\subsection{Method \code{stop_workers()}}{
Stop workers.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Rush$stop_workers(type = "terminate", worker_ids = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{type}}{(\code{character(1)})\cr
Type of stopping.
Either \code{"terminate"} or \code{"kill"}.
If \code{"terminate"} the workers evaluate the currently running task and then terminate.
If \code{"kill"} the workers are stopped immediately.}

\item{\code{worker_ids}}{(\code{character()})\cr
Worker ids to be stopped.
If \code{NULL} all workers are stopped.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Rush-detect_lost_workers"></a>}}
\if{latex}{\out{\hypertarget{method-Rush-detect_lost_workers}{}}}
\subsection{Method \code{detect_lost_workers()}}{
Detect lost workers.
The state of the worker is changed to \code{"lost"}.
Local workers without a heartbeat are checked by their process id.
Checking local workers on unix systems only takes a few microseconds per worker.
But checking local workers on windows might be very slow.
Workers with a heartbeat process are checked with the heartbeat.
Lost tasks are marked as \code{"lost"}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Rush$detect_lost_workers(restart_workers = FALSE, restart_tasks = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{restart_workers}}{(\code{logical(1)})\cr
Whether to restart lost workers.}

\item{\code{restart_tasks}}{(\code{logical(1)})\cr
Whether to restart lost tasks.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Rush-reset"></a>}}
\if{latex}{\out{\hypertarget{method-Rush-reset}{}}}
\subsection{Method \code{reset()}}{
Stop workers and delete data stored in redis.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Rush$reset(type = "kill")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{type}}{(\code{character(1)})\cr
Type of stopping.
Either \code{"terminate"} or \code{"kill"}.
If \code{"terminate"} the workers evaluate the currently running task and then terminate.
If \code{"kill"} the workers are stopped immediately.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Rush-read_log"></a>}}
\if{latex}{\out{\hypertarget{method-Rush-read_log}{}}}
\subsection{Method \code{read_log()}}{
Read log messages written with the \code{lgr} package from a worker.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Rush$read_log(worker_ids = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{worker_ids}}{(\code{character(1)})\cr
Worker ids.
If \code{NULL} all worker ids are used.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Rush-push_tasks"></a>}}
\if{latex}{\out{\hypertarget{method-Rush-push_tasks}{}}}
\subsection{Method \code{push_tasks()}}{
Pushes a task to the queue.
Task is added to queued tasks.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Rush$push_tasks(xss, extra = NULL, terminate_workers = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{xss}}{(list of named \code{list()})\cr
Lists of arguments for the function e.g. \verb{list(list(x1, x2), list(x1, x2)))}.}

\item{\code{extra}}{(\code{list})\cr
List of additional information stored along with the task e.g. \verb{list(list(timestamp), list(timestamp)))}.}

\item{\code{terminate_workers}}{(\code{logical(1)})\cr
Whether to stop the workers after evaluating the tasks.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
(\code{character()})\cr
Keys of the tasks.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Rush-push_priority_tasks"></a>}}
\if{latex}{\out{\hypertarget{method-Rush-push_priority_tasks}{}}}
\subsection{Method \code{push_priority_tasks()}}{
Pushes a task to the queue of a specific worker.
Task is added to queued priority tasks.
A worker evaluates the tasks in the priority queue before the shared queue.
If \code{priority} is \code{NA} the task is added to the shared queue.
If the worker is lost or worker id is not known, the task is added to the shared queue.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Rush$push_priority_tasks(xss, extra = NULL, priority = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{xss}}{(list of named \code{list()})\cr
Lists of arguments for the function e.g. \verb{list(list(x1, x2), list(x1, x2)))}.}

\item{\code{extra}}{(\code{list})\cr
List of additional information stored along with the task e.g. \verb{list(list(timestamp), list(timestamp)))}.}

\item{\code{priority}}{(\code{character()})\cr
Worker ids to which the tasks should be pushed.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
(\code{character()})\cr
Keys of the tasks.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Rush-fetch_latest_results"></a>}}
\if{latex}{\out{\hypertarget{method-Rush-fetch_latest_results}{}}}
\subsection{Method \code{fetch_latest_results()}}{
Fetch latest results from the data base.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Rush$fetch_latest_results(fields = "ys", data_format = "data.table")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{fields}}{(\code{character()})\cr
Fields to be read from the hashes.}

\item{\code{data_format}}{(\code{character()})\cr
Returned data format.
Choose \code{"data.table"} or "list".
The default is \code{"data.table"} but \code{"list"} is easier when list columns are present.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{data.table()}\cr
Latest results.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Rush-wait_for_latest_results"></a>}}
\if{latex}{\out{\hypertarget{method-Rush-wait_for_latest_results}{}}}
\subsection{Method \code{wait_for_latest_results()}}{
Block process until a new result is available.
Returns latest results or \code{NULL} if no result is available after \code{timeout} seconds.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Rush$wait_for_latest_results(
  fields = "ys",
  timeout = Inf,
  data_format = "data.table"
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{fields}}{(\code{character()})\cr
Fields to be read from the hashes.}

\item{\code{timeout}}{(\code{numeric(1)})\cr
Time to wait for a result in seconds.}

\item{\code{data_format}}{(\code{character()})\cr
Returned data format.
Choose \code{"data.table"} or "list".
The default is \code{"data.table"} but \code{"list"} is easier when list columns are present.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{data.table()}\cr
Latest results.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Rush-fetch_results"></a>}}
\if{latex}{\out{\hypertarget{method-Rush-fetch_results}{}}}
\subsection{Method \code{fetch_results()}}{
Fetch results from the data base.
Results are cached.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Rush$fetch_results(
  fields = "ys",
  reset_cache = FALSE,
  data_format = "data.table"
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{fields}}{(\code{character()})\cr
Fields to be read from the hashes.
Defaults to \code{"ys"}.}

\item{\code{reset_cache}}{(\code{logical(1)})\cr
Whether to reset the cache.}

\item{\code{data_format}}{(\code{character()})\cr
Returned data format.
Choose \code{"data.table"} or "list".
The default is \code{"data.table"} but \code{"list"} is easier when list columns are present.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{data.table()}
Results.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Rush-fetch_queued_tasks"></a>}}
\if{latex}{\out{\hypertarget{method-Rush-fetch_queued_tasks}{}}}
\subsection{Method \code{fetch_queued_tasks()}}{
Fetch queued tasks from the data base.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Rush$fetch_queued_tasks(
  fields = c("xs", "xs_extra"),
  data_format = "data.table"
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{fields}}{(\code{character()})\cr
Fields to be read from the hashes.
Defaults to \code{c("xs", "xs_extra")}.}

\item{\code{data_format}}{(\code{character()})\cr
Returned data format.
Choose \code{"data.table"} or "list".
The default is \code{"data.table"} but \code{"list"} is easier when list columns are present.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{data.table()}\cr
Table of queued tasks.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Rush-fetch_priority_tasks"></a>}}
\if{latex}{\out{\hypertarget{method-Rush-fetch_priority_tasks}{}}}
\subsection{Method \code{fetch_priority_tasks()}}{
Fetch queued priority tasks from the data base.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Rush$fetch_priority_tasks(
  fields = c("xs", "xs_extra"),
  data_format = "data.table"
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{fields}}{(\code{character()})\cr
Fields to be read from the hashes.
Defaults to \code{c("xs", "xs_extra")}.}

\item{\code{data_format}}{(\code{character()})\cr
Returned data format.
Choose \code{"data.table"} or "list".
The default is \code{"data.table"} but \code{"list"} is easier when list columns are present.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{data.table()}\cr
Table of queued priority tasks.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Rush-fetch_running_tasks"></a>}}
\if{latex}{\out{\hypertarget{method-Rush-fetch_running_tasks}{}}}
\subsection{Method \code{fetch_running_tasks()}}{
Fetch running tasks from the data base.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Rush$fetch_running_tasks(
  fields = c("xs", "xs_extra", "worker_extra"),
  data_format = "data.table"
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{fields}}{(\code{character()})\cr
Fields to be read from the hashes.
Defaults to \code{c("xs", "xs_extra", "worker_extra")}.}

\item{\code{data_format}}{(\code{character()})\cr
Returned data format.
Choose \code{"data.table"} or "list".
The default is \code{"data.table"} but \code{"list"} is easier when list columns are present.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{data.table()}\cr
Table of running tasks.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Rush-fetch_finished_tasks"></a>}}
\if{latex}{\out{\hypertarget{method-Rush-fetch_finished_tasks}{}}}
\subsection{Method \code{fetch_finished_tasks()}}{
Fetch finished tasks from the data base.
Finished tasks are cached.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Rush$fetch_finished_tasks(
  fields = c("xs", "ys", "xs_extra", "worker_extra", "ys_extra"),
  reset_cache = FALSE,
  data_format = "data.table"
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{fields}}{(\code{character()})\cr
Fields to be read from the hashes.
Defaults to \code{c("xs", "xs_extra", "worker_extra", "ys", "ys_extra")}.}

\item{\code{reset_cache}}{(\code{logical(1)})\cr
Whether to reset the cache.}

\item{\code{data_format}}{(\code{character()})\cr
Returned data format.
Choose \code{"data.table"} or "list".
The default is \code{"data.table"} but \code{"list"} is easier when list columns are present.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{data.table()}\cr
Table of finished tasks.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Rush-wait_for_finished_tasks"></a>}}
\if{latex}{\out{\hypertarget{method-Rush-wait_for_finished_tasks}{}}}
\subsection{Method \code{wait_for_finished_tasks()}}{
Block process until a new finished task is available.
Returns all finished tasks or \code{NULL} if no new task is available after \code{timeout} seconds.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Rush$wait_for_finished_tasks(
  fields = c("xs", "ys", "xs_extra", "worker_extra", "ys_extra"),
  timeout = Inf,
  data_format = "data.table"
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{fields}}{(\code{character()})\cr
Fields to be read from the hashes.
Defaults to \code{c("xs", "xs_extra", "worker_extra", "ys", "ys_extra")}.}

\item{\code{timeout}}{(\code{numeric(1)})\cr
Time to wait for a result in seconds.}

\item{\code{data_format}}{(\code{character()})\cr
Returned data format.
Choose \code{"data.table"} or "list".
The default is \code{"data.table"} but \code{"list"} is easier when list columns are present.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{data.table()}\cr
Table of finished tasks.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Rush-fetch_failed_tasks"></a>}}
\if{latex}{\out{\hypertarget{method-Rush-fetch_failed_tasks}{}}}
\subsection{Method \code{fetch_failed_tasks()}}{
Fetch failed tasks from the data base.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Rush$fetch_failed_tasks(
  fields = c("xs", "worker_extra", "condition"),
  data_format = "data.table"
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{fields}}{(\code{character()})\cr
Fields to be read from the hashes.
Defaults to \verb{c("xs", "xs_extra", "worker_extra", "condition"}.}

\item{\code{data_format}}{(\code{character()})\cr
Returned data format.
Choose \code{"data.table"} or "list".
The default is \code{"data.table"} but \code{"list"} is easier when list columns are present.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{data.table()}\cr
Table of failed tasks.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Rush-fetch_tasks"></a>}}
\if{latex}{\out{\hypertarget{method-Rush-fetch_tasks}{}}}
\subsection{Method \code{fetch_tasks()}}{
Fetch all tasks from the data base.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Rush$fetch_tasks(
  fields = c("xs", "ys", "xs_extra", "worker_extra", "ys_extra", "condition", "state"),
  data_format = "data.table"
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{fields}}{(\code{character()})\cr
Fields to be read from the hashes.
Defaults to \code{c("xs", "xs_extra", "worker_extra", "ys", "ys_extra", "condition", "state")}.}

\item{\code{data_format}}{(\code{character()})\cr
Returned data format.
Choose \code{"data.table"} or "list".
The default is \code{"data.table"} but \code{"list"} is easier when list columns are present.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
\code{data.table()}\cr
Table of all tasks.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Rush-wait_for_tasks"></a>}}
\if{latex}{\out{\hypertarget{method-Rush-wait_for_tasks}{}}}
\subsection{Method \code{wait_for_tasks()}}{
Wait until tasks are finished.
The function also unblocks when no worker is running or all tasks failed.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Rush$wait_for_tasks(keys, detect_lost_workers = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{keys}}{(\code{character()})\cr
Keys of the tasks to wait for.}

\item{\code{detect_lost_workers}}{(\code{logical(1)})\cr
Whether to detect failed tasks.
Comes with an overhead.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Rush-write_hashes"></a>}}
\if{latex}{\out{\hypertarget{method-Rush-write_hashes}{}}}
\subsection{Method \code{write_hashes()}}{
Writes a list to redis hashes.
The function serializes each element and writes it to a new hash.
The name of the argument defines the field into which the serialized element is written.
For example, \code{xs = list(list(x1 = 1, x2 = 2), list(x1 = 3, x2 = 4))} writes \code{serialize(list(x1 = 1, x2 = 2))} at field \code{xs} into a hash and \code{serialize(list(x1 = 3, x2 = 4))} at field \code{xs} into another hash.
The function can iterate over multiple lists simultaneously.
For example, \verb{xs = list(list(x1 = 1, x2 = 2), list(x1 = 3, x2 = 4)), ys = list(list(y = 3), list(y = 7))} creates two hashes with the fields \code{xs} and \code{ys}.
Different lengths are recycled.
The stored elements must be lists themselves.
The reading functions combine the hashes to a table where the names of the inner lists are the column names.
For example, \verb{xs = list(list(x1 = 1, x2 = 2), list(x1 = 3, x2 = 4)), ys = list(list(y = 3), list(y = 7))} becomes \code{data.table(x1 = c(1, 3), x2 = c(2, 4), y = c(3, 7))}.
Vectors in list columns must be wrapped in lists.
Otherwise, \verb{$read_values()} will expand the table by the length of the vectors.
For example, \verb{xs = list(list(x1 = 1, x2 = 2)), xs_extra = list(list(extra = c("A", "B", "C"))) does not work. Pass }xs_extra = list(list(extra = list(c("A", "B", "C"))))` instead.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Rush$write_hashes(..., .values = list(), keys = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{(named \code{list()})\cr
Lists to be written to the hashes.
The names of the arguments are used as fields.}

\item{\code{.values}}{(named \code{list()})\cr
Lists to be written to the hashes.
The names of the list are used as fields.}

\item{\code{keys}}{(character())\cr
Keys of the hashes.
If \code{NULL} new keys are generated.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
(\code{character()})\cr
Keys of the hashes.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Rush-read_hashes"></a>}}
\if{latex}{\out{\hypertarget{method-Rush-read_hashes}{}}}
\subsection{Method \code{read_hashes()}}{
Reads redis hashes written with \verb{$write_hashes()}.
The function reads the values of the \code{fields} in the hashes stored at \code{keys}.
The values of a hash are deserialized and combined into a single list.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Rush$read_hashes(keys, fields)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{keys}}{(\code{character()})\cr
Keys of the hashes.}

\item{\code{fields}}{(\code{character()})\cr
Fields to be read from the hashes.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
(list of \code{list()})\cr
The outer list contains one element for each key.
The inner list is the combination of the lists stored at the different fields.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Rush-n_tries"></a>}}
\if{latex}{\out{\hypertarget{method-Rush-n_tries}{}}}
\subsection{Method \code{n_tries()}}{
Returns the number of attempts to evaluate a task.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Rush$n_tries(keys)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{keys}}{(\code{character()})\cr
Keys of the tasks.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
(\code{integer()})\cr
Number of attempts.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Rush-clone"></a>}}
\if{latex}{\out{\hypertarget{method-Rush-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Rush$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
