---
title: "Task Queue"
vignette: >
  %\VignetteIndexEntry{Task Queue}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
---

# Scope

*rush* can also be used as a centralized network with a task queue.
In such a network, a central controller creates tasks and distributes them to the workers.
The workers evaluate the tasks and send the results back to the controller.
At the heart of a centralized network is a **queue** that holds the tasks to be evaluated.
The controller pushes tasks to the queue with  `$push_tasks()` and the workers pop tasks from the queue with `$pop_task()`.

# Simple Task Queue

The `worker_loop` is different in a centralized network.
Instead of creating new tasks, the worker pops tasks from the queue.
The task is evaluated and the results are sent to the data base with `push_results()`.

```{r}
worker_loop = function(rush) {
  while(!rush$terminated) {
    task = rush$pop_task()
    if (!is.null(task)) {
      ys = list(y = branin(task$xs$x1, task$xs$x2))
      rush$push_results(task$key, yss = list(ys))
    }
  }
}
```

We work again with the Branin function from the [decentralized network](rush.html) article.

```{r}
branin = function(x1, x2) {
  (x2 - 5.1 / (4 * pi^2) * x1^2 + 5 / pi * x1 - 6)^2 + 10 * (1 - 1 / (8 * pi)) * cos(x1) + 10
}
```

We start the workers.

```{r}
# Connection to the Redis database
config = redux::redis_config()

# Initialize rush controller
rush = rsh(
  network = "centralized-random-search",
  config = config)

worker_ids = rush$start_local_workers(
  worker_loop = worker_loop,
  n_workers = 4,
  globals = "branin")
```

We push a tasks to the queue.

```{r}
xs = list(x1 = runif(1, -5, 10), x2 = runif(1, 0, 15))

rush$push_tasks(xss = list(xs))
```

After a second we fetch the result.

```{r}
Sys.sleep(1)
rush$fetch_finished_tasks()
```

We can also push multiple tasks to the queue.

```{r}
xss = replicate(100, list(x1 = runif(1, -5, 10), x2 = runif(1, 0, 15)), simplify = FALSE)

rush$push_tasks(xss = xss)
```

```{r}
Sys.sleep(1)
rush$fetch_finished_tasks()
```

# Priority Queues

The controller can also push tasks to specific workers with the `$push_priority_tasks()` method.
The workers pop tasks from this queue with the higher priority than the shared queue.
The `priority` argument specifies the worker that should evaluate the task.

```{r}
xs = list(x1 = runif(1, -5, 10), x2 = runif(1, 0, 15))

rush$push_priority_tasks(xss = list(xs), priority = worker_ids[1])
```
