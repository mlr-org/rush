[11:41:45.539] plan(): Setting new future strategy stack:
[11:41:45.539] List of future strategies:
[11:41:45.539] 1. multisession:
[11:41:45.539]    - args: function (..., workers = 2, envir = parent.frame())
[11:41:45.539]    - tweaked: TRUE
[11:41:45.539]    - call: future::plan("multisession", workers = 2)
[11:41:45.539] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[11:41:45.539] multisession:
[11:41:45.539] - args: function (..., workers = 2, envir = parent.frame())
[11:41:45.539] - tweaked: TRUE
[11:41:45.539] - call: future::plan("multisession", workers = 2)
[11:41:45.540] getGlobalsAndPackages() ...
[11:41:45.540] Not searching for globals
[11:41:45.540] - globals: [0] <none>
[11:41:45.540] getGlobalsAndPackages() ... DONE
[11:41:45.540] [local output] makeClusterPSOCK() ...
[11:41:45.540] [local output] Workers: [n = 2] ‘localhost’, ‘localhost’
[11:41:45.541] [local output] Base port: 11110
[11:41:45.541] [local output] Getting setup options for 2 cluster nodes ...
[11:41:45.541] [local output]  - Node 1 of 2 ...
[11:41:45.541] [local output] localMachine=TRUE => revtunnel=FALSE

[11:41:45.542] [local output] Rscript port: 11110

[11:41:45.546] [local output]  - Node 2 of 2 ...
[11:41:45.546] [local output] localMachine=TRUE => revtunnel=FALSE

[11:41:45.547] [local output] Rscript port: 11110

[11:41:45.547] [local output] Getting setup options for 2 cluster nodes ... done
[11:41:45.548] [local output]  - Parallel setup requested for some PSOCK nodes
[11:41:45.548] [local output] Setting up PSOCK nodes in parallel
[11:41:45.548] List of 36
[11:41:45.548]  $ worker          : chr "localhost"
[11:41:45.548]   ..- attr(*, "localhost")= logi TRUE
[11:41:45.548]  $ master          : chr "localhost"
[11:41:45.548]  $ port            : int 11110
[11:41:45.548]  $ connectTimeout  : num 120
[11:41:45.548]  $ timeout         : num 2592000
[11:41:45.548]  $ rscript         : chr "'/usr/lib/R/bin/Rscript'"
[11:41:45.548]  $ homogeneous     : logi TRUE
[11:41:45.548]  $ rscript_args    : chr "--default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),fi"| __truncated__
[11:41:45.548]  $ rscript_envs    : NULL
[11:41:45.548]  $ rscript_libs    : chr [1:4] "/home/marc/R/x86_64-pc-linux-gnu-library/4.3" "/usr/local/lib/R/site-library" "/usr/lib/R/site-library" "/usr/lib/R/library"
[11:41:45.548]  $ rscript_startup : NULL
[11:41:45.548]  $ rscript_sh      : chr "sh"
[11:41:45.548]  $ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[11:41:45.548]  $ methods         : logi TRUE
[11:41:45.548]  $ socketOptions   : chr "no-delay"
[11:41:45.548]  $ useXDR          : logi FALSE
[11:41:45.548]  $ outfile         : chr "/dev/null"
[11:41:45.548]  $ renice          : int NA
[11:41:45.548]  $ rshcmd          : NULL
[11:41:45.548]  $ user            : chr(0) 
[11:41:45.548]  $ revtunnel       : logi FALSE
[11:41:45.548]  $ rshlogfile      : NULL
[11:41:45.548]  $ rshopts         : chr(0) 
[11:41:45.548]  $ rank            : int 1
[11:41:45.548]  $ manual          : logi FALSE
[11:41:45.548]  $ dryrun          : logi FALSE
[11:41:45.548]  $ quiet           : logi FALSE
[11:41:45.548]  $ setup_strategy  : chr "parallel"
[11:41:45.548]  $ local_cmd       : chr "'/usr/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWar"| __truncated__
[11:41:45.548]  $ pidfile         : chr "/tmp/RtmpcULeQ8/worker.rank=1.parallelly.parent=280098.446223587afec.pid"
[11:41:45.548]  $ rshcmd_label    : NULL
[11:41:45.548]  $ rsh_call        : NULL
[11:41:45.548]  $ cmd             : chr "'/usr/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWar"| __truncated__
[11:41:45.548]  $ localMachine    : logi TRUE
[11:41:45.548]  $ make_fcn        :function (worker = getOption2("parallelly.localhost.hostname", "localhost"), master = NULL, port, connectTimeout = getOption2("parallelly.makeNodePSOCK.connectTimeout", 2 * 60), timeout = getOption2("parallelly.makeNodePSOCK.timeout", 30 * 24 * 60 * 60), rscript = NULL, homogeneous = NULL, rscript_args = NULL, rscript_envs = NULL, rscript_libs = NULL, rscript_startup = NULL, rscript_sh = c("auto", 
[11:41:45.548]     "cmd", "sh"), default_packages = c("datasets", "utils", "grDevices", "graphics", "stats", if (methods) "methods"), methods = TRUE, socketOptions = getOption2("parallelly.makeNodePSOCK.socketOptions", "no-delay"), useXDR = getOption2("parallelly.makeNodePSOCK.useXDR", FALSE), outfile = "/dev/null", renice = NA_integer_, rshcmd = getOption2("parallelly.makeNodePSOCK.rshcmd", NULL), user = NULL, 
[11:41:45.548]     revtunnel = NA, rshlogfile = NULL, rshopts = getOption2("parallelly.makeNodePSOCK.rshopts", NULL), rank = 1L, manual = FALSE, dryrun = FALSE, quiet = FALSE, setup_strategy = getOption2("parallelly.makeNodePSOCK.setup_strategy", "parallel"), action = c("launch", "options"), verbose = FALSE)  
[11:41:45.548]  $ arguments       :List of 28
[11:41:45.548]   ..$ worker          : chr "localhost"
[11:41:45.548]   ..$ master          : NULL
[11:41:45.548]   ..$ port            : int 11110
[11:41:45.548]   ..$ connectTimeout  : num 120
[11:41:45.548]   ..$ timeout         : num 2592000
[11:41:45.548]   ..$ rscript         : NULL
[11:41:45.548]   ..$ homogeneous     : NULL
[11:41:45.548]   ..$ rscript_args    : NULL
[11:41:45.548]   ..$ rscript_envs    : NULL
[11:41:45.548]   ..$ rscript_libs    : chr [1:4] "/home/marc/R/x86_64-pc-linux-gnu-library/4.3" "/usr/local/lib/R/site-library" "/usr/lib/R/site-library" "/usr/lib/R/library"
[11:41:45.548]   ..$ rscript_startup : NULL
[11:41:45.548]   ..$ rscript_sh      : chr [1:3] "auto" "cmd" "sh"
[11:41:45.548]   ..$ default_packages: chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
[11:41:45.548]   ..$ methods         : logi TRUE
[11:41:45.548]   ..$ socketOptions   : chr "no-delay"
[11:41:45.548]   ..$ useXDR          : logi FALSE
[11:41:45.548]   ..$ outfile         : chr "/dev/null"
[11:41:45.548]   ..$ renice          : int NA
[11:41:45.548]   ..$ rshcmd          : NULL
[11:41:45.548]   ..$ user            : NULL
[11:41:45.548]   ..$ revtunnel       : logi NA
[11:41:45.548]   ..$ rshlogfile      : NULL
[11:41:45.548]   ..$ rshopts         : NULL
[11:41:45.548]   ..$ rank            : int 1
[11:41:45.548]   ..$ manual          : logi FALSE
[11:41:45.548]   ..$ dryrun          : logi FALSE
[11:41:45.548]   ..$ quiet           : logi FALSE
[11:41:45.548]   ..$ setup_strategy  : chr "parallel"
[11:41:45.548]  - attr(*, "class")= chr [1:2] "makeNodePSOCKOptions" "makeNodeOptions"
[11:41:45.560] [local output] System call to launch all workers:
[11:41:45.560] [local output] '/usr/lib/R/bin/Rscript' --default-packages=datasets,utils,grDevices,graphics,stats,methods -e 'try(suppressWarnings(cat(Sys.getpid(),file="/tmp/RtmpcULeQ8/worker.rank=1.parallelly.parent=280098.446223587afec.pid")), silent = TRUE)' -e 'options(socketOptions = "no-delay")' -e '.libPaths(c("/home/marc/R/x86_64-pc-linux-gnu-library/4.3","/usr/local/lib/R/site-library","/usr/lib/R/site-library","/usr/lib/R/library"))' -e 'workRSOCK <- tryCatch(parallel:::.workRSOCK, error=function(e) parallel:::.slaveRSOCK); workRSOCK()' MASTER=localhost PORT=11110 OUT=/dev/null TIMEOUT=2592000 XDR=FALSE SETUPTIMEOUT=120 SETUPSTRATEGY=parallel
[11:41:45.560] [local output] Starting PSOCK main server
[11:41:45.561] [local output] Workers launched
[11:41:45.561] [local output] Waiting for workers to connect back
[11:41:45.562]  - [local output] 0 workers out of 2 ready
[11:41:45.677]  - [local output] 0 workers out of 2 ready
[11:41:45.677]  - [local output] 1 workers out of 2 ready
[11:41:45.681]  - [local output] 1 workers out of 2 ready
[11:41:45.681]  - [local output] 2 workers out of 2 ready
[11:41:45.681] [local output] Launching of workers completed
[11:41:45.681] [local output] Collecting session information from workers
[11:41:45.682] [local output]  - Worker #1 of 2
[11:41:45.682] [local output]  - Worker #2 of 2
[11:41:45.683] [local output] makeClusterPSOCK() ... done
[11:41:45.691] Packages needed by the future expression (n = 0): <none>
[11:41:45.691] Packages needed by future strategies (n = 0): <none>
[11:41:45.692] {
[11:41:45.692]     {
[11:41:45.692]         {
[11:41:45.692]             ...future.startTime <- base::Sys.time()
[11:41:45.692]             {
[11:41:45.692]                 {
[11:41:45.692]                   {
[11:41:45.692]                     {
[11:41:45.692]                       base::local({
[11:41:45.692]                         has_future <- base::requireNamespace("future", 
[11:41:45.692]                           quietly = TRUE)
[11:41:45.692]                         if (has_future) {
[11:41:45.692]                           ns <- base::getNamespace("future")
[11:41:45.692]                           version <- ns[[".package"]][["version"]]
[11:41:45.692]                           if (is.null(version)) 
[11:41:45.692]                             version <- utils::packageVersion("future")
[11:41:45.692]                         }
[11:41:45.692]                         else {
[11:41:45.692]                           version <- NULL
[11:41:45.692]                         }
[11:41:45.692]                         if (!has_future || version < "1.8.0") {
[11:41:45.692]                           info <- base::c(r_version = base::gsub("R version ", 
[11:41:45.692]                             "", base::R.version$version.string), 
[11:41:45.692]                             platform = base::sprintf("%s (%s-bit)", 
[11:41:45.692]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:41:45.692]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:45.692]                               "release", "version")], collapse = " "), 
[11:41:45.692]                             hostname = base::Sys.info()[["nodename"]])
[11:41:45.692]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:41:45.692]                             info)
[11:41:45.692]                           info <- base::paste(info, collapse = "; ")
[11:41:45.692]                           if (!has_future) {
[11:41:45.692]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:45.692]                               info)
[11:41:45.692]                           }
[11:41:45.692]                           else {
[11:41:45.692]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:45.692]                               info, version)
[11:41:45.692]                           }
[11:41:45.692]                           base::stop(msg)
[11:41:45.692]                         }
[11:41:45.692]                       })
[11:41:45.692]                     }
[11:41:45.692]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:45.692]                     base::options(mc.cores = 1L)
[11:41:45.692]                   }
[11:41:45.692]                   options(future.plan = NULL)
[11:41:45.692]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:45.692]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:45.692]                 }
[11:41:45.692]                 ...future.workdir <- getwd()
[11:41:45.692]             }
[11:41:45.692]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:45.692]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:45.692]         }
[11:41:45.692]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:45.692]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:45.692]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:45.692]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:45.692]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:45.692]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:45.692]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:45.692]             base::names(...future.oldOptions))
[11:41:45.692]     }
[11:41:45.692]     if (FALSE) {
[11:41:45.692]     }
[11:41:45.692]     else {
[11:41:45.692]         if (TRUE) {
[11:41:45.692]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:45.692]                 open = "w")
[11:41:45.692]         }
[11:41:45.692]         else {
[11:41:45.692]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:45.692]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:45.692]         }
[11:41:45.692]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:45.692]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:45.692]             base::sink(type = "output", split = FALSE)
[11:41:45.692]             base::close(...future.stdout)
[11:41:45.692]         }, add = TRUE)
[11:41:45.692]     }
[11:41:45.692]     ...future.frame <- base::sys.nframe()
[11:41:45.692]     ...future.conditions <- base::list()
[11:41:45.692]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:45.692]     if (FALSE) {
[11:41:45.692]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:45.692]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:45.692]     }
[11:41:45.692]     ...future.result <- base::tryCatch({
[11:41:45.692]         base::withCallingHandlers({
[11:41:45.692]             ...future.value <- base::withVisible(base::local({
[11:41:45.692]                 ...future.makeSendCondition <- local({
[11:41:45.692]                   sendCondition <- NULL
[11:41:45.692]                   function(frame = 1L) {
[11:41:45.692]                     if (is.function(sendCondition)) 
[11:41:45.692]                       return(sendCondition)
[11:41:45.692]                     ns <- getNamespace("parallel")
[11:41:45.692]                     if (exists("sendData", mode = "function", 
[11:41:45.692]                       envir = ns)) {
[11:41:45.692]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:45.692]                         envir = ns)
[11:41:45.692]                       envir <- sys.frame(frame)
[11:41:45.692]                       master <- NULL
[11:41:45.692]                       while (!identical(envir, .GlobalEnv) && 
[11:41:45.692]                         !identical(envir, emptyenv())) {
[11:41:45.692]                         if (exists("master", mode = "list", envir = envir, 
[11:41:45.692]                           inherits = FALSE)) {
[11:41:45.692]                           master <- get("master", mode = "list", 
[11:41:45.692]                             envir = envir, inherits = FALSE)
[11:41:45.692]                           if (inherits(master, c("SOCKnode", 
[11:41:45.692]                             "SOCK0node"))) {
[11:41:45.692]                             sendCondition <<- function(cond) {
[11:41:45.692]                               data <- list(type = "VALUE", value = cond, 
[11:41:45.692]                                 success = TRUE)
[11:41:45.692]                               parallel_sendData(master, data)
[11:41:45.692]                             }
[11:41:45.692]                             return(sendCondition)
[11:41:45.692]                           }
[11:41:45.692]                         }
[11:41:45.692]                         frame <- frame + 1L
[11:41:45.692]                         envir <- sys.frame(frame)
[11:41:45.692]                       }
[11:41:45.692]                     }
[11:41:45.692]                     sendCondition <<- function(cond) NULL
[11:41:45.692]                   }
[11:41:45.692]                 })
[11:41:45.692]                 withCallingHandlers({
[11:41:45.692]                   NA
[11:41:45.692]                 }, immediateCondition = function(cond) {
[11:41:45.692]                   sendCondition <- ...future.makeSendCondition()
[11:41:45.692]                   sendCondition(cond)
[11:41:45.692]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:45.692]                   {
[11:41:45.692]                     inherits <- base::inherits
[11:41:45.692]                     invokeRestart <- base::invokeRestart
[11:41:45.692]                     is.null <- base::is.null
[11:41:45.692]                     muffled <- FALSE
[11:41:45.692]                     if (inherits(cond, "message")) {
[11:41:45.692]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:45.692]                       if (muffled) 
[11:41:45.692]                         invokeRestart("muffleMessage")
[11:41:45.692]                     }
[11:41:45.692]                     else if (inherits(cond, "warning")) {
[11:41:45.692]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:45.692]                       if (muffled) 
[11:41:45.692]                         invokeRestart("muffleWarning")
[11:41:45.692]                     }
[11:41:45.692]                     else if (inherits(cond, "condition")) {
[11:41:45.692]                       if (!is.null(pattern)) {
[11:41:45.692]                         computeRestarts <- base::computeRestarts
[11:41:45.692]                         grepl <- base::grepl
[11:41:45.692]                         restarts <- computeRestarts(cond)
[11:41:45.692]                         for (restart in restarts) {
[11:41:45.692]                           name <- restart$name
[11:41:45.692]                           if (is.null(name)) 
[11:41:45.692]                             next
[11:41:45.692]                           if (!grepl(pattern, name)) 
[11:41:45.692]                             next
[11:41:45.692]                           invokeRestart(restart)
[11:41:45.692]                           muffled <- TRUE
[11:41:45.692]                           break
[11:41:45.692]                         }
[11:41:45.692]                       }
[11:41:45.692]                     }
[11:41:45.692]                     invisible(muffled)
[11:41:45.692]                   }
[11:41:45.692]                   muffleCondition(cond)
[11:41:45.692]                 })
[11:41:45.692]             }))
[11:41:45.692]             future::FutureResult(value = ...future.value$value, 
[11:41:45.692]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:45.692]                   ...future.rng), globalenv = if (FALSE) 
[11:41:45.692]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:45.692]                     ...future.globalenv.names))
[11:41:45.692]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:45.692]         }, condition = base::local({
[11:41:45.692]             c <- base::c
[11:41:45.692]             inherits <- base::inherits
[11:41:45.692]             invokeRestart <- base::invokeRestart
[11:41:45.692]             length <- base::length
[11:41:45.692]             list <- base::list
[11:41:45.692]             seq.int <- base::seq.int
[11:41:45.692]             signalCondition <- base::signalCondition
[11:41:45.692]             sys.calls <- base::sys.calls
[11:41:45.692]             `[[` <- base::`[[`
[11:41:45.692]             `+` <- base::`+`
[11:41:45.692]             `<<-` <- base::`<<-`
[11:41:45.692]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:45.692]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:45.692]                   3L)]
[11:41:45.692]             }
[11:41:45.692]             function(cond) {
[11:41:45.692]                 is_error <- inherits(cond, "error")
[11:41:45.692]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:45.692]                   NULL)
[11:41:45.692]                 if (is_error) {
[11:41:45.692]                   sessionInformation <- function() {
[11:41:45.692]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:45.692]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:45.692]                       search = base::search(), system = base::Sys.info())
[11:41:45.692]                   }
[11:41:45.692]                   ...future.conditions[[length(...future.conditions) + 
[11:41:45.692]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:45.692]                     cond$call), session = sessionInformation(), 
[11:41:45.692]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:45.692]                   signalCondition(cond)
[11:41:45.692]                 }
[11:41:45.692]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:45.692]                 "immediateCondition"))) {
[11:41:45.692]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:45.692]                   ...future.conditions[[length(...future.conditions) + 
[11:41:45.692]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:45.692]                   if (TRUE && !signal) {
[11:41:45.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:45.692]                     {
[11:41:45.692]                       inherits <- base::inherits
[11:41:45.692]                       invokeRestart <- base::invokeRestart
[11:41:45.692]                       is.null <- base::is.null
[11:41:45.692]                       muffled <- FALSE
[11:41:45.692]                       if (inherits(cond, "message")) {
[11:41:45.692]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:45.692]                         if (muffled) 
[11:41:45.692]                           invokeRestart("muffleMessage")
[11:41:45.692]                       }
[11:41:45.692]                       else if (inherits(cond, "warning")) {
[11:41:45.692]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:45.692]                         if (muffled) 
[11:41:45.692]                           invokeRestart("muffleWarning")
[11:41:45.692]                       }
[11:41:45.692]                       else if (inherits(cond, "condition")) {
[11:41:45.692]                         if (!is.null(pattern)) {
[11:41:45.692]                           computeRestarts <- base::computeRestarts
[11:41:45.692]                           grepl <- base::grepl
[11:41:45.692]                           restarts <- computeRestarts(cond)
[11:41:45.692]                           for (restart in restarts) {
[11:41:45.692]                             name <- restart$name
[11:41:45.692]                             if (is.null(name)) 
[11:41:45.692]                               next
[11:41:45.692]                             if (!grepl(pattern, name)) 
[11:41:45.692]                               next
[11:41:45.692]                             invokeRestart(restart)
[11:41:45.692]                             muffled <- TRUE
[11:41:45.692]                             break
[11:41:45.692]                           }
[11:41:45.692]                         }
[11:41:45.692]                       }
[11:41:45.692]                       invisible(muffled)
[11:41:45.692]                     }
[11:41:45.692]                     muffleCondition(cond, pattern = "^muffle")
[11:41:45.692]                   }
[11:41:45.692]                 }
[11:41:45.692]                 else {
[11:41:45.692]                   if (TRUE) {
[11:41:45.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:45.692]                     {
[11:41:45.692]                       inherits <- base::inherits
[11:41:45.692]                       invokeRestart <- base::invokeRestart
[11:41:45.692]                       is.null <- base::is.null
[11:41:45.692]                       muffled <- FALSE
[11:41:45.692]                       if (inherits(cond, "message")) {
[11:41:45.692]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:45.692]                         if (muffled) 
[11:41:45.692]                           invokeRestart("muffleMessage")
[11:41:45.692]                       }
[11:41:45.692]                       else if (inherits(cond, "warning")) {
[11:41:45.692]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:45.692]                         if (muffled) 
[11:41:45.692]                           invokeRestart("muffleWarning")
[11:41:45.692]                       }
[11:41:45.692]                       else if (inherits(cond, "condition")) {
[11:41:45.692]                         if (!is.null(pattern)) {
[11:41:45.692]                           computeRestarts <- base::computeRestarts
[11:41:45.692]                           grepl <- base::grepl
[11:41:45.692]                           restarts <- computeRestarts(cond)
[11:41:45.692]                           for (restart in restarts) {
[11:41:45.692]                             name <- restart$name
[11:41:45.692]                             if (is.null(name)) 
[11:41:45.692]                               next
[11:41:45.692]                             if (!grepl(pattern, name)) 
[11:41:45.692]                               next
[11:41:45.692]                             invokeRestart(restart)
[11:41:45.692]                             muffled <- TRUE
[11:41:45.692]                             break
[11:41:45.692]                           }
[11:41:45.692]                         }
[11:41:45.692]                       }
[11:41:45.692]                       invisible(muffled)
[11:41:45.692]                     }
[11:41:45.692]                     muffleCondition(cond, pattern = "^muffle")
[11:41:45.692]                   }
[11:41:45.692]                 }
[11:41:45.692]             }
[11:41:45.692]         }))
[11:41:45.692]     }, error = function(ex) {
[11:41:45.692]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:45.692]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:45.692]                 ...future.rng), started = ...future.startTime, 
[11:41:45.692]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:45.692]             version = "1.8"), class = "FutureResult")
[11:41:45.692]     }, finally = {
[11:41:45.692]         if (!identical(...future.workdir, getwd())) 
[11:41:45.692]             setwd(...future.workdir)
[11:41:45.692]         {
[11:41:45.692]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:45.692]                 ...future.oldOptions$nwarnings <- NULL
[11:41:45.692]             }
[11:41:45.692]             base::options(...future.oldOptions)
[11:41:45.692]             if (.Platform$OS.type == "windows") {
[11:41:45.692]                 old_names <- names(...future.oldEnvVars)
[11:41:45.692]                 envs <- base::Sys.getenv()
[11:41:45.692]                 names <- names(envs)
[11:41:45.692]                 common <- intersect(names, old_names)
[11:41:45.692]                 added <- setdiff(names, old_names)
[11:41:45.692]                 removed <- setdiff(old_names, names)
[11:41:45.692]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:45.692]                   envs[common]]
[11:41:45.692]                 NAMES <- toupper(changed)
[11:41:45.692]                 args <- list()
[11:41:45.692]                 for (kk in seq_along(NAMES)) {
[11:41:45.692]                   name <- changed[[kk]]
[11:41:45.692]                   NAME <- NAMES[[kk]]
[11:41:45.692]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:45.692]                     next
[11:41:45.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:45.692]                 }
[11:41:45.692]                 NAMES <- toupper(added)
[11:41:45.692]                 for (kk in seq_along(NAMES)) {
[11:41:45.692]                   name <- added[[kk]]
[11:41:45.692]                   NAME <- NAMES[[kk]]
[11:41:45.692]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:45.692]                     next
[11:41:45.692]                   args[[name]] <- ""
[11:41:45.692]                 }
[11:41:45.692]                 NAMES <- toupper(removed)
[11:41:45.692]                 for (kk in seq_along(NAMES)) {
[11:41:45.692]                   name <- removed[[kk]]
[11:41:45.692]                   NAME <- NAMES[[kk]]
[11:41:45.692]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:45.692]                     next
[11:41:45.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:45.692]                 }
[11:41:45.692]                 if (length(args) > 0) 
[11:41:45.692]                   base::do.call(base::Sys.setenv, args = args)
[11:41:45.692]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:45.692]             }
[11:41:45.692]             else {
[11:41:45.692]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:45.692]             }
[11:41:45.692]             {
[11:41:45.692]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:45.692]                   0L) {
[11:41:45.692]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:45.692]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:45.692]                   base::options(opts)
[11:41:45.692]                 }
[11:41:45.692]                 {
[11:41:45.692]                   {
[11:41:45.692]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:45.692]                     NULL
[11:41:45.692]                   }
[11:41:45.692]                   options(future.plan = NULL)
[11:41:45.692]                   if (is.na(NA_character_)) 
[11:41:45.692]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:45.692]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:45.692]                   future::plan(list(function (..., workers = 2, 
[11:41:45.692]                     envir = parent.frame()) 
[11:41:45.692]                   strategy(..., workers = workers, envir = envir)), 
[11:41:45.692]                     .cleanup = FALSE, .init = FALSE)
[11:41:45.692]                 }
[11:41:45.692]             }
[11:41:45.692]         }
[11:41:45.692]     })
[11:41:45.692]     if (TRUE) {
[11:41:45.692]         base::sink(type = "output", split = FALSE)
[11:41:45.692]         if (TRUE) {
[11:41:45.692]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:45.692]         }
[11:41:45.692]         else {
[11:41:45.692]             ...future.result["stdout"] <- base::list(NULL)
[11:41:45.692]         }
[11:41:45.692]         base::close(...future.stdout)
[11:41:45.692]         ...future.stdout <- NULL
[11:41:45.692]     }
[11:41:45.692]     ...future.result$conditions <- ...future.conditions
[11:41:45.692]     ...future.result$finished <- base::Sys.time()
[11:41:45.692]     ...future.result
[11:41:45.692] }
[11:41:45.722] MultisessionFuture started
[11:41:45.722] result() for ClusterFuture ...
[11:41:45.722] receiveMessageFromWorker() for ClusterFuture ...
[11:41:45.722] - Validating connection of MultisessionFuture
[11:41:45.742] - received message: FutureResult
[11:41:45.742] - Received FutureResult
[11:41:45.742] - Erased future from FutureRegistry
[11:41:45.742] result() for ClusterFuture ...
[11:41:45.742] - result already collected: FutureResult
[11:41:45.742] result() for ClusterFuture ... done
[11:41:45.742] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:45.742] result() for ClusterFuture ... done
[11:41:45.742] result() for ClusterFuture ...
[11:41:45.742] - result already collected: FutureResult
[11:41:45.742] result() for ClusterFuture ... done
[11:41:45.742] plan(): plan_init() of ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[11:41:45.743] plan(): nbrOfWorkers() = 2
[11:41:45.773] future_mapply() ...
[11:41:45.774] Generating random seeds ...
[11:41:45.774] Generating random seed streams for 90 elements ...
[11:41:45.774] Generating random seed streams for 90 elements ... DONE
[11:41:45.774] Generating random seeds ... DONE
[11:41:45.774] Will set RNG state on exit: 10403, 17, 1428514719, -293900064, -1446267914, -10226558, 1603036508, -1789992137, 603332043, -1781430882, 919989502, 502895575, 1925901569, 1638960329, 862075035, -1546808037, -699758192, 1937183003, 1004967869, 12325709, -746984407, -1063405244, 745999031, -1126899671, -808961752, -1691711093, -1440641671, -1564498147, -816097316, 1871290560, -1434594550, 937244892, -1026922733, -1338866480, -718578061, -969318348, 1425942603, 1276811588, -121689201, -1375639170, -1561230349, 507214689, -331332938, 856707982, 1581579991, -2139409010, -705940012, -1727848421, -1539177831, -563250434, -266926711, 825213619, -11026624, -1105317838, -2129789956, 363249157, -800212252, 741857969, -865933029, 162084318, -1715777572, 1444744878, 275365380, -327734888, 1794554230, -1073279503, -493793751, -1538967607, -1202603294, 508068418, -763700248, -939004791, 920039222, 271819186, 1939469682, -1975699124, 174436304, -184017427, -1913666009, 661182735, 1263452977, 527922233, -1757026442, 1629974063, -603500830, 2031397210, -1332067105, 881914363, -778975459, -341361843, 158775639, -63522242, 1478121386, 190775342, -2104043378, -930149050, -2043150190, -1354432400, 575025809, -258130336, -134848772, 192428973, 188047933, 1109146058, 544207673, -2012193016, -670018286, -1812753114, 1869121327, 199509174, -311721757, 1714016277, 834014522, -1583546891, -882435610, 230839438, -641978064, -1411260064, 1553812256, 732976707, -161373554, 135757544, 1077749937, -1043963295, 1450911935, -635548605, 1532632231, 109945687, -1845580609, -787664594, 1354270552, -899449098, -1529245998, -1260877062, 679982303, 470792475, 1007092466, 591374581, -1128338212, -1242807936, -1144739184, -677103274, -1514555653, -1394309405, -1390727149, 252631919, 2076453056, -940246860, 825527268, 1452457144, 1904913503, 1928648416, 347052368, 1541634813, 634381998, -1781646308, -1323380156, 140790935, -708691007, -1519001114, 946700116, -1256557236, -166038545, 1992265880, -1989995838, 1280105109, -1221468749, 1311644588, 15364769, -2040362630, 1501919219, -733166112, -1812210641, 751923790, -233043305, -59892772, -1223846847, -1310979679, -1253531829, -1983299344, -1954950026, 1615466592, -18046222, -1450835855, 1614905217, 33707380, -1936626141, -1789171443, 516276795, -417174887, -1177191247, 960714183, -1220429038, 1412139923, 1155389650, 1931427129, -1245946494, -1668494422, -2004104537, -844010207, 1378253063, -1669347949, 1227473665, -1896263006, -1461176884, 514212702, 137475312, -1295704106, 1467945425, -272799904, 1423290942, -1170763547, -1685580834, 59358387, 1950166962, -1199658530, 963250385, -1385334501, -377354351, 175766016, 1933149683, 1988582782, 1896825598, 1440565790, 1935102394, -1499554560, -178161694, -1357442137, 1413734741, 1472095641, -1156875300, 1719440769, 1030618788, 1201678689, 428651250, 1864629818, 953996395, 1998923696, 1228388373, 787858026, 2079702751, -1505798573, 69997120, -706801654, 1597236927, 1044454201, -1554806209, 1387125667, -1781012066, 1290875673, -167474332, 229621773, -205219591, 1862354080, -367188228, -1754071192, -234176362, 876286405, 2045066398, -2012488151, -362337809, -664256153, 308561264, -1659118693, -1942119417, 1057747983, -109821263, -1907109784, 1033980317, 301405888, -20308542, 1680662604, 1109989017, -296400021, -352665533, -510255741, -1924487020, -1163225323, -2940982, 1030630181, -1678346940, -1321926639, 1797690761, 1291881334, 269699356, -1979554246, -1767253802, 66773688, 687730240, -1316402208, 708992354, -1383162608, 447122837, 1118501819, 514243794, -667824936, 727429126, 250857493, -482183863, 353992356, -1426379401, 359797115, 2086397026, -1076270387, -433049745, -2051159132, 902921338, 1509021870, -892835601, -171260298, -1868842578, 258618019, -630038435, -1893098483, 1760012877, -939863236, -499049294, -776305790, 134232125, 1348363565, 2015874639, -951776937, 834725339, 1653528820, 150388650, 1219939986, 415340065, -1879089845, 184583601, -1039077697, -1046178314, 1443750630, -1315175720, -1747250221, 1601140363, 1319779270, 733993568, 1600505511, 1751879414, 1739356834, -732614186, -544399939, 694004418, 692445418, 1084107272, -1246731700, -116022772, -149726023, -1077459398, 1426874859, 1286460592, -202549416, -215272087, 2048885835, 9629103, -1417596240, -788005493, -434875111, -1650852810, -1883241601, 1054256319, -471538550, -1662646765, 2083555404, 1904186205, -1283816009, -627048675, -808482277, -809864639, 538108000, -1750869439, -713746499, -743625049, 692245379, 1378204549, 881044238, 1692135655, 933680059, -1376403889, 769543553, 863540150, -141650899, 348832227, -1330488073, -1743248242, 450473454, 1033185684, 689842469, 1108123511, 1480864164, -942844161, -1147592314, 1950636927, 882587336, -927890783, 115304354, 1868249041, -1642098708, -94143575, 1736026861, -285555669, 1054014714, 1992952001, 1522350607, 1903088843, -1270387203, 1911547720, 801474530, -1203111310, 240223085, 708371221, -278479934, 27790478, -622882201, 774463460, -492345117, 2056577574, 2033831833, 1121178408, -920679877, 693229112, -659020943, 1002350405, 1014441427, 1161223416, 203057740, 1324938081, -768506082, -1604703510, 550032816, -229541932, -90730790, -1970817141, 124189531, 826622274, -162690021, 1649996631, 1699490467, -864656336, 428080643, -1371672179, 1077518950, -942983675, -245565269, -1229938, -216430970, -26851126, -661362539, 1195121039, -736124845, -1278163652, -1239043987, 211743985, 1753270051, 1642811036, -1395235256, 637762006, -644122419, 402325315, 162755629, 1472594902, 216258492, 890028244, -1585721346, 444004833, 2051609794, 2058998707, -194091793, 2100439769, -1048099300, -319280299, -139084409, -1490695476, -253152837, 673358259, -1221077550, -1167227670, -1887042155, 726887029, -1498503573, -905825532, 153559285, -1909441957, -1895298669, 859837631, 1879051944, 1764169927, -1371176537, 872154686, 1648955156, -1883063968, -858862401, 1177276786, -1960022765, -1937847549, -146073604, 1502760454, -1696056551, -518734427, 935710210, 1878504516, -962356387, 72456200, 459213106, 1061597356, 1394832925, 1428869988, -1012010291, 1216560623, -1219609985, -423640755, -1853057526, -476261805, 499471801, -2029479393, 583735072, 1964321694, -1902294916, 1450932419, -1846708383, -331477881, -1939219398, -1471341247, 322505136, -1050068195, 1051920026, -1159584542, -1969113660, 1914430845, -1942602041, 1210272803, -721762647, 2071205764, 1830006942, -391117891, 379034725, 810056369, 1540907925, 116102338, -1543671671, -837954660, -396713737, -733861600, 1402570710, -499510482, -35818343, 1732540381, 204620121, -346252395, 490204627, -743869566, 1629013678, -998790126, -1623920598, 73157769, -1955340636, 1625694699, -234086314, 1329239215, 1163567454, 1307121197, -958014310, -2069126671, 1702737370, -1871282441, -1485500591, 58749713, 1099407184, -271230744, 587381626, 1802165379, -1771630900, 722244756, 611883286, 1544176536, 415241627, 870571708, 681342038, 1289701342, -1268160948, 1895779373, 1532411899, -1828273968, 338949618, -1741690439, 861379272, -577203666, -980314092, -927365784, 2103541494, -1538251076, -1884245121, -247173930, 1335390558, 1532189570, 90737314, -1131499895, 1448335793, 1569998909, 971167651, -737073498, 2080072523, -1092837662, -1644495913, 997202024, -473606449, 1231204, -539927000, -817497936, -825460797, -1811774982, -1903486025, 806053392, 670335846, -185005156, 132513347, -1932274175, -1139600429, 462818801, 1435479421, 777779739, -1734217891, 1834065616, -660271681, -1460744356, 167344313
[11:41:45.775] Number of chunks: 90
[11:41:45.775] getGlobalsAndPackagesXApply() ...
[11:41:45.775]  - future.globals: FALSE
[11:41:45.775] getGlobalsAndPackages() ...
[11:41:45.775] Retrieving 'add' globals ...
[11:41:45.775] - 'add' globals retrieved: [2] ‘FUN’, ‘MoreArgs’
[11:41:45.775] Retrieving 'add' globals ... DONE
[11:41:45.775] Not searching for globals
[11:41:45.775] Resolving globals: FALSE
[11:41:45.778] The total size of the 2 globals is 157.50 KiB (161280 bytes)
[11:41:45.778] The total size of the 2 globals exported is 157.50 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘FUN’ (114.30 KiB of class ‘function’) and ‘MoreArgs’ (43.20 KiB of class ‘list’)
[11:41:45.778] - globals: [2] ‘FUN’, ‘MoreArgs’
[11:41:45.778] - packages: [1] ‘mlr3’
[11:41:45.778] getGlobalsAndPackages() ... DONE
[11:41:45.778]  - globals found/used: [n=2] ‘FUN’, ‘MoreArgs’
[11:41:45.778]  - needed namespaces: [n=1] ‘mlr3’
[11:41:45.778] Finding globals ... DONE
[11:41:45.778] Globals to be used in all futures (chunks): [n=2] ‘...future.FUN’, ‘MoreArgs’
[11:41:45.778] List of 2
[11:41:45.778]  $ ...future.FUN:function (iteration, task, learner, resampling, lgr_threshold, store_models = FALSE, pb = NULL, mode = "train")  
[11:41:45.778]  $ MoreArgs     :List of 5
[11:41:45.778]   ..$ task         :Classes 'TaskClassif', 'TaskSupervised', 'Task', 'R6' <TaskClassif:pima> 
[11:41:45.778]   ..$ resampling   :Classes 'ResamplingRepeatedCV', 'Resampling', 'R6' <ResamplingRepeatedCV> 
[11:41:45.778]   ..$ store_models : logi FALSE
[11:41:45.778]   ..$ lgr_threshold: Named int 300
[11:41:45.778]   .. ..- attr(*, "names")= chr "mlr3"
[11:41:45.778]   ..$ pb           : NULL
[11:41:45.778]  - attr(*, "where")=List of 2
[11:41:45.778]   ..$ ...future.FUN:<environment: R_EmptyEnv> 
[11:41:45.778]   ..$ MoreArgs     :<environment: R_EmptyEnv> 
[11:41:45.778]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:41:45.778]  - attr(*, "resolved")= logi FALSE
[11:41:45.778]  - attr(*, "total_size")= num 161280
[11:41:45.781] Packages to be attached in all futures: [n=1] ‘mlr3’
[11:41:45.781] getGlobalsAndPackagesXApply() ... DONE
[11:41:45.781] Number of futures (= number of chunks): 90
[11:41:45.781] Launching 90 futures (chunks) ...
[11:41:45.781] Chunk #1 of 90 ...
[11:41:45.781]  - seeds: [1] <seeds>
[11:41:45.781] getGlobalsAndPackages() ...
[11:41:45.781] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:45.781] Resolving globals: FALSE
[11:41:45.782] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:45.782] - packages: [1] ‘mlr3’
[11:41:45.782] getGlobalsAndPackages() ... DONE
[11:41:45.782] run() for ‘Future’ ...
[11:41:45.782] - state: ‘created’
[11:41:45.782] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:45.791] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:45.791] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:45.791]   - Field: ‘node’
[11:41:45.791]   - Field: ‘label’
[11:41:45.791]   - Field: ‘local’
[11:41:45.791]   - Field: ‘owner’
[11:41:45.791]   - Field: ‘envir’
[11:41:45.791]   - Field: ‘workers’
[11:41:45.791]   - Field: ‘packages’
[11:41:45.791]   - Field: ‘gc’
[11:41:45.791]   - Field: ‘conditions’
[11:41:45.791]   - Field: ‘persistent’
[11:41:45.791]   - Field: ‘expr’
[11:41:45.791]   - Field: ‘uuid’
[11:41:45.791]   - Field: ‘seed’
[11:41:45.791]   - Field: ‘version’
[11:41:45.791]   - Field: ‘result’
[11:41:45.791]   - Field: ‘asynchronous’
[11:41:45.791]   - Field: ‘calls’
[11:41:45.791]   - Field: ‘globals’
[11:41:45.791]   - Field: ‘stdout’
[11:41:45.791]   - Field: ‘earlySignal’
[11:41:45.792]   - Field: ‘lazy’
[11:41:45.792]   - Field: ‘state’
[11:41:45.792] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:45.792] - Launch lazy future ...
[11:41:45.792] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:45.792] Packages needed by future strategies (n = 0): <none>
[11:41:45.792] {
[11:41:45.792]     {
[11:41:45.792]         {
[11:41:45.792]             ...future.startTime <- base::Sys.time()
[11:41:45.792]             {
[11:41:45.792]                 {
[11:41:45.792]                   {
[11:41:45.792]                     {
[11:41:45.792]                       {
[11:41:45.792]                         base::local({
[11:41:45.792]                           has_future <- base::requireNamespace("future", 
[11:41:45.792]                             quietly = TRUE)
[11:41:45.792]                           if (has_future) {
[11:41:45.792]                             ns <- base::getNamespace("future")
[11:41:45.792]                             version <- ns[[".package"]][["version"]]
[11:41:45.792]                             if (is.null(version)) 
[11:41:45.792]                               version <- utils::packageVersion("future")
[11:41:45.792]                           }
[11:41:45.792]                           else {
[11:41:45.792]                             version <- NULL
[11:41:45.792]                           }
[11:41:45.792]                           if (!has_future || version < "1.8.0") {
[11:41:45.792]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:45.792]                               "", base::R.version$version.string), 
[11:41:45.792]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:45.792]                                 base::R.version$platform, 8 * 
[11:41:45.792]                                   base::.Machine$sizeof.pointer), 
[11:41:45.792]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:45.792]                                 "release", "version")], collapse = " "), 
[11:41:45.792]                               hostname = base::Sys.info()[["nodename"]])
[11:41:45.792]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:45.792]                               info)
[11:41:45.792]                             info <- base::paste(info, collapse = "; ")
[11:41:45.792]                             if (!has_future) {
[11:41:45.792]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:45.792]                                 info)
[11:41:45.792]                             }
[11:41:45.792]                             else {
[11:41:45.792]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:45.792]                                 info, version)
[11:41:45.792]                             }
[11:41:45.792]                             base::stop(msg)
[11:41:45.792]                           }
[11:41:45.792]                         })
[11:41:45.792]                       }
[11:41:45.792]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:45.792]                       base::options(mc.cores = 1L)
[11:41:45.792]                     }
[11:41:45.792]                     base::local({
[11:41:45.792]                       for (pkg in "mlr3") {
[11:41:45.792]                         base::loadNamespace(pkg)
[11:41:45.792]                         base::library(pkg, character.only = TRUE)
[11:41:45.792]                       }
[11:41:45.792]                     })
[11:41:45.792]                   }
[11:41:45.792]                   options(future.plan = NULL)
[11:41:45.792]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:45.792]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:45.792]                 }
[11:41:45.792]                 ...future.workdir <- getwd()
[11:41:45.792]             }
[11:41:45.792]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:45.792]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:45.792]         }
[11:41:45.792]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:45.792]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:45.792]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:45.792]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:45.792]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:45.792]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:45.792]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:45.792]             base::names(...future.oldOptions))
[11:41:45.792]     }
[11:41:45.792]     if (FALSE) {
[11:41:45.792]     }
[11:41:45.792]     else {
[11:41:45.792]         if (TRUE) {
[11:41:45.792]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:45.792]                 open = "w")
[11:41:45.792]         }
[11:41:45.792]         else {
[11:41:45.792]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:45.792]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:45.792]         }
[11:41:45.792]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:45.792]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:45.792]             base::sink(type = "output", split = FALSE)
[11:41:45.792]             base::close(...future.stdout)
[11:41:45.792]         }, add = TRUE)
[11:41:45.792]     }
[11:41:45.792]     ...future.frame <- base::sys.nframe()
[11:41:45.792]     ...future.conditions <- base::list()
[11:41:45.792]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:45.792]     if (FALSE) {
[11:41:45.792]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:45.792]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:45.792]     }
[11:41:45.792]     ...future.result <- base::tryCatch({
[11:41:45.792]         base::withCallingHandlers({
[11:41:45.792]             ...future.value <- base::withVisible(base::local({
[11:41:45.792]                 ...future.makeSendCondition <- local({
[11:41:45.792]                   sendCondition <- NULL
[11:41:45.792]                   function(frame = 1L) {
[11:41:45.792]                     if (is.function(sendCondition)) 
[11:41:45.792]                       return(sendCondition)
[11:41:45.792]                     ns <- getNamespace("parallel")
[11:41:45.792]                     if (exists("sendData", mode = "function", 
[11:41:45.792]                       envir = ns)) {
[11:41:45.792]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:45.792]                         envir = ns)
[11:41:45.792]                       envir <- sys.frame(frame)
[11:41:45.792]                       master <- NULL
[11:41:45.792]                       while (!identical(envir, .GlobalEnv) && 
[11:41:45.792]                         !identical(envir, emptyenv())) {
[11:41:45.792]                         if (exists("master", mode = "list", envir = envir, 
[11:41:45.792]                           inherits = FALSE)) {
[11:41:45.792]                           master <- get("master", mode = "list", 
[11:41:45.792]                             envir = envir, inherits = FALSE)
[11:41:45.792]                           if (inherits(master, c("SOCKnode", 
[11:41:45.792]                             "SOCK0node"))) {
[11:41:45.792]                             sendCondition <<- function(cond) {
[11:41:45.792]                               data <- list(type = "VALUE", value = cond, 
[11:41:45.792]                                 success = TRUE)
[11:41:45.792]                               parallel_sendData(master, data)
[11:41:45.792]                             }
[11:41:45.792]                             return(sendCondition)
[11:41:45.792]                           }
[11:41:45.792]                         }
[11:41:45.792]                         frame <- frame + 1L
[11:41:45.792]                         envir <- sys.frame(frame)
[11:41:45.792]                       }
[11:41:45.792]                     }
[11:41:45.792]                     sendCondition <<- function(cond) NULL
[11:41:45.792]                   }
[11:41:45.792]                 })
[11:41:45.792]                 withCallingHandlers({
[11:41:45.792]                   {
[11:41:45.792]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:45.792]                     if (!identical(...future.globals.maxSize.org, 
[11:41:45.792]                       ...future.globals.maxSize)) {
[11:41:45.792]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:45.792]                       on.exit(options(oopts), add = TRUE)
[11:41:45.792]                     }
[11:41:45.792]                     {
[11:41:45.792]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:45.792]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:45.792]                           envir = globalenv(), inherits = FALSE)
[11:41:45.792]                         ...future.FUN(...)
[11:41:45.792]                       }
[11:41:45.792]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:45.792]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:45.792]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:45.792]                         USE.NAMES = FALSE)
[11:41:45.792]                       do.call(mapply, args = args)
[11:41:45.792]                     }
[11:41:45.792]                   }
[11:41:45.792]                 }, immediateCondition = function(cond) {
[11:41:45.792]                   sendCondition <- ...future.makeSendCondition()
[11:41:45.792]                   sendCondition(cond)
[11:41:45.792]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:45.792]                   {
[11:41:45.792]                     inherits <- base::inherits
[11:41:45.792]                     invokeRestart <- base::invokeRestart
[11:41:45.792]                     is.null <- base::is.null
[11:41:45.792]                     muffled <- FALSE
[11:41:45.792]                     if (inherits(cond, "message")) {
[11:41:45.792]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:45.792]                       if (muffled) 
[11:41:45.792]                         invokeRestart("muffleMessage")
[11:41:45.792]                     }
[11:41:45.792]                     else if (inherits(cond, "warning")) {
[11:41:45.792]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:45.792]                       if (muffled) 
[11:41:45.792]                         invokeRestart("muffleWarning")
[11:41:45.792]                     }
[11:41:45.792]                     else if (inherits(cond, "condition")) {
[11:41:45.792]                       if (!is.null(pattern)) {
[11:41:45.792]                         computeRestarts <- base::computeRestarts
[11:41:45.792]                         grepl <- base::grepl
[11:41:45.792]                         restarts <- computeRestarts(cond)
[11:41:45.792]                         for (restart in restarts) {
[11:41:45.792]                           name <- restart$name
[11:41:45.792]                           if (is.null(name)) 
[11:41:45.792]                             next
[11:41:45.792]                           if (!grepl(pattern, name)) 
[11:41:45.792]                             next
[11:41:45.792]                           invokeRestart(restart)
[11:41:45.792]                           muffled <- TRUE
[11:41:45.792]                           break
[11:41:45.792]                         }
[11:41:45.792]                       }
[11:41:45.792]                     }
[11:41:45.792]                     invisible(muffled)
[11:41:45.792]                   }
[11:41:45.792]                   muffleCondition(cond)
[11:41:45.792]                 })
[11:41:45.792]             }))
[11:41:45.792]             future::FutureResult(value = ...future.value$value, 
[11:41:45.792]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:45.792]                   ...future.rng), globalenv = if (FALSE) 
[11:41:45.792]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:45.792]                     ...future.globalenv.names))
[11:41:45.792]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:45.792]         }, condition = base::local({
[11:41:45.792]             c <- base::c
[11:41:45.792]             inherits <- base::inherits
[11:41:45.792]             invokeRestart <- base::invokeRestart
[11:41:45.792]             length <- base::length
[11:41:45.792]             list <- base::list
[11:41:45.792]             seq.int <- base::seq.int
[11:41:45.792]             signalCondition <- base::signalCondition
[11:41:45.792]             sys.calls <- base::sys.calls
[11:41:45.792]             `[[` <- base::`[[`
[11:41:45.792]             `+` <- base::`+`
[11:41:45.792]             `<<-` <- base::`<<-`
[11:41:45.792]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:45.792]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:45.792]                   3L)]
[11:41:45.792]             }
[11:41:45.792]             function(cond) {
[11:41:45.792]                 is_error <- inherits(cond, "error")
[11:41:45.792]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:45.792]                   NULL)
[11:41:45.792]                 if (is_error) {
[11:41:45.792]                   sessionInformation <- function() {
[11:41:45.792]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:45.792]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:45.792]                       search = base::search(), system = base::Sys.info())
[11:41:45.792]                   }
[11:41:45.792]                   ...future.conditions[[length(...future.conditions) + 
[11:41:45.792]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:45.792]                     cond$call), session = sessionInformation(), 
[11:41:45.792]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:45.792]                   signalCondition(cond)
[11:41:45.792]                 }
[11:41:45.792]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:45.792]                 "immediateCondition"))) {
[11:41:45.792]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:45.792]                   ...future.conditions[[length(...future.conditions) + 
[11:41:45.792]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:45.792]                   if (TRUE && !signal) {
[11:41:45.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:45.792]                     {
[11:41:45.792]                       inherits <- base::inherits
[11:41:45.792]                       invokeRestart <- base::invokeRestart
[11:41:45.792]                       is.null <- base::is.null
[11:41:45.792]                       muffled <- FALSE
[11:41:45.792]                       if (inherits(cond, "message")) {
[11:41:45.792]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:45.792]                         if (muffled) 
[11:41:45.792]                           invokeRestart("muffleMessage")
[11:41:45.792]                       }
[11:41:45.792]                       else if (inherits(cond, "warning")) {
[11:41:45.792]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:45.792]                         if (muffled) 
[11:41:45.792]                           invokeRestart("muffleWarning")
[11:41:45.792]                       }
[11:41:45.792]                       else if (inherits(cond, "condition")) {
[11:41:45.792]                         if (!is.null(pattern)) {
[11:41:45.792]                           computeRestarts <- base::computeRestarts
[11:41:45.792]                           grepl <- base::grepl
[11:41:45.792]                           restarts <- computeRestarts(cond)
[11:41:45.792]                           for (restart in restarts) {
[11:41:45.792]                             name <- restart$name
[11:41:45.792]                             if (is.null(name)) 
[11:41:45.792]                               next
[11:41:45.792]                             if (!grepl(pattern, name)) 
[11:41:45.792]                               next
[11:41:45.792]                             invokeRestart(restart)
[11:41:45.792]                             muffled <- TRUE
[11:41:45.792]                             break
[11:41:45.792]                           }
[11:41:45.792]                         }
[11:41:45.792]                       }
[11:41:45.792]                       invisible(muffled)
[11:41:45.792]                     }
[11:41:45.792]                     muffleCondition(cond, pattern = "^muffle")
[11:41:45.792]                   }
[11:41:45.792]                 }
[11:41:45.792]                 else {
[11:41:45.792]                   if (TRUE) {
[11:41:45.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:45.792]                     {
[11:41:45.792]                       inherits <- base::inherits
[11:41:45.792]                       invokeRestart <- base::invokeRestart
[11:41:45.792]                       is.null <- base::is.null
[11:41:45.792]                       muffled <- FALSE
[11:41:45.792]                       if (inherits(cond, "message")) {
[11:41:45.792]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:45.792]                         if (muffled) 
[11:41:45.792]                           invokeRestart("muffleMessage")
[11:41:45.792]                       }
[11:41:45.792]                       else if (inherits(cond, "warning")) {
[11:41:45.792]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:45.792]                         if (muffled) 
[11:41:45.792]                           invokeRestart("muffleWarning")
[11:41:45.792]                       }
[11:41:45.792]                       else if (inherits(cond, "condition")) {
[11:41:45.792]                         if (!is.null(pattern)) {
[11:41:45.792]                           computeRestarts <- base::computeRestarts
[11:41:45.792]                           grepl <- base::grepl
[11:41:45.792]                           restarts <- computeRestarts(cond)
[11:41:45.792]                           for (restart in restarts) {
[11:41:45.792]                             name <- restart$name
[11:41:45.792]                             if (is.null(name)) 
[11:41:45.792]                               next
[11:41:45.792]                             if (!grepl(pattern, name)) 
[11:41:45.792]                               next
[11:41:45.792]                             invokeRestart(restart)
[11:41:45.792]                             muffled <- TRUE
[11:41:45.792]                             break
[11:41:45.792]                           }
[11:41:45.792]                         }
[11:41:45.792]                       }
[11:41:45.792]                       invisible(muffled)
[11:41:45.792]                     }
[11:41:45.792]                     muffleCondition(cond, pattern = "^muffle")
[11:41:45.792]                   }
[11:41:45.792]                 }
[11:41:45.792]             }
[11:41:45.792]         }))
[11:41:45.792]     }, error = function(ex) {
[11:41:45.792]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:45.792]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:45.792]                 ...future.rng), started = ...future.startTime, 
[11:41:45.792]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:45.792]             version = "1.8"), class = "FutureResult")
[11:41:45.792]     }, finally = {
[11:41:45.792]         if (!identical(...future.workdir, getwd())) 
[11:41:45.792]             setwd(...future.workdir)
[11:41:45.792]         {
[11:41:45.792]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:45.792]                 ...future.oldOptions$nwarnings <- NULL
[11:41:45.792]             }
[11:41:45.792]             base::options(...future.oldOptions)
[11:41:45.792]             if (.Platform$OS.type == "windows") {
[11:41:45.792]                 old_names <- names(...future.oldEnvVars)
[11:41:45.792]                 envs <- base::Sys.getenv()
[11:41:45.792]                 names <- names(envs)
[11:41:45.792]                 common <- intersect(names, old_names)
[11:41:45.792]                 added <- setdiff(names, old_names)
[11:41:45.792]                 removed <- setdiff(old_names, names)
[11:41:45.792]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:45.792]                   envs[common]]
[11:41:45.792]                 NAMES <- toupper(changed)
[11:41:45.792]                 args <- list()
[11:41:45.792]                 for (kk in seq_along(NAMES)) {
[11:41:45.792]                   name <- changed[[kk]]
[11:41:45.792]                   NAME <- NAMES[[kk]]
[11:41:45.792]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:45.792]                     next
[11:41:45.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:45.792]                 }
[11:41:45.792]                 NAMES <- toupper(added)
[11:41:45.792]                 for (kk in seq_along(NAMES)) {
[11:41:45.792]                   name <- added[[kk]]
[11:41:45.792]                   NAME <- NAMES[[kk]]
[11:41:45.792]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:45.792]                     next
[11:41:45.792]                   args[[name]] <- ""
[11:41:45.792]                 }
[11:41:45.792]                 NAMES <- toupper(removed)
[11:41:45.792]                 for (kk in seq_along(NAMES)) {
[11:41:45.792]                   name <- removed[[kk]]
[11:41:45.792]                   NAME <- NAMES[[kk]]
[11:41:45.792]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:45.792]                     next
[11:41:45.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:45.792]                 }
[11:41:45.792]                 if (length(args) > 0) 
[11:41:45.792]                   base::do.call(base::Sys.setenv, args = args)
[11:41:45.792]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:45.792]             }
[11:41:45.792]             else {
[11:41:45.792]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:45.792]             }
[11:41:45.792]             {
[11:41:45.792]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:45.792]                   0L) {
[11:41:45.792]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:45.792]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:45.792]                   base::options(opts)
[11:41:45.792]                 }
[11:41:45.792]                 {
[11:41:45.792]                   {
[11:41:45.792]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:45.792]                     NULL
[11:41:45.792]                   }
[11:41:45.792]                   options(future.plan = NULL)
[11:41:45.792]                   if (is.na(NA_character_)) 
[11:41:45.792]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:45.792]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:45.792]                   future::plan(list(function (..., workers = 2, 
[11:41:45.792]                     envir = parent.frame()) 
[11:41:45.792]                   strategy(..., workers = workers, envir = envir)), 
[11:41:45.792]                     .cleanup = FALSE, .init = FALSE)
[11:41:45.792]                 }
[11:41:45.792]             }
[11:41:45.792]         }
[11:41:45.792]     })
[11:41:45.792]     if (TRUE) {
[11:41:45.792]         base::sink(type = "output", split = FALSE)
[11:41:45.792]         if (TRUE) {
[11:41:45.792]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:45.792]         }
[11:41:45.792]         else {
[11:41:45.792]             ...future.result["stdout"] <- base::list(NULL)
[11:41:45.792]         }
[11:41:45.792]         base::close(...future.stdout)
[11:41:45.792]         ...future.stdout <- NULL
[11:41:45.792]     }
[11:41:45.792]     ...future.result$conditions <- ...future.conditions
[11:41:45.792]     ...future.result$finished <- base::Sys.time()
[11:41:45.792]     ...future.result
[11:41:45.792] }
[11:41:45.794] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:45.794] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:45.864] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:45.866] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:45.910] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:45.910] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:45.954] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:45.955] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:45.957] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:45.957] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:45.959] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:45.959] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:45.961] MultisessionFuture started
[11:41:45.961] - Launch lazy future ... done
[11:41:45.962] run() for ‘MultisessionFuture’ ... done
[11:41:45.962] Created future:
[11:41:45.962] MultisessionFuture:
[11:41:45.962] Label: ‘future_mapply-1’
[11:41:45.962] Expression:
[11:41:45.962] {
[11:41:45.962]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:45.962]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:45.962]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:45.962]         on.exit(options(oopts), add = TRUE)
[11:41:45.962]     }
[11:41:45.962]     {
[11:41:45.962]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:45.962]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:45.962]                 inherits = FALSE)
[11:41:45.962]             ...future.FUN(...)
[11:41:45.962]         }
[11:41:45.962]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:45.962]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:45.962]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:45.962]         do.call(mapply, args = args)
[11:41:45.962]     }
[11:41:45.962] }
[11:41:45.962] Lazy evaluation: FALSE
[11:41:45.962] Asynchronous evaluation: TRUE
[11:41:45.962] Local evaluation: TRUE
[11:41:45.962] Environment: 0x560ef58e1768
[11:41:45.962] Capture standard output: TRUE
[11:41:45.962] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:45.962] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:45.962] Packages: 1 packages (‘mlr3’)
[11:41:45.962] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:45.962] Resolved: FALSE
[11:41:45.962] Value: <not collected>
[11:41:45.962] Conditions captured: <none>
[11:41:45.962] Early signaling: FALSE
[11:41:45.962] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:45.962] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:45.979] Chunk #1 of 90 ... DONE
[11:41:45.979] Chunk #2 of 90 ...
[11:41:45.979]  - seeds: [1] <seeds>
[11:41:45.980] getGlobalsAndPackages() ...
[11:41:45.980] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:45.980] Resolving globals: FALSE
[11:41:45.981] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:45.981] - packages: [1] ‘mlr3’
[11:41:45.981] getGlobalsAndPackages() ... DONE
[11:41:45.981] run() for ‘Future’ ...
[11:41:45.982] - state: ‘created’
[11:41:45.982] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:45.993] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:45.993] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:45.993]   - Field: ‘node’
[11:41:45.993]   - Field: ‘label’
[11:41:45.993]   - Field: ‘local’
[11:41:45.993]   - Field: ‘owner’
[11:41:45.993]   - Field: ‘envir’
[11:41:45.993]   - Field: ‘workers’
[11:41:45.993]   - Field: ‘packages’
[11:41:45.993]   - Field: ‘gc’
[11:41:45.993]   - Field: ‘conditions’
[11:41:45.993]   - Field: ‘persistent’
[11:41:45.993]   - Field: ‘expr’
[11:41:45.993]   - Field: ‘uuid’
[11:41:45.993]   - Field: ‘seed’
[11:41:45.993]   - Field: ‘version’
[11:41:45.993]   - Field: ‘result’
[11:41:45.993]   - Field: ‘asynchronous’
[11:41:45.994]   - Field: ‘calls’
[11:41:45.994]   - Field: ‘globals’
[11:41:45.994]   - Field: ‘stdout’
[11:41:45.994]   - Field: ‘earlySignal’
[11:41:45.994]   - Field: ‘lazy’
[11:41:45.994]   - Field: ‘state’
[11:41:45.994] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:45.994] - Launch lazy future ...
[11:41:45.994] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:45.994] Packages needed by future strategies (n = 0): <none>
[11:41:45.994] {
[11:41:45.994]     {
[11:41:45.994]         {
[11:41:45.994]             ...future.startTime <- base::Sys.time()
[11:41:45.994]             {
[11:41:45.994]                 {
[11:41:45.994]                   {
[11:41:45.994]                     {
[11:41:45.994]                       {
[11:41:45.994]                         base::local({
[11:41:45.994]                           has_future <- base::requireNamespace("future", 
[11:41:45.994]                             quietly = TRUE)
[11:41:45.994]                           if (has_future) {
[11:41:45.994]                             ns <- base::getNamespace("future")
[11:41:45.994]                             version <- ns[[".package"]][["version"]]
[11:41:45.994]                             if (is.null(version)) 
[11:41:45.994]                               version <- utils::packageVersion("future")
[11:41:45.994]                           }
[11:41:45.994]                           else {
[11:41:45.994]                             version <- NULL
[11:41:45.994]                           }
[11:41:45.994]                           if (!has_future || version < "1.8.0") {
[11:41:45.994]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:45.994]                               "", base::R.version$version.string), 
[11:41:45.994]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:45.994]                                 base::R.version$platform, 8 * 
[11:41:45.994]                                   base::.Machine$sizeof.pointer), 
[11:41:45.994]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:45.994]                                 "release", "version")], collapse = " "), 
[11:41:45.994]                               hostname = base::Sys.info()[["nodename"]])
[11:41:45.994]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:45.994]                               info)
[11:41:45.994]                             info <- base::paste(info, collapse = "; ")
[11:41:45.994]                             if (!has_future) {
[11:41:45.994]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:45.994]                                 info)
[11:41:45.994]                             }
[11:41:45.994]                             else {
[11:41:45.994]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:45.994]                                 info, version)
[11:41:45.994]                             }
[11:41:45.994]                             base::stop(msg)
[11:41:45.994]                           }
[11:41:45.994]                         })
[11:41:45.994]                       }
[11:41:45.994]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:45.994]                       base::options(mc.cores = 1L)
[11:41:45.994]                     }
[11:41:45.994]                     base::local({
[11:41:45.994]                       for (pkg in "mlr3") {
[11:41:45.994]                         base::loadNamespace(pkg)
[11:41:45.994]                         base::library(pkg, character.only = TRUE)
[11:41:45.994]                       }
[11:41:45.994]                     })
[11:41:45.994]                   }
[11:41:45.994]                   options(future.plan = NULL)
[11:41:45.994]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:45.994]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:45.994]                 }
[11:41:45.994]                 ...future.workdir <- getwd()
[11:41:45.994]             }
[11:41:45.994]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:45.994]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:45.994]         }
[11:41:45.994]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:45.994]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:45.994]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:45.994]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:45.994]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:45.994]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:45.994]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:45.994]             base::names(...future.oldOptions))
[11:41:45.994]     }
[11:41:45.994]     if (FALSE) {
[11:41:45.994]     }
[11:41:45.994]     else {
[11:41:45.994]         if (TRUE) {
[11:41:45.994]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:45.994]                 open = "w")
[11:41:45.994]         }
[11:41:45.994]         else {
[11:41:45.994]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:45.994]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:45.994]         }
[11:41:45.994]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:45.994]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:45.994]             base::sink(type = "output", split = FALSE)
[11:41:45.994]             base::close(...future.stdout)
[11:41:45.994]         }, add = TRUE)
[11:41:45.994]     }
[11:41:45.994]     ...future.frame <- base::sys.nframe()
[11:41:45.994]     ...future.conditions <- base::list()
[11:41:45.994]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:45.994]     if (FALSE) {
[11:41:45.994]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:45.994]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:45.994]     }
[11:41:45.994]     ...future.result <- base::tryCatch({
[11:41:45.994]         base::withCallingHandlers({
[11:41:45.994]             ...future.value <- base::withVisible(base::local({
[11:41:45.994]                 ...future.makeSendCondition <- local({
[11:41:45.994]                   sendCondition <- NULL
[11:41:45.994]                   function(frame = 1L) {
[11:41:45.994]                     if (is.function(sendCondition)) 
[11:41:45.994]                       return(sendCondition)
[11:41:45.994]                     ns <- getNamespace("parallel")
[11:41:45.994]                     if (exists("sendData", mode = "function", 
[11:41:45.994]                       envir = ns)) {
[11:41:45.994]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:45.994]                         envir = ns)
[11:41:45.994]                       envir <- sys.frame(frame)
[11:41:45.994]                       master <- NULL
[11:41:45.994]                       while (!identical(envir, .GlobalEnv) && 
[11:41:45.994]                         !identical(envir, emptyenv())) {
[11:41:45.994]                         if (exists("master", mode = "list", envir = envir, 
[11:41:45.994]                           inherits = FALSE)) {
[11:41:45.994]                           master <- get("master", mode = "list", 
[11:41:45.994]                             envir = envir, inherits = FALSE)
[11:41:45.994]                           if (inherits(master, c("SOCKnode", 
[11:41:45.994]                             "SOCK0node"))) {
[11:41:45.994]                             sendCondition <<- function(cond) {
[11:41:45.994]                               data <- list(type = "VALUE", value = cond, 
[11:41:45.994]                                 success = TRUE)
[11:41:45.994]                               parallel_sendData(master, data)
[11:41:45.994]                             }
[11:41:45.994]                             return(sendCondition)
[11:41:45.994]                           }
[11:41:45.994]                         }
[11:41:45.994]                         frame <- frame + 1L
[11:41:45.994]                         envir <- sys.frame(frame)
[11:41:45.994]                       }
[11:41:45.994]                     }
[11:41:45.994]                     sendCondition <<- function(cond) NULL
[11:41:45.994]                   }
[11:41:45.994]                 })
[11:41:45.994]                 withCallingHandlers({
[11:41:45.994]                   {
[11:41:45.994]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:45.994]                     if (!identical(...future.globals.maxSize.org, 
[11:41:45.994]                       ...future.globals.maxSize)) {
[11:41:45.994]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:45.994]                       on.exit(options(oopts), add = TRUE)
[11:41:45.994]                     }
[11:41:45.994]                     {
[11:41:45.994]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:45.994]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:45.994]                           envir = globalenv(), inherits = FALSE)
[11:41:45.994]                         ...future.FUN(...)
[11:41:45.994]                       }
[11:41:45.994]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:45.994]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:45.994]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:45.994]                         USE.NAMES = FALSE)
[11:41:45.994]                       do.call(mapply, args = args)
[11:41:45.994]                     }
[11:41:45.994]                   }
[11:41:45.994]                 }, immediateCondition = function(cond) {
[11:41:45.994]                   sendCondition <- ...future.makeSendCondition()
[11:41:45.994]                   sendCondition(cond)
[11:41:45.994]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:45.994]                   {
[11:41:45.994]                     inherits <- base::inherits
[11:41:45.994]                     invokeRestart <- base::invokeRestart
[11:41:45.994]                     is.null <- base::is.null
[11:41:45.994]                     muffled <- FALSE
[11:41:45.994]                     if (inherits(cond, "message")) {
[11:41:45.994]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:45.994]                       if (muffled) 
[11:41:45.994]                         invokeRestart("muffleMessage")
[11:41:45.994]                     }
[11:41:45.994]                     else if (inherits(cond, "warning")) {
[11:41:45.994]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:45.994]                       if (muffled) 
[11:41:45.994]                         invokeRestart("muffleWarning")
[11:41:45.994]                     }
[11:41:45.994]                     else if (inherits(cond, "condition")) {
[11:41:45.994]                       if (!is.null(pattern)) {
[11:41:45.994]                         computeRestarts <- base::computeRestarts
[11:41:45.994]                         grepl <- base::grepl
[11:41:45.994]                         restarts <- computeRestarts(cond)
[11:41:45.994]                         for (restart in restarts) {
[11:41:45.994]                           name <- restart$name
[11:41:45.994]                           if (is.null(name)) 
[11:41:45.994]                             next
[11:41:45.994]                           if (!grepl(pattern, name)) 
[11:41:45.994]                             next
[11:41:45.994]                           invokeRestart(restart)
[11:41:45.994]                           muffled <- TRUE
[11:41:45.994]                           break
[11:41:45.994]                         }
[11:41:45.994]                       }
[11:41:45.994]                     }
[11:41:45.994]                     invisible(muffled)
[11:41:45.994]                   }
[11:41:45.994]                   muffleCondition(cond)
[11:41:45.994]                 })
[11:41:45.994]             }))
[11:41:45.994]             future::FutureResult(value = ...future.value$value, 
[11:41:45.994]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:45.994]                   ...future.rng), globalenv = if (FALSE) 
[11:41:45.994]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:45.994]                     ...future.globalenv.names))
[11:41:45.994]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:45.994]         }, condition = base::local({
[11:41:45.994]             c <- base::c
[11:41:45.994]             inherits <- base::inherits
[11:41:45.994]             invokeRestart <- base::invokeRestart
[11:41:45.994]             length <- base::length
[11:41:45.994]             list <- base::list
[11:41:45.994]             seq.int <- base::seq.int
[11:41:45.994]             signalCondition <- base::signalCondition
[11:41:45.994]             sys.calls <- base::sys.calls
[11:41:45.994]             `[[` <- base::`[[`
[11:41:45.994]             `+` <- base::`+`
[11:41:45.994]             `<<-` <- base::`<<-`
[11:41:45.994]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:45.994]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:45.994]                   3L)]
[11:41:45.994]             }
[11:41:45.994]             function(cond) {
[11:41:45.994]                 is_error <- inherits(cond, "error")
[11:41:45.994]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:45.994]                   NULL)
[11:41:45.994]                 if (is_error) {
[11:41:45.994]                   sessionInformation <- function() {
[11:41:45.994]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:45.994]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:45.994]                       search = base::search(), system = base::Sys.info())
[11:41:45.994]                   }
[11:41:45.994]                   ...future.conditions[[length(...future.conditions) + 
[11:41:45.994]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:45.994]                     cond$call), session = sessionInformation(), 
[11:41:45.994]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:45.994]                   signalCondition(cond)
[11:41:45.994]                 }
[11:41:45.994]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:45.994]                 "immediateCondition"))) {
[11:41:45.994]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:45.994]                   ...future.conditions[[length(...future.conditions) + 
[11:41:45.994]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:45.994]                   if (TRUE && !signal) {
[11:41:45.994]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:45.994]                     {
[11:41:45.994]                       inherits <- base::inherits
[11:41:45.994]                       invokeRestart <- base::invokeRestart
[11:41:45.994]                       is.null <- base::is.null
[11:41:45.994]                       muffled <- FALSE
[11:41:45.994]                       if (inherits(cond, "message")) {
[11:41:45.994]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:45.994]                         if (muffled) 
[11:41:45.994]                           invokeRestart("muffleMessage")
[11:41:45.994]                       }
[11:41:45.994]                       else if (inherits(cond, "warning")) {
[11:41:45.994]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:45.994]                         if (muffled) 
[11:41:45.994]                           invokeRestart("muffleWarning")
[11:41:45.994]                       }
[11:41:45.994]                       else if (inherits(cond, "condition")) {
[11:41:45.994]                         if (!is.null(pattern)) {
[11:41:45.994]                           computeRestarts <- base::computeRestarts
[11:41:45.994]                           grepl <- base::grepl
[11:41:45.994]                           restarts <- computeRestarts(cond)
[11:41:45.994]                           for (restart in restarts) {
[11:41:45.994]                             name <- restart$name
[11:41:45.994]                             if (is.null(name)) 
[11:41:45.994]                               next
[11:41:45.994]                             if (!grepl(pattern, name)) 
[11:41:45.994]                               next
[11:41:45.994]                             invokeRestart(restart)
[11:41:45.994]                             muffled <- TRUE
[11:41:45.994]                             break
[11:41:45.994]                           }
[11:41:45.994]                         }
[11:41:45.994]                       }
[11:41:45.994]                       invisible(muffled)
[11:41:45.994]                     }
[11:41:45.994]                     muffleCondition(cond, pattern = "^muffle")
[11:41:45.994]                   }
[11:41:45.994]                 }
[11:41:45.994]                 else {
[11:41:45.994]                   if (TRUE) {
[11:41:45.994]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:45.994]                     {
[11:41:45.994]                       inherits <- base::inherits
[11:41:45.994]                       invokeRestart <- base::invokeRestart
[11:41:45.994]                       is.null <- base::is.null
[11:41:45.994]                       muffled <- FALSE
[11:41:45.994]                       if (inherits(cond, "message")) {
[11:41:45.994]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:45.994]                         if (muffled) 
[11:41:45.994]                           invokeRestart("muffleMessage")
[11:41:45.994]                       }
[11:41:45.994]                       else if (inherits(cond, "warning")) {
[11:41:45.994]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:45.994]                         if (muffled) 
[11:41:45.994]                           invokeRestart("muffleWarning")
[11:41:45.994]                       }
[11:41:45.994]                       else if (inherits(cond, "condition")) {
[11:41:45.994]                         if (!is.null(pattern)) {
[11:41:45.994]                           computeRestarts <- base::computeRestarts
[11:41:45.994]                           grepl <- base::grepl
[11:41:45.994]                           restarts <- computeRestarts(cond)
[11:41:45.994]                           for (restart in restarts) {
[11:41:45.994]                             name <- restart$name
[11:41:45.994]                             if (is.null(name)) 
[11:41:45.994]                               next
[11:41:45.994]                             if (!grepl(pattern, name)) 
[11:41:45.994]                               next
[11:41:45.994]                             invokeRestart(restart)
[11:41:45.994]                             muffled <- TRUE
[11:41:45.994]                             break
[11:41:45.994]                           }
[11:41:45.994]                         }
[11:41:45.994]                       }
[11:41:45.994]                       invisible(muffled)
[11:41:45.994]                     }
[11:41:45.994]                     muffleCondition(cond, pattern = "^muffle")
[11:41:45.994]                   }
[11:41:45.994]                 }
[11:41:45.994]             }
[11:41:45.994]         }))
[11:41:45.994]     }, error = function(ex) {
[11:41:45.994]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:45.994]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:45.994]                 ...future.rng), started = ...future.startTime, 
[11:41:45.994]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:45.994]             version = "1.8"), class = "FutureResult")
[11:41:45.994]     }, finally = {
[11:41:45.994]         if (!identical(...future.workdir, getwd())) 
[11:41:45.994]             setwd(...future.workdir)
[11:41:45.994]         {
[11:41:45.994]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:45.994]                 ...future.oldOptions$nwarnings <- NULL
[11:41:45.994]             }
[11:41:45.994]             base::options(...future.oldOptions)
[11:41:45.994]             if (.Platform$OS.type == "windows") {
[11:41:45.994]                 old_names <- names(...future.oldEnvVars)
[11:41:45.994]                 envs <- base::Sys.getenv()
[11:41:45.994]                 names <- names(envs)
[11:41:45.994]                 common <- intersect(names, old_names)
[11:41:45.994]                 added <- setdiff(names, old_names)
[11:41:45.994]                 removed <- setdiff(old_names, names)
[11:41:45.994]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:45.994]                   envs[common]]
[11:41:45.994]                 NAMES <- toupper(changed)
[11:41:45.994]                 args <- list()
[11:41:45.994]                 for (kk in seq_along(NAMES)) {
[11:41:45.994]                   name <- changed[[kk]]
[11:41:45.994]                   NAME <- NAMES[[kk]]
[11:41:45.994]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:45.994]                     next
[11:41:45.994]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:45.994]                 }
[11:41:45.994]                 NAMES <- toupper(added)
[11:41:45.994]                 for (kk in seq_along(NAMES)) {
[11:41:45.994]                   name <- added[[kk]]
[11:41:45.994]                   NAME <- NAMES[[kk]]
[11:41:45.994]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:45.994]                     next
[11:41:45.994]                   args[[name]] <- ""
[11:41:45.994]                 }
[11:41:45.994]                 NAMES <- toupper(removed)
[11:41:45.994]                 for (kk in seq_along(NAMES)) {
[11:41:45.994]                   name <- removed[[kk]]
[11:41:45.994]                   NAME <- NAMES[[kk]]
[11:41:45.994]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:45.994]                     next
[11:41:45.994]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:45.994]                 }
[11:41:45.994]                 if (length(args) > 0) 
[11:41:45.994]                   base::do.call(base::Sys.setenv, args = args)
[11:41:45.994]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:45.994]             }
[11:41:45.994]             else {
[11:41:45.994]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:45.994]             }
[11:41:45.994]             {
[11:41:45.994]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:45.994]                   0L) {
[11:41:45.994]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:45.994]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:45.994]                   base::options(opts)
[11:41:45.994]                 }
[11:41:45.994]                 {
[11:41:45.994]                   {
[11:41:45.994]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:45.994]                     NULL
[11:41:45.994]                   }
[11:41:45.994]                   options(future.plan = NULL)
[11:41:45.994]                   if (is.na(NA_character_)) 
[11:41:45.994]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:45.994]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:45.994]                   future::plan(list(function (..., workers = 2, 
[11:41:45.994]                     envir = parent.frame()) 
[11:41:45.994]                   strategy(..., workers = workers, envir = envir)), 
[11:41:45.994]                     .cleanup = FALSE, .init = FALSE)
[11:41:45.994]                 }
[11:41:45.994]             }
[11:41:45.994]         }
[11:41:45.994]     })
[11:41:45.994]     if (TRUE) {
[11:41:45.994]         base::sink(type = "output", split = FALSE)
[11:41:45.994]         if (TRUE) {
[11:41:45.994]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:45.994]         }
[11:41:45.994]         else {
[11:41:45.994]             ...future.result["stdout"] <- base::list(NULL)
[11:41:45.994]         }
[11:41:45.994]         base::close(...future.stdout)
[11:41:45.994]         ...future.stdout <- NULL
[11:41:45.994]     }
[11:41:45.994]     ...future.result$conditions <- ...future.conditions
[11:41:45.994]     ...future.result$finished <- base::Sys.time()
[11:41:45.994]     ...future.result
[11:41:45.994] }
[11:41:46.026] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:46.026] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:46.106] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:46.110] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:46.154] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:46.155] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:46.203] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:46.204] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:46.206] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:46.206] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:46.207] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:46.208] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:46.208] MultisessionFuture started
[11:41:46.208] - Launch lazy future ... done
[11:41:46.209] run() for ‘MultisessionFuture’ ... done
[11:41:46.209] Created future:
[11:41:46.209] MultisessionFuture:
[11:41:46.209] Label: ‘future_mapply-2’
[11:41:46.209] Expression:
[11:41:46.209] {
[11:41:46.209]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:46.209]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:46.209]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:46.209]         on.exit(options(oopts), add = TRUE)
[11:41:46.209]     }
[11:41:46.209]     {
[11:41:46.209]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:46.209]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:46.209]                 inherits = FALSE)
[11:41:46.209]             ...future.FUN(...)
[11:41:46.209]         }
[11:41:46.209]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:46.209]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:46.209]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:46.209]         do.call(mapply, args = args)
[11:41:46.209]     }
[11:41:46.209] }
[11:41:46.209] Lazy evaluation: FALSE
[11:41:46.209] Asynchronous evaluation: TRUE
[11:41:46.209] Local evaluation: TRUE
[11:41:46.209] Environment: 0x560ef58e1768
[11:41:46.209] Capture standard output: TRUE
[11:41:46.209] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:46.209] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:46.209] Packages: 1 packages (‘mlr3’)
[11:41:46.209] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:46.209] Resolved: FALSE
[11:41:46.209] Value: <not collected>
[11:41:46.209] Conditions captured: <none>
[11:41:46.209] Early signaling: FALSE
[11:41:46.209] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:46.209] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:46.225] Chunk #2 of 90 ... DONE
[11:41:46.225] Chunk #3 of 90 ...
[11:41:46.225]  - seeds: [1] <seeds>
[11:41:46.225] getGlobalsAndPackages() ...
[11:41:46.225] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:46.226] Resolving globals: FALSE
[11:41:46.226] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:46.226] - packages: [1] ‘mlr3’
[11:41:46.226] getGlobalsAndPackages() ... DONE
[11:41:46.227] run() for ‘Future’ ...
[11:41:46.227] - state: ‘created’
[11:41:46.227] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:46.237] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:46.237] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:46.238]   - Field: ‘node’
[11:41:46.238]   - Field: ‘label’
[11:41:46.238]   - Field: ‘local’
[11:41:46.238]   - Field: ‘owner’
[11:41:46.238]   - Field: ‘envir’
[11:41:46.238]   - Field: ‘workers’
[11:41:46.238]   - Field: ‘packages’
[11:41:46.238]   - Field: ‘gc’
[11:41:46.238]   - Field: ‘conditions’
[11:41:46.238]   - Field: ‘persistent’
[11:41:46.238]   - Field: ‘expr’
[11:41:46.238]   - Field: ‘uuid’
[11:41:46.238]   - Field: ‘seed’
[11:41:46.238]   - Field: ‘version’
[11:41:46.238]   - Field: ‘result’
[11:41:46.238]   - Field: ‘asynchronous’
[11:41:46.238]   - Field: ‘calls’
[11:41:46.238]   - Field: ‘globals’
[11:41:46.238]   - Field: ‘stdout’
[11:41:46.238]   - Field: ‘earlySignal’
[11:41:46.238]   - Field: ‘lazy’
[11:41:46.238]   - Field: ‘state’
[11:41:46.238] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:46.239] - Launch lazy future ...
[11:41:46.239] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:46.239] Packages needed by future strategies (n = 0): <none>
[11:41:46.239] {
[11:41:46.239]     {
[11:41:46.239]         {
[11:41:46.239]             ...future.startTime <- base::Sys.time()
[11:41:46.239]             {
[11:41:46.239]                 {
[11:41:46.239]                   {
[11:41:46.239]                     {
[11:41:46.239]                       {
[11:41:46.239]                         base::local({
[11:41:46.239]                           has_future <- base::requireNamespace("future", 
[11:41:46.239]                             quietly = TRUE)
[11:41:46.239]                           if (has_future) {
[11:41:46.239]                             ns <- base::getNamespace("future")
[11:41:46.239]                             version <- ns[[".package"]][["version"]]
[11:41:46.239]                             if (is.null(version)) 
[11:41:46.239]                               version <- utils::packageVersion("future")
[11:41:46.239]                           }
[11:41:46.239]                           else {
[11:41:46.239]                             version <- NULL
[11:41:46.239]                           }
[11:41:46.239]                           if (!has_future || version < "1.8.0") {
[11:41:46.239]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:46.239]                               "", base::R.version$version.string), 
[11:41:46.239]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:46.239]                                 base::R.version$platform, 8 * 
[11:41:46.239]                                   base::.Machine$sizeof.pointer), 
[11:41:46.239]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:46.239]                                 "release", "version")], collapse = " "), 
[11:41:46.239]                               hostname = base::Sys.info()[["nodename"]])
[11:41:46.239]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:46.239]                               info)
[11:41:46.239]                             info <- base::paste(info, collapse = "; ")
[11:41:46.239]                             if (!has_future) {
[11:41:46.239]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:46.239]                                 info)
[11:41:46.239]                             }
[11:41:46.239]                             else {
[11:41:46.239]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:46.239]                                 info, version)
[11:41:46.239]                             }
[11:41:46.239]                             base::stop(msg)
[11:41:46.239]                           }
[11:41:46.239]                         })
[11:41:46.239]                       }
[11:41:46.239]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:46.239]                       base::options(mc.cores = 1L)
[11:41:46.239]                     }
[11:41:46.239]                     base::local({
[11:41:46.239]                       for (pkg in "mlr3") {
[11:41:46.239]                         base::loadNamespace(pkg)
[11:41:46.239]                         base::library(pkg, character.only = TRUE)
[11:41:46.239]                       }
[11:41:46.239]                     })
[11:41:46.239]                   }
[11:41:46.239]                   options(future.plan = NULL)
[11:41:46.239]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:46.239]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:46.239]                 }
[11:41:46.239]                 ...future.workdir <- getwd()
[11:41:46.239]             }
[11:41:46.239]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:46.239]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:46.239]         }
[11:41:46.239]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:46.239]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:46.239]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:46.239]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:46.239]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:46.239]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:46.239]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:46.239]             base::names(...future.oldOptions))
[11:41:46.239]     }
[11:41:46.239]     if (FALSE) {
[11:41:46.239]     }
[11:41:46.239]     else {
[11:41:46.239]         if (TRUE) {
[11:41:46.239]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:46.239]                 open = "w")
[11:41:46.239]         }
[11:41:46.239]         else {
[11:41:46.239]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:46.239]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:46.239]         }
[11:41:46.239]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:46.239]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:46.239]             base::sink(type = "output", split = FALSE)
[11:41:46.239]             base::close(...future.stdout)
[11:41:46.239]         }, add = TRUE)
[11:41:46.239]     }
[11:41:46.239]     ...future.frame <- base::sys.nframe()
[11:41:46.239]     ...future.conditions <- base::list()
[11:41:46.239]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:46.239]     if (FALSE) {
[11:41:46.239]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:46.239]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:46.239]     }
[11:41:46.239]     ...future.result <- base::tryCatch({
[11:41:46.239]         base::withCallingHandlers({
[11:41:46.239]             ...future.value <- base::withVisible(base::local({
[11:41:46.239]                 ...future.makeSendCondition <- local({
[11:41:46.239]                   sendCondition <- NULL
[11:41:46.239]                   function(frame = 1L) {
[11:41:46.239]                     if (is.function(sendCondition)) 
[11:41:46.239]                       return(sendCondition)
[11:41:46.239]                     ns <- getNamespace("parallel")
[11:41:46.239]                     if (exists("sendData", mode = "function", 
[11:41:46.239]                       envir = ns)) {
[11:41:46.239]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:46.239]                         envir = ns)
[11:41:46.239]                       envir <- sys.frame(frame)
[11:41:46.239]                       master <- NULL
[11:41:46.239]                       while (!identical(envir, .GlobalEnv) && 
[11:41:46.239]                         !identical(envir, emptyenv())) {
[11:41:46.239]                         if (exists("master", mode = "list", envir = envir, 
[11:41:46.239]                           inherits = FALSE)) {
[11:41:46.239]                           master <- get("master", mode = "list", 
[11:41:46.239]                             envir = envir, inherits = FALSE)
[11:41:46.239]                           if (inherits(master, c("SOCKnode", 
[11:41:46.239]                             "SOCK0node"))) {
[11:41:46.239]                             sendCondition <<- function(cond) {
[11:41:46.239]                               data <- list(type = "VALUE", value = cond, 
[11:41:46.239]                                 success = TRUE)
[11:41:46.239]                               parallel_sendData(master, data)
[11:41:46.239]                             }
[11:41:46.239]                             return(sendCondition)
[11:41:46.239]                           }
[11:41:46.239]                         }
[11:41:46.239]                         frame <- frame + 1L
[11:41:46.239]                         envir <- sys.frame(frame)
[11:41:46.239]                       }
[11:41:46.239]                     }
[11:41:46.239]                     sendCondition <<- function(cond) NULL
[11:41:46.239]                   }
[11:41:46.239]                 })
[11:41:46.239]                 withCallingHandlers({
[11:41:46.239]                   {
[11:41:46.239]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:46.239]                     if (!identical(...future.globals.maxSize.org, 
[11:41:46.239]                       ...future.globals.maxSize)) {
[11:41:46.239]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:46.239]                       on.exit(options(oopts), add = TRUE)
[11:41:46.239]                     }
[11:41:46.239]                     {
[11:41:46.239]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:46.239]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:46.239]                           envir = globalenv(), inherits = FALSE)
[11:41:46.239]                         ...future.FUN(...)
[11:41:46.239]                       }
[11:41:46.239]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:46.239]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:46.239]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:46.239]                         USE.NAMES = FALSE)
[11:41:46.239]                       do.call(mapply, args = args)
[11:41:46.239]                     }
[11:41:46.239]                   }
[11:41:46.239]                 }, immediateCondition = function(cond) {
[11:41:46.239]                   sendCondition <- ...future.makeSendCondition()
[11:41:46.239]                   sendCondition(cond)
[11:41:46.239]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:46.239]                   {
[11:41:46.239]                     inherits <- base::inherits
[11:41:46.239]                     invokeRestart <- base::invokeRestart
[11:41:46.239]                     is.null <- base::is.null
[11:41:46.239]                     muffled <- FALSE
[11:41:46.239]                     if (inherits(cond, "message")) {
[11:41:46.239]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:46.239]                       if (muffled) 
[11:41:46.239]                         invokeRestart("muffleMessage")
[11:41:46.239]                     }
[11:41:46.239]                     else if (inherits(cond, "warning")) {
[11:41:46.239]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:46.239]                       if (muffled) 
[11:41:46.239]                         invokeRestart("muffleWarning")
[11:41:46.239]                     }
[11:41:46.239]                     else if (inherits(cond, "condition")) {
[11:41:46.239]                       if (!is.null(pattern)) {
[11:41:46.239]                         computeRestarts <- base::computeRestarts
[11:41:46.239]                         grepl <- base::grepl
[11:41:46.239]                         restarts <- computeRestarts(cond)
[11:41:46.239]                         for (restart in restarts) {
[11:41:46.239]                           name <- restart$name
[11:41:46.239]                           if (is.null(name)) 
[11:41:46.239]                             next
[11:41:46.239]                           if (!grepl(pattern, name)) 
[11:41:46.239]                             next
[11:41:46.239]                           invokeRestart(restart)
[11:41:46.239]                           muffled <- TRUE
[11:41:46.239]                           break
[11:41:46.239]                         }
[11:41:46.239]                       }
[11:41:46.239]                     }
[11:41:46.239]                     invisible(muffled)
[11:41:46.239]                   }
[11:41:46.239]                   muffleCondition(cond)
[11:41:46.239]                 })
[11:41:46.239]             }))
[11:41:46.239]             future::FutureResult(value = ...future.value$value, 
[11:41:46.239]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:46.239]                   ...future.rng), globalenv = if (FALSE) 
[11:41:46.239]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:46.239]                     ...future.globalenv.names))
[11:41:46.239]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:46.239]         }, condition = base::local({
[11:41:46.239]             c <- base::c
[11:41:46.239]             inherits <- base::inherits
[11:41:46.239]             invokeRestart <- base::invokeRestart
[11:41:46.239]             length <- base::length
[11:41:46.239]             list <- base::list
[11:41:46.239]             seq.int <- base::seq.int
[11:41:46.239]             signalCondition <- base::signalCondition
[11:41:46.239]             sys.calls <- base::sys.calls
[11:41:46.239]             `[[` <- base::`[[`
[11:41:46.239]             `+` <- base::`+`
[11:41:46.239]             `<<-` <- base::`<<-`
[11:41:46.239]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:46.239]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:46.239]                   3L)]
[11:41:46.239]             }
[11:41:46.239]             function(cond) {
[11:41:46.239]                 is_error <- inherits(cond, "error")
[11:41:46.239]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:46.239]                   NULL)
[11:41:46.239]                 if (is_error) {
[11:41:46.239]                   sessionInformation <- function() {
[11:41:46.239]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:46.239]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:46.239]                       search = base::search(), system = base::Sys.info())
[11:41:46.239]                   }
[11:41:46.239]                   ...future.conditions[[length(...future.conditions) + 
[11:41:46.239]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:46.239]                     cond$call), session = sessionInformation(), 
[11:41:46.239]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:46.239]                   signalCondition(cond)
[11:41:46.239]                 }
[11:41:46.239]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:46.239]                 "immediateCondition"))) {
[11:41:46.239]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:46.239]                   ...future.conditions[[length(...future.conditions) + 
[11:41:46.239]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:46.239]                   if (TRUE && !signal) {
[11:41:46.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:46.239]                     {
[11:41:46.239]                       inherits <- base::inherits
[11:41:46.239]                       invokeRestart <- base::invokeRestart
[11:41:46.239]                       is.null <- base::is.null
[11:41:46.239]                       muffled <- FALSE
[11:41:46.239]                       if (inherits(cond, "message")) {
[11:41:46.239]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:46.239]                         if (muffled) 
[11:41:46.239]                           invokeRestart("muffleMessage")
[11:41:46.239]                       }
[11:41:46.239]                       else if (inherits(cond, "warning")) {
[11:41:46.239]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:46.239]                         if (muffled) 
[11:41:46.239]                           invokeRestart("muffleWarning")
[11:41:46.239]                       }
[11:41:46.239]                       else if (inherits(cond, "condition")) {
[11:41:46.239]                         if (!is.null(pattern)) {
[11:41:46.239]                           computeRestarts <- base::computeRestarts
[11:41:46.239]                           grepl <- base::grepl
[11:41:46.239]                           restarts <- computeRestarts(cond)
[11:41:46.239]                           for (restart in restarts) {
[11:41:46.239]                             name <- restart$name
[11:41:46.239]                             if (is.null(name)) 
[11:41:46.239]                               next
[11:41:46.239]                             if (!grepl(pattern, name)) 
[11:41:46.239]                               next
[11:41:46.239]                             invokeRestart(restart)
[11:41:46.239]                             muffled <- TRUE
[11:41:46.239]                             break
[11:41:46.239]                           }
[11:41:46.239]                         }
[11:41:46.239]                       }
[11:41:46.239]                       invisible(muffled)
[11:41:46.239]                     }
[11:41:46.239]                     muffleCondition(cond, pattern = "^muffle")
[11:41:46.239]                   }
[11:41:46.239]                 }
[11:41:46.239]                 else {
[11:41:46.239]                   if (TRUE) {
[11:41:46.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:46.239]                     {
[11:41:46.239]                       inherits <- base::inherits
[11:41:46.239]                       invokeRestart <- base::invokeRestart
[11:41:46.239]                       is.null <- base::is.null
[11:41:46.239]                       muffled <- FALSE
[11:41:46.239]                       if (inherits(cond, "message")) {
[11:41:46.239]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:46.239]                         if (muffled) 
[11:41:46.239]                           invokeRestart("muffleMessage")
[11:41:46.239]                       }
[11:41:46.239]                       else if (inherits(cond, "warning")) {
[11:41:46.239]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:46.239]                         if (muffled) 
[11:41:46.239]                           invokeRestart("muffleWarning")
[11:41:46.239]                       }
[11:41:46.239]                       else if (inherits(cond, "condition")) {
[11:41:46.239]                         if (!is.null(pattern)) {
[11:41:46.239]                           computeRestarts <- base::computeRestarts
[11:41:46.239]                           grepl <- base::grepl
[11:41:46.239]                           restarts <- computeRestarts(cond)
[11:41:46.239]                           for (restart in restarts) {
[11:41:46.239]                             name <- restart$name
[11:41:46.239]                             if (is.null(name)) 
[11:41:46.239]                               next
[11:41:46.239]                             if (!grepl(pattern, name)) 
[11:41:46.239]                               next
[11:41:46.239]                             invokeRestart(restart)
[11:41:46.239]                             muffled <- TRUE
[11:41:46.239]                             break
[11:41:46.239]                           }
[11:41:46.239]                         }
[11:41:46.239]                       }
[11:41:46.239]                       invisible(muffled)
[11:41:46.239]                     }
[11:41:46.239]                     muffleCondition(cond, pattern = "^muffle")
[11:41:46.239]                   }
[11:41:46.239]                 }
[11:41:46.239]             }
[11:41:46.239]         }))
[11:41:46.239]     }, error = function(ex) {
[11:41:46.239]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:46.239]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:46.239]                 ...future.rng), started = ...future.startTime, 
[11:41:46.239]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:46.239]             version = "1.8"), class = "FutureResult")
[11:41:46.239]     }, finally = {
[11:41:46.239]         if (!identical(...future.workdir, getwd())) 
[11:41:46.239]             setwd(...future.workdir)
[11:41:46.239]         {
[11:41:46.239]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:46.239]                 ...future.oldOptions$nwarnings <- NULL
[11:41:46.239]             }
[11:41:46.239]             base::options(...future.oldOptions)
[11:41:46.239]             if (.Platform$OS.type == "windows") {
[11:41:46.239]                 old_names <- names(...future.oldEnvVars)
[11:41:46.239]                 envs <- base::Sys.getenv()
[11:41:46.239]                 names <- names(envs)
[11:41:46.239]                 common <- intersect(names, old_names)
[11:41:46.239]                 added <- setdiff(names, old_names)
[11:41:46.239]                 removed <- setdiff(old_names, names)
[11:41:46.239]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:46.239]                   envs[common]]
[11:41:46.239]                 NAMES <- toupper(changed)
[11:41:46.239]                 args <- list()
[11:41:46.239]                 for (kk in seq_along(NAMES)) {
[11:41:46.239]                   name <- changed[[kk]]
[11:41:46.239]                   NAME <- NAMES[[kk]]
[11:41:46.239]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:46.239]                     next
[11:41:46.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:46.239]                 }
[11:41:46.239]                 NAMES <- toupper(added)
[11:41:46.239]                 for (kk in seq_along(NAMES)) {
[11:41:46.239]                   name <- added[[kk]]
[11:41:46.239]                   NAME <- NAMES[[kk]]
[11:41:46.239]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:46.239]                     next
[11:41:46.239]                   args[[name]] <- ""
[11:41:46.239]                 }
[11:41:46.239]                 NAMES <- toupper(removed)
[11:41:46.239]                 for (kk in seq_along(NAMES)) {
[11:41:46.239]                   name <- removed[[kk]]
[11:41:46.239]                   NAME <- NAMES[[kk]]
[11:41:46.239]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:46.239]                     next
[11:41:46.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:46.239]                 }
[11:41:46.239]                 if (length(args) > 0) 
[11:41:46.239]                   base::do.call(base::Sys.setenv, args = args)
[11:41:46.239]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:46.239]             }
[11:41:46.239]             else {
[11:41:46.239]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:46.239]             }
[11:41:46.239]             {
[11:41:46.239]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:46.239]                   0L) {
[11:41:46.239]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:46.239]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:46.239]                   base::options(opts)
[11:41:46.239]                 }
[11:41:46.239]                 {
[11:41:46.239]                   {
[11:41:46.239]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:46.239]                     NULL
[11:41:46.239]                   }
[11:41:46.239]                   options(future.plan = NULL)
[11:41:46.239]                   if (is.na(NA_character_)) 
[11:41:46.239]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:46.239]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:46.239]                   future::plan(list(function (..., workers = 2, 
[11:41:46.239]                     envir = parent.frame()) 
[11:41:46.239]                   strategy(..., workers = workers, envir = envir)), 
[11:41:46.239]                     .cleanup = FALSE, .init = FALSE)
[11:41:46.239]                 }
[11:41:46.239]             }
[11:41:46.239]         }
[11:41:46.239]     })
[11:41:46.239]     if (TRUE) {
[11:41:46.239]         base::sink(type = "output", split = FALSE)
[11:41:46.239]         if (TRUE) {
[11:41:46.239]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:46.239]         }
[11:41:46.239]         else {
[11:41:46.239]             ...future.result["stdout"] <- base::list(NULL)
[11:41:46.239]         }
[11:41:46.239]         base::close(...future.stdout)
[11:41:46.239]         ...future.stdout <- NULL
[11:41:46.239]     }
[11:41:46.239]     ...future.result$conditions <- ...future.conditions
[11:41:46.239]     ...future.result$finished <- base::Sys.time()
[11:41:46.239]     ...future.result
[11:41:46.239] }
[11:41:46.241] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:46.251] receiveMessageFromWorker() for ClusterFuture ...
[11:41:46.251] - Validating connection of MultisessionFuture
[11:41:46.252] - received message: FutureResult
[11:41:46.252] - Received FutureResult
[11:41:46.252] - Erased future from FutureRegistry
[11:41:46.252] result() for ClusterFuture ...
[11:41:46.252] - result already collected: FutureResult
[11:41:46.252] result() for ClusterFuture ... done
[11:41:46.252] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:46.252] result() for ClusterFuture ...
[11:41:46.252] - result already collected: FutureResult
[11:41:46.252] result() for ClusterFuture ... done
[11:41:46.252] result() for ClusterFuture ...
[11:41:46.252] - result already collected: FutureResult
[11:41:46.252] result() for ClusterFuture ... done
[11:41:46.253] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:46.253] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:46.297] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:46.301] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:46.345] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:46.346] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:46.390] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:46.392] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:46.393] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:46.394] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:46.396] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:46.396] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:46.397] MultisessionFuture started
[11:41:46.397] - Launch lazy future ... done
[11:41:46.397] run() for ‘MultisessionFuture’ ... done
[11:41:46.397] Created future:
[11:41:46.397] MultisessionFuture:
[11:41:46.397] Label: ‘future_mapply-3’
[11:41:46.397] Expression:
[11:41:46.397] {
[11:41:46.397]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:46.397]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:46.397]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:46.397]         on.exit(options(oopts), add = TRUE)
[11:41:46.397]     }
[11:41:46.397]     {
[11:41:46.397]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:46.397]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:46.397]                 inherits = FALSE)
[11:41:46.397]             ...future.FUN(...)
[11:41:46.397]         }
[11:41:46.397]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:46.397]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:46.397]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:46.397]         do.call(mapply, args = args)
[11:41:46.397]     }
[11:41:46.397] }
[11:41:46.397] Lazy evaluation: FALSE
[11:41:46.397] Asynchronous evaluation: TRUE
[11:41:46.397] Local evaluation: TRUE
[11:41:46.397] Environment: 0x560ef58e1768
[11:41:46.397] Capture standard output: TRUE
[11:41:46.397] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:46.397] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:46.397] Packages: 1 packages (‘mlr3’)
[11:41:46.397] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:46.397] Resolved: FALSE
[11:41:46.397] Value: <not collected>
[11:41:46.397] Conditions captured: <none>
[11:41:46.397] Early signaling: FALSE
[11:41:46.397] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:46.397] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:46.411] Chunk #3 of 90 ... DONE
[11:41:46.411] Chunk #4 of 90 ...
[11:41:46.412]  - seeds: [1] <seeds>
[11:41:46.412] getGlobalsAndPackages() ...
[11:41:46.412] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:46.412] Resolving globals: FALSE
[11:41:46.413] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:46.413] - packages: [1] ‘mlr3’
[11:41:46.413] getGlobalsAndPackages() ... DONE
[11:41:46.413] run() for ‘Future’ ...
[11:41:46.413] - state: ‘created’
[11:41:46.414] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:46.438] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:46.438] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:46.438]   - Field: ‘node’
[11:41:46.438]   - Field: ‘label’
[11:41:46.438]   - Field: ‘local’
[11:41:46.438]   - Field: ‘owner’
[11:41:46.438]   - Field: ‘envir’
[11:41:46.438]   - Field: ‘workers’
[11:41:46.438]   - Field: ‘packages’
[11:41:46.438]   - Field: ‘gc’
[11:41:46.439]   - Field: ‘conditions’
[11:41:46.439]   - Field: ‘persistent’
[11:41:46.439]   - Field: ‘expr’
[11:41:46.439]   - Field: ‘uuid’
[11:41:46.439]   - Field: ‘seed’
[11:41:46.439]   - Field: ‘version’
[11:41:46.439]   - Field: ‘result’
[11:41:46.439]   - Field: ‘asynchronous’
[11:41:46.439]   - Field: ‘calls’
[11:41:46.439]   - Field: ‘globals’
[11:41:46.439]   - Field: ‘stdout’
[11:41:46.439]   - Field: ‘earlySignal’
[11:41:46.439]   - Field: ‘lazy’
[11:41:46.439]   - Field: ‘state’
[11:41:46.439] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:46.439] - Launch lazy future ...
[11:41:46.440] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:46.440] Packages needed by future strategies (n = 0): <none>
[11:41:46.440] {
[11:41:46.440]     {
[11:41:46.440]         {
[11:41:46.440]             ...future.startTime <- base::Sys.time()
[11:41:46.440]             {
[11:41:46.440]                 {
[11:41:46.440]                   {
[11:41:46.440]                     {
[11:41:46.440]                       {
[11:41:46.440]                         base::local({
[11:41:46.440]                           has_future <- base::requireNamespace("future", 
[11:41:46.440]                             quietly = TRUE)
[11:41:46.440]                           if (has_future) {
[11:41:46.440]                             ns <- base::getNamespace("future")
[11:41:46.440]                             version <- ns[[".package"]][["version"]]
[11:41:46.440]                             if (is.null(version)) 
[11:41:46.440]                               version <- utils::packageVersion("future")
[11:41:46.440]                           }
[11:41:46.440]                           else {
[11:41:46.440]                             version <- NULL
[11:41:46.440]                           }
[11:41:46.440]                           if (!has_future || version < "1.8.0") {
[11:41:46.440]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:46.440]                               "", base::R.version$version.string), 
[11:41:46.440]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:46.440]                                 base::R.version$platform, 8 * 
[11:41:46.440]                                   base::.Machine$sizeof.pointer), 
[11:41:46.440]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:46.440]                                 "release", "version")], collapse = " "), 
[11:41:46.440]                               hostname = base::Sys.info()[["nodename"]])
[11:41:46.440]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:46.440]                               info)
[11:41:46.440]                             info <- base::paste(info, collapse = "; ")
[11:41:46.440]                             if (!has_future) {
[11:41:46.440]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:46.440]                                 info)
[11:41:46.440]                             }
[11:41:46.440]                             else {
[11:41:46.440]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:46.440]                                 info, version)
[11:41:46.440]                             }
[11:41:46.440]                             base::stop(msg)
[11:41:46.440]                           }
[11:41:46.440]                         })
[11:41:46.440]                       }
[11:41:46.440]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:46.440]                       base::options(mc.cores = 1L)
[11:41:46.440]                     }
[11:41:46.440]                     base::local({
[11:41:46.440]                       for (pkg in "mlr3") {
[11:41:46.440]                         base::loadNamespace(pkg)
[11:41:46.440]                         base::library(pkg, character.only = TRUE)
[11:41:46.440]                       }
[11:41:46.440]                     })
[11:41:46.440]                   }
[11:41:46.440]                   options(future.plan = NULL)
[11:41:46.440]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:46.440]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:46.440]                 }
[11:41:46.440]                 ...future.workdir <- getwd()
[11:41:46.440]             }
[11:41:46.440]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:46.440]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:46.440]         }
[11:41:46.440]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:46.440]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:46.440]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:46.440]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:46.440]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:46.440]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:46.440]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:46.440]             base::names(...future.oldOptions))
[11:41:46.440]     }
[11:41:46.440]     if (FALSE) {
[11:41:46.440]     }
[11:41:46.440]     else {
[11:41:46.440]         if (TRUE) {
[11:41:46.440]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:46.440]                 open = "w")
[11:41:46.440]         }
[11:41:46.440]         else {
[11:41:46.440]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:46.440]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:46.440]         }
[11:41:46.440]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:46.440]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:46.440]             base::sink(type = "output", split = FALSE)
[11:41:46.440]             base::close(...future.stdout)
[11:41:46.440]         }, add = TRUE)
[11:41:46.440]     }
[11:41:46.440]     ...future.frame <- base::sys.nframe()
[11:41:46.440]     ...future.conditions <- base::list()
[11:41:46.440]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:46.440]     if (FALSE) {
[11:41:46.440]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:46.440]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:46.440]     }
[11:41:46.440]     ...future.result <- base::tryCatch({
[11:41:46.440]         base::withCallingHandlers({
[11:41:46.440]             ...future.value <- base::withVisible(base::local({
[11:41:46.440]                 ...future.makeSendCondition <- local({
[11:41:46.440]                   sendCondition <- NULL
[11:41:46.440]                   function(frame = 1L) {
[11:41:46.440]                     if (is.function(sendCondition)) 
[11:41:46.440]                       return(sendCondition)
[11:41:46.440]                     ns <- getNamespace("parallel")
[11:41:46.440]                     if (exists("sendData", mode = "function", 
[11:41:46.440]                       envir = ns)) {
[11:41:46.440]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:46.440]                         envir = ns)
[11:41:46.440]                       envir <- sys.frame(frame)
[11:41:46.440]                       master <- NULL
[11:41:46.440]                       while (!identical(envir, .GlobalEnv) && 
[11:41:46.440]                         !identical(envir, emptyenv())) {
[11:41:46.440]                         if (exists("master", mode = "list", envir = envir, 
[11:41:46.440]                           inherits = FALSE)) {
[11:41:46.440]                           master <- get("master", mode = "list", 
[11:41:46.440]                             envir = envir, inherits = FALSE)
[11:41:46.440]                           if (inherits(master, c("SOCKnode", 
[11:41:46.440]                             "SOCK0node"))) {
[11:41:46.440]                             sendCondition <<- function(cond) {
[11:41:46.440]                               data <- list(type = "VALUE", value = cond, 
[11:41:46.440]                                 success = TRUE)
[11:41:46.440]                               parallel_sendData(master, data)
[11:41:46.440]                             }
[11:41:46.440]                             return(sendCondition)
[11:41:46.440]                           }
[11:41:46.440]                         }
[11:41:46.440]                         frame <- frame + 1L
[11:41:46.440]                         envir <- sys.frame(frame)
[11:41:46.440]                       }
[11:41:46.440]                     }
[11:41:46.440]                     sendCondition <<- function(cond) NULL
[11:41:46.440]                   }
[11:41:46.440]                 })
[11:41:46.440]                 withCallingHandlers({
[11:41:46.440]                   {
[11:41:46.440]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:46.440]                     if (!identical(...future.globals.maxSize.org, 
[11:41:46.440]                       ...future.globals.maxSize)) {
[11:41:46.440]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:46.440]                       on.exit(options(oopts), add = TRUE)
[11:41:46.440]                     }
[11:41:46.440]                     {
[11:41:46.440]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:46.440]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:46.440]                           envir = globalenv(), inherits = FALSE)
[11:41:46.440]                         ...future.FUN(...)
[11:41:46.440]                       }
[11:41:46.440]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:46.440]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:46.440]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:46.440]                         USE.NAMES = FALSE)
[11:41:46.440]                       do.call(mapply, args = args)
[11:41:46.440]                     }
[11:41:46.440]                   }
[11:41:46.440]                 }, immediateCondition = function(cond) {
[11:41:46.440]                   sendCondition <- ...future.makeSendCondition()
[11:41:46.440]                   sendCondition(cond)
[11:41:46.440]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:46.440]                   {
[11:41:46.440]                     inherits <- base::inherits
[11:41:46.440]                     invokeRestart <- base::invokeRestart
[11:41:46.440]                     is.null <- base::is.null
[11:41:46.440]                     muffled <- FALSE
[11:41:46.440]                     if (inherits(cond, "message")) {
[11:41:46.440]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:46.440]                       if (muffled) 
[11:41:46.440]                         invokeRestart("muffleMessage")
[11:41:46.440]                     }
[11:41:46.440]                     else if (inherits(cond, "warning")) {
[11:41:46.440]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:46.440]                       if (muffled) 
[11:41:46.440]                         invokeRestart("muffleWarning")
[11:41:46.440]                     }
[11:41:46.440]                     else if (inherits(cond, "condition")) {
[11:41:46.440]                       if (!is.null(pattern)) {
[11:41:46.440]                         computeRestarts <- base::computeRestarts
[11:41:46.440]                         grepl <- base::grepl
[11:41:46.440]                         restarts <- computeRestarts(cond)
[11:41:46.440]                         for (restart in restarts) {
[11:41:46.440]                           name <- restart$name
[11:41:46.440]                           if (is.null(name)) 
[11:41:46.440]                             next
[11:41:46.440]                           if (!grepl(pattern, name)) 
[11:41:46.440]                             next
[11:41:46.440]                           invokeRestart(restart)
[11:41:46.440]                           muffled <- TRUE
[11:41:46.440]                           break
[11:41:46.440]                         }
[11:41:46.440]                       }
[11:41:46.440]                     }
[11:41:46.440]                     invisible(muffled)
[11:41:46.440]                   }
[11:41:46.440]                   muffleCondition(cond)
[11:41:46.440]                 })
[11:41:46.440]             }))
[11:41:46.440]             future::FutureResult(value = ...future.value$value, 
[11:41:46.440]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:46.440]                   ...future.rng), globalenv = if (FALSE) 
[11:41:46.440]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:46.440]                     ...future.globalenv.names))
[11:41:46.440]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:46.440]         }, condition = base::local({
[11:41:46.440]             c <- base::c
[11:41:46.440]             inherits <- base::inherits
[11:41:46.440]             invokeRestart <- base::invokeRestart
[11:41:46.440]             length <- base::length
[11:41:46.440]             list <- base::list
[11:41:46.440]             seq.int <- base::seq.int
[11:41:46.440]             signalCondition <- base::signalCondition
[11:41:46.440]             sys.calls <- base::sys.calls
[11:41:46.440]             `[[` <- base::`[[`
[11:41:46.440]             `+` <- base::`+`
[11:41:46.440]             `<<-` <- base::`<<-`
[11:41:46.440]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:46.440]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:46.440]                   3L)]
[11:41:46.440]             }
[11:41:46.440]             function(cond) {
[11:41:46.440]                 is_error <- inherits(cond, "error")
[11:41:46.440]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:46.440]                   NULL)
[11:41:46.440]                 if (is_error) {
[11:41:46.440]                   sessionInformation <- function() {
[11:41:46.440]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:46.440]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:46.440]                       search = base::search(), system = base::Sys.info())
[11:41:46.440]                   }
[11:41:46.440]                   ...future.conditions[[length(...future.conditions) + 
[11:41:46.440]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:46.440]                     cond$call), session = sessionInformation(), 
[11:41:46.440]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:46.440]                   signalCondition(cond)
[11:41:46.440]                 }
[11:41:46.440]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:46.440]                 "immediateCondition"))) {
[11:41:46.440]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:46.440]                   ...future.conditions[[length(...future.conditions) + 
[11:41:46.440]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:46.440]                   if (TRUE && !signal) {
[11:41:46.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:46.440]                     {
[11:41:46.440]                       inherits <- base::inherits
[11:41:46.440]                       invokeRestart <- base::invokeRestart
[11:41:46.440]                       is.null <- base::is.null
[11:41:46.440]                       muffled <- FALSE
[11:41:46.440]                       if (inherits(cond, "message")) {
[11:41:46.440]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:46.440]                         if (muffled) 
[11:41:46.440]                           invokeRestart("muffleMessage")
[11:41:46.440]                       }
[11:41:46.440]                       else if (inherits(cond, "warning")) {
[11:41:46.440]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:46.440]                         if (muffled) 
[11:41:46.440]                           invokeRestart("muffleWarning")
[11:41:46.440]                       }
[11:41:46.440]                       else if (inherits(cond, "condition")) {
[11:41:46.440]                         if (!is.null(pattern)) {
[11:41:46.440]                           computeRestarts <- base::computeRestarts
[11:41:46.440]                           grepl <- base::grepl
[11:41:46.440]                           restarts <- computeRestarts(cond)
[11:41:46.440]                           for (restart in restarts) {
[11:41:46.440]                             name <- restart$name
[11:41:46.440]                             if (is.null(name)) 
[11:41:46.440]                               next
[11:41:46.440]                             if (!grepl(pattern, name)) 
[11:41:46.440]                               next
[11:41:46.440]                             invokeRestart(restart)
[11:41:46.440]                             muffled <- TRUE
[11:41:46.440]                             break
[11:41:46.440]                           }
[11:41:46.440]                         }
[11:41:46.440]                       }
[11:41:46.440]                       invisible(muffled)
[11:41:46.440]                     }
[11:41:46.440]                     muffleCondition(cond, pattern = "^muffle")
[11:41:46.440]                   }
[11:41:46.440]                 }
[11:41:46.440]                 else {
[11:41:46.440]                   if (TRUE) {
[11:41:46.440]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:46.440]                     {
[11:41:46.440]                       inherits <- base::inherits
[11:41:46.440]                       invokeRestart <- base::invokeRestart
[11:41:46.440]                       is.null <- base::is.null
[11:41:46.440]                       muffled <- FALSE
[11:41:46.440]                       if (inherits(cond, "message")) {
[11:41:46.440]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:46.440]                         if (muffled) 
[11:41:46.440]                           invokeRestart("muffleMessage")
[11:41:46.440]                       }
[11:41:46.440]                       else if (inherits(cond, "warning")) {
[11:41:46.440]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:46.440]                         if (muffled) 
[11:41:46.440]                           invokeRestart("muffleWarning")
[11:41:46.440]                       }
[11:41:46.440]                       else if (inherits(cond, "condition")) {
[11:41:46.440]                         if (!is.null(pattern)) {
[11:41:46.440]                           computeRestarts <- base::computeRestarts
[11:41:46.440]                           grepl <- base::grepl
[11:41:46.440]                           restarts <- computeRestarts(cond)
[11:41:46.440]                           for (restart in restarts) {
[11:41:46.440]                             name <- restart$name
[11:41:46.440]                             if (is.null(name)) 
[11:41:46.440]                               next
[11:41:46.440]                             if (!grepl(pattern, name)) 
[11:41:46.440]                               next
[11:41:46.440]                             invokeRestart(restart)
[11:41:46.440]                             muffled <- TRUE
[11:41:46.440]                             break
[11:41:46.440]                           }
[11:41:46.440]                         }
[11:41:46.440]                       }
[11:41:46.440]                       invisible(muffled)
[11:41:46.440]                     }
[11:41:46.440]                     muffleCondition(cond, pattern = "^muffle")
[11:41:46.440]                   }
[11:41:46.440]                 }
[11:41:46.440]             }
[11:41:46.440]         }))
[11:41:46.440]     }, error = function(ex) {
[11:41:46.440]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:46.440]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:46.440]                 ...future.rng), started = ...future.startTime, 
[11:41:46.440]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:46.440]             version = "1.8"), class = "FutureResult")
[11:41:46.440]     }, finally = {
[11:41:46.440]         if (!identical(...future.workdir, getwd())) 
[11:41:46.440]             setwd(...future.workdir)
[11:41:46.440]         {
[11:41:46.440]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:46.440]                 ...future.oldOptions$nwarnings <- NULL
[11:41:46.440]             }
[11:41:46.440]             base::options(...future.oldOptions)
[11:41:46.440]             if (.Platform$OS.type == "windows") {
[11:41:46.440]                 old_names <- names(...future.oldEnvVars)
[11:41:46.440]                 envs <- base::Sys.getenv()
[11:41:46.440]                 names <- names(envs)
[11:41:46.440]                 common <- intersect(names, old_names)
[11:41:46.440]                 added <- setdiff(names, old_names)
[11:41:46.440]                 removed <- setdiff(old_names, names)
[11:41:46.440]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:46.440]                   envs[common]]
[11:41:46.440]                 NAMES <- toupper(changed)
[11:41:46.440]                 args <- list()
[11:41:46.440]                 for (kk in seq_along(NAMES)) {
[11:41:46.440]                   name <- changed[[kk]]
[11:41:46.440]                   NAME <- NAMES[[kk]]
[11:41:46.440]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:46.440]                     next
[11:41:46.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:46.440]                 }
[11:41:46.440]                 NAMES <- toupper(added)
[11:41:46.440]                 for (kk in seq_along(NAMES)) {
[11:41:46.440]                   name <- added[[kk]]
[11:41:46.440]                   NAME <- NAMES[[kk]]
[11:41:46.440]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:46.440]                     next
[11:41:46.440]                   args[[name]] <- ""
[11:41:46.440]                 }
[11:41:46.440]                 NAMES <- toupper(removed)
[11:41:46.440]                 for (kk in seq_along(NAMES)) {
[11:41:46.440]                   name <- removed[[kk]]
[11:41:46.440]                   NAME <- NAMES[[kk]]
[11:41:46.440]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:46.440]                     next
[11:41:46.440]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:46.440]                 }
[11:41:46.440]                 if (length(args) > 0) 
[11:41:46.440]                   base::do.call(base::Sys.setenv, args = args)
[11:41:46.440]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:46.440]             }
[11:41:46.440]             else {
[11:41:46.440]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:46.440]             }
[11:41:46.440]             {
[11:41:46.440]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:46.440]                   0L) {
[11:41:46.440]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:46.440]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:46.440]                   base::options(opts)
[11:41:46.440]                 }
[11:41:46.440]                 {
[11:41:46.440]                   {
[11:41:46.440]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:46.440]                     NULL
[11:41:46.440]                   }
[11:41:46.440]                   options(future.plan = NULL)
[11:41:46.440]                   if (is.na(NA_character_)) 
[11:41:46.440]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:46.440]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:46.440]                   future::plan(list(function (..., workers = 2, 
[11:41:46.440]                     envir = parent.frame()) 
[11:41:46.440]                   strategy(..., workers = workers, envir = envir)), 
[11:41:46.440]                     .cleanup = FALSE, .init = FALSE)
[11:41:46.440]                 }
[11:41:46.440]             }
[11:41:46.440]         }
[11:41:46.440]     })
[11:41:46.440]     if (TRUE) {
[11:41:46.440]         base::sink(type = "output", split = FALSE)
[11:41:46.440]         if (TRUE) {
[11:41:46.440]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:46.440]         }
[11:41:46.440]         else {
[11:41:46.440]             ...future.result["stdout"] <- base::list(NULL)
[11:41:46.440]         }
[11:41:46.440]         base::close(...future.stdout)
[11:41:46.440]         ...future.stdout <- NULL
[11:41:46.440]     }
[11:41:46.440]     ...future.result$conditions <- ...future.conditions
[11:41:46.440]     ...future.result$finished <- base::Sys.time()
[11:41:46.440]     ...future.result
[11:41:46.440] }
[11:41:46.442] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:46.453] receiveMessageFromWorker() for ClusterFuture ...
[11:41:46.453] - Validating connection of MultisessionFuture
[11:41:46.453] - received message: FutureResult
[11:41:46.453] - Received FutureResult
[11:41:46.453] - Erased future from FutureRegistry
[11:41:46.453] result() for ClusterFuture ...
[11:41:46.453] - result already collected: FutureResult
[11:41:46.453] result() for ClusterFuture ... done
[11:41:46.453] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:46.453] result() for ClusterFuture ...
[11:41:46.453] - result already collected: FutureResult
[11:41:46.453] result() for ClusterFuture ... done
[11:41:46.454] result() for ClusterFuture ...
[11:41:46.454] - result already collected: FutureResult
[11:41:46.454] result() for ClusterFuture ... done
[11:41:46.454] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:46.454] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:46.498] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:46.506] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:46.508] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:46.509] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:46.553] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:46.554] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:46.555] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:46.555] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:46.556] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:46.556] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:46.557] MultisessionFuture started
[11:41:46.557] - Launch lazy future ... done
[11:41:46.557] run() for ‘MultisessionFuture’ ... done
[11:41:46.557] Created future:
[11:41:46.558] MultisessionFuture:
[11:41:46.558] Label: ‘future_mapply-4’
[11:41:46.558] Expression:
[11:41:46.558] {
[11:41:46.558]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:46.558]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:46.558]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:46.558]         on.exit(options(oopts), add = TRUE)
[11:41:46.558]     }
[11:41:46.558]     {
[11:41:46.558]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:46.558]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:46.558]                 inherits = FALSE)
[11:41:46.558]             ...future.FUN(...)
[11:41:46.558]         }
[11:41:46.558]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:46.558]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:46.558]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:46.558]         do.call(mapply, args = args)
[11:41:46.558]     }
[11:41:46.558] }
[11:41:46.558] Lazy evaluation: FALSE
[11:41:46.558] Asynchronous evaluation: TRUE
[11:41:46.558] Local evaluation: TRUE
[11:41:46.558] Environment: 0x560ef58e1768
[11:41:46.558] Capture standard output: TRUE
[11:41:46.558] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:46.558] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:46.558] Packages: 1 packages (‘mlr3’)
[11:41:46.558] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:46.558] Resolved: FALSE
[11:41:46.558] Value: <not collected>
[11:41:46.558] Conditions captured: <none>
[11:41:46.558] Early signaling: FALSE
[11:41:46.558] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:46.558] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:46.573] Chunk #4 of 90 ... DONE
[11:41:46.573] Chunk #5 of 90 ...
[11:41:46.573]  - seeds: [1] <seeds>
[11:41:46.573] getGlobalsAndPackages() ...
[11:41:46.574] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:46.574] Resolving globals: FALSE
[11:41:46.574] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:46.574] - packages: [1] ‘mlr3’
[11:41:46.574] getGlobalsAndPackages() ... DONE
[11:41:46.575] run() for ‘Future’ ...
[11:41:46.575] - state: ‘created’
[11:41:46.575] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:46.585] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:46.585] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:46.585]   - Field: ‘node’
[11:41:46.585]   - Field: ‘label’
[11:41:46.585]   - Field: ‘local’
[11:41:46.585]   - Field: ‘owner’
[11:41:46.585]   - Field: ‘envir’
[11:41:46.586]   - Field: ‘workers’
[11:41:46.586]   - Field: ‘packages’
[11:41:46.586]   - Field: ‘gc’
[11:41:46.586]   - Field: ‘conditions’
[11:41:46.586]   - Field: ‘persistent’
[11:41:46.586]   - Field: ‘expr’
[11:41:46.586]   - Field: ‘uuid’
[11:41:46.586]   - Field: ‘seed’
[11:41:46.586]   - Field: ‘version’
[11:41:46.586]   - Field: ‘result’
[11:41:46.586]   - Field: ‘asynchronous’
[11:41:46.586]   - Field: ‘calls’
[11:41:46.586]   - Field: ‘globals’
[11:41:46.586]   - Field: ‘stdout’
[11:41:46.586]   - Field: ‘earlySignal’
[11:41:46.586]   - Field: ‘lazy’
[11:41:46.586]   - Field: ‘state’
[11:41:46.586] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:46.586] - Launch lazy future ...
[11:41:46.586] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:46.587] Packages needed by future strategies (n = 0): <none>
[11:41:46.587] {
[11:41:46.587]     {
[11:41:46.587]         {
[11:41:46.587]             ...future.startTime <- base::Sys.time()
[11:41:46.587]             {
[11:41:46.587]                 {
[11:41:46.587]                   {
[11:41:46.587]                     {
[11:41:46.587]                       {
[11:41:46.587]                         base::local({
[11:41:46.587]                           has_future <- base::requireNamespace("future", 
[11:41:46.587]                             quietly = TRUE)
[11:41:46.587]                           if (has_future) {
[11:41:46.587]                             ns <- base::getNamespace("future")
[11:41:46.587]                             version <- ns[[".package"]][["version"]]
[11:41:46.587]                             if (is.null(version)) 
[11:41:46.587]                               version <- utils::packageVersion("future")
[11:41:46.587]                           }
[11:41:46.587]                           else {
[11:41:46.587]                             version <- NULL
[11:41:46.587]                           }
[11:41:46.587]                           if (!has_future || version < "1.8.0") {
[11:41:46.587]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:46.587]                               "", base::R.version$version.string), 
[11:41:46.587]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:46.587]                                 base::R.version$platform, 8 * 
[11:41:46.587]                                   base::.Machine$sizeof.pointer), 
[11:41:46.587]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:46.587]                                 "release", "version")], collapse = " "), 
[11:41:46.587]                               hostname = base::Sys.info()[["nodename"]])
[11:41:46.587]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:46.587]                               info)
[11:41:46.587]                             info <- base::paste(info, collapse = "; ")
[11:41:46.587]                             if (!has_future) {
[11:41:46.587]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:46.587]                                 info)
[11:41:46.587]                             }
[11:41:46.587]                             else {
[11:41:46.587]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:46.587]                                 info, version)
[11:41:46.587]                             }
[11:41:46.587]                             base::stop(msg)
[11:41:46.587]                           }
[11:41:46.587]                         })
[11:41:46.587]                       }
[11:41:46.587]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:46.587]                       base::options(mc.cores = 1L)
[11:41:46.587]                     }
[11:41:46.587]                     base::local({
[11:41:46.587]                       for (pkg in "mlr3") {
[11:41:46.587]                         base::loadNamespace(pkg)
[11:41:46.587]                         base::library(pkg, character.only = TRUE)
[11:41:46.587]                       }
[11:41:46.587]                     })
[11:41:46.587]                   }
[11:41:46.587]                   options(future.plan = NULL)
[11:41:46.587]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:46.587]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:46.587]                 }
[11:41:46.587]                 ...future.workdir <- getwd()
[11:41:46.587]             }
[11:41:46.587]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:46.587]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:46.587]         }
[11:41:46.587]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:46.587]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:46.587]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:46.587]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:46.587]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:46.587]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:46.587]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:46.587]             base::names(...future.oldOptions))
[11:41:46.587]     }
[11:41:46.587]     if (FALSE) {
[11:41:46.587]     }
[11:41:46.587]     else {
[11:41:46.587]         if (TRUE) {
[11:41:46.587]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:46.587]                 open = "w")
[11:41:46.587]         }
[11:41:46.587]         else {
[11:41:46.587]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:46.587]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:46.587]         }
[11:41:46.587]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:46.587]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:46.587]             base::sink(type = "output", split = FALSE)
[11:41:46.587]             base::close(...future.stdout)
[11:41:46.587]         }, add = TRUE)
[11:41:46.587]     }
[11:41:46.587]     ...future.frame <- base::sys.nframe()
[11:41:46.587]     ...future.conditions <- base::list()
[11:41:46.587]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:46.587]     if (FALSE) {
[11:41:46.587]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:46.587]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:46.587]     }
[11:41:46.587]     ...future.result <- base::tryCatch({
[11:41:46.587]         base::withCallingHandlers({
[11:41:46.587]             ...future.value <- base::withVisible(base::local({
[11:41:46.587]                 ...future.makeSendCondition <- local({
[11:41:46.587]                   sendCondition <- NULL
[11:41:46.587]                   function(frame = 1L) {
[11:41:46.587]                     if (is.function(sendCondition)) 
[11:41:46.587]                       return(sendCondition)
[11:41:46.587]                     ns <- getNamespace("parallel")
[11:41:46.587]                     if (exists("sendData", mode = "function", 
[11:41:46.587]                       envir = ns)) {
[11:41:46.587]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:46.587]                         envir = ns)
[11:41:46.587]                       envir <- sys.frame(frame)
[11:41:46.587]                       master <- NULL
[11:41:46.587]                       while (!identical(envir, .GlobalEnv) && 
[11:41:46.587]                         !identical(envir, emptyenv())) {
[11:41:46.587]                         if (exists("master", mode = "list", envir = envir, 
[11:41:46.587]                           inherits = FALSE)) {
[11:41:46.587]                           master <- get("master", mode = "list", 
[11:41:46.587]                             envir = envir, inherits = FALSE)
[11:41:46.587]                           if (inherits(master, c("SOCKnode", 
[11:41:46.587]                             "SOCK0node"))) {
[11:41:46.587]                             sendCondition <<- function(cond) {
[11:41:46.587]                               data <- list(type = "VALUE", value = cond, 
[11:41:46.587]                                 success = TRUE)
[11:41:46.587]                               parallel_sendData(master, data)
[11:41:46.587]                             }
[11:41:46.587]                             return(sendCondition)
[11:41:46.587]                           }
[11:41:46.587]                         }
[11:41:46.587]                         frame <- frame + 1L
[11:41:46.587]                         envir <- sys.frame(frame)
[11:41:46.587]                       }
[11:41:46.587]                     }
[11:41:46.587]                     sendCondition <<- function(cond) NULL
[11:41:46.587]                   }
[11:41:46.587]                 })
[11:41:46.587]                 withCallingHandlers({
[11:41:46.587]                   {
[11:41:46.587]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:46.587]                     if (!identical(...future.globals.maxSize.org, 
[11:41:46.587]                       ...future.globals.maxSize)) {
[11:41:46.587]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:46.587]                       on.exit(options(oopts), add = TRUE)
[11:41:46.587]                     }
[11:41:46.587]                     {
[11:41:46.587]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:46.587]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:46.587]                           envir = globalenv(), inherits = FALSE)
[11:41:46.587]                         ...future.FUN(...)
[11:41:46.587]                       }
[11:41:46.587]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:46.587]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:46.587]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:46.587]                         USE.NAMES = FALSE)
[11:41:46.587]                       do.call(mapply, args = args)
[11:41:46.587]                     }
[11:41:46.587]                   }
[11:41:46.587]                 }, immediateCondition = function(cond) {
[11:41:46.587]                   sendCondition <- ...future.makeSendCondition()
[11:41:46.587]                   sendCondition(cond)
[11:41:46.587]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:46.587]                   {
[11:41:46.587]                     inherits <- base::inherits
[11:41:46.587]                     invokeRestart <- base::invokeRestart
[11:41:46.587]                     is.null <- base::is.null
[11:41:46.587]                     muffled <- FALSE
[11:41:46.587]                     if (inherits(cond, "message")) {
[11:41:46.587]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:46.587]                       if (muffled) 
[11:41:46.587]                         invokeRestart("muffleMessage")
[11:41:46.587]                     }
[11:41:46.587]                     else if (inherits(cond, "warning")) {
[11:41:46.587]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:46.587]                       if (muffled) 
[11:41:46.587]                         invokeRestart("muffleWarning")
[11:41:46.587]                     }
[11:41:46.587]                     else if (inherits(cond, "condition")) {
[11:41:46.587]                       if (!is.null(pattern)) {
[11:41:46.587]                         computeRestarts <- base::computeRestarts
[11:41:46.587]                         grepl <- base::grepl
[11:41:46.587]                         restarts <- computeRestarts(cond)
[11:41:46.587]                         for (restart in restarts) {
[11:41:46.587]                           name <- restart$name
[11:41:46.587]                           if (is.null(name)) 
[11:41:46.587]                             next
[11:41:46.587]                           if (!grepl(pattern, name)) 
[11:41:46.587]                             next
[11:41:46.587]                           invokeRestart(restart)
[11:41:46.587]                           muffled <- TRUE
[11:41:46.587]                           break
[11:41:46.587]                         }
[11:41:46.587]                       }
[11:41:46.587]                     }
[11:41:46.587]                     invisible(muffled)
[11:41:46.587]                   }
[11:41:46.587]                   muffleCondition(cond)
[11:41:46.587]                 })
[11:41:46.587]             }))
[11:41:46.587]             future::FutureResult(value = ...future.value$value, 
[11:41:46.587]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:46.587]                   ...future.rng), globalenv = if (FALSE) 
[11:41:46.587]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:46.587]                     ...future.globalenv.names))
[11:41:46.587]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:46.587]         }, condition = base::local({
[11:41:46.587]             c <- base::c
[11:41:46.587]             inherits <- base::inherits
[11:41:46.587]             invokeRestart <- base::invokeRestart
[11:41:46.587]             length <- base::length
[11:41:46.587]             list <- base::list
[11:41:46.587]             seq.int <- base::seq.int
[11:41:46.587]             signalCondition <- base::signalCondition
[11:41:46.587]             sys.calls <- base::sys.calls
[11:41:46.587]             `[[` <- base::`[[`
[11:41:46.587]             `+` <- base::`+`
[11:41:46.587]             `<<-` <- base::`<<-`
[11:41:46.587]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:46.587]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:46.587]                   3L)]
[11:41:46.587]             }
[11:41:46.587]             function(cond) {
[11:41:46.587]                 is_error <- inherits(cond, "error")
[11:41:46.587]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:46.587]                   NULL)
[11:41:46.587]                 if (is_error) {
[11:41:46.587]                   sessionInformation <- function() {
[11:41:46.587]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:46.587]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:46.587]                       search = base::search(), system = base::Sys.info())
[11:41:46.587]                   }
[11:41:46.587]                   ...future.conditions[[length(...future.conditions) + 
[11:41:46.587]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:46.587]                     cond$call), session = sessionInformation(), 
[11:41:46.587]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:46.587]                   signalCondition(cond)
[11:41:46.587]                 }
[11:41:46.587]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:46.587]                 "immediateCondition"))) {
[11:41:46.587]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:46.587]                   ...future.conditions[[length(...future.conditions) + 
[11:41:46.587]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:46.587]                   if (TRUE && !signal) {
[11:41:46.587]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:46.587]                     {
[11:41:46.587]                       inherits <- base::inherits
[11:41:46.587]                       invokeRestart <- base::invokeRestart
[11:41:46.587]                       is.null <- base::is.null
[11:41:46.587]                       muffled <- FALSE
[11:41:46.587]                       if (inherits(cond, "message")) {
[11:41:46.587]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:46.587]                         if (muffled) 
[11:41:46.587]                           invokeRestart("muffleMessage")
[11:41:46.587]                       }
[11:41:46.587]                       else if (inherits(cond, "warning")) {
[11:41:46.587]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:46.587]                         if (muffled) 
[11:41:46.587]                           invokeRestart("muffleWarning")
[11:41:46.587]                       }
[11:41:46.587]                       else if (inherits(cond, "condition")) {
[11:41:46.587]                         if (!is.null(pattern)) {
[11:41:46.587]                           computeRestarts <- base::computeRestarts
[11:41:46.587]                           grepl <- base::grepl
[11:41:46.587]                           restarts <- computeRestarts(cond)
[11:41:46.587]                           for (restart in restarts) {
[11:41:46.587]                             name <- restart$name
[11:41:46.587]                             if (is.null(name)) 
[11:41:46.587]                               next
[11:41:46.587]                             if (!grepl(pattern, name)) 
[11:41:46.587]                               next
[11:41:46.587]                             invokeRestart(restart)
[11:41:46.587]                             muffled <- TRUE
[11:41:46.587]                             break
[11:41:46.587]                           }
[11:41:46.587]                         }
[11:41:46.587]                       }
[11:41:46.587]                       invisible(muffled)
[11:41:46.587]                     }
[11:41:46.587]                     muffleCondition(cond, pattern = "^muffle")
[11:41:46.587]                   }
[11:41:46.587]                 }
[11:41:46.587]                 else {
[11:41:46.587]                   if (TRUE) {
[11:41:46.587]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:46.587]                     {
[11:41:46.587]                       inherits <- base::inherits
[11:41:46.587]                       invokeRestart <- base::invokeRestart
[11:41:46.587]                       is.null <- base::is.null
[11:41:46.587]                       muffled <- FALSE
[11:41:46.587]                       if (inherits(cond, "message")) {
[11:41:46.587]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:46.587]                         if (muffled) 
[11:41:46.587]                           invokeRestart("muffleMessage")
[11:41:46.587]                       }
[11:41:46.587]                       else if (inherits(cond, "warning")) {
[11:41:46.587]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:46.587]                         if (muffled) 
[11:41:46.587]                           invokeRestart("muffleWarning")
[11:41:46.587]                       }
[11:41:46.587]                       else if (inherits(cond, "condition")) {
[11:41:46.587]                         if (!is.null(pattern)) {
[11:41:46.587]                           computeRestarts <- base::computeRestarts
[11:41:46.587]                           grepl <- base::grepl
[11:41:46.587]                           restarts <- computeRestarts(cond)
[11:41:46.587]                           for (restart in restarts) {
[11:41:46.587]                             name <- restart$name
[11:41:46.587]                             if (is.null(name)) 
[11:41:46.587]                               next
[11:41:46.587]                             if (!grepl(pattern, name)) 
[11:41:46.587]                               next
[11:41:46.587]                             invokeRestart(restart)
[11:41:46.587]                             muffled <- TRUE
[11:41:46.587]                             break
[11:41:46.587]                           }
[11:41:46.587]                         }
[11:41:46.587]                       }
[11:41:46.587]                       invisible(muffled)
[11:41:46.587]                     }
[11:41:46.587]                     muffleCondition(cond, pattern = "^muffle")
[11:41:46.587]                   }
[11:41:46.587]                 }
[11:41:46.587]             }
[11:41:46.587]         }))
[11:41:46.587]     }, error = function(ex) {
[11:41:46.587]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:46.587]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:46.587]                 ...future.rng), started = ...future.startTime, 
[11:41:46.587]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:46.587]             version = "1.8"), class = "FutureResult")
[11:41:46.587]     }, finally = {
[11:41:46.587]         if (!identical(...future.workdir, getwd())) 
[11:41:46.587]             setwd(...future.workdir)
[11:41:46.587]         {
[11:41:46.587]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:46.587]                 ...future.oldOptions$nwarnings <- NULL
[11:41:46.587]             }
[11:41:46.587]             base::options(...future.oldOptions)
[11:41:46.587]             if (.Platform$OS.type == "windows") {
[11:41:46.587]                 old_names <- names(...future.oldEnvVars)
[11:41:46.587]                 envs <- base::Sys.getenv()
[11:41:46.587]                 names <- names(envs)
[11:41:46.587]                 common <- intersect(names, old_names)
[11:41:46.587]                 added <- setdiff(names, old_names)
[11:41:46.587]                 removed <- setdiff(old_names, names)
[11:41:46.587]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:46.587]                   envs[common]]
[11:41:46.587]                 NAMES <- toupper(changed)
[11:41:46.587]                 args <- list()
[11:41:46.587]                 for (kk in seq_along(NAMES)) {
[11:41:46.587]                   name <- changed[[kk]]
[11:41:46.587]                   NAME <- NAMES[[kk]]
[11:41:46.587]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:46.587]                     next
[11:41:46.587]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:46.587]                 }
[11:41:46.587]                 NAMES <- toupper(added)
[11:41:46.587]                 for (kk in seq_along(NAMES)) {
[11:41:46.587]                   name <- added[[kk]]
[11:41:46.587]                   NAME <- NAMES[[kk]]
[11:41:46.587]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:46.587]                     next
[11:41:46.587]                   args[[name]] <- ""
[11:41:46.587]                 }
[11:41:46.587]                 NAMES <- toupper(removed)
[11:41:46.587]                 for (kk in seq_along(NAMES)) {
[11:41:46.587]                   name <- removed[[kk]]
[11:41:46.587]                   NAME <- NAMES[[kk]]
[11:41:46.587]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:46.587]                     next
[11:41:46.587]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:46.587]                 }
[11:41:46.587]                 if (length(args) > 0) 
[11:41:46.587]                   base::do.call(base::Sys.setenv, args = args)
[11:41:46.587]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:46.587]             }
[11:41:46.587]             else {
[11:41:46.587]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:46.587]             }
[11:41:46.587]             {
[11:41:46.587]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:46.587]                   0L) {
[11:41:46.587]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:46.587]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:46.587]                   base::options(opts)
[11:41:46.587]                 }
[11:41:46.587]                 {
[11:41:46.587]                   {
[11:41:46.587]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:46.587]                     NULL
[11:41:46.587]                   }
[11:41:46.587]                   options(future.plan = NULL)
[11:41:46.587]                   if (is.na(NA_character_)) 
[11:41:46.587]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:46.587]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:46.587]                   future::plan(list(function (..., workers = 2, 
[11:41:46.587]                     envir = parent.frame()) 
[11:41:46.587]                   strategy(..., workers = workers, envir = envir)), 
[11:41:46.587]                     .cleanup = FALSE, .init = FALSE)
[11:41:46.587]                 }
[11:41:46.587]             }
[11:41:46.587]         }
[11:41:46.587]     })
[11:41:46.587]     if (TRUE) {
[11:41:46.587]         base::sink(type = "output", split = FALSE)
[11:41:46.587]         if (TRUE) {
[11:41:46.587]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:46.587]         }
[11:41:46.587]         else {
[11:41:46.587]             ...future.result["stdout"] <- base::list(NULL)
[11:41:46.587]         }
[11:41:46.587]         base::close(...future.stdout)
[11:41:46.587]         ...future.stdout <- NULL
[11:41:46.587]     }
[11:41:46.587]     ...future.result$conditions <- ...future.conditions
[11:41:46.587]     ...future.result$finished <- base::Sys.time()
[11:41:46.587]     ...future.result
[11:41:46.587] }
[11:41:46.588] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:46.599] receiveMessageFromWorker() for ClusterFuture ...
[11:41:46.599] - Validating connection of MultisessionFuture
[11:41:46.599] - received message: FutureResult
[11:41:46.599] - Received FutureResult
[11:41:46.599] - Erased future from FutureRegistry
[11:41:46.599] result() for ClusterFuture ...
[11:41:46.599] - result already collected: FutureResult
[11:41:46.600] result() for ClusterFuture ... done
[11:41:46.600] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:46.600] result() for ClusterFuture ...
[11:41:46.600] - result already collected: FutureResult
[11:41:46.600] result() for ClusterFuture ... done
[11:41:46.600] result() for ClusterFuture ...
[11:41:46.600] - result already collected: FutureResult
[11:41:46.600] result() for ClusterFuture ... done
[11:41:46.600] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:46.601] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:46.650] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:46.655] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:46.698] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:46.699] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:46.746] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:46.748] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:46.749] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:46.750] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:46.752] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:46.752] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:46.753] MultisessionFuture started
[11:41:46.753] - Launch lazy future ... done
[11:41:46.753] run() for ‘MultisessionFuture’ ... done
[11:41:46.753] Created future:
[11:41:46.753] MultisessionFuture:
[11:41:46.753] Label: ‘future_mapply-5’
[11:41:46.753] Expression:
[11:41:46.753] {
[11:41:46.753]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:46.753]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:46.753]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:46.753]         on.exit(options(oopts), add = TRUE)
[11:41:46.753]     }
[11:41:46.753]     {
[11:41:46.753]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:46.753]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:46.753]                 inherits = FALSE)
[11:41:46.753]             ...future.FUN(...)
[11:41:46.753]         }
[11:41:46.753]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:46.753]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:46.753]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:46.753]         do.call(mapply, args = args)
[11:41:46.753]     }
[11:41:46.753] }
[11:41:46.753] Lazy evaluation: FALSE
[11:41:46.753] Asynchronous evaluation: TRUE
[11:41:46.753] Local evaluation: TRUE
[11:41:46.753] Environment: 0x560ef58e1768
[11:41:46.753] Capture standard output: TRUE
[11:41:46.753] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:46.753] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:46.753] Packages: 1 packages (‘mlr3’)
[11:41:46.753] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:46.753] Resolved: FALSE
[11:41:46.753] Value: <not collected>
[11:41:46.753] Conditions captured: <none>
[11:41:46.753] Early signaling: FALSE
[11:41:46.753] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:46.753] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:46.769] Chunk #5 of 90 ... DONE
[11:41:46.769] Chunk #6 of 90 ...
[11:41:46.770]  - seeds: [1] <seeds>
[11:41:46.770] getGlobalsAndPackages() ...
[11:41:46.770] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:46.770] Resolving globals: FALSE
[11:41:46.771] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:46.771] - packages: [1] ‘mlr3’
[11:41:46.771] getGlobalsAndPackages() ... DONE
[11:41:46.772] run() for ‘Future’ ...
[11:41:46.772] - state: ‘created’
[11:41:46.772] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:46.785] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:46.785] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:46.785]   - Field: ‘node’
[11:41:46.785]   - Field: ‘label’
[11:41:46.785]   - Field: ‘local’
[11:41:46.785]   - Field: ‘owner’
[11:41:46.785]   - Field: ‘envir’
[11:41:46.785]   - Field: ‘workers’
[11:41:46.785]   - Field: ‘packages’
[11:41:46.785]   - Field: ‘gc’
[11:41:46.786]   - Field: ‘conditions’
[11:41:46.786]   - Field: ‘persistent’
[11:41:46.786]   - Field: ‘expr’
[11:41:46.786]   - Field: ‘uuid’
[11:41:46.786]   - Field: ‘seed’
[11:41:46.786]   - Field: ‘version’
[11:41:46.786]   - Field: ‘result’
[11:41:46.786]   - Field: ‘asynchronous’
[11:41:46.786]   - Field: ‘calls’
[11:41:46.786]   - Field: ‘globals’
[11:41:46.786]   - Field: ‘stdout’
[11:41:46.786]   - Field: ‘earlySignal’
[11:41:46.786]   - Field: ‘lazy’
[11:41:46.786]   - Field: ‘state’
[11:41:46.786] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:46.786] - Launch lazy future ...
[11:41:46.786] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:46.786] Packages needed by future strategies (n = 0): <none>
[11:41:46.787] {
[11:41:46.787]     {
[11:41:46.787]         {
[11:41:46.787]             ...future.startTime <- base::Sys.time()
[11:41:46.787]             {
[11:41:46.787]                 {
[11:41:46.787]                   {
[11:41:46.787]                     {
[11:41:46.787]                       {
[11:41:46.787]                         base::local({
[11:41:46.787]                           has_future <- base::requireNamespace("future", 
[11:41:46.787]                             quietly = TRUE)
[11:41:46.787]                           if (has_future) {
[11:41:46.787]                             ns <- base::getNamespace("future")
[11:41:46.787]                             version <- ns[[".package"]][["version"]]
[11:41:46.787]                             if (is.null(version)) 
[11:41:46.787]                               version <- utils::packageVersion("future")
[11:41:46.787]                           }
[11:41:46.787]                           else {
[11:41:46.787]                             version <- NULL
[11:41:46.787]                           }
[11:41:46.787]                           if (!has_future || version < "1.8.0") {
[11:41:46.787]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:46.787]                               "", base::R.version$version.string), 
[11:41:46.787]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:46.787]                                 base::R.version$platform, 8 * 
[11:41:46.787]                                   base::.Machine$sizeof.pointer), 
[11:41:46.787]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:46.787]                                 "release", "version")], collapse = " "), 
[11:41:46.787]                               hostname = base::Sys.info()[["nodename"]])
[11:41:46.787]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:46.787]                               info)
[11:41:46.787]                             info <- base::paste(info, collapse = "; ")
[11:41:46.787]                             if (!has_future) {
[11:41:46.787]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:46.787]                                 info)
[11:41:46.787]                             }
[11:41:46.787]                             else {
[11:41:46.787]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:46.787]                                 info, version)
[11:41:46.787]                             }
[11:41:46.787]                             base::stop(msg)
[11:41:46.787]                           }
[11:41:46.787]                         })
[11:41:46.787]                       }
[11:41:46.787]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:46.787]                       base::options(mc.cores = 1L)
[11:41:46.787]                     }
[11:41:46.787]                     base::local({
[11:41:46.787]                       for (pkg in "mlr3") {
[11:41:46.787]                         base::loadNamespace(pkg)
[11:41:46.787]                         base::library(pkg, character.only = TRUE)
[11:41:46.787]                       }
[11:41:46.787]                     })
[11:41:46.787]                   }
[11:41:46.787]                   options(future.plan = NULL)
[11:41:46.787]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:46.787]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:46.787]                 }
[11:41:46.787]                 ...future.workdir <- getwd()
[11:41:46.787]             }
[11:41:46.787]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:46.787]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:46.787]         }
[11:41:46.787]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:46.787]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:46.787]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:46.787]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:46.787]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:46.787]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:46.787]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:46.787]             base::names(...future.oldOptions))
[11:41:46.787]     }
[11:41:46.787]     if (FALSE) {
[11:41:46.787]     }
[11:41:46.787]     else {
[11:41:46.787]         if (TRUE) {
[11:41:46.787]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:46.787]                 open = "w")
[11:41:46.787]         }
[11:41:46.787]         else {
[11:41:46.787]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:46.787]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:46.787]         }
[11:41:46.787]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:46.787]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:46.787]             base::sink(type = "output", split = FALSE)
[11:41:46.787]             base::close(...future.stdout)
[11:41:46.787]         }, add = TRUE)
[11:41:46.787]     }
[11:41:46.787]     ...future.frame <- base::sys.nframe()
[11:41:46.787]     ...future.conditions <- base::list()
[11:41:46.787]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:46.787]     if (FALSE) {
[11:41:46.787]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:46.787]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:46.787]     }
[11:41:46.787]     ...future.result <- base::tryCatch({
[11:41:46.787]         base::withCallingHandlers({
[11:41:46.787]             ...future.value <- base::withVisible(base::local({
[11:41:46.787]                 ...future.makeSendCondition <- local({
[11:41:46.787]                   sendCondition <- NULL
[11:41:46.787]                   function(frame = 1L) {
[11:41:46.787]                     if (is.function(sendCondition)) 
[11:41:46.787]                       return(sendCondition)
[11:41:46.787]                     ns <- getNamespace("parallel")
[11:41:46.787]                     if (exists("sendData", mode = "function", 
[11:41:46.787]                       envir = ns)) {
[11:41:46.787]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:46.787]                         envir = ns)
[11:41:46.787]                       envir <- sys.frame(frame)
[11:41:46.787]                       master <- NULL
[11:41:46.787]                       while (!identical(envir, .GlobalEnv) && 
[11:41:46.787]                         !identical(envir, emptyenv())) {
[11:41:46.787]                         if (exists("master", mode = "list", envir = envir, 
[11:41:46.787]                           inherits = FALSE)) {
[11:41:46.787]                           master <- get("master", mode = "list", 
[11:41:46.787]                             envir = envir, inherits = FALSE)
[11:41:46.787]                           if (inherits(master, c("SOCKnode", 
[11:41:46.787]                             "SOCK0node"))) {
[11:41:46.787]                             sendCondition <<- function(cond) {
[11:41:46.787]                               data <- list(type = "VALUE", value = cond, 
[11:41:46.787]                                 success = TRUE)
[11:41:46.787]                               parallel_sendData(master, data)
[11:41:46.787]                             }
[11:41:46.787]                             return(sendCondition)
[11:41:46.787]                           }
[11:41:46.787]                         }
[11:41:46.787]                         frame <- frame + 1L
[11:41:46.787]                         envir <- sys.frame(frame)
[11:41:46.787]                       }
[11:41:46.787]                     }
[11:41:46.787]                     sendCondition <<- function(cond) NULL
[11:41:46.787]                   }
[11:41:46.787]                 })
[11:41:46.787]                 withCallingHandlers({
[11:41:46.787]                   {
[11:41:46.787]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:46.787]                     if (!identical(...future.globals.maxSize.org, 
[11:41:46.787]                       ...future.globals.maxSize)) {
[11:41:46.787]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:46.787]                       on.exit(options(oopts), add = TRUE)
[11:41:46.787]                     }
[11:41:46.787]                     {
[11:41:46.787]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:46.787]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:46.787]                           envir = globalenv(), inherits = FALSE)
[11:41:46.787]                         ...future.FUN(...)
[11:41:46.787]                       }
[11:41:46.787]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:46.787]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:46.787]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:46.787]                         USE.NAMES = FALSE)
[11:41:46.787]                       do.call(mapply, args = args)
[11:41:46.787]                     }
[11:41:46.787]                   }
[11:41:46.787]                 }, immediateCondition = function(cond) {
[11:41:46.787]                   sendCondition <- ...future.makeSendCondition()
[11:41:46.787]                   sendCondition(cond)
[11:41:46.787]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:46.787]                   {
[11:41:46.787]                     inherits <- base::inherits
[11:41:46.787]                     invokeRestart <- base::invokeRestart
[11:41:46.787]                     is.null <- base::is.null
[11:41:46.787]                     muffled <- FALSE
[11:41:46.787]                     if (inherits(cond, "message")) {
[11:41:46.787]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:46.787]                       if (muffled) 
[11:41:46.787]                         invokeRestart("muffleMessage")
[11:41:46.787]                     }
[11:41:46.787]                     else if (inherits(cond, "warning")) {
[11:41:46.787]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:46.787]                       if (muffled) 
[11:41:46.787]                         invokeRestart("muffleWarning")
[11:41:46.787]                     }
[11:41:46.787]                     else if (inherits(cond, "condition")) {
[11:41:46.787]                       if (!is.null(pattern)) {
[11:41:46.787]                         computeRestarts <- base::computeRestarts
[11:41:46.787]                         grepl <- base::grepl
[11:41:46.787]                         restarts <- computeRestarts(cond)
[11:41:46.787]                         for (restart in restarts) {
[11:41:46.787]                           name <- restart$name
[11:41:46.787]                           if (is.null(name)) 
[11:41:46.787]                             next
[11:41:46.787]                           if (!grepl(pattern, name)) 
[11:41:46.787]                             next
[11:41:46.787]                           invokeRestart(restart)
[11:41:46.787]                           muffled <- TRUE
[11:41:46.787]                           break
[11:41:46.787]                         }
[11:41:46.787]                       }
[11:41:46.787]                     }
[11:41:46.787]                     invisible(muffled)
[11:41:46.787]                   }
[11:41:46.787]                   muffleCondition(cond)
[11:41:46.787]                 })
[11:41:46.787]             }))
[11:41:46.787]             future::FutureResult(value = ...future.value$value, 
[11:41:46.787]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:46.787]                   ...future.rng), globalenv = if (FALSE) 
[11:41:46.787]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:46.787]                     ...future.globalenv.names))
[11:41:46.787]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:46.787]         }, condition = base::local({
[11:41:46.787]             c <- base::c
[11:41:46.787]             inherits <- base::inherits
[11:41:46.787]             invokeRestart <- base::invokeRestart
[11:41:46.787]             length <- base::length
[11:41:46.787]             list <- base::list
[11:41:46.787]             seq.int <- base::seq.int
[11:41:46.787]             signalCondition <- base::signalCondition
[11:41:46.787]             sys.calls <- base::sys.calls
[11:41:46.787]             `[[` <- base::`[[`
[11:41:46.787]             `+` <- base::`+`
[11:41:46.787]             `<<-` <- base::`<<-`
[11:41:46.787]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:46.787]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:46.787]                   3L)]
[11:41:46.787]             }
[11:41:46.787]             function(cond) {
[11:41:46.787]                 is_error <- inherits(cond, "error")
[11:41:46.787]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:46.787]                   NULL)
[11:41:46.787]                 if (is_error) {
[11:41:46.787]                   sessionInformation <- function() {
[11:41:46.787]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:46.787]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:46.787]                       search = base::search(), system = base::Sys.info())
[11:41:46.787]                   }
[11:41:46.787]                   ...future.conditions[[length(...future.conditions) + 
[11:41:46.787]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:46.787]                     cond$call), session = sessionInformation(), 
[11:41:46.787]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:46.787]                   signalCondition(cond)
[11:41:46.787]                 }
[11:41:46.787]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:46.787]                 "immediateCondition"))) {
[11:41:46.787]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:46.787]                   ...future.conditions[[length(...future.conditions) + 
[11:41:46.787]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:46.787]                   if (TRUE && !signal) {
[11:41:46.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:46.787]                     {
[11:41:46.787]                       inherits <- base::inherits
[11:41:46.787]                       invokeRestart <- base::invokeRestart
[11:41:46.787]                       is.null <- base::is.null
[11:41:46.787]                       muffled <- FALSE
[11:41:46.787]                       if (inherits(cond, "message")) {
[11:41:46.787]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:46.787]                         if (muffled) 
[11:41:46.787]                           invokeRestart("muffleMessage")
[11:41:46.787]                       }
[11:41:46.787]                       else if (inherits(cond, "warning")) {
[11:41:46.787]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:46.787]                         if (muffled) 
[11:41:46.787]                           invokeRestart("muffleWarning")
[11:41:46.787]                       }
[11:41:46.787]                       else if (inherits(cond, "condition")) {
[11:41:46.787]                         if (!is.null(pattern)) {
[11:41:46.787]                           computeRestarts <- base::computeRestarts
[11:41:46.787]                           grepl <- base::grepl
[11:41:46.787]                           restarts <- computeRestarts(cond)
[11:41:46.787]                           for (restart in restarts) {
[11:41:46.787]                             name <- restart$name
[11:41:46.787]                             if (is.null(name)) 
[11:41:46.787]                               next
[11:41:46.787]                             if (!grepl(pattern, name)) 
[11:41:46.787]                               next
[11:41:46.787]                             invokeRestart(restart)
[11:41:46.787]                             muffled <- TRUE
[11:41:46.787]                             break
[11:41:46.787]                           }
[11:41:46.787]                         }
[11:41:46.787]                       }
[11:41:46.787]                       invisible(muffled)
[11:41:46.787]                     }
[11:41:46.787]                     muffleCondition(cond, pattern = "^muffle")
[11:41:46.787]                   }
[11:41:46.787]                 }
[11:41:46.787]                 else {
[11:41:46.787]                   if (TRUE) {
[11:41:46.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:46.787]                     {
[11:41:46.787]                       inherits <- base::inherits
[11:41:46.787]                       invokeRestart <- base::invokeRestart
[11:41:46.787]                       is.null <- base::is.null
[11:41:46.787]                       muffled <- FALSE
[11:41:46.787]                       if (inherits(cond, "message")) {
[11:41:46.787]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:46.787]                         if (muffled) 
[11:41:46.787]                           invokeRestart("muffleMessage")
[11:41:46.787]                       }
[11:41:46.787]                       else if (inherits(cond, "warning")) {
[11:41:46.787]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:46.787]                         if (muffled) 
[11:41:46.787]                           invokeRestart("muffleWarning")
[11:41:46.787]                       }
[11:41:46.787]                       else if (inherits(cond, "condition")) {
[11:41:46.787]                         if (!is.null(pattern)) {
[11:41:46.787]                           computeRestarts <- base::computeRestarts
[11:41:46.787]                           grepl <- base::grepl
[11:41:46.787]                           restarts <- computeRestarts(cond)
[11:41:46.787]                           for (restart in restarts) {
[11:41:46.787]                             name <- restart$name
[11:41:46.787]                             if (is.null(name)) 
[11:41:46.787]                               next
[11:41:46.787]                             if (!grepl(pattern, name)) 
[11:41:46.787]                               next
[11:41:46.787]                             invokeRestart(restart)
[11:41:46.787]                             muffled <- TRUE
[11:41:46.787]                             break
[11:41:46.787]                           }
[11:41:46.787]                         }
[11:41:46.787]                       }
[11:41:46.787]                       invisible(muffled)
[11:41:46.787]                     }
[11:41:46.787]                     muffleCondition(cond, pattern = "^muffle")
[11:41:46.787]                   }
[11:41:46.787]                 }
[11:41:46.787]             }
[11:41:46.787]         }))
[11:41:46.787]     }, error = function(ex) {
[11:41:46.787]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:46.787]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:46.787]                 ...future.rng), started = ...future.startTime, 
[11:41:46.787]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:46.787]             version = "1.8"), class = "FutureResult")
[11:41:46.787]     }, finally = {
[11:41:46.787]         if (!identical(...future.workdir, getwd())) 
[11:41:46.787]             setwd(...future.workdir)
[11:41:46.787]         {
[11:41:46.787]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:46.787]                 ...future.oldOptions$nwarnings <- NULL
[11:41:46.787]             }
[11:41:46.787]             base::options(...future.oldOptions)
[11:41:46.787]             if (.Platform$OS.type == "windows") {
[11:41:46.787]                 old_names <- names(...future.oldEnvVars)
[11:41:46.787]                 envs <- base::Sys.getenv()
[11:41:46.787]                 names <- names(envs)
[11:41:46.787]                 common <- intersect(names, old_names)
[11:41:46.787]                 added <- setdiff(names, old_names)
[11:41:46.787]                 removed <- setdiff(old_names, names)
[11:41:46.787]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:46.787]                   envs[common]]
[11:41:46.787]                 NAMES <- toupper(changed)
[11:41:46.787]                 args <- list()
[11:41:46.787]                 for (kk in seq_along(NAMES)) {
[11:41:46.787]                   name <- changed[[kk]]
[11:41:46.787]                   NAME <- NAMES[[kk]]
[11:41:46.787]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:46.787]                     next
[11:41:46.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:46.787]                 }
[11:41:46.787]                 NAMES <- toupper(added)
[11:41:46.787]                 for (kk in seq_along(NAMES)) {
[11:41:46.787]                   name <- added[[kk]]
[11:41:46.787]                   NAME <- NAMES[[kk]]
[11:41:46.787]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:46.787]                     next
[11:41:46.787]                   args[[name]] <- ""
[11:41:46.787]                 }
[11:41:46.787]                 NAMES <- toupper(removed)
[11:41:46.787]                 for (kk in seq_along(NAMES)) {
[11:41:46.787]                   name <- removed[[kk]]
[11:41:46.787]                   NAME <- NAMES[[kk]]
[11:41:46.787]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:46.787]                     next
[11:41:46.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:46.787]                 }
[11:41:46.787]                 if (length(args) > 0) 
[11:41:46.787]                   base::do.call(base::Sys.setenv, args = args)
[11:41:46.787]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:46.787]             }
[11:41:46.787]             else {
[11:41:46.787]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:46.787]             }
[11:41:46.787]             {
[11:41:46.787]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:46.787]                   0L) {
[11:41:46.787]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:46.787]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:46.787]                   base::options(opts)
[11:41:46.787]                 }
[11:41:46.787]                 {
[11:41:46.787]                   {
[11:41:46.787]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:46.787]                     NULL
[11:41:46.787]                   }
[11:41:46.787]                   options(future.plan = NULL)
[11:41:46.787]                   if (is.na(NA_character_)) 
[11:41:46.787]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:46.787]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:46.787]                   future::plan(list(function (..., workers = 2, 
[11:41:46.787]                     envir = parent.frame()) 
[11:41:46.787]                   strategy(..., workers = workers, envir = envir)), 
[11:41:46.787]                     .cleanup = FALSE, .init = FALSE)
[11:41:46.787]                 }
[11:41:46.787]             }
[11:41:46.787]         }
[11:41:46.787]     })
[11:41:46.787]     if (TRUE) {
[11:41:46.787]         base::sink(type = "output", split = FALSE)
[11:41:46.787]         if (TRUE) {
[11:41:46.787]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:46.787]         }
[11:41:46.787]         else {
[11:41:46.787]             ...future.result["stdout"] <- base::list(NULL)
[11:41:46.787]         }
[11:41:46.787]         base::close(...future.stdout)
[11:41:46.787]         ...future.stdout <- NULL
[11:41:46.787]     }
[11:41:46.787]     ...future.result$conditions <- ...future.conditions
[11:41:46.787]     ...future.result$finished <- base::Sys.time()
[11:41:46.787]     ...future.result
[11:41:46.787] }
[11:41:46.788] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:46.800] receiveMessageFromWorker() for ClusterFuture ...
[11:41:46.800] - Validating connection of MultisessionFuture
[11:41:46.801] - received message: FutureResult
[11:41:46.801] - Received FutureResult
[11:41:46.801] - Erased future from FutureRegistry
[11:41:46.801] result() for ClusterFuture ...
[11:41:46.801] - result already collected: FutureResult
[11:41:46.801] result() for ClusterFuture ... done
[11:41:46.802] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:46.802] result() for ClusterFuture ...
[11:41:46.802] - result already collected: FutureResult
[11:41:46.802] result() for ClusterFuture ... done
[11:41:46.802] result() for ClusterFuture ...
[11:41:46.802] - result already collected: FutureResult
[11:41:46.802] result() for ClusterFuture ... done
[11:41:46.803] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:46.803] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:46.846] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:46.854] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:46.898] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:46.900] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:46.947] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:46.948] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:46.949] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:46.950] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:46.951] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:46.951] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:46.953] MultisessionFuture started
[11:41:46.953] - Launch lazy future ... done
[11:41:46.953] run() for ‘MultisessionFuture’ ... done
[11:41:46.954] Created future:
[11:41:46.954] MultisessionFuture:
[11:41:46.954] Label: ‘future_mapply-6’
[11:41:46.954] Expression:
[11:41:46.954] {
[11:41:46.954]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:46.954]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:46.954]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:46.954]         on.exit(options(oopts), add = TRUE)
[11:41:46.954]     }
[11:41:46.954]     {
[11:41:46.954]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:46.954]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:46.954]                 inherits = FALSE)
[11:41:46.954]             ...future.FUN(...)
[11:41:46.954]         }
[11:41:46.954]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:46.954]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:46.954]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:46.954]         do.call(mapply, args = args)
[11:41:46.954]     }
[11:41:46.954] }
[11:41:46.954] Lazy evaluation: FALSE
[11:41:46.954] Asynchronous evaluation: TRUE
[11:41:46.954] Local evaluation: TRUE
[11:41:46.954] Environment: 0x560ef58e1768
[11:41:46.954] Capture standard output: TRUE
[11:41:46.954] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:46.954] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:46.954] Packages: 1 packages (‘mlr3’)
[11:41:46.954] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:46.954] Resolved: FALSE
[11:41:46.954] Value: <not collected>
[11:41:46.954] Conditions captured: <none>
[11:41:46.954] Early signaling: FALSE
[11:41:46.954] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:46.954] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:46.973] Chunk #6 of 90 ... DONE
[11:41:46.973] Chunk #7 of 90 ...
[11:41:46.974]  - seeds: [1] <seeds>
[11:41:46.974] getGlobalsAndPackages() ...
[11:41:46.974] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:46.975] Resolving globals: FALSE
[11:41:46.976] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:46.976] - packages: [1] ‘mlr3’
[11:41:46.976] getGlobalsAndPackages() ... DONE
[11:41:46.977] run() for ‘Future’ ...
[11:41:46.977] - state: ‘created’
[11:41:46.977] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:46.991] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:46.991] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:46.991]   - Field: ‘node’
[11:41:46.991]   - Field: ‘label’
[11:41:46.991]   - Field: ‘local’
[11:41:46.991]   - Field: ‘owner’
[11:41:46.991]   - Field: ‘envir’
[11:41:46.991]   - Field: ‘workers’
[11:41:46.991]   - Field: ‘packages’
[11:41:46.991]   - Field: ‘gc’
[11:41:46.991]   - Field: ‘conditions’
[11:41:46.991]   - Field: ‘persistent’
[11:41:46.991]   - Field: ‘expr’
[11:41:46.991]   - Field: ‘uuid’
[11:41:46.991]   - Field: ‘seed’
[11:41:46.991]   - Field: ‘version’
[11:41:46.991]   - Field: ‘result’
[11:41:46.991]   - Field: ‘asynchronous’
[11:41:46.991]   - Field: ‘calls’
[11:41:46.991]   - Field: ‘globals’
[11:41:46.991]   - Field: ‘stdout’
[11:41:46.992]   - Field: ‘earlySignal’
[11:41:46.992]   - Field: ‘lazy’
[11:41:46.992]   - Field: ‘state’
[11:41:46.992] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:46.992] - Launch lazy future ...
[11:41:46.992] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:46.992] Packages needed by future strategies (n = 0): <none>
[11:41:46.992] {
[11:41:46.992]     {
[11:41:46.992]         {
[11:41:46.992]             ...future.startTime <- base::Sys.time()
[11:41:46.992]             {
[11:41:46.992]                 {
[11:41:46.992]                   {
[11:41:46.992]                     {
[11:41:46.992]                       {
[11:41:46.992]                         base::local({
[11:41:46.992]                           has_future <- base::requireNamespace("future", 
[11:41:46.992]                             quietly = TRUE)
[11:41:46.992]                           if (has_future) {
[11:41:46.992]                             ns <- base::getNamespace("future")
[11:41:46.992]                             version <- ns[[".package"]][["version"]]
[11:41:46.992]                             if (is.null(version)) 
[11:41:46.992]                               version <- utils::packageVersion("future")
[11:41:46.992]                           }
[11:41:46.992]                           else {
[11:41:46.992]                             version <- NULL
[11:41:46.992]                           }
[11:41:46.992]                           if (!has_future || version < "1.8.0") {
[11:41:46.992]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:46.992]                               "", base::R.version$version.string), 
[11:41:46.992]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:46.992]                                 base::R.version$platform, 8 * 
[11:41:46.992]                                   base::.Machine$sizeof.pointer), 
[11:41:46.992]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:46.992]                                 "release", "version")], collapse = " "), 
[11:41:46.992]                               hostname = base::Sys.info()[["nodename"]])
[11:41:46.992]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:46.992]                               info)
[11:41:46.992]                             info <- base::paste(info, collapse = "; ")
[11:41:46.992]                             if (!has_future) {
[11:41:46.992]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:46.992]                                 info)
[11:41:46.992]                             }
[11:41:46.992]                             else {
[11:41:46.992]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:46.992]                                 info, version)
[11:41:46.992]                             }
[11:41:46.992]                             base::stop(msg)
[11:41:46.992]                           }
[11:41:46.992]                         })
[11:41:46.992]                       }
[11:41:46.992]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:46.992]                       base::options(mc.cores = 1L)
[11:41:46.992]                     }
[11:41:46.992]                     base::local({
[11:41:46.992]                       for (pkg in "mlr3") {
[11:41:46.992]                         base::loadNamespace(pkg)
[11:41:46.992]                         base::library(pkg, character.only = TRUE)
[11:41:46.992]                       }
[11:41:46.992]                     })
[11:41:46.992]                   }
[11:41:46.992]                   options(future.plan = NULL)
[11:41:46.992]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:46.992]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:46.992]                 }
[11:41:46.992]                 ...future.workdir <- getwd()
[11:41:46.992]             }
[11:41:46.992]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:46.992]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:46.992]         }
[11:41:46.992]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:46.992]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:46.992]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:46.992]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:46.992]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:46.992]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:46.992]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:46.992]             base::names(...future.oldOptions))
[11:41:46.992]     }
[11:41:46.992]     if (FALSE) {
[11:41:46.992]     }
[11:41:46.992]     else {
[11:41:46.992]         if (TRUE) {
[11:41:46.992]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:46.992]                 open = "w")
[11:41:46.992]         }
[11:41:46.992]         else {
[11:41:46.992]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:46.992]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:46.992]         }
[11:41:46.992]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:46.992]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:46.992]             base::sink(type = "output", split = FALSE)
[11:41:46.992]             base::close(...future.stdout)
[11:41:46.992]         }, add = TRUE)
[11:41:46.992]     }
[11:41:46.992]     ...future.frame <- base::sys.nframe()
[11:41:46.992]     ...future.conditions <- base::list()
[11:41:46.992]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:46.992]     if (FALSE) {
[11:41:46.992]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:46.992]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:46.992]     }
[11:41:46.992]     ...future.result <- base::tryCatch({
[11:41:46.992]         base::withCallingHandlers({
[11:41:46.992]             ...future.value <- base::withVisible(base::local({
[11:41:46.992]                 ...future.makeSendCondition <- local({
[11:41:46.992]                   sendCondition <- NULL
[11:41:46.992]                   function(frame = 1L) {
[11:41:46.992]                     if (is.function(sendCondition)) 
[11:41:46.992]                       return(sendCondition)
[11:41:46.992]                     ns <- getNamespace("parallel")
[11:41:46.992]                     if (exists("sendData", mode = "function", 
[11:41:46.992]                       envir = ns)) {
[11:41:46.992]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:46.992]                         envir = ns)
[11:41:46.992]                       envir <- sys.frame(frame)
[11:41:46.992]                       master <- NULL
[11:41:46.992]                       while (!identical(envir, .GlobalEnv) && 
[11:41:46.992]                         !identical(envir, emptyenv())) {
[11:41:46.992]                         if (exists("master", mode = "list", envir = envir, 
[11:41:46.992]                           inherits = FALSE)) {
[11:41:46.992]                           master <- get("master", mode = "list", 
[11:41:46.992]                             envir = envir, inherits = FALSE)
[11:41:46.992]                           if (inherits(master, c("SOCKnode", 
[11:41:46.992]                             "SOCK0node"))) {
[11:41:46.992]                             sendCondition <<- function(cond) {
[11:41:46.992]                               data <- list(type = "VALUE", value = cond, 
[11:41:46.992]                                 success = TRUE)
[11:41:46.992]                               parallel_sendData(master, data)
[11:41:46.992]                             }
[11:41:46.992]                             return(sendCondition)
[11:41:46.992]                           }
[11:41:46.992]                         }
[11:41:46.992]                         frame <- frame + 1L
[11:41:46.992]                         envir <- sys.frame(frame)
[11:41:46.992]                       }
[11:41:46.992]                     }
[11:41:46.992]                     sendCondition <<- function(cond) NULL
[11:41:46.992]                   }
[11:41:46.992]                 })
[11:41:46.992]                 withCallingHandlers({
[11:41:46.992]                   {
[11:41:46.992]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:46.992]                     if (!identical(...future.globals.maxSize.org, 
[11:41:46.992]                       ...future.globals.maxSize)) {
[11:41:46.992]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:46.992]                       on.exit(options(oopts), add = TRUE)
[11:41:46.992]                     }
[11:41:46.992]                     {
[11:41:46.992]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:46.992]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:46.992]                           envir = globalenv(), inherits = FALSE)
[11:41:46.992]                         ...future.FUN(...)
[11:41:46.992]                       }
[11:41:46.992]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:46.992]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:46.992]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:46.992]                         USE.NAMES = FALSE)
[11:41:46.992]                       do.call(mapply, args = args)
[11:41:46.992]                     }
[11:41:46.992]                   }
[11:41:46.992]                 }, immediateCondition = function(cond) {
[11:41:46.992]                   sendCondition <- ...future.makeSendCondition()
[11:41:46.992]                   sendCondition(cond)
[11:41:46.992]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:46.992]                   {
[11:41:46.992]                     inherits <- base::inherits
[11:41:46.992]                     invokeRestart <- base::invokeRestart
[11:41:46.992]                     is.null <- base::is.null
[11:41:46.992]                     muffled <- FALSE
[11:41:46.992]                     if (inherits(cond, "message")) {
[11:41:46.992]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:46.992]                       if (muffled) 
[11:41:46.992]                         invokeRestart("muffleMessage")
[11:41:46.992]                     }
[11:41:46.992]                     else if (inherits(cond, "warning")) {
[11:41:46.992]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:46.992]                       if (muffled) 
[11:41:46.992]                         invokeRestart("muffleWarning")
[11:41:46.992]                     }
[11:41:46.992]                     else if (inherits(cond, "condition")) {
[11:41:46.992]                       if (!is.null(pattern)) {
[11:41:46.992]                         computeRestarts <- base::computeRestarts
[11:41:46.992]                         grepl <- base::grepl
[11:41:46.992]                         restarts <- computeRestarts(cond)
[11:41:46.992]                         for (restart in restarts) {
[11:41:46.992]                           name <- restart$name
[11:41:46.992]                           if (is.null(name)) 
[11:41:46.992]                             next
[11:41:46.992]                           if (!grepl(pattern, name)) 
[11:41:46.992]                             next
[11:41:46.992]                           invokeRestart(restart)
[11:41:46.992]                           muffled <- TRUE
[11:41:46.992]                           break
[11:41:46.992]                         }
[11:41:46.992]                       }
[11:41:46.992]                     }
[11:41:46.992]                     invisible(muffled)
[11:41:46.992]                   }
[11:41:46.992]                   muffleCondition(cond)
[11:41:46.992]                 })
[11:41:46.992]             }))
[11:41:46.992]             future::FutureResult(value = ...future.value$value, 
[11:41:46.992]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:46.992]                   ...future.rng), globalenv = if (FALSE) 
[11:41:46.992]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:46.992]                     ...future.globalenv.names))
[11:41:46.992]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:46.992]         }, condition = base::local({
[11:41:46.992]             c <- base::c
[11:41:46.992]             inherits <- base::inherits
[11:41:46.992]             invokeRestart <- base::invokeRestart
[11:41:46.992]             length <- base::length
[11:41:46.992]             list <- base::list
[11:41:46.992]             seq.int <- base::seq.int
[11:41:46.992]             signalCondition <- base::signalCondition
[11:41:46.992]             sys.calls <- base::sys.calls
[11:41:46.992]             `[[` <- base::`[[`
[11:41:46.992]             `+` <- base::`+`
[11:41:46.992]             `<<-` <- base::`<<-`
[11:41:46.992]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:46.992]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:46.992]                   3L)]
[11:41:46.992]             }
[11:41:46.992]             function(cond) {
[11:41:46.992]                 is_error <- inherits(cond, "error")
[11:41:46.992]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:46.992]                   NULL)
[11:41:46.992]                 if (is_error) {
[11:41:46.992]                   sessionInformation <- function() {
[11:41:46.992]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:46.992]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:46.992]                       search = base::search(), system = base::Sys.info())
[11:41:46.992]                   }
[11:41:46.992]                   ...future.conditions[[length(...future.conditions) + 
[11:41:46.992]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:46.992]                     cond$call), session = sessionInformation(), 
[11:41:46.992]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:46.992]                   signalCondition(cond)
[11:41:46.992]                 }
[11:41:46.992]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:46.992]                 "immediateCondition"))) {
[11:41:46.992]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:46.992]                   ...future.conditions[[length(...future.conditions) + 
[11:41:46.992]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:46.992]                   if (TRUE && !signal) {
[11:41:46.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:46.992]                     {
[11:41:46.992]                       inherits <- base::inherits
[11:41:46.992]                       invokeRestart <- base::invokeRestart
[11:41:46.992]                       is.null <- base::is.null
[11:41:46.992]                       muffled <- FALSE
[11:41:46.992]                       if (inherits(cond, "message")) {
[11:41:46.992]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:46.992]                         if (muffled) 
[11:41:46.992]                           invokeRestart("muffleMessage")
[11:41:46.992]                       }
[11:41:46.992]                       else if (inherits(cond, "warning")) {
[11:41:46.992]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:46.992]                         if (muffled) 
[11:41:46.992]                           invokeRestart("muffleWarning")
[11:41:46.992]                       }
[11:41:46.992]                       else if (inherits(cond, "condition")) {
[11:41:46.992]                         if (!is.null(pattern)) {
[11:41:46.992]                           computeRestarts <- base::computeRestarts
[11:41:46.992]                           grepl <- base::grepl
[11:41:46.992]                           restarts <- computeRestarts(cond)
[11:41:46.992]                           for (restart in restarts) {
[11:41:46.992]                             name <- restart$name
[11:41:46.992]                             if (is.null(name)) 
[11:41:46.992]                               next
[11:41:46.992]                             if (!grepl(pattern, name)) 
[11:41:46.992]                               next
[11:41:46.992]                             invokeRestart(restart)
[11:41:46.992]                             muffled <- TRUE
[11:41:46.992]                             break
[11:41:46.992]                           }
[11:41:46.992]                         }
[11:41:46.992]                       }
[11:41:46.992]                       invisible(muffled)
[11:41:46.992]                     }
[11:41:46.992]                     muffleCondition(cond, pattern = "^muffle")
[11:41:46.992]                   }
[11:41:46.992]                 }
[11:41:46.992]                 else {
[11:41:46.992]                   if (TRUE) {
[11:41:46.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:46.992]                     {
[11:41:46.992]                       inherits <- base::inherits
[11:41:46.992]                       invokeRestart <- base::invokeRestart
[11:41:46.992]                       is.null <- base::is.null
[11:41:46.992]                       muffled <- FALSE
[11:41:46.992]                       if (inherits(cond, "message")) {
[11:41:46.992]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:46.992]                         if (muffled) 
[11:41:46.992]                           invokeRestart("muffleMessage")
[11:41:46.992]                       }
[11:41:46.992]                       else if (inherits(cond, "warning")) {
[11:41:46.992]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:46.992]                         if (muffled) 
[11:41:46.992]                           invokeRestart("muffleWarning")
[11:41:46.992]                       }
[11:41:46.992]                       else if (inherits(cond, "condition")) {
[11:41:46.992]                         if (!is.null(pattern)) {
[11:41:46.992]                           computeRestarts <- base::computeRestarts
[11:41:46.992]                           grepl <- base::grepl
[11:41:46.992]                           restarts <- computeRestarts(cond)
[11:41:46.992]                           for (restart in restarts) {
[11:41:46.992]                             name <- restart$name
[11:41:46.992]                             if (is.null(name)) 
[11:41:46.992]                               next
[11:41:46.992]                             if (!grepl(pattern, name)) 
[11:41:46.992]                               next
[11:41:46.992]                             invokeRestart(restart)
[11:41:46.992]                             muffled <- TRUE
[11:41:46.992]                             break
[11:41:46.992]                           }
[11:41:46.992]                         }
[11:41:46.992]                       }
[11:41:46.992]                       invisible(muffled)
[11:41:46.992]                     }
[11:41:46.992]                     muffleCondition(cond, pattern = "^muffle")
[11:41:46.992]                   }
[11:41:46.992]                 }
[11:41:46.992]             }
[11:41:46.992]         }))
[11:41:46.992]     }, error = function(ex) {
[11:41:46.992]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:46.992]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:46.992]                 ...future.rng), started = ...future.startTime, 
[11:41:46.992]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:46.992]             version = "1.8"), class = "FutureResult")
[11:41:46.992]     }, finally = {
[11:41:46.992]         if (!identical(...future.workdir, getwd())) 
[11:41:46.992]             setwd(...future.workdir)
[11:41:46.992]         {
[11:41:46.992]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:46.992]                 ...future.oldOptions$nwarnings <- NULL
[11:41:46.992]             }
[11:41:46.992]             base::options(...future.oldOptions)
[11:41:46.992]             if (.Platform$OS.type == "windows") {
[11:41:46.992]                 old_names <- names(...future.oldEnvVars)
[11:41:46.992]                 envs <- base::Sys.getenv()
[11:41:46.992]                 names <- names(envs)
[11:41:46.992]                 common <- intersect(names, old_names)
[11:41:46.992]                 added <- setdiff(names, old_names)
[11:41:46.992]                 removed <- setdiff(old_names, names)
[11:41:46.992]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:46.992]                   envs[common]]
[11:41:46.992]                 NAMES <- toupper(changed)
[11:41:46.992]                 args <- list()
[11:41:46.992]                 for (kk in seq_along(NAMES)) {
[11:41:46.992]                   name <- changed[[kk]]
[11:41:46.992]                   NAME <- NAMES[[kk]]
[11:41:46.992]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:46.992]                     next
[11:41:46.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:46.992]                 }
[11:41:46.992]                 NAMES <- toupper(added)
[11:41:46.992]                 for (kk in seq_along(NAMES)) {
[11:41:46.992]                   name <- added[[kk]]
[11:41:46.992]                   NAME <- NAMES[[kk]]
[11:41:46.992]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:46.992]                     next
[11:41:46.992]                   args[[name]] <- ""
[11:41:46.992]                 }
[11:41:46.992]                 NAMES <- toupper(removed)
[11:41:46.992]                 for (kk in seq_along(NAMES)) {
[11:41:46.992]                   name <- removed[[kk]]
[11:41:46.992]                   NAME <- NAMES[[kk]]
[11:41:46.992]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:46.992]                     next
[11:41:46.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:46.992]                 }
[11:41:46.992]                 if (length(args) > 0) 
[11:41:46.992]                   base::do.call(base::Sys.setenv, args = args)
[11:41:46.992]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:46.992]             }
[11:41:46.992]             else {
[11:41:46.992]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:46.992]             }
[11:41:46.992]             {
[11:41:46.992]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:46.992]                   0L) {
[11:41:46.992]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:46.992]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:46.992]                   base::options(opts)
[11:41:46.992]                 }
[11:41:46.992]                 {
[11:41:46.992]                   {
[11:41:46.992]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:46.992]                     NULL
[11:41:46.992]                   }
[11:41:46.992]                   options(future.plan = NULL)
[11:41:46.992]                   if (is.na(NA_character_)) 
[11:41:46.992]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:46.992]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:46.992]                   future::plan(list(function (..., workers = 2, 
[11:41:46.992]                     envir = parent.frame()) 
[11:41:46.992]                   strategy(..., workers = workers, envir = envir)), 
[11:41:46.992]                     .cleanup = FALSE, .init = FALSE)
[11:41:46.992]                 }
[11:41:46.992]             }
[11:41:46.992]         }
[11:41:46.992]     })
[11:41:46.992]     if (TRUE) {
[11:41:46.992]         base::sink(type = "output", split = FALSE)
[11:41:46.992]         if (TRUE) {
[11:41:46.992]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:46.992]         }
[11:41:46.992]         else {
[11:41:46.992]             ...future.result["stdout"] <- base::list(NULL)
[11:41:46.992]         }
[11:41:46.992]         base::close(...future.stdout)
[11:41:46.992]         ...future.stdout <- NULL
[11:41:46.992]     }
[11:41:46.992]     ...future.result$conditions <- ...future.conditions
[11:41:46.992]     ...future.result$finished <- base::Sys.time()
[11:41:46.992]     ...future.result
[11:41:46.992] }
[11:41:46.994] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:47.005] receiveMessageFromWorker() for ClusterFuture ...
[11:41:47.005] - Validating connection of MultisessionFuture
[11:41:47.005] - received message: FutureResult
[11:41:47.005] - Received FutureResult
[11:41:47.005] - Erased future from FutureRegistry
[11:41:47.005] result() for ClusterFuture ...
[11:41:47.006] - result already collected: FutureResult
[11:41:47.006] result() for ClusterFuture ... done
[11:41:47.006] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:47.006] result() for ClusterFuture ...
[11:41:47.006] - result already collected: FutureResult
[11:41:47.006] result() for ClusterFuture ... done
[11:41:47.006] result() for ClusterFuture ...
[11:41:47.006] - result already collected: FutureResult
[11:41:47.006] result() for ClusterFuture ... done
[11:41:47.007] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:47.007] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:47.050] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:47.058] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:47.102] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:47.103] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:47.151] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:47.152] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:47.153] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:47.154] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:47.155] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:47.156] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:47.156] MultisessionFuture started
[11:41:47.156] - Launch lazy future ... done
[11:41:47.157] run() for ‘MultisessionFuture’ ... done
[11:41:47.157] Created future:
[11:41:47.157] MultisessionFuture:
[11:41:47.157] Label: ‘future_mapply-7’
[11:41:47.157] Expression:
[11:41:47.157] {
[11:41:47.157]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:47.157]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:47.157]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:47.157]         on.exit(options(oopts), add = TRUE)
[11:41:47.157]     }
[11:41:47.157]     {
[11:41:47.157]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:47.157]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:47.157]                 inherits = FALSE)
[11:41:47.157]             ...future.FUN(...)
[11:41:47.157]         }
[11:41:47.157]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:47.157]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:47.157]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:47.157]         do.call(mapply, args = args)
[11:41:47.157]     }
[11:41:47.157] }
[11:41:47.157] Lazy evaluation: FALSE
[11:41:47.157] Asynchronous evaluation: TRUE
[11:41:47.157] Local evaluation: TRUE
[11:41:47.157] Environment: 0x560ef58e1768
[11:41:47.157] Capture standard output: TRUE
[11:41:47.157] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:47.157] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:47.157] Packages: 1 packages (‘mlr3’)
[11:41:47.157] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:47.157] Resolved: FALSE
[11:41:47.157] Value: <not collected>
[11:41:47.157] Conditions captured: <none>
[11:41:47.157] Early signaling: FALSE
[11:41:47.157] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:47.157] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:47.177] Chunk #7 of 90 ... DONE
[11:41:47.177] Chunk #8 of 90 ...
[11:41:47.177]  - seeds: [1] <seeds>
[11:41:47.177] getGlobalsAndPackages() ...
[11:41:47.177] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:47.178] Resolving globals: FALSE
[11:41:47.178] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:47.179] - packages: [1] ‘mlr3’
[11:41:47.179] getGlobalsAndPackages() ... DONE
[11:41:47.179] run() for ‘Future’ ...
[11:41:47.179] - state: ‘created’
[11:41:47.179] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:47.190] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:47.190] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:47.190]   - Field: ‘node’
[11:41:47.190]   - Field: ‘label’
[11:41:47.190]   - Field: ‘local’
[11:41:47.190]   - Field: ‘owner’
[11:41:47.190]   - Field: ‘envir’
[11:41:47.190]   - Field: ‘workers’
[11:41:47.190]   - Field: ‘packages’
[11:41:47.190]   - Field: ‘gc’
[11:41:47.190]   - Field: ‘conditions’
[11:41:47.190]   - Field: ‘persistent’
[11:41:47.190]   - Field: ‘expr’
[11:41:47.190]   - Field: ‘uuid’
[11:41:47.190]   - Field: ‘seed’
[11:41:47.190]   - Field: ‘version’
[11:41:47.191]   - Field: ‘result’
[11:41:47.191]   - Field: ‘asynchronous’
[11:41:47.191]   - Field: ‘calls’
[11:41:47.191]   - Field: ‘globals’
[11:41:47.191]   - Field: ‘stdout’
[11:41:47.191]   - Field: ‘earlySignal’
[11:41:47.191]   - Field: ‘lazy’
[11:41:47.191]   - Field: ‘state’
[11:41:47.191] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:47.191] - Launch lazy future ...
[11:41:47.191] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:47.191] Packages needed by future strategies (n = 0): <none>
[11:41:47.192] {
[11:41:47.192]     {
[11:41:47.192]         {
[11:41:47.192]             ...future.startTime <- base::Sys.time()
[11:41:47.192]             {
[11:41:47.192]                 {
[11:41:47.192]                   {
[11:41:47.192]                     {
[11:41:47.192]                       {
[11:41:47.192]                         base::local({
[11:41:47.192]                           has_future <- base::requireNamespace("future", 
[11:41:47.192]                             quietly = TRUE)
[11:41:47.192]                           if (has_future) {
[11:41:47.192]                             ns <- base::getNamespace("future")
[11:41:47.192]                             version <- ns[[".package"]][["version"]]
[11:41:47.192]                             if (is.null(version)) 
[11:41:47.192]                               version <- utils::packageVersion("future")
[11:41:47.192]                           }
[11:41:47.192]                           else {
[11:41:47.192]                             version <- NULL
[11:41:47.192]                           }
[11:41:47.192]                           if (!has_future || version < "1.8.0") {
[11:41:47.192]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:47.192]                               "", base::R.version$version.string), 
[11:41:47.192]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:47.192]                                 base::R.version$platform, 8 * 
[11:41:47.192]                                   base::.Machine$sizeof.pointer), 
[11:41:47.192]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:47.192]                                 "release", "version")], collapse = " "), 
[11:41:47.192]                               hostname = base::Sys.info()[["nodename"]])
[11:41:47.192]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:47.192]                               info)
[11:41:47.192]                             info <- base::paste(info, collapse = "; ")
[11:41:47.192]                             if (!has_future) {
[11:41:47.192]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:47.192]                                 info)
[11:41:47.192]                             }
[11:41:47.192]                             else {
[11:41:47.192]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:47.192]                                 info, version)
[11:41:47.192]                             }
[11:41:47.192]                             base::stop(msg)
[11:41:47.192]                           }
[11:41:47.192]                         })
[11:41:47.192]                       }
[11:41:47.192]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:47.192]                       base::options(mc.cores = 1L)
[11:41:47.192]                     }
[11:41:47.192]                     base::local({
[11:41:47.192]                       for (pkg in "mlr3") {
[11:41:47.192]                         base::loadNamespace(pkg)
[11:41:47.192]                         base::library(pkg, character.only = TRUE)
[11:41:47.192]                       }
[11:41:47.192]                     })
[11:41:47.192]                   }
[11:41:47.192]                   options(future.plan = NULL)
[11:41:47.192]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:47.192]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:47.192]                 }
[11:41:47.192]                 ...future.workdir <- getwd()
[11:41:47.192]             }
[11:41:47.192]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:47.192]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:47.192]         }
[11:41:47.192]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:47.192]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:47.192]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:47.192]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:47.192]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:47.192]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:47.192]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:47.192]             base::names(...future.oldOptions))
[11:41:47.192]     }
[11:41:47.192]     if (FALSE) {
[11:41:47.192]     }
[11:41:47.192]     else {
[11:41:47.192]         if (TRUE) {
[11:41:47.192]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:47.192]                 open = "w")
[11:41:47.192]         }
[11:41:47.192]         else {
[11:41:47.192]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:47.192]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:47.192]         }
[11:41:47.192]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:47.192]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:47.192]             base::sink(type = "output", split = FALSE)
[11:41:47.192]             base::close(...future.stdout)
[11:41:47.192]         }, add = TRUE)
[11:41:47.192]     }
[11:41:47.192]     ...future.frame <- base::sys.nframe()
[11:41:47.192]     ...future.conditions <- base::list()
[11:41:47.192]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:47.192]     if (FALSE) {
[11:41:47.192]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:47.192]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:47.192]     }
[11:41:47.192]     ...future.result <- base::tryCatch({
[11:41:47.192]         base::withCallingHandlers({
[11:41:47.192]             ...future.value <- base::withVisible(base::local({
[11:41:47.192]                 ...future.makeSendCondition <- local({
[11:41:47.192]                   sendCondition <- NULL
[11:41:47.192]                   function(frame = 1L) {
[11:41:47.192]                     if (is.function(sendCondition)) 
[11:41:47.192]                       return(sendCondition)
[11:41:47.192]                     ns <- getNamespace("parallel")
[11:41:47.192]                     if (exists("sendData", mode = "function", 
[11:41:47.192]                       envir = ns)) {
[11:41:47.192]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:47.192]                         envir = ns)
[11:41:47.192]                       envir <- sys.frame(frame)
[11:41:47.192]                       master <- NULL
[11:41:47.192]                       while (!identical(envir, .GlobalEnv) && 
[11:41:47.192]                         !identical(envir, emptyenv())) {
[11:41:47.192]                         if (exists("master", mode = "list", envir = envir, 
[11:41:47.192]                           inherits = FALSE)) {
[11:41:47.192]                           master <- get("master", mode = "list", 
[11:41:47.192]                             envir = envir, inherits = FALSE)
[11:41:47.192]                           if (inherits(master, c("SOCKnode", 
[11:41:47.192]                             "SOCK0node"))) {
[11:41:47.192]                             sendCondition <<- function(cond) {
[11:41:47.192]                               data <- list(type = "VALUE", value = cond, 
[11:41:47.192]                                 success = TRUE)
[11:41:47.192]                               parallel_sendData(master, data)
[11:41:47.192]                             }
[11:41:47.192]                             return(sendCondition)
[11:41:47.192]                           }
[11:41:47.192]                         }
[11:41:47.192]                         frame <- frame + 1L
[11:41:47.192]                         envir <- sys.frame(frame)
[11:41:47.192]                       }
[11:41:47.192]                     }
[11:41:47.192]                     sendCondition <<- function(cond) NULL
[11:41:47.192]                   }
[11:41:47.192]                 })
[11:41:47.192]                 withCallingHandlers({
[11:41:47.192]                   {
[11:41:47.192]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:47.192]                     if (!identical(...future.globals.maxSize.org, 
[11:41:47.192]                       ...future.globals.maxSize)) {
[11:41:47.192]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:47.192]                       on.exit(options(oopts), add = TRUE)
[11:41:47.192]                     }
[11:41:47.192]                     {
[11:41:47.192]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:47.192]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:47.192]                           envir = globalenv(), inherits = FALSE)
[11:41:47.192]                         ...future.FUN(...)
[11:41:47.192]                       }
[11:41:47.192]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:47.192]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:47.192]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:47.192]                         USE.NAMES = FALSE)
[11:41:47.192]                       do.call(mapply, args = args)
[11:41:47.192]                     }
[11:41:47.192]                   }
[11:41:47.192]                 }, immediateCondition = function(cond) {
[11:41:47.192]                   sendCondition <- ...future.makeSendCondition()
[11:41:47.192]                   sendCondition(cond)
[11:41:47.192]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:47.192]                   {
[11:41:47.192]                     inherits <- base::inherits
[11:41:47.192]                     invokeRestart <- base::invokeRestart
[11:41:47.192]                     is.null <- base::is.null
[11:41:47.192]                     muffled <- FALSE
[11:41:47.192]                     if (inherits(cond, "message")) {
[11:41:47.192]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:47.192]                       if (muffled) 
[11:41:47.192]                         invokeRestart("muffleMessage")
[11:41:47.192]                     }
[11:41:47.192]                     else if (inherits(cond, "warning")) {
[11:41:47.192]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:47.192]                       if (muffled) 
[11:41:47.192]                         invokeRestart("muffleWarning")
[11:41:47.192]                     }
[11:41:47.192]                     else if (inherits(cond, "condition")) {
[11:41:47.192]                       if (!is.null(pattern)) {
[11:41:47.192]                         computeRestarts <- base::computeRestarts
[11:41:47.192]                         grepl <- base::grepl
[11:41:47.192]                         restarts <- computeRestarts(cond)
[11:41:47.192]                         for (restart in restarts) {
[11:41:47.192]                           name <- restart$name
[11:41:47.192]                           if (is.null(name)) 
[11:41:47.192]                             next
[11:41:47.192]                           if (!grepl(pattern, name)) 
[11:41:47.192]                             next
[11:41:47.192]                           invokeRestart(restart)
[11:41:47.192]                           muffled <- TRUE
[11:41:47.192]                           break
[11:41:47.192]                         }
[11:41:47.192]                       }
[11:41:47.192]                     }
[11:41:47.192]                     invisible(muffled)
[11:41:47.192]                   }
[11:41:47.192]                   muffleCondition(cond)
[11:41:47.192]                 })
[11:41:47.192]             }))
[11:41:47.192]             future::FutureResult(value = ...future.value$value, 
[11:41:47.192]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:47.192]                   ...future.rng), globalenv = if (FALSE) 
[11:41:47.192]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:47.192]                     ...future.globalenv.names))
[11:41:47.192]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:47.192]         }, condition = base::local({
[11:41:47.192]             c <- base::c
[11:41:47.192]             inherits <- base::inherits
[11:41:47.192]             invokeRestart <- base::invokeRestart
[11:41:47.192]             length <- base::length
[11:41:47.192]             list <- base::list
[11:41:47.192]             seq.int <- base::seq.int
[11:41:47.192]             signalCondition <- base::signalCondition
[11:41:47.192]             sys.calls <- base::sys.calls
[11:41:47.192]             `[[` <- base::`[[`
[11:41:47.192]             `+` <- base::`+`
[11:41:47.192]             `<<-` <- base::`<<-`
[11:41:47.192]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:47.192]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:47.192]                   3L)]
[11:41:47.192]             }
[11:41:47.192]             function(cond) {
[11:41:47.192]                 is_error <- inherits(cond, "error")
[11:41:47.192]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:47.192]                   NULL)
[11:41:47.192]                 if (is_error) {
[11:41:47.192]                   sessionInformation <- function() {
[11:41:47.192]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:47.192]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:47.192]                       search = base::search(), system = base::Sys.info())
[11:41:47.192]                   }
[11:41:47.192]                   ...future.conditions[[length(...future.conditions) + 
[11:41:47.192]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:47.192]                     cond$call), session = sessionInformation(), 
[11:41:47.192]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:47.192]                   signalCondition(cond)
[11:41:47.192]                 }
[11:41:47.192]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:47.192]                 "immediateCondition"))) {
[11:41:47.192]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:47.192]                   ...future.conditions[[length(...future.conditions) + 
[11:41:47.192]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:47.192]                   if (TRUE && !signal) {
[11:41:47.192]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:47.192]                     {
[11:41:47.192]                       inherits <- base::inherits
[11:41:47.192]                       invokeRestart <- base::invokeRestart
[11:41:47.192]                       is.null <- base::is.null
[11:41:47.192]                       muffled <- FALSE
[11:41:47.192]                       if (inherits(cond, "message")) {
[11:41:47.192]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:47.192]                         if (muffled) 
[11:41:47.192]                           invokeRestart("muffleMessage")
[11:41:47.192]                       }
[11:41:47.192]                       else if (inherits(cond, "warning")) {
[11:41:47.192]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:47.192]                         if (muffled) 
[11:41:47.192]                           invokeRestart("muffleWarning")
[11:41:47.192]                       }
[11:41:47.192]                       else if (inherits(cond, "condition")) {
[11:41:47.192]                         if (!is.null(pattern)) {
[11:41:47.192]                           computeRestarts <- base::computeRestarts
[11:41:47.192]                           grepl <- base::grepl
[11:41:47.192]                           restarts <- computeRestarts(cond)
[11:41:47.192]                           for (restart in restarts) {
[11:41:47.192]                             name <- restart$name
[11:41:47.192]                             if (is.null(name)) 
[11:41:47.192]                               next
[11:41:47.192]                             if (!grepl(pattern, name)) 
[11:41:47.192]                               next
[11:41:47.192]                             invokeRestart(restart)
[11:41:47.192]                             muffled <- TRUE
[11:41:47.192]                             break
[11:41:47.192]                           }
[11:41:47.192]                         }
[11:41:47.192]                       }
[11:41:47.192]                       invisible(muffled)
[11:41:47.192]                     }
[11:41:47.192]                     muffleCondition(cond, pattern = "^muffle")
[11:41:47.192]                   }
[11:41:47.192]                 }
[11:41:47.192]                 else {
[11:41:47.192]                   if (TRUE) {
[11:41:47.192]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:47.192]                     {
[11:41:47.192]                       inherits <- base::inherits
[11:41:47.192]                       invokeRestart <- base::invokeRestart
[11:41:47.192]                       is.null <- base::is.null
[11:41:47.192]                       muffled <- FALSE
[11:41:47.192]                       if (inherits(cond, "message")) {
[11:41:47.192]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:47.192]                         if (muffled) 
[11:41:47.192]                           invokeRestart("muffleMessage")
[11:41:47.192]                       }
[11:41:47.192]                       else if (inherits(cond, "warning")) {
[11:41:47.192]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:47.192]                         if (muffled) 
[11:41:47.192]                           invokeRestart("muffleWarning")
[11:41:47.192]                       }
[11:41:47.192]                       else if (inherits(cond, "condition")) {
[11:41:47.192]                         if (!is.null(pattern)) {
[11:41:47.192]                           computeRestarts <- base::computeRestarts
[11:41:47.192]                           grepl <- base::grepl
[11:41:47.192]                           restarts <- computeRestarts(cond)
[11:41:47.192]                           for (restart in restarts) {
[11:41:47.192]                             name <- restart$name
[11:41:47.192]                             if (is.null(name)) 
[11:41:47.192]                               next
[11:41:47.192]                             if (!grepl(pattern, name)) 
[11:41:47.192]                               next
[11:41:47.192]                             invokeRestart(restart)
[11:41:47.192]                             muffled <- TRUE
[11:41:47.192]                             break
[11:41:47.192]                           }
[11:41:47.192]                         }
[11:41:47.192]                       }
[11:41:47.192]                       invisible(muffled)
[11:41:47.192]                     }
[11:41:47.192]                     muffleCondition(cond, pattern = "^muffle")
[11:41:47.192]                   }
[11:41:47.192]                 }
[11:41:47.192]             }
[11:41:47.192]         }))
[11:41:47.192]     }, error = function(ex) {
[11:41:47.192]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:47.192]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:47.192]                 ...future.rng), started = ...future.startTime, 
[11:41:47.192]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:47.192]             version = "1.8"), class = "FutureResult")
[11:41:47.192]     }, finally = {
[11:41:47.192]         if (!identical(...future.workdir, getwd())) 
[11:41:47.192]             setwd(...future.workdir)
[11:41:47.192]         {
[11:41:47.192]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:47.192]                 ...future.oldOptions$nwarnings <- NULL
[11:41:47.192]             }
[11:41:47.192]             base::options(...future.oldOptions)
[11:41:47.192]             if (.Platform$OS.type == "windows") {
[11:41:47.192]                 old_names <- names(...future.oldEnvVars)
[11:41:47.192]                 envs <- base::Sys.getenv()
[11:41:47.192]                 names <- names(envs)
[11:41:47.192]                 common <- intersect(names, old_names)
[11:41:47.192]                 added <- setdiff(names, old_names)
[11:41:47.192]                 removed <- setdiff(old_names, names)
[11:41:47.192]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:47.192]                   envs[common]]
[11:41:47.192]                 NAMES <- toupper(changed)
[11:41:47.192]                 args <- list()
[11:41:47.192]                 for (kk in seq_along(NAMES)) {
[11:41:47.192]                   name <- changed[[kk]]
[11:41:47.192]                   NAME <- NAMES[[kk]]
[11:41:47.192]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:47.192]                     next
[11:41:47.192]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:47.192]                 }
[11:41:47.192]                 NAMES <- toupper(added)
[11:41:47.192]                 for (kk in seq_along(NAMES)) {
[11:41:47.192]                   name <- added[[kk]]
[11:41:47.192]                   NAME <- NAMES[[kk]]
[11:41:47.192]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:47.192]                     next
[11:41:47.192]                   args[[name]] <- ""
[11:41:47.192]                 }
[11:41:47.192]                 NAMES <- toupper(removed)
[11:41:47.192]                 for (kk in seq_along(NAMES)) {
[11:41:47.192]                   name <- removed[[kk]]
[11:41:47.192]                   NAME <- NAMES[[kk]]
[11:41:47.192]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:47.192]                     next
[11:41:47.192]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:47.192]                 }
[11:41:47.192]                 if (length(args) > 0) 
[11:41:47.192]                   base::do.call(base::Sys.setenv, args = args)
[11:41:47.192]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:47.192]             }
[11:41:47.192]             else {
[11:41:47.192]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:47.192]             }
[11:41:47.192]             {
[11:41:47.192]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:47.192]                   0L) {
[11:41:47.192]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:47.192]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:47.192]                   base::options(opts)
[11:41:47.192]                 }
[11:41:47.192]                 {
[11:41:47.192]                   {
[11:41:47.192]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:47.192]                     NULL
[11:41:47.192]                   }
[11:41:47.192]                   options(future.plan = NULL)
[11:41:47.192]                   if (is.na(NA_character_)) 
[11:41:47.192]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:47.192]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:47.192]                   future::plan(list(function (..., workers = 2, 
[11:41:47.192]                     envir = parent.frame()) 
[11:41:47.192]                   strategy(..., workers = workers, envir = envir)), 
[11:41:47.192]                     .cleanup = FALSE, .init = FALSE)
[11:41:47.192]                 }
[11:41:47.192]             }
[11:41:47.192]         }
[11:41:47.192]     })
[11:41:47.192]     if (TRUE) {
[11:41:47.192]         base::sink(type = "output", split = FALSE)
[11:41:47.192]         if (TRUE) {
[11:41:47.192]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:47.192]         }
[11:41:47.192]         else {
[11:41:47.192]             ...future.result["stdout"] <- base::list(NULL)
[11:41:47.192]         }
[11:41:47.192]         base::close(...future.stdout)
[11:41:47.192]         ...future.stdout <- NULL
[11:41:47.192]     }
[11:41:47.192]     ...future.result$conditions <- ...future.conditions
[11:41:47.192]     ...future.result$finished <- base::Sys.time()
[11:41:47.192]     ...future.result
[11:41:47.192] }
[11:41:47.193] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:47.205] receiveMessageFromWorker() for ClusterFuture ...
[11:41:47.205] - Validating connection of MultisessionFuture
[11:41:47.205] - received message: FutureResult
[11:41:47.205] - Received FutureResult
[11:41:47.205] - Erased future from FutureRegistry
[11:41:47.206] result() for ClusterFuture ...
[11:41:47.206] - result already collected: FutureResult
[11:41:47.206] result() for ClusterFuture ... done
[11:41:47.206] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:47.206] result() for ClusterFuture ...
[11:41:47.206] - result already collected: FutureResult
[11:41:47.206] result() for ClusterFuture ... done
[11:41:47.206] result() for ClusterFuture ...
[11:41:47.206] - result already collected: FutureResult
[11:41:47.206] result() for ClusterFuture ... done
[11:41:47.207] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:47.208] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:47.250] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:47.257] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:47.306] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:47.307] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:47.355] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:47.355] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:47.357] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:47.358] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:47.359] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:47.359] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:47.360] MultisessionFuture started
[11:41:47.361] - Launch lazy future ... done
[11:41:47.361] run() for ‘MultisessionFuture’ ... done
[11:41:47.361] Created future:
[11:41:47.361] MultisessionFuture:
[11:41:47.361] Label: ‘future_mapply-8’
[11:41:47.361] Expression:
[11:41:47.361] {
[11:41:47.361]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:47.361]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:47.361]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:47.361]         on.exit(options(oopts), add = TRUE)
[11:41:47.361]     }
[11:41:47.361]     {
[11:41:47.361]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:47.361]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:47.361]                 inherits = FALSE)
[11:41:47.361]             ...future.FUN(...)
[11:41:47.361]         }
[11:41:47.361]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:47.361]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:47.361]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:47.361]         do.call(mapply, args = args)
[11:41:47.361]     }
[11:41:47.361] }
[11:41:47.361] Lazy evaluation: FALSE
[11:41:47.361] Asynchronous evaluation: TRUE
[11:41:47.361] Local evaluation: TRUE
[11:41:47.361] Environment: 0x560ef58e1768
[11:41:47.361] Capture standard output: TRUE
[11:41:47.361] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:47.361] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:47.361] Packages: 1 packages (‘mlr3’)
[11:41:47.361] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:47.361] Resolved: FALSE
[11:41:47.361] Value: <not collected>
[11:41:47.361] Conditions captured: <none>
[11:41:47.361] Early signaling: FALSE
[11:41:47.361] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:47.361] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:47.379] Chunk #8 of 90 ... DONE
[11:41:47.379] Chunk #9 of 90 ...
[11:41:47.380]  - seeds: [1] <seeds>
[11:41:47.380] getGlobalsAndPackages() ...
[11:41:47.380] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:47.380] Resolving globals: FALSE
[11:41:47.381] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:47.381] - packages: [1] ‘mlr3’
[11:41:47.381] getGlobalsAndPackages() ... DONE
[11:41:47.381] run() for ‘Future’ ...
[11:41:47.382] - state: ‘created’
[11:41:47.382] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:47.392] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:47.392] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:47.392]   - Field: ‘node’
[11:41:47.392]   - Field: ‘label’
[11:41:47.392]   - Field: ‘local’
[11:41:47.392]   - Field: ‘owner’
[11:41:47.392]   - Field: ‘envir’
[11:41:47.392]   - Field: ‘workers’
[11:41:47.392]   - Field: ‘packages’
[11:41:47.392]   - Field: ‘gc’
[11:41:47.392]   - Field: ‘conditions’
[11:41:47.392]   - Field: ‘persistent’
[11:41:47.392]   - Field: ‘expr’
[11:41:47.393]   - Field: ‘uuid’
[11:41:47.393]   - Field: ‘seed’
[11:41:47.393]   - Field: ‘version’
[11:41:47.393]   - Field: ‘result’
[11:41:47.393]   - Field: ‘asynchronous’
[11:41:47.393]   - Field: ‘calls’
[11:41:47.393]   - Field: ‘globals’
[11:41:47.393]   - Field: ‘stdout’
[11:41:47.393]   - Field: ‘earlySignal’
[11:41:47.393]   - Field: ‘lazy’
[11:41:47.393]   - Field: ‘state’
[11:41:47.393] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:47.393] - Launch lazy future ...
[11:41:47.393] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:47.393] Packages needed by future strategies (n = 0): <none>
[11:41:47.394] {
[11:41:47.394]     {
[11:41:47.394]         {
[11:41:47.394]             ...future.startTime <- base::Sys.time()
[11:41:47.394]             {
[11:41:47.394]                 {
[11:41:47.394]                   {
[11:41:47.394]                     {
[11:41:47.394]                       {
[11:41:47.394]                         base::local({
[11:41:47.394]                           has_future <- base::requireNamespace("future", 
[11:41:47.394]                             quietly = TRUE)
[11:41:47.394]                           if (has_future) {
[11:41:47.394]                             ns <- base::getNamespace("future")
[11:41:47.394]                             version <- ns[[".package"]][["version"]]
[11:41:47.394]                             if (is.null(version)) 
[11:41:47.394]                               version <- utils::packageVersion("future")
[11:41:47.394]                           }
[11:41:47.394]                           else {
[11:41:47.394]                             version <- NULL
[11:41:47.394]                           }
[11:41:47.394]                           if (!has_future || version < "1.8.0") {
[11:41:47.394]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:47.394]                               "", base::R.version$version.string), 
[11:41:47.394]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:47.394]                                 base::R.version$platform, 8 * 
[11:41:47.394]                                   base::.Machine$sizeof.pointer), 
[11:41:47.394]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:47.394]                                 "release", "version")], collapse = " "), 
[11:41:47.394]                               hostname = base::Sys.info()[["nodename"]])
[11:41:47.394]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:47.394]                               info)
[11:41:47.394]                             info <- base::paste(info, collapse = "; ")
[11:41:47.394]                             if (!has_future) {
[11:41:47.394]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:47.394]                                 info)
[11:41:47.394]                             }
[11:41:47.394]                             else {
[11:41:47.394]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:47.394]                                 info, version)
[11:41:47.394]                             }
[11:41:47.394]                             base::stop(msg)
[11:41:47.394]                           }
[11:41:47.394]                         })
[11:41:47.394]                       }
[11:41:47.394]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:47.394]                       base::options(mc.cores = 1L)
[11:41:47.394]                     }
[11:41:47.394]                     base::local({
[11:41:47.394]                       for (pkg in "mlr3") {
[11:41:47.394]                         base::loadNamespace(pkg)
[11:41:47.394]                         base::library(pkg, character.only = TRUE)
[11:41:47.394]                       }
[11:41:47.394]                     })
[11:41:47.394]                   }
[11:41:47.394]                   options(future.plan = NULL)
[11:41:47.394]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:47.394]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:47.394]                 }
[11:41:47.394]                 ...future.workdir <- getwd()
[11:41:47.394]             }
[11:41:47.394]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:47.394]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:47.394]         }
[11:41:47.394]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:47.394]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:47.394]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:47.394]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:47.394]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:47.394]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:47.394]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:47.394]             base::names(...future.oldOptions))
[11:41:47.394]     }
[11:41:47.394]     if (FALSE) {
[11:41:47.394]     }
[11:41:47.394]     else {
[11:41:47.394]         if (TRUE) {
[11:41:47.394]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:47.394]                 open = "w")
[11:41:47.394]         }
[11:41:47.394]         else {
[11:41:47.394]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:47.394]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:47.394]         }
[11:41:47.394]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:47.394]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:47.394]             base::sink(type = "output", split = FALSE)
[11:41:47.394]             base::close(...future.stdout)
[11:41:47.394]         }, add = TRUE)
[11:41:47.394]     }
[11:41:47.394]     ...future.frame <- base::sys.nframe()
[11:41:47.394]     ...future.conditions <- base::list()
[11:41:47.394]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:47.394]     if (FALSE) {
[11:41:47.394]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:47.394]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:47.394]     }
[11:41:47.394]     ...future.result <- base::tryCatch({
[11:41:47.394]         base::withCallingHandlers({
[11:41:47.394]             ...future.value <- base::withVisible(base::local({
[11:41:47.394]                 ...future.makeSendCondition <- local({
[11:41:47.394]                   sendCondition <- NULL
[11:41:47.394]                   function(frame = 1L) {
[11:41:47.394]                     if (is.function(sendCondition)) 
[11:41:47.394]                       return(sendCondition)
[11:41:47.394]                     ns <- getNamespace("parallel")
[11:41:47.394]                     if (exists("sendData", mode = "function", 
[11:41:47.394]                       envir = ns)) {
[11:41:47.394]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:47.394]                         envir = ns)
[11:41:47.394]                       envir <- sys.frame(frame)
[11:41:47.394]                       master <- NULL
[11:41:47.394]                       while (!identical(envir, .GlobalEnv) && 
[11:41:47.394]                         !identical(envir, emptyenv())) {
[11:41:47.394]                         if (exists("master", mode = "list", envir = envir, 
[11:41:47.394]                           inherits = FALSE)) {
[11:41:47.394]                           master <- get("master", mode = "list", 
[11:41:47.394]                             envir = envir, inherits = FALSE)
[11:41:47.394]                           if (inherits(master, c("SOCKnode", 
[11:41:47.394]                             "SOCK0node"))) {
[11:41:47.394]                             sendCondition <<- function(cond) {
[11:41:47.394]                               data <- list(type = "VALUE", value = cond, 
[11:41:47.394]                                 success = TRUE)
[11:41:47.394]                               parallel_sendData(master, data)
[11:41:47.394]                             }
[11:41:47.394]                             return(sendCondition)
[11:41:47.394]                           }
[11:41:47.394]                         }
[11:41:47.394]                         frame <- frame + 1L
[11:41:47.394]                         envir <- sys.frame(frame)
[11:41:47.394]                       }
[11:41:47.394]                     }
[11:41:47.394]                     sendCondition <<- function(cond) NULL
[11:41:47.394]                   }
[11:41:47.394]                 })
[11:41:47.394]                 withCallingHandlers({
[11:41:47.394]                   {
[11:41:47.394]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:47.394]                     if (!identical(...future.globals.maxSize.org, 
[11:41:47.394]                       ...future.globals.maxSize)) {
[11:41:47.394]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:47.394]                       on.exit(options(oopts), add = TRUE)
[11:41:47.394]                     }
[11:41:47.394]                     {
[11:41:47.394]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:47.394]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:47.394]                           envir = globalenv(), inherits = FALSE)
[11:41:47.394]                         ...future.FUN(...)
[11:41:47.394]                       }
[11:41:47.394]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:47.394]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:47.394]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:47.394]                         USE.NAMES = FALSE)
[11:41:47.394]                       do.call(mapply, args = args)
[11:41:47.394]                     }
[11:41:47.394]                   }
[11:41:47.394]                 }, immediateCondition = function(cond) {
[11:41:47.394]                   sendCondition <- ...future.makeSendCondition()
[11:41:47.394]                   sendCondition(cond)
[11:41:47.394]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:47.394]                   {
[11:41:47.394]                     inherits <- base::inherits
[11:41:47.394]                     invokeRestart <- base::invokeRestart
[11:41:47.394]                     is.null <- base::is.null
[11:41:47.394]                     muffled <- FALSE
[11:41:47.394]                     if (inherits(cond, "message")) {
[11:41:47.394]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:47.394]                       if (muffled) 
[11:41:47.394]                         invokeRestart("muffleMessage")
[11:41:47.394]                     }
[11:41:47.394]                     else if (inherits(cond, "warning")) {
[11:41:47.394]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:47.394]                       if (muffled) 
[11:41:47.394]                         invokeRestart("muffleWarning")
[11:41:47.394]                     }
[11:41:47.394]                     else if (inherits(cond, "condition")) {
[11:41:47.394]                       if (!is.null(pattern)) {
[11:41:47.394]                         computeRestarts <- base::computeRestarts
[11:41:47.394]                         grepl <- base::grepl
[11:41:47.394]                         restarts <- computeRestarts(cond)
[11:41:47.394]                         for (restart in restarts) {
[11:41:47.394]                           name <- restart$name
[11:41:47.394]                           if (is.null(name)) 
[11:41:47.394]                             next
[11:41:47.394]                           if (!grepl(pattern, name)) 
[11:41:47.394]                             next
[11:41:47.394]                           invokeRestart(restart)
[11:41:47.394]                           muffled <- TRUE
[11:41:47.394]                           break
[11:41:47.394]                         }
[11:41:47.394]                       }
[11:41:47.394]                     }
[11:41:47.394]                     invisible(muffled)
[11:41:47.394]                   }
[11:41:47.394]                   muffleCondition(cond)
[11:41:47.394]                 })
[11:41:47.394]             }))
[11:41:47.394]             future::FutureResult(value = ...future.value$value, 
[11:41:47.394]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:47.394]                   ...future.rng), globalenv = if (FALSE) 
[11:41:47.394]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:47.394]                     ...future.globalenv.names))
[11:41:47.394]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:47.394]         }, condition = base::local({
[11:41:47.394]             c <- base::c
[11:41:47.394]             inherits <- base::inherits
[11:41:47.394]             invokeRestart <- base::invokeRestart
[11:41:47.394]             length <- base::length
[11:41:47.394]             list <- base::list
[11:41:47.394]             seq.int <- base::seq.int
[11:41:47.394]             signalCondition <- base::signalCondition
[11:41:47.394]             sys.calls <- base::sys.calls
[11:41:47.394]             `[[` <- base::`[[`
[11:41:47.394]             `+` <- base::`+`
[11:41:47.394]             `<<-` <- base::`<<-`
[11:41:47.394]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:47.394]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:47.394]                   3L)]
[11:41:47.394]             }
[11:41:47.394]             function(cond) {
[11:41:47.394]                 is_error <- inherits(cond, "error")
[11:41:47.394]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:47.394]                   NULL)
[11:41:47.394]                 if (is_error) {
[11:41:47.394]                   sessionInformation <- function() {
[11:41:47.394]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:47.394]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:47.394]                       search = base::search(), system = base::Sys.info())
[11:41:47.394]                   }
[11:41:47.394]                   ...future.conditions[[length(...future.conditions) + 
[11:41:47.394]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:47.394]                     cond$call), session = sessionInformation(), 
[11:41:47.394]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:47.394]                   signalCondition(cond)
[11:41:47.394]                 }
[11:41:47.394]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:47.394]                 "immediateCondition"))) {
[11:41:47.394]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:47.394]                   ...future.conditions[[length(...future.conditions) + 
[11:41:47.394]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:47.394]                   if (TRUE && !signal) {
[11:41:47.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:47.394]                     {
[11:41:47.394]                       inherits <- base::inherits
[11:41:47.394]                       invokeRestart <- base::invokeRestart
[11:41:47.394]                       is.null <- base::is.null
[11:41:47.394]                       muffled <- FALSE
[11:41:47.394]                       if (inherits(cond, "message")) {
[11:41:47.394]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:47.394]                         if (muffled) 
[11:41:47.394]                           invokeRestart("muffleMessage")
[11:41:47.394]                       }
[11:41:47.394]                       else if (inherits(cond, "warning")) {
[11:41:47.394]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:47.394]                         if (muffled) 
[11:41:47.394]                           invokeRestart("muffleWarning")
[11:41:47.394]                       }
[11:41:47.394]                       else if (inherits(cond, "condition")) {
[11:41:47.394]                         if (!is.null(pattern)) {
[11:41:47.394]                           computeRestarts <- base::computeRestarts
[11:41:47.394]                           grepl <- base::grepl
[11:41:47.394]                           restarts <- computeRestarts(cond)
[11:41:47.394]                           for (restart in restarts) {
[11:41:47.394]                             name <- restart$name
[11:41:47.394]                             if (is.null(name)) 
[11:41:47.394]                               next
[11:41:47.394]                             if (!grepl(pattern, name)) 
[11:41:47.394]                               next
[11:41:47.394]                             invokeRestart(restart)
[11:41:47.394]                             muffled <- TRUE
[11:41:47.394]                             break
[11:41:47.394]                           }
[11:41:47.394]                         }
[11:41:47.394]                       }
[11:41:47.394]                       invisible(muffled)
[11:41:47.394]                     }
[11:41:47.394]                     muffleCondition(cond, pattern = "^muffle")
[11:41:47.394]                   }
[11:41:47.394]                 }
[11:41:47.394]                 else {
[11:41:47.394]                   if (TRUE) {
[11:41:47.394]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:47.394]                     {
[11:41:47.394]                       inherits <- base::inherits
[11:41:47.394]                       invokeRestart <- base::invokeRestart
[11:41:47.394]                       is.null <- base::is.null
[11:41:47.394]                       muffled <- FALSE
[11:41:47.394]                       if (inherits(cond, "message")) {
[11:41:47.394]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:47.394]                         if (muffled) 
[11:41:47.394]                           invokeRestart("muffleMessage")
[11:41:47.394]                       }
[11:41:47.394]                       else if (inherits(cond, "warning")) {
[11:41:47.394]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:47.394]                         if (muffled) 
[11:41:47.394]                           invokeRestart("muffleWarning")
[11:41:47.394]                       }
[11:41:47.394]                       else if (inherits(cond, "condition")) {
[11:41:47.394]                         if (!is.null(pattern)) {
[11:41:47.394]                           computeRestarts <- base::computeRestarts
[11:41:47.394]                           grepl <- base::grepl
[11:41:47.394]                           restarts <- computeRestarts(cond)
[11:41:47.394]                           for (restart in restarts) {
[11:41:47.394]                             name <- restart$name
[11:41:47.394]                             if (is.null(name)) 
[11:41:47.394]                               next
[11:41:47.394]                             if (!grepl(pattern, name)) 
[11:41:47.394]                               next
[11:41:47.394]                             invokeRestart(restart)
[11:41:47.394]                             muffled <- TRUE
[11:41:47.394]                             break
[11:41:47.394]                           }
[11:41:47.394]                         }
[11:41:47.394]                       }
[11:41:47.394]                       invisible(muffled)
[11:41:47.394]                     }
[11:41:47.394]                     muffleCondition(cond, pattern = "^muffle")
[11:41:47.394]                   }
[11:41:47.394]                 }
[11:41:47.394]             }
[11:41:47.394]         }))
[11:41:47.394]     }, error = function(ex) {
[11:41:47.394]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:47.394]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:47.394]                 ...future.rng), started = ...future.startTime, 
[11:41:47.394]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:47.394]             version = "1.8"), class = "FutureResult")
[11:41:47.394]     }, finally = {
[11:41:47.394]         if (!identical(...future.workdir, getwd())) 
[11:41:47.394]             setwd(...future.workdir)
[11:41:47.394]         {
[11:41:47.394]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:47.394]                 ...future.oldOptions$nwarnings <- NULL
[11:41:47.394]             }
[11:41:47.394]             base::options(...future.oldOptions)
[11:41:47.394]             if (.Platform$OS.type == "windows") {
[11:41:47.394]                 old_names <- names(...future.oldEnvVars)
[11:41:47.394]                 envs <- base::Sys.getenv()
[11:41:47.394]                 names <- names(envs)
[11:41:47.394]                 common <- intersect(names, old_names)
[11:41:47.394]                 added <- setdiff(names, old_names)
[11:41:47.394]                 removed <- setdiff(old_names, names)
[11:41:47.394]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:47.394]                   envs[common]]
[11:41:47.394]                 NAMES <- toupper(changed)
[11:41:47.394]                 args <- list()
[11:41:47.394]                 for (kk in seq_along(NAMES)) {
[11:41:47.394]                   name <- changed[[kk]]
[11:41:47.394]                   NAME <- NAMES[[kk]]
[11:41:47.394]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:47.394]                     next
[11:41:47.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:47.394]                 }
[11:41:47.394]                 NAMES <- toupper(added)
[11:41:47.394]                 for (kk in seq_along(NAMES)) {
[11:41:47.394]                   name <- added[[kk]]
[11:41:47.394]                   NAME <- NAMES[[kk]]
[11:41:47.394]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:47.394]                     next
[11:41:47.394]                   args[[name]] <- ""
[11:41:47.394]                 }
[11:41:47.394]                 NAMES <- toupper(removed)
[11:41:47.394]                 for (kk in seq_along(NAMES)) {
[11:41:47.394]                   name <- removed[[kk]]
[11:41:47.394]                   NAME <- NAMES[[kk]]
[11:41:47.394]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:47.394]                     next
[11:41:47.394]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:47.394]                 }
[11:41:47.394]                 if (length(args) > 0) 
[11:41:47.394]                   base::do.call(base::Sys.setenv, args = args)
[11:41:47.394]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:47.394]             }
[11:41:47.394]             else {
[11:41:47.394]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:47.394]             }
[11:41:47.394]             {
[11:41:47.394]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:47.394]                   0L) {
[11:41:47.394]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:47.394]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:47.394]                   base::options(opts)
[11:41:47.394]                 }
[11:41:47.394]                 {
[11:41:47.394]                   {
[11:41:47.394]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:47.394]                     NULL
[11:41:47.394]                   }
[11:41:47.394]                   options(future.plan = NULL)
[11:41:47.394]                   if (is.na(NA_character_)) 
[11:41:47.394]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:47.394]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:47.394]                   future::plan(list(function (..., workers = 2, 
[11:41:47.394]                     envir = parent.frame()) 
[11:41:47.394]                   strategy(..., workers = workers, envir = envir)), 
[11:41:47.394]                     .cleanup = FALSE, .init = FALSE)
[11:41:47.394]                 }
[11:41:47.394]             }
[11:41:47.394]         }
[11:41:47.394]     })
[11:41:47.394]     if (TRUE) {
[11:41:47.394]         base::sink(type = "output", split = FALSE)
[11:41:47.394]         if (TRUE) {
[11:41:47.394]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:47.394]         }
[11:41:47.394]         else {
[11:41:47.394]             ...future.result["stdout"] <- base::list(NULL)
[11:41:47.394]         }
[11:41:47.394]         base::close(...future.stdout)
[11:41:47.394]         ...future.stdout <- NULL
[11:41:47.394]     }
[11:41:47.394]     ...future.result$conditions <- ...future.conditions
[11:41:47.394]     ...future.result$finished <- base::Sys.time()
[11:41:47.394]     ...future.result
[11:41:47.394] }
[11:41:47.395] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:47.406] receiveMessageFromWorker() for ClusterFuture ...
[11:41:47.407] - Validating connection of MultisessionFuture
[11:41:47.407] - received message: FutureResult
[11:41:47.407] - Received FutureResult
[11:41:47.407] - Erased future from FutureRegistry
[11:41:47.407] result() for ClusterFuture ...
[11:41:47.407] - result already collected: FutureResult
[11:41:47.407] result() for ClusterFuture ... done
[11:41:47.408] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:47.408] result() for ClusterFuture ...
[11:41:47.408] - result already collected: FutureResult
[11:41:47.408] result() for ClusterFuture ... done
[11:41:47.408] result() for ClusterFuture ...
[11:41:47.408] - result already collected: FutureResult
[11:41:47.408] result() for ClusterFuture ... done
[11:41:47.409] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:47.409] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:47.454] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:47.462] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:47.465] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:47.465] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:47.510] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:47.511] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:47.513] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:47.513] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:47.514] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:47.515] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:47.516] MultisessionFuture started
[11:41:47.516] - Launch lazy future ... done
[11:41:47.516] run() for ‘MultisessionFuture’ ... done
[11:41:47.517] Created future:
[11:41:47.517] MultisessionFuture:
[11:41:47.517] Label: ‘future_mapply-9’
[11:41:47.517] Expression:
[11:41:47.517] {
[11:41:47.517]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:47.517]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:47.517]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:47.517]         on.exit(options(oopts), add = TRUE)
[11:41:47.517]     }
[11:41:47.517]     {
[11:41:47.517]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:47.517]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:47.517]                 inherits = FALSE)
[11:41:47.517]             ...future.FUN(...)
[11:41:47.517]         }
[11:41:47.517]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:47.517]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:47.517]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:47.517]         do.call(mapply, args = args)
[11:41:47.517]     }
[11:41:47.517] }
[11:41:47.517] Lazy evaluation: FALSE
[11:41:47.517] Asynchronous evaluation: TRUE
[11:41:47.517] Local evaluation: TRUE
[11:41:47.517] Environment: 0x560ef58e1768
[11:41:47.517] Capture standard output: TRUE
[11:41:47.517] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:47.517] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:47.517] Packages: 1 packages (‘mlr3’)
[11:41:47.517] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:47.517] Resolved: FALSE
[11:41:47.517] Value: <not collected>
[11:41:47.517] Conditions captured: <none>
[11:41:47.517] Early signaling: FALSE
[11:41:47.517] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:47.517] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:47.535] Chunk #9 of 90 ... DONE
[11:41:47.535] Chunk #10 of 90 ...
[11:41:47.535]  - seeds: [1] <seeds>
[11:41:47.535] getGlobalsAndPackages() ...
[11:41:47.535] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:47.536] Resolving globals: FALSE
[11:41:47.536] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:47.536] - packages: [1] ‘mlr3’
[11:41:47.536] getGlobalsAndPackages() ... DONE
[11:41:47.537] run() for ‘Future’ ...
[11:41:47.537] - state: ‘created’
[11:41:47.537] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:47.547] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:47.547] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:47.547]   - Field: ‘node’
[11:41:47.547]   - Field: ‘label’
[11:41:47.547]   - Field: ‘local’
[11:41:47.547]   - Field: ‘owner’
[11:41:47.547]   - Field: ‘envir’
[11:41:47.547]   - Field: ‘workers’
[11:41:47.547]   - Field: ‘packages’
[11:41:47.547]   - Field: ‘gc’
[11:41:47.547]   - Field: ‘conditions’
[11:41:47.547]   - Field: ‘persistent’
[11:41:47.548]   - Field: ‘expr’
[11:41:47.548]   - Field: ‘uuid’
[11:41:47.548]   - Field: ‘seed’
[11:41:47.548]   - Field: ‘version’
[11:41:47.548]   - Field: ‘result’
[11:41:47.548]   - Field: ‘asynchronous’
[11:41:47.548]   - Field: ‘calls’
[11:41:47.548]   - Field: ‘globals’
[11:41:47.548]   - Field: ‘stdout’
[11:41:47.548]   - Field: ‘earlySignal’
[11:41:47.548]   - Field: ‘lazy’
[11:41:47.548]   - Field: ‘state’
[11:41:47.548] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:47.548] - Launch lazy future ...
[11:41:47.548] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:47.548] Packages needed by future strategies (n = 0): <none>
[11:41:47.549] {
[11:41:47.549]     {
[11:41:47.549]         {
[11:41:47.549]             ...future.startTime <- base::Sys.time()
[11:41:47.549]             {
[11:41:47.549]                 {
[11:41:47.549]                   {
[11:41:47.549]                     {
[11:41:47.549]                       {
[11:41:47.549]                         base::local({
[11:41:47.549]                           has_future <- base::requireNamespace("future", 
[11:41:47.549]                             quietly = TRUE)
[11:41:47.549]                           if (has_future) {
[11:41:47.549]                             ns <- base::getNamespace("future")
[11:41:47.549]                             version <- ns[[".package"]][["version"]]
[11:41:47.549]                             if (is.null(version)) 
[11:41:47.549]                               version <- utils::packageVersion("future")
[11:41:47.549]                           }
[11:41:47.549]                           else {
[11:41:47.549]                             version <- NULL
[11:41:47.549]                           }
[11:41:47.549]                           if (!has_future || version < "1.8.0") {
[11:41:47.549]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:47.549]                               "", base::R.version$version.string), 
[11:41:47.549]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:47.549]                                 base::R.version$platform, 8 * 
[11:41:47.549]                                   base::.Machine$sizeof.pointer), 
[11:41:47.549]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:47.549]                                 "release", "version")], collapse = " "), 
[11:41:47.549]                               hostname = base::Sys.info()[["nodename"]])
[11:41:47.549]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:47.549]                               info)
[11:41:47.549]                             info <- base::paste(info, collapse = "; ")
[11:41:47.549]                             if (!has_future) {
[11:41:47.549]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:47.549]                                 info)
[11:41:47.549]                             }
[11:41:47.549]                             else {
[11:41:47.549]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:47.549]                                 info, version)
[11:41:47.549]                             }
[11:41:47.549]                             base::stop(msg)
[11:41:47.549]                           }
[11:41:47.549]                         })
[11:41:47.549]                       }
[11:41:47.549]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:47.549]                       base::options(mc.cores = 1L)
[11:41:47.549]                     }
[11:41:47.549]                     base::local({
[11:41:47.549]                       for (pkg in "mlr3") {
[11:41:47.549]                         base::loadNamespace(pkg)
[11:41:47.549]                         base::library(pkg, character.only = TRUE)
[11:41:47.549]                       }
[11:41:47.549]                     })
[11:41:47.549]                   }
[11:41:47.549]                   options(future.plan = NULL)
[11:41:47.549]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:47.549]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:47.549]                 }
[11:41:47.549]                 ...future.workdir <- getwd()
[11:41:47.549]             }
[11:41:47.549]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:47.549]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:47.549]         }
[11:41:47.549]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:47.549]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:47.549]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:47.549]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:47.549]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:47.549]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:47.549]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:47.549]             base::names(...future.oldOptions))
[11:41:47.549]     }
[11:41:47.549]     if (FALSE) {
[11:41:47.549]     }
[11:41:47.549]     else {
[11:41:47.549]         if (TRUE) {
[11:41:47.549]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:47.549]                 open = "w")
[11:41:47.549]         }
[11:41:47.549]         else {
[11:41:47.549]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:47.549]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:47.549]         }
[11:41:47.549]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:47.549]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:47.549]             base::sink(type = "output", split = FALSE)
[11:41:47.549]             base::close(...future.stdout)
[11:41:47.549]         }, add = TRUE)
[11:41:47.549]     }
[11:41:47.549]     ...future.frame <- base::sys.nframe()
[11:41:47.549]     ...future.conditions <- base::list()
[11:41:47.549]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:47.549]     if (FALSE) {
[11:41:47.549]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:47.549]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:47.549]     }
[11:41:47.549]     ...future.result <- base::tryCatch({
[11:41:47.549]         base::withCallingHandlers({
[11:41:47.549]             ...future.value <- base::withVisible(base::local({
[11:41:47.549]                 ...future.makeSendCondition <- local({
[11:41:47.549]                   sendCondition <- NULL
[11:41:47.549]                   function(frame = 1L) {
[11:41:47.549]                     if (is.function(sendCondition)) 
[11:41:47.549]                       return(sendCondition)
[11:41:47.549]                     ns <- getNamespace("parallel")
[11:41:47.549]                     if (exists("sendData", mode = "function", 
[11:41:47.549]                       envir = ns)) {
[11:41:47.549]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:47.549]                         envir = ns)
[11:41:47.549]                       envir <- sys.frame(frame)
[11:41:47.549]                       master <- NULL
[11:41:47.549]                       while (!identical(envir, .GlobalEnv) && 
[11:41:47.549]                         !identical(envir, emptyenv())) {
[11:41:47.549]                         if (exists("master", mode = "list", envir = envir, 
[11:41:47.549]                           inherits = FALSE)) {
[11:41:47.549]                           master <- get("master", mode = "list", 
[11:41:47.549]                             envir = envir, inherits = FALSE)
[11:41:47.549]                           if (inherits(master, c("SOCKnode", 
[11:41:47.549]                             "SOCK0node"))) {
[11:41:47.549]                             sendCondition <<- function(cond) {
[11:41:47.549]                               data <- list(type = "VALUE", value = cond, 
[11:41:47.549]                                 success = TRUE)
[11:41:47.549]                               parallel_sendData(master, data)
[11:41:47.549]                             }
[11:41:47.549]                             return(sendCondition)
[11:41:47.549]                           }
[11:41:47.549]                         }
[11:41:47.549]                         frame <- frame + 1L
[11:41:47.549]                         envir <- sys.frame(frame)
[11:41:47.549]                       }
[11:41:47.549]                     }
[11:41:47.549]                     sendCondition <<- function(cond) NULL
[11:41:47.549]                   }
[11:41:47.549]                 })
[11:41:47.549]                 withCallingHandlers({
[11:41:47.549]                   {
[11:41:47.549]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:47.549]                     if (!identical(...future.globals.maxSize.org, 
[11:41:47.549]                       ...future.globals.maxSize)) {
[11:41:47.549]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:47.549]                       on.exit(options(oopts), add = TRUE)
[11:41:47.549]                     }
[11:41:47.549]                     {
[11:41:47.549]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:47.549]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:47.549]                           envir = globalenv(), inherits = FALSE)
[11:41:47.549]                         ...future.FUN(...)
[11:41:47.549]                       }
[11:41:47.549]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:47.549]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:47.549]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:47.549]                         USE.NAMES = FALSE)
[11:41:47.549]                       do.call(mapply, args = args)
[11:41:47.549]                     }
[11:41:47.549]                   }
[11:41:47.549]                 }, immediateCondition = function(cond) {
[11:41:47.549]                   sendCondition <- ...future.makeSendCondition()
[11:41:47.549]                   sendCondition(cond)
[11:41:47.549]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:47.549]                   {
[11:41:47.549]                     inherits <- base::inherits
[11:41:47.549]                     invokeRestart <- base::invokeRestart
[11:41:47.549]                     is.null <- base::is.null
[11:41:47.549]                     muffled <- FALSE
[11:41:47.549]                     if (inherits(cond, "message")) {
[11:41:47.549]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:47.549]                       if (muffled) 
[11:41:47.549]                         invokeRestart("muffleMessage")
[11:41:47.549]                     }
[11:41:47.549]                     else if (inherits(cond, "warning")) {
[11:41:47.549]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:47.549]                       if (muffled) 
[11:41:47.549]                         invokeRestart("muffleWarning")
[11:41:47.549]                     }
[11:41:47.549]                     else if (inherits(cond, "condition")) {
[11:41:47.549]                       if (!is.null(pattern)) {
[11:41:47.549]                         computeRestarts <- base::computeRestarts
[11:41:47.549]                         grepl <- base::grepl
[11:41:47.549]                         restarts <- computeRestarts(cond)
[11:41:47.549]                         for (restart in restarts) {
[11:41:47.549]                           name <- restart$name
[11:41:47.549]                           if (is.null(name)) 
[11:41:47.549]                             next
[11:41:47.549]                           if (!grepl(pattern, name)) 
[11:41:47.549]                             next
[11:41:47.549]                           invokeRestart(restart)
[11:41:47.549]                           muffled <- TRUE
[11:41:47.549]                           break
[11:41:47.549]                         }
[11:41:47.549]                       }
[11:41:47.549]                     }
[11:41:47.549]                     invisible(muffled)
[11:41:47.549]                   }
[11:41:47.549]                   muffleCondition(cond)
[11:41:47.549]                 })
[11:41:47.549]             }))
[11:41:47.549]             future::FutureResult(value = ...future.value$value, 
[11:41:47.549]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:47.549]                   ...future.rng), globalenv = if (FALSE) 
[11:41:47.549]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:47.549]                     ...future.globalenv.names))
[11:41:47.549]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:47.549]         }, condition = base::local({
[11:41:47.549]             c <- base::c
[11:41:47.549]             inherits <- base::inherits
[11:41:47.549]             invokeRestart <- base::invokeRestart
[11:41:47.549]             length <- base::length
[11:41:47.549]             list <- base::list
[11:41:47.549]             seq.int <- base::seq.int
[11:41:47.549]             signalCondition <- base::signalCondition
[11:41:47.549]             sys.calls <- base::sys.calls
[11:41:47.549]             `[[` <- base::`[[`
[11:41:47.549]             `+` <- base::`+`
[11:41:47.549]             `<<-` <- base::`<<-`
[11:41:47.549]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:47.549]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:47.549]                   3L)]
[11:41:47.549]             }
[11:41:47.549]             function(cond) {
[11:41:47.549]                 is_error <- inherits(cond, "error")
[11:41:47.549]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:47.549]                   NULL)
[11:41:47.549]                 if (is_error) {
[11:41:47.549]                   sessionInformation <- function() {
[11:41:47.549]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:47.549]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:47.549]                       search = base::search(), system = base::Sys.info())
[11:41:47.549]                   }
[11:41:47.549]                   ...future.conditions[[length(...future.conditions) + 
[11:41:47.549]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:47.549]                     cond$call), session = sessionInformation(), 
[11:41:47.549]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:47.549]                   signalCondition(cond)
[11:41:47.549]                 }
[11:41:47.549]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:47.549]                 "immediateCondition"))) {
[11:41:47.549]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:47.549]                   ...future.conditions[[length(...future.conditions) + 
[11:41:47.549]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:47.549]                   if (TRUE && !signal) {
[11:41:47.549]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:47.549]                     {
[11:41:47.549]                       inherits <- base::inherits
[11:41:47.549]                       invokeRestart <- base::invokeRestart
[11:41:47.549]                       is.null <- base::is.null
[11:41:47.549]                       muffled <- FALSE
[11:41:47.549]                       if (inherits(cond, "message")) {
[11:41:47.549]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:47.549]                         if (muffled) 
[11:41:47.549]                           invokeRestart("muffleMessage")
[11:41:47.549]                       }
[11:41:47.549]                       else if (inherits(cond, "warning")) {
[11:41:47.549]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:47.549]                         if (muffled) 
[11:41:47.549]                           invokeRestart("muffleWarning")
[11:41:47.549]                       }
[11:41:47.549]                       else if (inherits(cond, "condition")) {
[11:41:47.549]                         if (!is.null(pattern)) {
[11:41:47.549]                           computeRestarts <- base::computeRestarts
[11:41:47.549]                           grepl <- base::grepl
[11:41:47.549]                           restarts <- computeRestarts(cond)
[11:41:47.549]                           for (restart in restarts) {
[11:41:47.549]                             name <- restart$name
[11:41:47.549]                             if (is.null(name)) 
[11:41:47.549]                               next
[11:41:47.549]                             if (!grepl(pattern, name)) 
[11:41:47.549]                               next
[11:41:47.549]                             invokeRestart(restart)
[11:41:47.549]                             muffled <- TRUE
[11:41:47.549]                             break
[11:41:47.549]                           }
[11:41:47.549]                         }
[11:41:47.549]                       }
[11:41:47.549]                       invisible(muffled)
[11:41:47.549]                     }
[11:41:47.549]                     muffleCondition(cond, pattern = "^muffle")
[11:41:47.549]                   }
[11:41:47.549]                 }
[11:41:47.549]                 else {
[11:41:47.549]                   if (TRUE) {
[11:41:47.549]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:47.549]                     {
[11:41:47.549]                       inherits <- base::inherits
[11:41:47.549]                       invokeRestart <- base::invokeRestart
[11:41:47.549]                       is.null <- base::is.null
[11:41:47.549]                       muffled <- FALSE
[11:41:47.549]                       if (inherits(cond, "message")) {
[11:41:47.549]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:47.549]                         if (muffled) 
[11:41:47.549]                           invokeRestart("muffleMessage")
[11:41:47.549]                       }
[11:41:47.549]                       else if (inherits(cond, "warning")) {
[11:41:47.549]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:47.549]                         if (muffled) 
[11:41:47.549]                           invokeRestart("muffleWarning")
[11:41:47.549]                       }
[11:41:47.549]                       else if (inherits(cond, "condition")) {
[11:41:47.549]                         if (!is.null(pattern)) {
[11:41:47.549]                           computeRestarts <- base::computeRestarts
[11:41:47.549]                           grepl <- base::grepl
[11:41:47.549]                           restarts <- computeRestarts(cond)
[11:41:47.549]                           for (restart in restarts) {
[11:41:47.549]                             name <- restart$name
[11:41:47.549]                             if (is.null(name)) 
[11:41:47.549]                               next
[11:41:47.549]                             if (!grepl(pattern, name)) 
[11:41:47.549]                               next
[11:41:47.549]                             invokeRestart(restart)
[11:41:47.549]                             muffled <- TRUE
[11:41:47.549]                             break
[11:41:47.549]                           }
[11:41:47.549]                         }
[11:41:47.549]                       }
[11:41:47.549]                       invisible(muffled)
[11:41:47.549]                     }
[11:41:47.549]                     muffleCondition(cond, pattern = "^muffle")
[11:41:47.549]                   }
[11:41:47.549]                 }
[11:41:47.549]             }
[11:41:47.549]         }))
[11:41:47.549]     }, error = function(ex) {
[11:41:47.549]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:47.549]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:47.549]                 ...future.rng), started = ...future.startTime, 
[11:41:47.549]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:47.549]             version = "1.8"), class = "FutureResult")
[11:41:47.549]     }, finally = {
[11:41:47.549]         if (!identical(...future.workdir, getwd())) 
[11:41:47.549]             setwd(...future.workdir)
[11:41:47.549]         {
[11:41:47.549]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:47.549]                 ...future.oldOptions$nwarnings <- NULL
[11:41:47.549]             }
[11:41:47.549]             base::options(...future.oldOptions)
[11:41:47.549]             if (.Platform$OS.type == "windows") {
[11:41:47.549]                 old_names <- names(...future.oldEnvVars)
[11:41:47.549]                 envs <- base::Sys.getenv()
[11:41:47.549]                 names <- names(envs)
[11:41:47.549]                 common <- intersect(names, old_names)
[11:41:47.549]                 added <- setdiff(names, old_names)
[11:41:47.549]                 removed <- setdiff(old_names, names)
[11:41:47.549]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:47.549]                   envs[common]]
[11:41:47.549]                 NAMES <- toupper(changed)
[11:41:47.549]                 args <- list()
[11:41:47.549]                 for (kk in seq_along(NAMES)) {
[11:41:47.549]                   name <- changed[[kk]]
[11:41:47.549]                   NAME <- NAMES[[kk]]
[11:41:47.549]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:47.549]                     next
[11:41:47.549]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:47.549]                 }
[11:41:47.549]                 NAMES <- toupper(added)
[11:41:47.549]                 for (kk in seq_along(NAMES)) {
[11:41:47.549]                   name <- added[[kk]]
[11:41:47.549]                   NAME <- NAMES[[kk]]
[11:41:47.549]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:47.549]                     next
[11:41:47.549]                   args[[name]] <- ""
[11:41:47.549]                 }
[11:41:47.549]                 NAMES <- toupper(removed)
[11:41:47.549]                 for (kk in seq_along(NAMES)) {
[11:41:47.549]                   name <- removed[[kk]]
[11:41:47.549]                   NAME <- NAMES[[kk]]
[11:41:47.549]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:47.549]                     next
[11:41:47.549]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:47.549]                 }
[11:41:47.549]                 if (length(args) > 0) 
[11:41:47.549]                   base::do.call(base::Sys.setenv, args = args)
[11:41:47.549]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:47.549]             }
[11:41:47.549]             else {
[11:41:47.549]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:47.549]             }
[11:41:47.549]             {
[11:41:47.549]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:47.549]                   0L) {
[11:41:47.549]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:47.549]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:47.549]                   base::options(opts)
[11:41:47.549]                 }
[11:41:47.549]                 {
[11:41:47.549]                   {
[11:41:47.549]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:47.549]                     NULL
[11:41:47.549]                   }
[11:41:47.549]                   options(future.plan = NULL)
[11:41:47.549]                   if (is.na(NA_character_)) 
[11:41:47.549]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:47.549]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:47.549]                   future::plan(list(function (..., workers = 2, 
[11:41:47.549]                     envir = parent.frame()) 
[11:41:47.549]                   strategy(..., workers = workers, envir = envir)), 
[11:41:47.549]                     .cleanup = FALSE, .init = FALSE)
[11:41:47.549]                 }
[11:41:47.549]             }
[11:41:47.549]         }
[11:41:47.549]     })
[11:41:47.549]     if (TRUE) {
[11:41:47.549]         base::sink(type = "output", split = FALSE)
[11:41:47.549]         if (TRUE) {
[11:41:47.549]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:47.549]         }
[11:41:47.549]         else {
[11:41:47.549]             ...future.result["stdout"] <- base::list(NULL)
[11:41:47.549]         }
[11:41:47.549]         base::close(...future.stdout)
[11:41:47.549]         ...future.stdout <- NULL
[11:41:47.549]     }
[11:41:47.549]     ...future.result$conditions <- ...future.conditions
[11:41:47.549]     ...future.result$finished <- base::Sys.time()
[11:41:47.549]     ...future.result
[11:41:47.549] }
[11:41:47.550] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:47.562] receiveMessageFromWorker() for ClusterFuture ...
[11:41:47.562] - Validating connection of MultisessionFuture
[11:41:47.562] - received message: FutureResult
[11:41:47.563] - Received FutureResult
[11:41:47.563] - Erased future from FutureRegistry
[11:41:47.563] result() for ClusterFuture ...
[11:41:47.563] - result already collected: FutureResult
[11:41:47.563] result() for ClusterFuture ... done
[11:41:47.563] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:47.563] result() for ClusterFuture ...
[11:41:47.563] - result already collected: FutureResult
[11:41:47.563] result() for ClusterFuture ... done
[11:41:47.563] result() for ClusterFuture ...
[11:41:47.564] - result already collected: FutureResult
[11:41:47.564] result() for ClusterFuture ... done
[11:41:47.564] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:47.565] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:47.610] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:47.618] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:47.662] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:47.663] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:47.715] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:47.716] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:47.718] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:47.718] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:47.719] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:47.720] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:47.720] MultisessionFuture started
[11:41:47.720] - Launch lazy future ... done
[11:41:47.720] run() for ‘MultisessionFuture’ ... done
[11:41:47.721] Created future:
[11:41:47.721] MultisessionFuture:
[11:41:47.721] Label: ‘future_mapply-10’
[11:41:47.721] Expression:
[11:41:47.721] {
[11:41:47.721]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:47.721]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:47.721]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:47.721]         on.exit(options(oopts), add = TRUE)
[11:41:47.721]     }
[11:41:47.721]     {
[11:41:47.721]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:47.721]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:47.721]                 inherits = FALSE)
[11:41:47.721]             ...future.FUN(...)
[11:41:47.721]         }
[11:41:47.721]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:47.721]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:47.721]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:47.721]         do.call(mapply, args = args)
[11:41:47.721]     }
[11:41:47.721] }
[11:41:47.721] Lazy evaluation: FALSE
[11:41:47.721] Asynchronous evaluation: TRUE
[11:41:47.721] Local evaluation: TRUE
[11:41:47.721] Environment: 0x560ef58e1768
[11:41:47.721] Capture standard output: TRUE
[11:41:47.721] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:47.721] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:47.721] Packages: 1 packages (‘mlr3’)
[11:41:47.721] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:47.721] Resolved: FALSE
[11:41:47.721] Value: <not collected>
[11:41:47.721] Conditions captured: <none>
[11:41:47.721] Early signaling: FALSE
[11:41:47.721] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:47.721] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:47.736] Chunk #10 of 90 ... DONE
[11:41:47.736] Chunk #11 of 90 ...
[11:41:47.736]  - seeds: [1] <seeds>
[11:41:47.737] getGlobalsAndPackages() ...
[11:41:47.737] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:47.737] Resolving globals: FALSE
[11:41:47.737] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:47.738] - packages: [1] ‘mlr3’
[11:41:47.738] getGlobalsAndPackages() ... DONE
[11:41:47.738] run() for ‘Future’ ...
[11:41:47.738] - state: ‘created’
[11:41:47.738] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:47.749] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:47.749] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:47.749]   - Field: ‘node’
[11:41:47.749]   - Field: ‘label’
[11:41:47.749]   - Field: ‘local’
[11:41:47.749]   - Field: ‘owner’
[11:41:47.749]   - Field: ‘envir’
[11:41:47.749]   - Field: ‘workers’
[11:41:47.749]   - Field: ‘packages’
[11:41:47.749]   - Field: ‘gc’
[11:41:47.749]   - Field: ‘conditions’
[11:41:47.749]   - Field: ‘persistent’
[11:41:47.749]   - Field: ‘expr’
[11:41:47.749]   - Field: ‘uuid’
[11:41:47.749]   - Field: ‘seed’
[11:41:47.749]   - Field: ‘version’
[11:41:47.749]   - Field: ‘result’
[11:41:47.750]   - Field: ‘asynchronous’
[11:41:47.750]   - Field: ‘calls’
[11:41:47.750]   - Field: ‘globals’
[11:41:47.750]   - Field: ‘stdout’
[11:41:47.750]   - Field: ‘earlySignal’
[11:41:47.750]   - Field: ‘lazy’
[11:41:47.750]   - Field: ‘state’
[11:41:47.750] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:47.750] - Launch lazy future ...
[11:41:47.750] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:47.750] Packages needed by future strategies (n = 0): <none>
[11:41:47.750] {
[11:41:47.750]     {
[11:41:47.750]         {
[11:41:47.750]             ...future.startTime <- base::Sys.time()
[11:41:47.750]             {
[11:41:47.750]                 {
[11:41:47.750]                   {
[11:41:47.750]                     {
[11:41:47.750]                       {
[11:41:47.750]                         base::local({
[11:41:47.750]                           has_future <- base::requireNamespace("future", 
[11:41:47.750]                             quietly = TRUE)
[11:41:47.750]                           if (has_future) {
[11:41:47.750]                             ns <- base::getNamespace("future")
[11:41:47.750]                             version <- ns[[".package"]][["version"]]
[11:41:47.750]                             if (is.null(version)) 
[11:41:47.750]                               version <- utils::packageVersion("future")
[11:41:47.750]                           }
[11:41:47.750]                           else {
[11:41:47.750]                             version <- NULL
[11:41:47.750]                           }
[11:41:47.750]                           if (!has_future || version < "1.8.0") {
[11:41:47.750]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:47.750]                               "", base::R.version$version.string), 
[11:41:47.750]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:47.750]                                 base::R.version$platform, 8 * 
[11:41:47.750]                                   base::.Machine$sizeof.pointer), 
[11:41:47.750]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:47.750]                                 "release", "version")], collapse = " "), 
[11:41:47.750]                               hostname = base::Sys.info()[["nodename"]])
[11:41:47.750]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:47.750]                               info)
[11:41:47.750]                             info <- base::paste(info, collapse = "; ")
[11:41:47.750]                             if (!has_future) {
[11:41:47.750]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:47.750]                                 info)
[11:41:47.750]                             }
[11:41:47.750]                             else {
[11:41:47.750]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:47.750]                                 info, version)
[11:41:47.750]                             }
[11:41:47.750]                             base::stop(msg)
[11:41:47.750]                           }
[11:41:47.750]                         })
[11:41:47.750]                       }
[11:41:47.750]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:47.750]                       base::options(mc.cores = 1L)
[11:41:47.750]                     }
[11:41:47.750]                     base::local({
[11:41:47.750]                       for (pkg in "mlr3") {
[11:41:47.750]                         base::loadNamespace(pkg)
[11:41:47.750]                         base::library(pkg, character.only = TRUE)
[11:41:47.750]                       }
[11:41:47.750]                     })
[11:41:47.750]                   }
[11:41:47.750]                   options(future.plan = NULL)
[11:41:47.750]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:47.750]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:47.750]                 }
[11:41:47.750]                 ...future.workdir <- getwd()
[11:41:47.750]             }
[11:41:47.750]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:47.750]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:47.750]         }
[11:41:47.750]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:47.750]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:47.750]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:47.750]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:47.750]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:47.750]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:47.750]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:47.750]             base::names(...future.oldOptions))
[11:41:47.750]     }
[11:41:47.750]     if (FALSE) {
[11:41:47.750]     }
[11:41:47.750]     else {
[11:41:47.750]         if (TRUE) {
[11:41:47.750]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:47.750]                 open = "w")
[11:41:47.750]         }
[11:41:47.750]         else {
[11:41:47.750]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:47.750]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:47.750]         }
[11:41:47.750]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:47.750]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:47.750]             base::sink(type = "output", split = FALSE)
[11:41:47.750]             base::close(...future.stdout)
[11:41:47.750]         }, add = TRUE)
[11:41:47.750]     }
[11:41:47.750]     ...future.frame <- base::sys.nframe()
[11:41:47.750]     ...future.conditions <- base::list()
[11:41:47.750]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:47.750]     if (FALSE) {
[11:41:47.750]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:47.750]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:47.750]     }
[11:41:47.750]     ...future.result <- base::tryCatch({
[11:41:47.750]         base::withCallingHandlers({
[11:41:47.750]             ...future.value <- base::withVisible(base::local({
[11:41:47.750]                 ...future.makeSendCondition <- local({
[11:41:47.750]                   sendCondition <- NULL
[11:41:47.750]                   function(frame = 1L) {
[11:41:47.750]                     if (is.function(sendCondition)) 
[11:41:47.750]                       return(sendCondition)
[11:41:47.750]                     ns <- getNamespace("parallel")
[11:41:47.750]                     if (exists("sendData", mode = "function", 
[11:41:47.750]                       envir = ns)) {
[11:41:47.750]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:47.750]                         envir = ns)
[11:41:47.750]                       envir <- sys.frame(frame)
[11:41:47.750]                       master <- NULL
[11:41:47.750]                       while (!identical(envir, .GlobalEnv) && 
[11:41:47.750]                         !identical(envir, emptyenv())) {
[11:41:47.750]                         if (exists("master", mode = "list", envir = envir, 
[11:41:47.750]                           inherits = FALSE)) {
[11:41:47.750]                           master <- get("master", mode = "list", 
[11:41:47.750]                             envir = envir, inherits = FALSE)
[11:41:47.750]                           if (inherits(master, c("SOCKnode", 
[11:41:47.750]                             "SOCK0node"))) {
[11:41:47.750]                             sendCondition <<- function(cond) {
[11:41:47.750]                               data <- list(type = "VALUE", value = cond, 
[11:41:47.750]                                 success = TRUE)
[11:41:47.750]                               parallel_sendData(master, data)
[11:41:47.750]                             }
[11:41:47.750]                             return(sendCondition)
[11:41:47.750]                           }
[11:41:47.750]                         }
[11:41:47.750]                         frame <- frame + 1L
[11:41:47.750]                         envir <- sys.frame(frame)
[11:41:47.750]                       }
[11:41:47.750]                     }
[11:41:47.750]                     sendCondition <<- function(cond) NULL
[11:41:47.750]                   }
[11:41:47.750]                 })
[11:41:47.750]                 withCallingHandlers({
[11:41:47.750]                   {
[11:41:47.750]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:47.750]                     if (!identical(...future.globals.maxSize.org, 
[11:41:47.750]                       ...future.globals.maxSize)) {
[11:41:47.750]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:47.750]                       on.exit(options(oopts), add = TRUE)
[11:41:47.750]                     }
[11:41:47.750]                     {
[11:41:47.750]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:47.750]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:47.750]                           envir = globalenv(), inherits = FALSE)
[11:41:47.750]                         ...future.FUN(...)
[11:41:47.750]                       }
[11:41:47.750]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:47.750]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:47.750]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:47.750]                         USE.NAMES = FALSE)
[11:41:47.750]                       do.call(mapply, args = args)
[11:41:47.750]                     }
[11:41:47.750]                   }
[11:41:47.750]                 }, immediateCondition = function(cond) {
[11:41:47.750]                   sendCondition <- ...future.makeSendCondition()
[11:41:47.750]                   sendCondition(cond)
[11:41:47.750]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:47.750]                   {
[11:41:47.750]                     inherits <- base::inherits
[11:41:47.750]                     invokeRestart <- base::invokeRestart
[11:41:47.750]                     is.null <- base::is.null
[11:41:47.750]                     muffled <- FALSE
[11:41:47.750]                     if (inherits(cond, "message")) {
[11:41:47.750]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:47.750]                       if (muffled) 
[11:41:47.750]                         invokeRestart("muffleMessage")
[11:41:47.750]                     }
[11:41:47.750]                     else if (inherits(cond, "warning")) {
[11:41:47.750]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:47.750]                       if (muffled) 
[11:41:47.750]                         invokeRestart("muffleWarning")
[11:41:47.750]                     }
[11:41:47.750]                     else if (inherits(cond, "condition")) {
[11:41:47.750]                       if (!is.null(pattern)) {
[11:41:47.750]                         computeRestarts <- base::computeRestarts
[11:41:47.750]                         grepl <- base::grepl
[11:41:47.750]                         restarts <- computeRestarts(cond)
[11:41:47.750]                         for (restart in restarts) {
[11:41:47.750]                           name <- restart$name
[11:41:47.750]                           if (is.null(name)) 
[11:41:47.750]                             next
[11:41:47.750]                           if (!grepl(pattern, name)) 
[11:41:47.750]                             next
[11:41:47.750]                           invokeRestart(restart)
[11:41:47.750]                           muffled <- TRUE
[11:41:47.750]                           break
[11:41:47.750]                         }
[11:41:47.750]                       }
[11:41:47.750]                     }
[11:41:47.750]                     invisible(muffled)
[11:41:47.750]                   }
[11:41:47.750]                   muffleCondition(cond)
[11:41:47.750]                 })
[11:41:47.750]             }))
[11:41:47.750]             future::FutureResult(value = ...future.value$value, 
[11:41:47.750]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:47.750]                   ...future.rng), globalenv = if (FALSE) 
[11:41:47.750]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:47.750]                     ...future.globalenv.names))
[11:41:47.750]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:47.750]         }, condition = base::local({
[11:41:47.750]             c <- base::c
[11:41:47.750]             inherits <- base::inherits
[11:41:47.750]             invokeRestart <- base::invokeRestart
[11:41:47.750]             length <- base::length
[11:41:47.750]             list <- base::list
[11:41:47.750]             seq.int <- base::seq.int
[11:41:47.750]             signalCondition <- base::signalCondition
[11:41:47.750]             sys.calls <- base::sys.calls
[11:41:47.750]             `[[` <- base::`[[`
[11:41:47.750]             `+` <- base::`+`
[11:41:47.750]             `<<-` <- base::`<<-`
[11:41:47.750]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:47.750]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:47.750]                   3L)]
[11:41:47.750]             }
[11:41:47.750]             function(cond) {
[11:41:47.750]                 is_error <- inherits(cond, "error")
[11:41:47.750]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:47.750]                   NULL)
[11:41:47.750]                 if (is_error) {
[11:41:47.750]                   sessionInformation <- function() {
[11:41:47.750]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:47.750]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:47.750]                       search = base::search(), system = base::Sys.info())
[11:41:47.750]                   }
[11:41:47.750]                   ...future.conditions[[length(...future.conditions) + 
[11:41:47.750]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:47.750]                     cond$call), session = sessionInformation(), 
[11:41:47.750]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:47.750]                   signalCondition(cond)
[11:41:47.750]                 }
[11:41:47.750]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:47.750]                 "immediateCondition"))) {
[11:41:47.750]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:47.750]                   ...future.conditions[[length(...future.conditions) + 
[11:41:47.750]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:47.750]                   if (TRUE && !signal) {
[11:41:47.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:47.750]                     {
[11:41:47.750]                       inherits <- base::inherits
[11:41:47.750]                       invokeRestart <- base::invokeRestart
[11:41:47.750]                       is.null <- base::is.null
[11:41:47.750]                       muffled <- FALSE
[11:41:47.750]                       if (inherits(cond, "message")) {
[11:41:47.750]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:47.750]                         if (muffled) 
[11:41:47.750]                           invokeRestart("muffleMessage")
[11:41:47.750]                       }
[11:41:47.750]                       else if (inherits(cond, "warning")) {
[11:41:47.750]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:47.750]                         if (muffled) 
[11:41:47.750]                           invokeRestart("muffleWarning")
[11:41:47.750]                       }
[11:41:47.750]                       else if (inherits(cond, "condition")) {
[11:41:47.750]                         if (!is.null(pattern)) {
[11:41:47.750]                           computeRestarts <- base::computeRestarts
[11:41:47.750]                           grepl <- base::grepl
[11:41:47.750]                           restarts <- computeRestarts(cond)
[11:41:47.750]                           for (restart in restarts) {
[11:41:47.750]                             name <- restart$name
[11:41:47.750]                             if (is.null(name)) 
[11:41:47.750]                               next
[11:41:47.750]                             if (!grepl(pattern, name)) 
[11:41:47.750]                               next
[11:41:47.750]                             invokeRestart(restart)
[11:41:47.750]                             muffled <- TRUE
[11:41:47.750]                             break
[11:41:47.750]                           }
[11:41:47.750]                         }
[11:41:47.750]                       }
[11:41:47.750]                       invisible(muffled)
[11:41:47.750]                     }
[11:41:47.750]                     muffleCondition(cond, pattern = "^muffle")
[11:41:47.750]                   }
[11:41:47.750]                 }
[11:41:47.750]                 else {
[11:41:47.750]                   if (TRUE) {
[11:41:47.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:47.750]                     {
[11:41:47.750]                       inherits <- base::inherits
[11:41:47.750]                       invokeRestart <- base::invokeRestart
[11:41:47.750]                       is.null <- base::is.null
[11:41:47.750]                       muffled <- FALSE
[11:41:47.750]                       if (inherits(cond, "message")) {
[11:41:47.750]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:47.750]                         if (muffled) 
[11:41:47.750]                           invokeRestart("muffleMessage")
[11:41:47.750]                       }
[11:41:47.750]                       else if (inherits(cond, "warning")) {
[11:41:47.750]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:47.750]                         if (muffled) 
[11:41:47.750]                           invokeRestart("muffleWarning")
[11:41:47.750]                       }
[11:41:47.750]                       else if (inherits(cond, "condition")) {
[11:41:47.750]                         if (!is.null(pattern)) {
[11:41:47.750]                           computeRestarts <- base::computeRestarts
[11:41:47.750]                           grepl <- base::grepl
[11:41:47.750]                           restarts <- computeRestarts(cond)
[11:41:47.750]                           for (restart in restarts) {
[11:41:47.750]                             name <- restart$name
[11:41:47.750]                             if (is.null(name)) 
[11:41:47.750]                               next
[11:41:47.750]                             if (!grepl(pattern, name)) 
[11:41:47.750]                               next
[11:41:47.750]                             invokeRestart(restart)
[11:41:47.750]                             muffled <- TRUE
[11:41:47.750]                             break
[11:41:47.750]                           }
[11:41:47.750]                         }
[11:41:47.750]                       }
[11:41:47.750]                       invisible(muffled)
[11:41:47.750]                     }
[11:41:47.750]                     muffleCondition(cond, pattern = "^muffle")
[11:41:47.750]                   }
[11:41:47.750]                 }
[11:41:47.750]             }
[11:41:47.750]         }))
[11:41:47.750]     }, error = function(ex) {
[11:41:47.750]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:47.750]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:47.750]                 ...future.rng), started = ...future.startTime, 
[11:41:47.750]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:47.750]             version = "1.8"), class = "FutureResult")
[11:41:47.750]     }, finally = {
[11:41:47.750]         if (!identical(...future.workdir, getwd())) 
[11:41:47.750]             setwd(...future.workdir)
[11:41:47.750]         {
[11:41:47.750]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:47.750]                 ...future.oldOptions$nwarnings <- NULL
[11:41:47.750]             }
[11:41:47.750]             base::options(...future.oldOptions)
[11:41:47.750]             if (.Platform$OS.type == "windows") {
[11:41:47.750]                 old_names <- names(...future.oldEnvVars)
[11:41:47.750]                 envs <- base::Sys.getenv()
[11:41:47.750]                 names <- names(envs)
[11:41:47.750]                 common <- intersect(names, old_names)
[11:41:47.750]                 added <- setdiff(names, old_names)
[11:41:47.750]                 removed <- setdiff(old_names, names)
[11:41:47.750]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:47.750]                   envs[common]]
[11:41:47.750]                 NAMES <- toupper(changed)
[11:41:47.750]                 args <- list()
[11:41:47.750]                 for (kk in seq_along(NAMES)) {
[11:41:47.750]                   name <- changed[[kk]]
[11:41:47.750]                   NAME <- NAMES[[kk]]
[11:41:47.750]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:47.750]                     next
[11:41:47.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:47.750]                 }
[11:41:47.750]                 NAMES <- toupper(added)
[11:41:47.750]                 for (kk in seq_along(NAMES)) {
[11:41:47.750]                   name <- added[[kk]]
[11:41:47.750]                   NAME <- NAMES[[kk]]
[11:41:47.750]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:47.750]                     next
[11:41:47.750]                   args[[name]] <- ""
[11:41:47.750]                 }
[11:41:47.750]                 NAMES <- toupper(removed)
[11:41:47.750]                 for (kk in seq_along(NAMES)) {
[11:41:47.750]                   name <- removed[[kk]]
[11:41:47.750]                   NAME <- NAMES[[kk]]
[11:41:47.750]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:47.750]                     next
[11:41:47.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:47.750]                 }
[11:41:47.750]                 if (length(args) > 0) 
[11:41:47.750]                   base::do.call(base::Sys.setenv, args = args)
[11:41:47.750]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:47.750]             }
[11:41:47.750]             else {
[11:41:47.750]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:47.750]             }
[11:41:47.750]             {
[11:41:47.750]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:47.750]                   0L) {
[11:41:47.750]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:47.750]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:47.750]                   base::options(opts)
[11:41:47.750]                 }
[11:41:47.750]                 {
[11:41:47.750]                   {
[11:41:47.750]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:47.750]                     NULL
[11:41:47.750]                   }
[11:41:47.750]                   options(future.plan = NULL)
[11:41:47.750]                   if (is.na(NA_character_)) 
[11:41:47.750]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:47.750]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:47.750]                   future::plan(list(function (..., workers = 2, 
[11:41:47.750]                     envir = parent.frame()) 
[11:41:47.750]                   strategy(..., workers = workers, envir = envir)), 
[11:41:47.750]                     .cleanup = FALSE, .init = FALSE)
[11:41:47.750]                 }
[11:41:47.750]             }
[11:41:47.750]         }
[11:41:47.750]     })
[11:41:47.750]     if (TRUE) {
[11:41:47.750]         base::sink(type = "output", split = FALSE)
[11:41:47.750]         if (TRUE) {
[11:41:47.750]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:47.750]         }
[11:41:47.750]         else {
[11:41:47.750]             ...future.result["stdout"] <- base::list(NULL)
[11:41:47.750]         }
[11:41:47.750]         base::close(...future.stdout)
[11:41:47.750]         ...future.stdout <- NULL
[11:41:47.750]     }
[11:41:47.750]     ...future.result$conditions <- ...future.conditions
[11:41:47.750]     ...future.result$finished <- base::Sys.time()
[11:41:47.750]     ...future.result
[11:41:47.750] }
[11:41:47.752] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:47.762] receiveMessageFromWorker() for ClusterFuture ...
[11:41:47.763] - Validating connection of MultisessionFuture
[11:41:47.763] - received message: FutureResult
[11:41:47.763] - Received FutureResult
[11:41:47.763] - Erased future from FutureRegistry
[11:41:47.763] result() for ClusterFuture ...
[11:41:47.763] - result already collected: FutureResult
[11:41:47.763] result() for ClusterFuture ... done
[11:41:47.763] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:47.763] result() for ClusterFuture ...
[11:41:47.763] - result already collected: FutureResult
[11:41:47.763] result() for ClusterFuture ... done
[11:41:47.763] result() for ClusterFuture ...
[11:41:47.763] - result already collected: FutureResult
[11:41:47.763] result() for ClusterFuture ... done
[11:41:47.766] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:47.772] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:47.814] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:47.825] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:47.827] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:47.827] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:47.871] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:47.872] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:47.874] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:47.874] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:47.876] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:47.876] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:47.878] MultisessionFuture started
[11:41:47.878] - Launch lazy future ... done
[11:41:47.879] run() for ‘MultisessionFuture’ ... done
[11:41:47.879] Created future:
[11:41:47.879] MultisessionFuture:
[11:41:47.879] Label: ‘future_mapply-11’
[11:41:47.879] Expression:
[11:41:47.879] {
[11:41:47.879]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:47.879]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:47.879]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:47.879]         on.exit(options(oopts), add = TRUE)
[11:41:47.879]     }
[11:41:47.879]     {
[11:41:47.879]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:47.879]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:47.879]                 inherits = FALSE)
[11:41:47.879]             ...future.FUN(...)
[11:41:47.879]         }
[11:41:47.879]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:47.879]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:47.879]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:47.879]         do.call(mapply, args = args)
[11:41:47.879]     }
[11:41:47.879] }
[11:41:47.879] Lazy evaluation: FALSE
[11:41:47.879] Asynchronous evaluation: TRUE
[11:41:47.879] Local evaluation: TRUE
[11:41:47.879] Environment: 0x560ef58e1768
[11:41:47.879] Capture standard output: TRUE
[11:41:47.879] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:47.879] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:47.879] Packages: 1 packages (‘mlr3’)
[11:41:47.879] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:47.879] Resolved: FALSE
[11:41:47.879] Value: <not collected>
[11:41:47.879] Conditions captured: <none>
[11:41:47.879] Early signaling: FALSE
[11:41:47.879] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:47.879] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:47.898] Chunk #11 of 90 ... DONE
[11:41:47.898] Chunk #12 of 90 ...
[11:41:47.899]  - seeds: [1] <seeds>
[11:41:47.899] getGlobalsAndPackages() ...
[11:41:47.899] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:47.899] Resolving globals: FALSE
[11:41:47.900] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:47.901] - packages: [1] ‘mlr3’
[11:41:47.901] getGlobalsAndPackages() ... DONE
[11:41:47.902] run() for ‘Future’ ...
[11:41:47.902] - state: ‘created’
[11:41:47.902] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:47.914] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:47.914] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:47.914]   - Field: ‘node’
[11:41:47.914]   - Field: ‘label’
[11:41:47.914]   - Field: ‘local’
[11:41:47.914]   - Field: ‘owner’
[11:41:47.914]   - Field: ‘envir’
[11:41:47.914]   - Field: ‘workers’
[11:41:47.915]   - Field: ‘packages’
[11:41:47.915]   - Field: ‘gc’
[11:41:47.915]   - Field: ‘conditions’
[11:41:47.915]   - Field: ‘persistent’
[11:41:47.915]   - Field: ‘expr’
[11:41:47.915]   - Field: ‘uuid’
[11:41:47.915]   - Field: ‘seed’
[11:41:47.915]   - Field: ‘version’
[11:41:47.915]   - Field: ‘result’
[11:41:47.915]   - Field: ‘asynchronous’
[11:41:47.915]   - Field: ‘calls’
[11:41:47.915]   - Field: ‘globals’
[11:41:47.915]   - Field: ‘stdout’
[11:41:47.915]   - Field: ‘earlySignal’
[11:41:47.915]   - Field: ‘lazy’
[11:41:47.915]   - Field: ‘state’
[11:41:47.915] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:47.915] - Launch lazy future ...
[11:41:47.915] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:47.915] Packages needed by future strategies (n = 0): <none>
[11:41:47.916] {
[11:41:47.916]     {
[11:41:47.916]         {
[11:41:47.916]             ...future.startTime <- base::Sys.time()
[11:41:47.916]             {
[11:41:47.916]                 {
[11:41:47.916]                   {
[11:41:47.916]                     {
[11:41:47.916]                       {
[11:41:47.916]                         base::local({
[11:41:47.916]                           has_future <- base::requireNamespace("future", 
[11:41:47.916]                             quietly = TRUE)
[11:41:47.916]                           if (has_future) {
[11:41:47.916]                             ns <- base::getNamespace("future")
[11:41:47.916]                             version <- ns[[".package"]][["version"]]
[11:41:47.916]                             if (is.null(version)) 
[11:41:47.916]                               version <- utils::packageVersion("future")
[11:41:47.916]                           }
[11:41:47.916]                           else {
[11:41:47.916]                             version <- NULL
[11:41:47.916]                           }
[11:41:47.916]                           if (!has_future || version < "1.8.0") {
[11:41:47.916]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:47.916]                               "", base::R.version$version.string), 
[11:41:47.916]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:47.916]                                 base::R.version$platform, 8 * 
[11:41:47.916]                                   base::.Machine$sizeof.pointer), 
[11:41:47.916]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:47.916]                                 "release", "version")], collapse = " "), 
[11:41:47.916]                               hostname = base::Sys.info()[["nodename"]])
[11:41:47.916]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:47.916]                               info)
[11:41:47.916]                             info <- base::paste(info, collapse = "; ")
[11:41:47.916]                             if (!has_future) {
[11:41:47.916]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:47.916]                                 info)
[11:41:47.916]                             }
[11:41:47.916]                             else {
[11:41:47.916]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:47.916]                                 info, version)
[11:41:47.916]                             }
[11:41:47.916]                             base::stop(msg)
[11:41:47.916]                           }
[11:41:47.916]                         })
[11:41:47.916]                       }
[11:41:47.916]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:47.916]                       base::options(mc.cores = 1L)
[11:41:47.916]                     }
[11:41:47.916]                     base::local({
[11:41:47.916]                       for (pkg in "mlr3") {
[11:41:47.916]                         base::loadNamespace(pkg)
[11:41:47.916]                         base::library(pkg, character.only = TRUE)
[11:41:47.916]                       }
[11:41:47.916]                     })
[11:41:47.916]                   }
[11:41:47.916]                   options(future.plan = NULL)
[11:41:47.916]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:47.916]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:47.916]                 }
[11:41:47.916]                 ...future.workdir <- getwd()
[11:41:47.916]             }
[11:41:47.916]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:47.916]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:47.916]         }
[11:41:47.916]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:47.916]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:47.916]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:47.916]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:47.916]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:47.916]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:47.916]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:47.916]             base::names(...future.oldOptions))
[11:41:47.916]     }
[11:41:47.916]     if (FALSE) {
[11:41:47.916]     }
[11:41:47.916]     else {
[11:41:47.916]         if (TRUE) {
[11:41:47.916]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:47.916]                 open = "w")
[11:41:47.916]         }
[11:41:47.916]         else {
[11:41:47.916]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:47.916]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:47.916]         }
[11:41:47.916]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:47.916]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:47.916]             base::sink(type = "output", split = FALSE)
[11:41:47.916]             base::close(...future.stdout)
[11:41:47.916]         }, add = TRUE)
[11:41:47.916]     }
[11:41:47.916]     ...future.frame <- base::sys.nframe()
[11:41:47.916]     ...future.conditions <- base::list()
[11:41:47.916]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:47.916]     if (FALSE) {
[11:41:47.916]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:47.916]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:47.916]     }
[11:41:47.916]     ...future.result <- base::tryCatch({
[11:41:47.916]         base::withCallingHandlers({
[11:41:47.916]             ...future.value <- base::withVisible(base::local({
[11:41:47.916]                 ...future.makeSendCondition <- local({
[11:41:47.916]                   sendCondition <- NULL
[11:41:47.916]                   function(frame = 1L) {
[11:41:47.916]                     if (is.function(sendCondition)) 
[11:41:47.916]                       return(sendCondition)
[11:41:47.916]                     ns <- getNamespace("parallel")
[11:41:47.916]                     if (exists("sendData", mode = "function", 
[11:41:47.916]                       envir = ns)) {
[11:41:47.916]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:47.916]                         envir = ns)
[11:41:47.916]                       envir <- sys.frame(frame)
[11:41:47.916]                       master <- NULL
[11:41:47.916]                       while (!identical(envir, .GlobalEnv) && 
[11:41:47.916]                         !identical(envir, emptyenv())) {
[11:41:47.916]                         if (exists("master", mode = "list", envir = envir, 
[11:41:47.916]                           inherits = FALSE)) {
[11:41:47.916]                           master <- get("master", mode = "list", 
[11:41:47.916]                             envir = envir, inherits = FALSE)
[11:41:47.916]                           if (inherits(master, c("SOCKnode", 
[11:41:47.916]                             "SOCK0node"))) {
[11:41:47.916]                             sendCondition <<- function(cond) {
[11:41:47.916]                               data <- list(type = "VALUE", value = cond, 
[11:41:47.916]                                 success = TRUE)
[11:41:47.916]                               parallel_sendData(master, data)
[11:41:47.916]                             }
[11:41:47.916]                             return(sendCondition)
[11:41:47.916]                           }
[11:41:47.916]                         }
[11:41:47.916]                         frame <- frame + 1L
[11:41:47.916]                         envir <- sys.frame(frame)
[11:41:47.916]                       }
[11:41:47.916]                     }
[11:41:47.916]                     sendCondition <<- function(cond) NULL
[11:41:47.916]                   }
[11:41:47.916]                 })
[11:41:47.916]                 withCallingHandlers({
[11:41:47.916]                   {
[11:41:47.916]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:47.916]                     if (!identical(...future.globals.maxSize.org, 
[11:41:47.916]                       ...future.globals.maxSize)) {
[11:41:47.916]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:47.916]                       on.exit(options(oopts), add = TRUE)
[11:41:47.916]                     }
[11:41:47.916]                     {
[11:41:47.916]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:47.916]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:47.916]                           envir = globalenv(), inherits = FALSE)
[11:41:47.916]                         ...future.FUN(...)
[11:41:47.916]                       }
[11:41:47.916]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:47.916]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:47.916]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:47.916]                         USE.NAMES = FALSE)
[11:41:47.916]                       do.call(mapply, args = args)
[11:41:47.916]                     }
[11:41:47.916]                   }
[11:41:47.916]                 }, immediateCondition = function(cond) {
[11:41:47.916]                   sendCondition <- ...future.makeSendCondition()
[11:41:47.916]                   sendCondition(cond)
[11:41:47.916]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:47.916]                   {
[11:41:47.916]                     inherits <- base::inherits
[11:41:47.916]                     invokeRestart <- base::invokeRestart
[11:41:47.916]                     is.null <- base::is.null
[11:41:47.916]                     muffled <- FALSE
[11:41:47.916]                     if (inherits(cond, "message")) {
[11:41:47.916]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:47.916]                       if (muffled) 
[11:41:47.916]                         invokeRestart("muffleMessage")
[11:41:47.916]                     }
[11:41:47.916]                     else if (inherits(cond, "warning")) {
[11:41:47.916]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:47.916]                       if (muffled) 
[11:41:47.916]                         invokeRestart("muffleWarning")
[11:41:47.916]                     }
[11:41:47.916]                     else if (inherits(cond, "condition")) {
[11:41:47.916]                       if (!is.null(pattern)) {
[11:41:47.916]                         computeRestarts <- base::computeRestarts
[11:41:47.916]                         grepl <- base::grepl
[11:41:47.916]                         restarts <- computeRestarts(cond)
[11:41:47.916]                         for (restart in restarts) {
[11:41:47.916]                           name <- restart$name
[11:41:47.916]                           if (is.null(name)) 
[11:41:47.916]                             next
[11:41:47.916]                           if (!grepl(pattern, name)) 
[11:41:47.916]                             next
[11:41:47.916]                           invokeRestart(restart)
[11:41:47.916]                           muffled <- TRUE
[11:41:47.916]                           break
[11:41:47.916]                         }
[11:41:47.916]                       }
[11:41:47.916]                     }
[11:41:47.916]                     invisible(muffled)
[11:41:47.916]                   }
[11:41:47.916]                   muffleCondition(cond)
[11:41:47.916]                 })
[11:41:47.916]             }))
[11:41:47.916]             future::FutureResult(value = ...future.value$value, 
[11:41:47.916]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:47.916]                   ...future.rng), globalenv = if (FALSE) 
[11:41:47.916]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:47.916]                     ...future.globalenv.names))
[11:41:47.916]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:47.916]         }, condition = base::local({
[11:41:47.916]             c <- base::c
[11:41:47.916]             inherits <- base::inherits
[11:41:47.916]             invokeRestart <- base::invokeRestart
[11:41:47.916]             length <- base::length
[11:41:47.916]             list <- base::list
[11:41:47.916]             seq.int <- base::seq.int
[11:41:47.916]             signalCondition <- base::signalCondition
[11:41:47.916]             sys.calls <- base::sys.calls
[11:41:47.916]             `[[` <- base::`[[`
[11:41:47.916]             `+` <- base::`+`
[11:41:47.916]             `<<-` <- base::`<<-`
[11:41:47.916]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:47.916]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:47.916]                   3L)]
[11:41:47.916]             }
[11:41:47.916]             function(cond) {
[11:41:47.916]                 is_error <- inherits(cond, "error")
[11:41:47.916]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:47.916]                   NULL)
[11:41:47.916]                 if (is_error) {
[11:41:47.916]                   sessionInformation <- function() {
[11:41:47.916]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:47.916]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:47.916]                       search = base::search(), system = base::Sys.info())
[11:41:47.916]                   }
[11:41:47.916]                   ...future.conditions[[length(...future.conditions) + 
[11:41:47.916]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:47.916]                     cond$call), session = sessionInformation(), 
[11:41:47.916]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:47.916]                   signalCondition(cond)
[11:41:47.916]                 }
[11:41:47.916]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:47.916]                 "immediateCondition"))) {
[11:41:47.916]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:47.916]                   ...future.conditions[[length(...future.conditions) + 
[11:41:47.916]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:47.916]                   if (TRUE && !signal) {
[11:41:47.916]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:47.916]                     {
[11:41:47.916]                       inherits <- base::inherits
[11:41:47.916]                       invokeRestart <- base::invokeRestart
[11:41:47.916]                       is.null <- base::is.null
[11:41:47.916]                       muffled <- FALSE
[11:41:47.916]                       if (inherits(cond, "message")) {
[11:41:47.916]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:47.916]                         if (muffled) 
[11:41:47.916]                           invokeRestart("muffleMessage")
[11:41:47.916]                       }
[11:41:47.916]                       else if (inherits(cond, "warning")) {
[11:41:47.916]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:47.916]                         if (muffled) 
[11:41:47.916]                           invokeRestart("muffleWarning")
[11:41:47.916]                       }
[11:41:47.916]                       else if (inherits(cond, "condition")) {
[11:41:47.916]                         if (!is.null(pattern)) {
[11:41:47.916]                           computeRestarts <- base::computeRestarts
[11:41:47.916]                           grepl <- base::grepl
[11:41:47.916]                           restarts <- computeRestarts(cond)
[11:41:47.916]                           for (restart in restarts) {
[11:41:47.916]                             name <- restart$name
[11:41:47.916]                             if (is.null(name)) 
[11:41:47.916]                               next
[11:41:47.916]                             if (!grepl(pattern, name)) 
[11:41:47.916]                               next
[11:41:47.916]                             invokeRestart(restart)
[11:41:47.916]                             muffled <- TRUE
[11:41:47.916]                             break
[11:41:47.916]                           }
[11:41:47.916]                         }
[11:41:47.916]                       }
[11:41:47.916]                       invisible(muffled)
[11:41:47.916]                     }
[11:41:47.916]                     muffleCondition(cond, pattern = "^muffle")
[11:41:47.916]                   }
[11:41:47.916]                 }
[11:41:47.916]                 else {
[11:41:47.916]                   if (TRUE) {
[11:41:47.916]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:47.916]                     {
[11:41:47.916]                       inherits <- base::inherits
[11:41:47.916]                       invokeRestart <- base::invokeRestart
[11:41:47.916]                       is.null <- base::is.null
[11:41:47.916]                       muffled <- FALSE
[11:41:47.916]                       if (inherits(cond, "message")) {
[11:41:47.916]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:47.916]                         if (muffled) 
[11:41:47.916]                           invokeRestart("muffleMessage")
[11:41:47.916]                       }
[11:41:47.916]                       else if (inherits(cond, "warning")) {
[11:41:47.916]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:47.916]                         if (muffled) 
[11:41:47.916]                           invokeRestart("muffleWarning")
[11:41:47.916]                       }
[11:41:47.916]                       else if (inherits(cond, "condition")) {
[11:41:47.916]                         if (!is.null(pattern)) {
[11:41:47.916]                           computeRestarts <- base::computeRestarts
[11:41:47.916]                           grepl <- base::grepl
[11:41:47.916]                           restarts <- computeRestarts(cond)
[11:41:47.916]                           for (restart in restarts) {
[11:41:47.916]                             name <- restart$name
[11:41:47.916]                             if (is.null(name)) 
[11:41:47.916]                               next
[11:41:47.916]                             if (!grepl(pattern, name)) 
[11:41:47.916]                               next
[11:41:47.916]                             invokeRestart(restart)
[11:41:47.916]                             muffled <- TRUE
[11:41:47.916]                             break
[11:41:47.916]                           }
[11:41:47.916]                         }
[11:41:47.916]                       }
[11:41:47.916]                       invisible(muffled)
[11:41:47.916]                     }
[11:41:47.916]                     muffleCondition(cond, pattern = "^muffle")
[11:41:47.916]                   }
[11:41:47.916]                 }
[11:41:47.916]             }
[11:41:47.916]         }))
[11:41:47.916]     }, error = function(ex) {
[11:41:47.916]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:47.916]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:47.916]                 ...future.rng), started = ...future.startTime, 
[11:41:47.916]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:47.916]             version = "1.8"), class = "FutureResult")
[11:41:47.916]     }, finally = {
[11:41:47.916]         if (!identical(...future.workdir, getwd())) 
[11:41:47.916]             setwd(...future.workdir)
[11:41:47.916]         {
[11:41:47.916]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:47.916]                 ...future.oldOptions$nwarnings <- NULL
[11:41:47.916]             }
[11:41:47.916]             base::options(...future.oldOptions)
[11:41:47.916]             if (.Platform$OS.type == "windows") {
[11:41:47.916]                 old_names <- names(...future.oldEnvVars)
[11:41:47.916]                 envs <- base::Sys.getenv()
[11:41:47.916]                 names <- names(envs)
[11:41:47.916]                 common <- intersect(names, old_names)
[11:41:47.916]                 added <- setdiff(names, old_names)
[11:41:47.916]                 removed <- setdiff(old_names, names)
[11:41:47.916]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:47.916]                   envs[common]]
[11:41:47.916]                 NAMES <- toupper(changed)
[11:41:47.916]                 args <- list()
[11:41:47.916]                 for (kk in seq_along(NAMES)) {
[11:41:47.916]                   name <- changed[[kk]]
[11:41:47.916]                   NAME <- NAMES[[kk]]
[11:41:47.916]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:47.916]                     next
[11:41:47.916]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:47.916]                 }
[11:41:47.916]                 NAMES <- toupper(added)
[11:41:47.916]                 for (kk in seq_along(NAMES)) {
[11:41:47.916]                   name <- added[[kk]]
[11:41:47.916]                   NAME <- NAMES[[kk]]
[11:41:47.916]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:47.916]                     next
[11:41:47.916]                   args[[name]] <- ""
[11:41:47.916]                 }
[11:41:47.916]                 NAMES <- toupper(removed)
[11:41:47.916]                 for (kk in seq_along(NAMES)) {
[11:41:47.916]                   name <- removed[[kk]]
[11:41:47.916]                   NAME <- NAMES[[kk]]
[11:41:47.916]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:47.916]                     next
[11:41:47.916]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:47.916]                 }
[11:41:47.916]                 if (length(args) > 0) 
[11:41:47.916]                   base::do.call(base::Sys.setenv, args = args)
[11:41:47.916]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:47.916]             }
[11:41:47.916]             else {
[11:41:47.916]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:47.916]             }
[11:41:47.916]             {
[11:41:47.916]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:47.916]                   0L) {
[11:41:47.916]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:47.916]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:47.916]                   base::options(opts)
[11:41:47.916]                 }
[11:41:47.916]                 {
[11:41:47.916]                   {
[11:41:47.916]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:47.916]                     NULL
[11:41:47.916]                   }
[11:41:47.916]                   options(future.plan = NULL)
[11:41:47.916]                   if (is.na(NA_character_)) 
[11:41:47.916]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:47.916]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:47.916]                   future::plan(list(function (..., workers = 2, 
[11:41:47.916]                     envir = parent.frame()) 
[11:41:47.916]                   strategy(..., workers = workers, envir = envir)), 
[11:41:47.916]                     .cleanup = FALSE, .init = FALSE)
[11:41:47.916]                 }
[11:41:47.916]             }
[11:41:47.916]         }
[11:41:47.916]     })
[11:41:47.916]     if (TRUE) {
[11:41:47.916]         base::sink(type = "output", split = FALSE)
[11:41:47.916]         if (TRUE) {
[11:41:47.916]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:47.916]         }
[11:41:47.916]         else {
[11:41:47.916]             ...future.result["stdout"] <- base::list(NULL)
[11:41:47.916]         }
[11:41:47.916]         base::close(...future.stdout)
[11:41:47.916]         ...future.stdout <- NULL
[11:41:47.916]     }
[11:41:47.916]     ...future.result$conditions <- ...future.conditions
[11:41:47.916]     ...future.result$finished <- base::Sys.time()
[11:41:47.916]     ...future.result
[11:41:47.916] }
[11:41:47.917] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:47.928] receiveMessageFromWorker() for ClusterFuture ...
[11:41:47.928] - Validating connection of MultisessionFuture
[11:41:47.928] - received message: FutureResult
[11:41:47.929] - Received FutureResult
[11:41:47.929] - Erased future from FutureRegistry
[11:41:47.929] result() for ClusterFuture ...
[11:41:47.929] - result already collected: FutureResult
[11:41:47.929] result() for ClusterFuture ... done
[11:41:47.929] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:47.929] result() for ClusterFuture ...
[11:41:47.929] - result already collected: FutureResult
[11:41:47.930] result() for ClusterFuture ... done
[11:41:47.930] result() for ClusterFuture ...
[11:41:47.930] - result already collected: FutureResult
[11:41:47.930] result() for ClusterFuture ... done
[11:41:47.931] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:47.931] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:47.974] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:47.984] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:48.030] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:48.031] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:48.078] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:48.079] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:48.081] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:48.081] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:48.083] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:48.083] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:48.084] MultisessionFuture started
[11:41:48.085] - Launch lazy future ... done
[11:41:48.085] run() for ‘MultisessionFuture’ ... done
[11:41:48.085] Created future:
[11:41:48.086] MultisessionFuture:
[11:41:48.086] Label: ‘future_mapply-12’
[11:41:48.086] Expression:
[11:41:48.086] {
[11:41:48.086]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:48.086]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:48.086]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:48.086]         on.exit(options(oopts), add = TRUE)
[11:41:48.086]     }
[11:41:48.086]     {
[11:41:48.086]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:48.086]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:48.086]                 inherits = FALSE)
[11:41:48.086]             ...future.FUN(...)
[11:41:48.086]         }
[11:41:48.086]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:48.086]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:48.086]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:48.086]         do.call(mapply, args = args)
[11:41:48.086]     }
[11:41:48.086] }
[11:41:48.086] Lazy evaluation: FALSE
[11:41:48.086] Asynchronous evaluation: TRUE
[11:41:48.086] Local evaluation: TRUE
[11:41:48.086] Environment: 0x560ef58e1768
[11:41:48.086] Capture standard output: TRUE
[11:41:48.086] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:48.086] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:48.086] Packages: 1 packages (‘mlr3’)
[11:41:48.086] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:48.086] Resolved: FALSE
[11:41:48.086] Value: <not collected>
[11:41:48.086] Conditions captured: <none>
[11:41:48.086] Early signaling: FALSE
[11:41:48.086] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:48.086] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:48.105] Chunk #12 of 90 ... DONE
[11:41:48.105] Chunk #13 of 90 ...
[11:41:48.105]  - seeds: [1] <seeds>
[11:41:48.105] getGlobalsAndPackages() ...
[11:41:48.106] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:48.106] Resolving globals: FALSE
[11:41:48.106] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:48.107] - packages: [1] ‘mlr3’
[11:41:48.107] getGlobalsAndPackages() ... DONE
[11:41:48.107] run() for ‘Future’ ...
[11:41:48.107] - state: ‘created’
[11:41:48.108] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:48.119] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:48.119] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:48.119]   - Field: ‘node’
[11:41:48.119]   - Field: ‘label’
[11:41:48.119]   - Field: ‘local’
[11:41:48.119]   - Field: ‘owner’
[11:41:48.119]   - Field: ‘envir’
[11:41:48.119]   - Field: ‘workers’
[11:41:48.119]   - Field: ‘packages’
[11:41:48.119]   - Field: ‘gc’
[11:41:48.119]   - Field: ‘conditions’
[11:41:48.119]   - Field: ‘persistent’
[11:41:48.120]   - Field: ‘expr’
[11:41:48.120]   - Field: ‘uuid’
[11:41:48.120]   - Field: ‘seed’
[11:41:48.120]   - Field: ‘version’
[11:41:48.120]   - Field: ‘result’
[11:41:48.120]   - Field: ‘asynchronous’
[11:41:48.120]   - Field: ‘calls’
[11:41:48.120]   - Field: ‘globals’
[11:41:48.120]   - Field: ‘stdout’
[11:41:48.120]   - Field: ‘earlySignal’
[11:41:48.120]   - Field: ‘lazy’
[11:41:48.120]   - Field: ‘state’
[11:41:48.120] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:48.120] - Launch lazy future ...
[11:41:48.120] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:48.120] Packages needed by future strategies (n = 0): <none>
[11:41:48.121] {
[11:41:48.121]     {
[11:41:48.121]         {
[11:41:48.121]             ...future.startTime <- base::Sys.time()
[11:41:48.121]             {
[11:41:48.121]                 {
[11:41:48.121]                   {
[11:41:48.121]                     {
[11:41:48.121]                       {
[11:41:48.121]                         base::local({
[11:41:48.121]                           has_future <- base::requireNamespace("future", 
[11:41:48.121]                             quietly = TRUE)
[11:41:48.121]                           if (has_future) {
[11:41:48.121]                             ns <- base::getNamespace("future")
[11:41:48.121]                             version <- ns[[".package"]][["version"]]
[11:41:48.121]                             if (is.null(version)) 
[11:41:48.121]                               version <- utils::packageVersion("future")
[11:41:48.121]                           }
[11:41:48.121]                           else {
[11:41:48.121]                             version <- NULL
[11:41:48.121]                           }
[11:41:48.121]                           if (!has_future || version < "1.8.0") {
[11:41:48.121]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:48.121]                               "", base::R.version$version.string), 
[11:41:48.121]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:48.121]                                 base::R.version$platform, 8 * 
[11:41:48.121]                                   base::.Machine$sizeof.pointer), 
[11:41:48.121]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:48.121]                                 "release", "version")], collapse = " "), 
[11:41:48.121]                               hostname = base::Sys.info()[["nodename"]])
[11:41:48.121]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:48.121]                               info)
[11:41:48.121]                             info <- base::paste(info, collapse = "; ")
[11:41:48.121]                             if (!has_future) {
[11:41:48.121]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:48.121]                                 info)
[11:41:48.121]                             }
[11:41:48.121]                             else {
[11:41:48.121]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:48.121]                                 info, version)
[11:41:48.121]                             }
[11:41:48.121]                             base::stop(msg)
[11:41:48.121]                           }
[11:41:48.121]                         })
[11:41:48.121]                       }
[11:41:48.121]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:48.121]                       base::options(mc.cores = 1L)
[11:41:48.121]                     }
[11:41:48.121]                     base::local({
[11:41:48.121]                       for (pkg in "mlr3") {
[11:41:48.121]                         base::loadNamespace(pkg)
[11:41:48.121]                         base::library(pkg, character.only = TRUE)
[11:41:48.121]                       }
[11:41:48.121]                     })
[11:41:48.121]                   }
[11:41:48.121]                   options(future.plan = NULL)
[11:41:48.121]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:48.121]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:48.121]                 }
[11:41:48.121]                 ...future.workdir <- getwd()
[11:41:48.121]             }
[11:41:48.121]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:48.121]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:48.121]         }
[11:41:48.121]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:48.121]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:48.121]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:48.121]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:48.121]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:48.121]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:48.121]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:48.121]             base::names(...future.oldOptions))
[11:41:48.121]     }
[11:41:48.121]     if (FALSE) {
[11:41:48.121]     }
[11:41:48.121]     else {
[11:41:48.121]         if (TRUE) {
[11:41:48.121]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:48.121]                 open = "w")
[11:41:48.121]         }
[11:41:48.121]         else {
[11:41:48.121]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:48.121]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:48.121]         }
[11:41:48.121]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:48.121]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:48.121]             base::sink(type = "output", split = FALSE)
[11:41:48.121]             base::close(...future.stdout)
[11:41:48.121]         }, add = TRUE)
[11:41:48.121]     }
[11:41:48.121]     ...future.frame <- base::sys.nframe()
[11:41:48.121]     ...future.conditions <- base::list()
[11:41:48.121]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:48.121]     if (FALSE) {
[11:41:48.121]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:48.121]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:48.121]     }
[11:41:48.121]     ...future.result <- base::tryCatch({
[11:41:48.121]         base::withCallingHandlers({
[11:41:48.121]             ...future.value <- base::withVisible(base::local({
[11:41:48.121]                 ...future.makeSendCondition <- local({
[11:41:48.121]                   sendCondition <- NULL
[11:41:48.121]                   function(frame = 1L) {
[11:41:48.121]                     if (is.function(sendCondition)) 
[11:41:48.121]                       return(sendCondition)
[11:41:48.121]                     ns <- getNamespace("parallel")
[11:41:48.121]                     if (exists("sendData", mode = "function", 
[11:41:48.121]                       envir = ns)) {
[11:41:48.121]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:48.121]                         envir = ns)
[11:41:48.121]                       envir <- sys.frame(frame)
[11:41:48.121]                       master <- NULL
[11:41:48.121]                       while (!identical(envir, .GlobalEnv) && 
[11:41:48.121]                         !identical(envir, emptyenv())) {
[11:41:48.121]                         if (exists("master", mode = "list", envir = envir, 
[11:41:48.121]                           inherits = FALSE)) {
[11:41:48.121]                           master <- get("master", mode = "list", 
[11:41:48.121]                             envir = envir, inherits = FALSE)
[11:41:48.121]                           if (inherits(master, c("SOCKnode", 
[11:41:48.121]                             "SOCK0node"))) {
[11:41:48.121]                             sendCondition <<- function(cond) {
[11:41:48.121]                               data <- list(type = "VALUE", value = cond, 
[11:41:48.121]                                 success = TRUE)
[11:41:48.121]                               parallel_sendData(master, data)
[11:41:48.121]                             }
[11:41:48.121]                             return(sendCondition)
[11:41:48.121]                           }
[11:41:48.121]                         }
[11:41:48.121]                         frame <- frame + 1L
[11:41:48.121]                         envir <- sys.frame(frame)
[11:41:48.121]                       }
[11:41:48.121]                     }
[11:41:48.121]                     sendCondition <<- function(cond) NULL
[11:41:48.121]                   }
[11:41:48.121]                 })
[11:41:48.121]                 withCallingHandlers({
[11:41:48.121]                   {
[11:41:48.121]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:48.121]                     if (!identical(...future.globals.maxSize.org, 
[11:41:48.121]                       ...future.globals.maxSize)) {
[11:41:48.121]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:48.121]                       on.exit(options(oopts), add = TRUE)
[11:41:48.121]                     }
[11:41:48.121]                     {
[11:41:48.121]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:48.121]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:48.121]                           envir = globalenv(), inherits = FALSE)
[11:41:48.121]                         ...future.FUN(...)
[11:41:48.121]                       }
[11:41:48.121]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:48.121]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:48.121]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:48.121]                         USE.NAMES = FALSE)
[11:41:48.121]                       do.call(mapply, args = args)
[11:41:48.121]                     }
[11:41:48.121]                   }
[11:41:48.121]                 }, immediateCondition = function(cond) {
[11:41:48.121]                   sendCondition <- ...future.makeSendCondition()
[11:41:48.121]                   sendCondition(cond)
[11:41:48.121]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:48.121]                   {
[11:41:48.121]                     inherits <- base::inherits
[11:41:48.121]                     invokeRestart <- base::invokeRestart
[11:41:48.121]                     is.null <- base::is.null
[11:41:48.121]                     muffled <- FALSE
[11:41:48.121]                     if (inherits(cond, "message")) {
[11:41:48.121]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:48.121]                       if (muffled) 
[11:41:48.121]                         invokeRestart("muffleMessage")
[11:41:48.121]                     }
[11:41:48.121]                     else if (inherits(cond, "warning")) {
[11:41:48.121]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:48.121]                       if (muffled) 
[11:41:48.121]                         invokeRestart("muffleWarning")
[11:41:48.121]                     }
[11:41:48.121]                     else if (inherits(cond, "condition")) {
[11:41:48.121]                       if (!is.null(pattern)) {
[11:41:48.121]                         computeRestarts <- base::computeRestarts
[11:41:48.121]                         grepl <- base::grepl
[11:41:48.121]                         restarts <- computeRestarts(cond)
[11:41:48.121]                         for (restart in restarts) {
[11:41:48.121]                           name <- restart$name
[11:41:48.121]                           if (is.null(name)) 
[11:41:48.121]                             next
[11:41:48.121]                           if (!grepl(pattern, name)) 
[11:41:48.121]                             next
[11:41:48.121]                           invokeRestart(restart)
[11:41:48.121]                           muffled <- TRUE
[11:41:48.121]                           break
[11:41:48.121]                         }
[11:41:48.121]                       }
[11:41:48.121]                     }
[11:41:48.121]                     invisible(muffled)
[11:41:48.121]                   }
[11:41:48.121]                   muffleCondition(cond)
[11:41:48.121]                 })
[11:41:48.121]             }))
[11:41:48.121]             future::FutureResult(value = ...future.value$value, 
[11:41:48.121]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:48.121]                   ...future.rng), globalenv = if (FALSE) 
[11:41:48.121]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:48.121]                     ...future.globalenv.names))
[11:41:48.121]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:48.121]         }, condition = base::local({
[11:41:48.121]             c <- base::c
[11:41:48.121]             inherits <- base::inherits
[11:41:48.121]             invokeRestart <- base::invokeRestart
[11:41:48.121]             length <- base::length
[11:41:48.121]             list <- base::list
[11:41:48.121]             seq.int <- base::seq.int
[11:41:48.121]             signalCondition <- base::signalCondition
[11:41:48.121]             sys.calls <- base::sys.calls
[11:41:48.121]             `[[` <- base::`[[`
[11:41:48.121]             `+` <- base::`+`
[11:41:48.121]             `<<-` <- base::`<<-`
[11:41:48.121]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:48.121]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:48.121]                   3L)]
[11:41:48.121]             }
[11:41:48.121]             function(cond) {
[11:41:48.121]                 is_error <- inherits(cond, "error")
[11:41:48.121]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:48.121]                   NULL)
[11:41:48.121]                 if (is_error) {
[11:41:48.121]                   sessionInformation <- function() {
[11:41:48.121]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:48.121]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:48.121]                       search = base::search(), system = base::Sys.info())
[11:41:48.121]                   }
[11:41:48.121]                   ...future.conditions[[length(...future.conditions) + 
[11:41:48.121]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:48.121]                     cond$call), session = sessionInformation(), 
[11:41:48.121]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:48.121]                   signalCondition(cond)
[11:41:48.121]                 }
[11:41:48.121]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:48.121]                 "immediateCondition"))) {
[11:41:48.121]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:48.121]                   ...future.conditions[[length(...future.conditions) + 
[11:41:48.121]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:48.121]                   if (TRUE && !signal) {
[11:41:48.121]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:48.121]                     {
[11:41:48.121]                       inherits <- base::inherits
[11:41:48.121]                       invokeRestart <- base::invokeRestart
[11:41:48.121]                       is.null <- base::is.null
[11:41:48.121]                       muffled <- FALSE
[11:41:48.121]                       if (inherits(cond, "message")) {
[11:41:48.121]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:48.121]                         if (muffled) 
[11:41:48.121]                           invokeRestart("muffleMessage")
[11:41:48.121]                       }
[11:41:48.121]                       else if (inherits(cond, "warning")) {
[11:41:48.121]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:48.121]                         if (muffled) 
[11:41:48.121]                           invokeRestart("muffleWarning")
[11:41:48.121]                       }
[11:41:48.121]                       else if (inherits(cond, "condition")) {
[11:41:48.121]                         if (!is.null(pattern)) {
[11:41:48.121]                           computeRestarts <- base::computeRestarts
[11:41:48.121]                           grepl <- base::grepl
[11:41:48.121]                           restarts <- computeRestarts(cond)
[11:41:48.121]                           for (restart in restarts) {
[11:41:48.121]                             name <- restart$name
[11:41:48.121]                             if (is.null(name)) 
[11:41:48.121]                               next
[11:41:48.121]                             if (!grepl(pattern, name)) 
[11:41:48.121]                               next
[11:41:48.121]                             invokeRestart(restart)
[11:41:48.121]                             muffled <- TRUE
[11:41:48.121]                             break
[11:41:48.121]                           }
[11:41:48.121]                         }
[11:41:48.121]                       }
[11:41:48.121]                       invisible(muffled)
[11:41:48.121]                     }
[11:41:48.121]                     muffleCondition(cond, pattern = "^muffle")
[11:41:48.121]                   }
[11:41:48.121]                 }
[11:41:48.121]                 else {
[11:41:48.121]                   if (TRUE) {
[11:41:48.121]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:48.121]                     {
[11:41:48.121]                       inherits <- base::inherits
[11:41:48.121]                       invokeRestart <- base::invokeRestart
[11:41:48.121]                       is.null <- base::is.null
[11:41:48.121]                       muffled <- FALSE
[11:41:48.121]                       if (inherits(cond, "message")) {
[11:41:48.121]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:48.121]                         if (muffled) 
[11:41:48.121]                           invokeRestart("muffleMessage")
[11:41:48.121]                       }
[11:41:48.121]                       else if (inherits(cond, "warning")) {
[11:41:48.121]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:48.121]                         if (muffled) 
[11:41:48.121]                           invokeRestart("muffleWarning")
[11:41:48.121]                       }
[11:41:48.121]                       else if (inherits(cond, "condition")) {
[11:41:48.121]                         if (!is.null(pattern)) {
[11:41:48.121]                           computeRestarts <- base::computeRestarts
[11:41:48.121]                           grepl <- base::grepl
[11:41:48.121]                           restarts <- computeRestarts(cond)
[11:41:48.121]                           for (restart in restarts) {
[11:41:48.121]                             name <- restart$name
[11:41:48.121]                             if (is.null(name)) 
[11:41:48.121]                               next
[11:41:48.121]                             if (!grepl(pattern, name)) 
[11:41:48.121]                               next
[11:41:48.121]                             invokeRestart(restart)
[11:41:48.121]                             muffled <- TRUE
[11:41:48.121]                             break
[11:41:48.121]                           }
[11:41:48.121]                         }
[11:41:48.121]                       }
[11:41:48.121]                       invisible(muffled)
[11:41:48.121]                     }
[11:41:48.121]                     muffleCondition(cond, pattern = "^muffle")
[11:41:48.121]                   }
[11:41:48.121]                 }
[11:41:48.121]             }
[11:41:48.121]         }))
[11:41:48.121]     }, error = function(ex) {
[11:41:48.121]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:48.121]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:48.121]                 ...future.rng), started = ...future.startTime, 
[11:41:48.121]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:48.121]             version = "1.8"), class = "FutureResult")
[11:41:48.121]     }, finally = {
[11:41:48.121]         if (!identical(...future.workdir, getwd())) 
[11:41:48.121]             setwd(...future.workdir)
[11:41:48.121]         {
[11:41:48.121]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:48.121]                 ...future.oldOptions$nwarnings <- NULL
[11:41:48.121]             }
[11:41:48.121]             base::options(...future.oldOptions)
[11:41:48.121]             if (.Platform$OS.type == "windows") {
[11:41:48.121]                 old_names <- names(...future.oldEnvVars)
[11:41:48.121]                 envs <- base::Sys.getenv()
[11:41:48.121]                 names <- names(envs)
[11:41:48.121]                 common <- intersect(names, old_names)
[11:41:48.121]                 added <- setdiff(names, old_names)
[11:41:48.121]                 removed <- setdiff(old_names, names)
[11:41:48.121]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:48.121]                   envs[common]]
[11:41:48.121]                 NAMES <- toupper(changed)
[11:41:48.121]                 args <- list()
[11:41:48.121]                 for (kk in seq_along(NAMES)) {
[11:41:48.121]                   name <- changed[[kk]]
[11:41:48.121]                   NAME <- NAMES[[kk]]
[11:41:48.121]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:48.121]                     next
[11:41:48.121]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:48.121]                 }
[11:41:48.121]                 NAMES <- toupper(added)
[11:41:48.121]                 for (kk in seq_along(NAMES)) {
[11:41:48.121]                   name <- added[[kk]]
[11:41:48.121]                   NAME <- NAMES[[kk]]
[11:41:48.121]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:48.121]                     next
[11:41:48.121]                   args[[name]] <- ""
[11:41:48.121]                 }
[11:41:48.121]                 NAMES <- toupper(removed)
[11:41:48.121]                 for (kk in seq_along(NAMES)) {
[11:41:48.121]                   name <- removed[[kk]]
[11:41:48.121]                   NAME <- NAMES[[kk]]
[11:41:48.121]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:48.121]                     next
[11:41:48.121]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:48.121]                 }
[11:41:48.121]                 if (length(args) > 0) 
[11:41:48.121]                   base::do.call(base::Sys.setenv, args = args)
[11:41:48.121]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:48.121]             }
[11:41:48.121]             else {
[11:41:48.121]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:48.121]             }
[11:41:48.121]             {
[11:41:48.121]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:48.121]                   0L) {
[11:41:48.121]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:48.121]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:48.121]                   base::options(opts)
[11:41:48.121]                 }
[11:41:48.121]                 {
[11:41:48.121]                   {
[11:41:48.121]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:48.121]                     NULL
[11:41:48.121]                   }
[11:41:48.121]                   options(future.plan = NULL)
[11:41:48.121]                   if (is.na(NA_character_)) 
[11:41:48.121]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:48.121]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:48.121]                   future::plan(list(function (..., workers = 2, 
[11:41:48.121]                     envir = parent.frame()) 
[11:41:48.121]                   strategy(..., workers = workers, envir = envir)), 
[11:41:48.121]                     .cleanup = FALSE, .init = FALSE)
[11:41:48.121]                 }
[11:41:48.121]             }
[11:41:48.121]         }
[11:41:48.121]     })
[11:41:48.121]     if (TRUE) {
[11:41:48.121]         base::sink(type = "output", split = FALSE)
[11:41:48.121]         if (TRUE) {
[11:41:48.121]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:48.121]         }
[11:41:48.121]         else {
[11:41:48.121]             ...future.result["stdout"] <- base::list(NULL)
[11:41:48.121]         }
[11:41:48.121]         base::close(...future.stdout)
[11:41:48.121]         ...future.stdout <- NULL
[11:41:48.121]     }
[11:41:48.121]     ...future.result$conditions <- ...future.conditions
[11:41:48.121]     ...future.result$finished <- base::Sys.time()
[11:41:48.121]     ...future.result
[11:41:48.121] }
[11:41:48.122] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:48.133] receiveMessageFromWorker() for ClusterFuture ...
[11:41:48.133] - Validating connection of MultisessionFuture
[11:41:48.133] - received message: FutureResult
[11:41:48.134] - Received FutureResult
[11:41:48.134] - Erased future from FutureRegistry
[11:41:48.134] result() for ClusterFuture ...
[11:41:48.134] - result already collected: FutureResult
[11:41:48.134] result() for ClusterFuture ... done
[11:41:48.134] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:48.134] result() for ClusterFuture ...
[11:41:48.134] - result already collected: FutureResult
[11:41:48.135] result() for ClusterFuture ... done
[11:41:48.135] result() for ClusterFuture ...
[11:41:48.135] - result already collected: FutureResult
[11:41:48.135] result() for ClusterFuture ... done
[11:41:48.136] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:48.136] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:48.178] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:48.187] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:48.230] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:48.231] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:48.278] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:48.279] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:48.280] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:48.281] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:48.282] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:48.282] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:48.284] MultisessionFuture started
[11:41:48.284] - Launch lazy future ... done
[11:41:48.284] run() for ‘MultisessionFuture’ ... done
[11:41:48.285] Created future:
[11:41:48.285] MultisessionFuture:
[11:41:48.285] Label: ‘future_mapply-13’
[11:41:48.285] Expression:
[11:41:48.285] {
[11:41:48.285]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:48.285]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:48.285]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:48.285]         on.exit(options(oopts), add = TRUE)
[11:41:48.285]     }
[11:41:48.285]     {
[11:41:48.285]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:48.285]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:48.285]                 inherits = FALSE)
[11:41:48.285]             ...future.FUN(...)
[11:41:48.285]         }
[11:41:48.285]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:48.285]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:48.285]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:48.285]         do.call(mapply, args = args)
[11:41:48.285]     }
[11:41:48.285] }
[11:41:48.285] Lazy evaluation: FALSE
[11:41:48.285] Asynchronous evaluation: TRUE
[11:41:48.285] Local evaluation: TRUE
[11:41:48.285] Environment: 0x560ef58e1768
[11:41:48.285] Capture standard output: TRUE
[11:41:48.285] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:48.285] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:48.285] Packages: 1 packages (‘mlr3’)
[11:41:48.285] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:48.285] Resolved: FALSE
[11:41:48.285] Value: <not collected>
[11:41:48.285] Conditions captured: <none>
[11:41:48.285] Early signaling: FALSE
[11:41:48.285] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:48.285] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:48.303] Chunk #13 of 90 ... DONE
[11:41:48.304] Chunk #14 of 90 ...
[11:41:48.304]  - seeds: [1] <seeds>
[11:41:48.304] getGlobalsAndPackages() ...
[11:41:48.304] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:48.304] Resolving globals: FALSE
[11:41:48.305] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:48.305] - packages: [1] ‘mlr3’
[11:41:48.305] getGlobalsAndPackages() ... DONE
[11:41:48.306] run() for ‘Future’ ...
[11:41:48.306] - state: ‘created’
[11:41:48.306] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:48.317] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:48.317] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:48.317]   - Field: ‘node’
[11:41:48.317]   - Field: ‘label’
[11:41:48.317]   - Field: ‘local’
[11:41:48.317]   - Field: ‘owner’
[11:41:48.317]   - Field: ‘envir’
[11:41:48.317]   - Field: ‘workers’
[11:41:48.317]   - Field: ‘packages’
[11:41:48.317]   - Field: ‘gc’
[11:41:48.317]   - Field: ‘conditions’
[11:41:48.317]   - Field: ‘persistent’
[11:41:48.317]   - Field: ‘expr’
[11:41:48.317]   - Field: ‘uuid’
[11:41:48.317]   - Field: ‘seed’
[11:41:48.317]   - Field: ‘version’
[11:41:48.317]   - Field: ‘result’
[11:41:48.318]   - Field: ‘asynchronous’
[11:41:48.318]   - Field: ‘calls’
[11:41:48.318]   - Field: ‘globals’
[11:41:48.318]   - Field: ‘stdout’
[11:41:48.318]   - Field: ‘earlySignal’
[11:41:48.318]   - Field: ‘lazy’
[11:41:48.318]   - Field: ‘state’
[11:41:48.318] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:48.318] - Launch lazy future ...
[11:41:48.318] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:48.318] Packages needed by future strategies (n = 0): <none>
[11:41:48.318] {
[11:41:48.318]     {
[11:41:48.318]         {
[11:41:48.318]             ...future.startTime <- base::Sys.time()
[11:41:48.318]             {
[11:41:48.318]                 {
[11:41:48.318]                   {
[11:41:48.318]                     {
[11:41:48.318]                       {
[11:41:48.318]                         base::local({
[11:41:48.318]                           has_future <- base::requireNamespace("future", 
[11:41:48.318]                             quietly = TRUE)
[11:41:48.318]                           if (has_future) {
[11:41:48.318]                             ns <- base::getNamespace("future")
[11:41:48.318]                             version <- ns[[".package"]][["version"]]
[11:41:48.318]                             if (is.null(version)) 
[11:41:48.318]                               version <- utils::packageVersion("future")
[11:41:48.318]                           }
[11:41:48.318]                           else {
[11:41:48.318]                             version <- NULL
[11:41:48.318]                           }
[11:41:48.318]                           if (!has_future || version < "1.8.0") {
[11:41:48.318]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:48.318]                               "", base::R.version$version.string), 
[11:41:48.318]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:48.318]                                 base::R.version$platform, 8 * 
[11:41:48.318]                                   base::.Machine$sizeof.pointer), 
[11:41:48.318]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:48.318]                                 "release", "version")], collapse = " "), 
[11:41:48.318]                               hostname = base::Sys.info()[["nodename"]])
[11:41:48.318]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:48.318]                               info)
[11:41:48.318]                             info <- base::paste(info, collapse = "; ")
[11:41:48.318]                             if (!has_future) {
[11:41:48.318]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:48.318]                                 info)
[11:41:48.318]                             }
[11:41:48.318]                             else {
[11:41:48.318]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:48.318]                                 info, version)
[11:41:48.318]                             }
[11:41:48.318]                             base::stop(msg)
[11:41:48.318]                           }
[11:41:48.318]                         })
[11:41:48.318]                       }
[11:41:48.318]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:48.318]                       base::options(mc.cores = 1L)
[11:41:48.318]                     }
[11:41:48.318]                     base::local({
[11:41:48.318]                       for (pkg in "mlr3") {
[11:41:48.318]                         base::loadNamespace(pkg)
[11:41:48.318]                         base::library(pkg, character.only = TRUE)
[11:41:48.318]                       }
[11:41:48.318]                     })
[11:41:48.318]                   }
[11:41:48.318]                   options(future.plan = NULL)
[11:41:48.318]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:48.318]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:48.318]                 }
[11:41:48.318]                 ...future.workdir <- getwd()
[11:41:48.318]             }
[11:41:48.318]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:48.318]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:48.318]         }
[11:41:48.318]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:48.318]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:48.318]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:48.318]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:48.318]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:48.318]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:48.318]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:48.318]             base::names(...future.oldOptions))
[11:41:48.318]     }
[11:41:48.318]     if (FALSE) {
[11:41:48.318]     }
[11:41:48.318]     else {
[11:41:48.318]         if (TRUE) {
[11:41:48.318]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:48.318]                 open = "w")
[11:41:48.318]         }
[11:41:48.318]         else {
[11:41:48.318]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:48.318]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:48.318]         }
[11:41:48.318]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:48.318]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:48.318]             base::sink(type = "output", split = FALSE)
[11:41:48.318]             base::close(...future.stdout)
[11:41:48.318]         }, add = TRUE)
[11:41:48.318]     }
[11:41:48.318]     ...future.frame <- base::sys.nframe()
[11:41:48.318]     ...future.conditions <- base::list()
[11:41:48.318]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:48.318]     if (FALSE) {
[11:41:48.318]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:48.318]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:48.318]     }
[11:41:48.318]     ...future.result <- base::tryCatch({
[11:41:48.318]         base::withCallingHandlers({
[11:41:48.318]             ...future.value <- base::withVisible(base::local({
[11:41:48.318]                 ...future.makeSendCondition <- local({
[11:41:48.318]                   sendCondition <- NULL
[11:41:48.318]                   function(frame = 1L) {
[11:41:48.318]                     if (is.function(sendCondition)) 
[11:41:48.318]                       return(sendCondition)
[11:41:48.318]                     ns <- getNamespace("parallel")
[11:41:48.318]                     if (exists("sendData", mode = "function", 
[11:41:48.318]                       envir = ns)) {
[11:41:48.318]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:48.318]                         envir = ns)
[11:41:48.318]                       envir <- sys.frame(frame)
[11:41:48.318]                       master <- NULL
[11:41:48.318]                       while (!identical(envir, .GlobalEnv) && 
[11:41:48.318]                         !identical(envir, emptyenv())) {
[11:41:48.318]                         if (exists("master", mode = "list", envir = envir, 
[11:41:48.318]                           inherits = FALSE)) {
[11:41:48.318]                           master <- get("master", mode = "list", 
[11:41:48.318]                             envir = envir, inherits = FALSE)
[11:41:48.318]                           if (inherits(master, c("SOCKnode", 
[11:41:48.318]                             "SOCK0node"))) {
[11:41:48.318]                             sendCondition <<- function(cond) {
[11:41:48.318]                               data <- list(type = "VALUE", value = cond, 
[11:41:48.318]                                 success = TRUE)
[11:41:48.318]                               parallel_sendData(master, data)
[11:41:48.318]                             }
[11:41:48.318]                             return(sendCondition)
[11:41:48.318]                           }
[11:41:48.318]                         }
[11:41:48.318]                         frame <- frame + 1L
[11:41:48.318]                         envir <- sys.frame(frame)
[11:41:48.318]                       }
[11:41:48.318]                     }
[11:41:48.318]                     sendCondition <<- function(cond) NULL
[11:41:48.318]                   }
[11:41:48.318]                 })
[11:41:48.318]                 withCallingHandlers({
[11:41:48.318]                   {
[11:41:48.318]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:48.318]                     if (!identical(...future.globals.maxSize.org, 
[11:41:48.318]                       ...future.globals.maxSize)) {
[11:41:48.318]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:48.318]                       on.exit(options(oopts), add = TRUE)
[11:41:48.318]                     }
[11:41:48.318]                     {
[11:41:48.318]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:48.318]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:48.318]                           envir = globalenv(), inherits = FALSE)
[11:41:48.318]                         ...future.FUN(...)
[11:41:48.318]                       }
[11:41:48.318]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:48.318]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:48.318]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:48.318]                         USE.NAMES = FALSE)
[11:41:48.318]                       do.call(mapply, args = args)
[11:41:48.318]                     }
[11:41:48.318]                   }
[11:41:48.318]                 }, immediateCondition = function(cond) {
[11:41:48.318]                   sendCondition <- ...future.makeSendCondition()
[11:41:48.318]                   sendCondition(cond)
[11:41:48.318]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:48.318]                   {
[11:41:48.318]                     inherits <- base::inherits
[11:41:48.318]                     invokeRestart <- base::invokeRestart
[11:41:48.318]                     is.null <- base::is.null
[11:41:48.318]                     muffled <- FALSE
[11:41:48.318]                     if (inherits(cond, "message")) {
[11:41:48.318]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:48.318]                       if (muffled) 
[11:41:48.318]                         invokeRestart("muffleMessage")
[11:41:48.318]                     }
[11:41:48.318]                     else if (inherits(cond, "warning")) {
[11:41:48.318]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:48.318]                       if (muffled) 
[11:41:48.318]                         invokeRestart("muffleWarning")
[11:41:48.318]                     }
[11:41:48.318]                     else if (inherits(cond, "condition")) {
[11:41:48.318]                       if (!is.null(pattern)) {
[11:41:48.318]                         computeRestarts <- base::computeRestarts
[11:41:48.318]                         grepl <- base::grepl
[11:41:48.318]                         restarts <- computeRestarts(cond)
[11:41:48.318]                         for (restart in restarts) {
[11:41:48.318]                           name <- restart$name
[11:41:48.318]                           if (is.null(name)) 
[11:41:48.318]                             next
[11:41:48.318]                           if (!grepl(pattern, name)) 
[11:41:48.318]                             next
[11:41:48.318]                           invokeRestart(restart)
[11:41:48.318]                           muffled <- TRUE
[11:41:48.318]                           break
[11:41:48.318]                         }
[11:41:48.318]                       }
[11:41:48.318]                     }
[11:41:48.318]                     invisible(muffled)
[11:41:48.318]                   }
[11:41:48.318]                   muffleCondition(cond)
[11:41:48.318]                 })
[11:41:48.318]             }))
[11:41:48.318]             future::FutureResult(value = ...future.value$value, 
[11:41:48.318]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:48.318]                   ...future.rng), globalenv = if (FALSE) 
[11:41:48.318]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:48.318]                     ...future.globalenv.names))
[11:41:48.318]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:48.318]         }, condition = base::local({
[11:41:48.318]             c <- base::c
[11:41:48.318]             inherits <- base::inherits
[11:41:48.318]             invokeRestart <- base::invokeRestart
[11:41:48.318]             length <- base::length
[11:41:48.318]             list <- base::list
[11:41:48.318]             seq.int <- base::seq.int
[11:41:48.318]             signalCondition <- base::signalCondition
[11:41:48.318]             sys.calls <- base::sys.calls
[11:41:48.318]             `[[` <- base::`[[`
[11:41:48.318]             `+` <- base::`+`
[11:41:48.318]             `<<-` <- base::`<<-`
[11:41:48.318]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:48.318]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:48.318]                   3L)]
[11:41:48.318]             }
[11:41:48.318]             function(cond) {
[11:41:48.318]                 is_error <- inherits(cond, "error")
[11:41:48.318]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:48.318]                   NULL)
[11:41:48.318]                 if (is_error) {
[11:41:48.318]                   sessionInformation <- function() {
[11:41:48.318]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:48.318]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:48.318]                       search = base::search(), system = base::Sys.info())
[11:41:48.318]                   }
[11:41:48.318]                   ...future.conditions[[length(...future.conditions) + 
[11:41:48.318]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:48.318]                     cond$call), session = sessionInformation(), 
[11:41:48.318]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:48.318]                   signalCondition(cond)
[11:41:48.318]                 }
[11:41:48.318]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:48.318]                 "immediateCondition"))) {
[11:41:48.318]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:48.318]                   ...future.conditions[[length(...future.conditions) + 
[11:41:48.318]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:48.318]                   if (TRUE && !signal) {
[11:41:48.318]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:48.318]                     {
[11:41:48.318]                       inherits <- base::inherits
[11:41:48.318]                       invokeRestart <- base::invokeRestart
[11:41:48.318]                       is.null <- base::is.null
[11:41:48.318]                       muffled <- FALSE
[11:41:48.318]                       if (inherits(cond, "message")) {
[11:41:48.318]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:48.318]                         if (muffled) 
[11:41:48.318]                           invokeRestart("muffleMessage")
[11:41:48.318]                       }
[11:41:48.318]                       else if (inherits(cond, "warning")) {
[11:41:48.318]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:48.318]                         if (muffled) 
[11:41:48.318]                           invokeRestart("muffleWarning")
[11:41:48.318]                       }
[11:41:48.318]                       else if (inherits(cond, "condition")) {
[11:41:48.318]                         if (!is.null(pattern)) {
[11:41:48.318]                           computeRestarts <- base::computeRestarts
[11:41:48.318]                           grepl <- base::grepl
[11:41:48.318]                           restarts <- computeRestarts(cond)
[11:41:48.318]                           for (restart in restarts) {
[11:41:48.318]                             name <- restart$name
[11:41:48.318]                             if (is.null(name)) 
[11:41:48.318]                               next
[11:41:48.318]                             if (!grepl(pattern, name)) 
[11:41:48.318]                               next
[11:41:48.318]                             invokeRestart(restart)
[11:41:48.318]                             muffled <- TRUE
[11:41:48.318]                             break
[11:41:48.318]                           }
[11:41:48.318]                         }
[11:41:48.318]                       }
[11:41:48.318]                       invisible(muffled)
[11:41:48.318]                     }
[11:41:48.318]                     muffleCondition(cond, pattern = "^muffle")
[11:41:48.318]                   }
[11:41:48.318]                 }
[11:41:48.318]                 else {
[11:41:48.318]                   if (TRUE) {
[11:41:48.318]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:48.318]                     {
[11:41:48.318]                       inherits <- base::inherits
[11:41:48.318]                       invokeRestart <- base::invokeRestart
[11:41:48.318]                       is.null <- base::is.null
[11:41:48.318]                       muffled <- FALSE
[11:41:48.318]                       if (inherits(cond, "message")) {
[11:41:48.318]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:48.318]                         if (muffled) 
[11:41:48.318]                           invokeRestart("muffleMessage")
[11:41:48.318]                       }
[11:41:48.318]                       else if (inherits(cond, "warning")) {
[11:41:48.318]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:48.318]                         if (muffled) 
[11:41:48.318]                           invokeRestart("muffleWarning")
[11:41:48.318]                       }
[11:41:48.318]                       else if (inherits(cond, "condition")) {
[11:41:48.318]                         if (!is.null(pattern)) {
[11:41:48.318]                           computeRestarts <- base::computeRestarts
[11:41:48.318]                           grepl <- base::grepl
[11:41:48.318]                           restarts <- computeRestarts(cond)
[11:41:48.318]                           for (restart in restarts) {
[11:41:48.318]                             name <- restart$name
[11:41:48.318]                             if (is.null(name)) 
[11:41:48.318]                               next
[11:41:48.318]                             if (!grepl(pattern, name)) 
[11:41:48.318]                               next
[11:41:48.318]                             invokeRestart(restart)
[11:41:48.318]                             muffled <- TRUE
[11:41:48.318]                             break
[11:41:48.318]                           }
[11:41:48.318]                         }
[11:41:48.318]                       }
[11:41:48.318]                       invisible(muffled)
[11:41:48.318]                     }
[11:41:48.318]                     muffleCondition(cond, pattern = "^muffle")
[11:41:48.318]                   }
[11:41:48.318]                 }
[11:41:48.318]             }
[11:41:48.318]         }))
[11:41:48.318]     }, error = function(ex) {
[11:41:48.318]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:48.318]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:48.318]                 ...future.rng), started = ...future.startTime, 
[11:41:48.318]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:48.318]             version = "1.8"), class = "FutureResult")
[11:41:48.318]     }, finally = {
[11:41:48.318]         if (!identical(...future.workdir, getwd())) 
[11:41:48.318]             setwd(...future.workdir)
[11:41:48.318]         {
[11:41:48.318]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:48.318]                 ...future.oldOptions$nwarnings <- NULL
[11:41:48.318]             }
[11:41:48.318]             base::options(...future.oldOptions)
[11:41:48.318]             if (.Platform$OS.type == "windows") {
[11:41:48.318]                 old_names <- names(...future.oldEnvVars)
[11:41:48.318]                 envs <- base::Sys.getenv()
[11:41:48.318]                 names <- names(envs)
[11:41:48.318]                 common <- intersect(names, old_names)
[11:41:48.318]                 added <- setdiff(names, old_names)
[11:41:48.318]                 removed <- setdiff(old_names, names)
[11:41:48.318]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:48.318]                   envs[common]]
[11:41:48.318]                 NAMES <- toupper(changed)
[11:41:48.318]                 args <- list()
[11:41:48.318]                 for (kk in seq_along(NAMES)) {
[11:41:48.318]                   name <- changed[[kk]]
[11:41:48.318]                   NAME <- NAMES[[kk]]
[11:41:48.318]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:48.318]                     next
[11:41:48.318]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:48.318]                 }
[11:41:48.318]                 NAMES <- toupper(added)
[11:41:48.318]                 for (kk in seq_along(NAMES)) {
[11:41:48.318]                   name <- added[[kk]]
[11:41:48.318]                   NAME <- NAMES[[kk]]
[11:41:48.318]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:48.318]                     next
[11:41:48.318]                   args[[name]] <- ""
[11:41:48.318]                 }
[11:41:48.318]                 NAMES <- toupper(removed)
[11:41:48.318]                 for (kk in seq_along(NAMES)) {
[11:41:48.318]                   name <- removed[[kk]]
[11:41:48.318]                   NAME <- NAMES[[kk]]
[11:41:48.318]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:48.318]                     next
[11:41:48.318]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:48.318]                 }
[11:41:48.318]                 if (length(args) > 0) 
[11:41:48.318]                   base::do.call(base::Sys.setenv, args = args)
[11:41:48.318]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:48.318]             }
[11:41:48.318]             else {
[11:41:48.318]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:48.318]             }
[11:41:48.318]             {
[11:41:48.318]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:48.318]                   0L) {
[11:41:48.318]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:48.318]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:48.318]                   base::options(opts)
[11:41:48.318]                 }
[11:41:48.318]                 {
[11:41:48.318]                   {
[11:41:48.318]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:48.318]                     NULL
[11:41:48.318]                   }
[11:41:48.318]                   options(future.plan = NULL)
[11:41:48.318]                   if (is.na(NA_character_)) 
[11:41:48.318]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:48.318]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:48.318]                   future::plan(list(function (..., workers = 2, 
[11:41:48.318]                     envir = parent.frame()) 
[11:41:48.318]                   strategy(..., workers = workers, envir = envir)), 
[11:41:48.318]                     .cleanup = FALSE, .init = FALSE)
[11:41:48.318]                 }
[11:41:48.318]             }
[11:41:48.318]         }
[11:41:48.318]     })
[11:41:48.318]     if (TRUE) {
[11:41:48.318]         base::sink(type = "output", split = FALSE)
[11:41:48.318]         if (TRUE) {
[11:41:48.318]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:48.318]         }
[11:41:48.318]         else {
[11:41:48.318]             ...future.result["stdout"] <- base::list(NULL)
[11:41:48.318]         }
[11:41:48.318]         base::close(...future.stdout)
[11:41:48.318]         ...future.stdout <- NULL
[11:41:48.318]     }
[11:41:48.318]     ...future.result$conditions <- ...future.conditions
[11:41:48.318]     ...future.result$finished <- base::Sys.time()
[11:41:48.318]     ...future.result
[11:41:48.318] }
[11:41:48.320] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:48.331] receiveMessageFromWorker() for ClusterFuture ...
[11:41:48.331] - Validating connection of MultisessionFuture
[11:41:48.331] - received message: FutureResult
[11:41:48.331] - Received FutureResult
[11:41:48.331] - Erased future from FutureRegistry
[11:41:48.332] result() for ClusterFuture ...
[11:41:48.332] - result already collected: FutureResult
[11:41:48.332] result() for ClusterFuture ... done
[11:41:48.332] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:48.332] result() for ClusterFuture ...
[11:41:48.332] - result already collected: FutureResult
[11:41:48.332] result() for ClusterFuture ... done
[11:41:48.332] result() for ClusterFuture ...
[11:41:48.332] - result already collected: FutureResult
[11:41:48.332] result() for ClusterFuture ... done
[11:41:48.333] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:48.333] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:48.378] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:48.385] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:48.387] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:48.387] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:48.430] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:48.431] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:48.432] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:48.433] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:48.434] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:48.435] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:48.436] MultisessionFuture started
[11:41:48.436] - Launch lazy future ... done
[11:41:48.436] run() for ‘MultisessionFuture’ ... done
[11:41:48.437] Created future:
[11:41:48.437] MultisessionFuture:
[11:41:48.437] Label: ‘future_mapply-14’
[11:41:48.437] Expression:
[11:41:48.437] {
[11:41:48.437]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:48.437]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:48.437]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:48.437]         on.exit(options(oopts), add = TRUE)
[11:41:48.437]     }
[11:41:48.437]     {
[11:41:48.437]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:48.437]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:48.437]                 inherits = FALSE)
[11:41:48.437]             ...future.FUN(...)
[11:41:48.437]         }
[11:41:48.437]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:48.437]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:48.437]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:48.437]         do.call(mapply, args = args)
[11:41:48.437]     }
[11:41:48.437] }
[11:41:48.437] Lazy evaluation: FALSE
[11:41:48.437] Asynchronous evaluation: TRUE
[11:41:48.437] Local evaluation: TRUE
[11:41:48.437] Environment: 0x560ef58e1768
[11:41:48.437] Capture standard output: TRUE
[11:41:48.437] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:48.437] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:48.437] Packages: 1 packages (‘mlr3’)
[11:41:48.437] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:48.437] Resolved: FALSE
[11:41:48.437] Value: <not collected>
[11:41:48.437] Conditions captured: <none>
[11:41:48.437] Early signaling: FALSE
[11:41:48.437] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:48.437] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:48.454] Chunk #14 of 90 ... DONE
[11:41:48.454] Chunk #15 of 90 ...
[11:41:48.455]  - seeds: [1] <seeds>
[11:41:48.455] getGlobalsAndPackages() ...
[11:41:48.455] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:48.455] Resolving globals: FALSE
[11:41:48.456] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:48.456] - packages: [1] ‘mlr3’
[11:41:48.456] getGlobalsAndPackages() ... DONE
[11:41:48.457] run() for ‘Future’ ...
[11:41:48.457] - state: ‘created’
[11:41:48.457] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:48.477] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:48.477] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:48.477]   - Field: ‘node’
[11:41:48.477]   - Field: ‘label’
[11:41:48.477]   - Field: ‘local’
[11:41:48.477]   - Field: ‘owner’
[11:41:48.477]   - Field: ‘envir’
[11:41:48.477]   - Field: ‘workers’
[11:41:48.477]   - Field: ‘packages’
[11:41:48.477]   - Field: ‘gc’
[11:41:48.477]   - Field: ‘conditions’
[11:41:48.478]   - Field: ‘persistent’
[11:41:48.478]   - Field: ‘expr’
[11:41:48.478]   - Field: ‘uuid’
[11:41:48.478]   - Field: ‘seed’
[11:41:48.478]   - Field: ‘version’
[11:41:48.478]   - Field: ‘result’
[11:41:48.478]   - Field: ‘asynchronous’
[11:41:48.478]   - Field: ‘calls’
[11:41:48.478]   - Field: ‘globals’
[11:41:48.478]   - Field: ‘stdout’
[11:41:48.478]   - Field: ‘earlySignal’
[11:41:48.478]   - Field: ‘lazy’
[11:41:48.478]   - Field: ‘state’
[11:41:48.478] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:48.478] - Launch lazy future ...
[11:41:48.479] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:48.479] Packages needed by future strategies (n = 0): <none>
[11:41:48.479] {
[11:41:48.479]     {
[11:41:48.479]         {
[11:41:48.479]             ...future.startTime <- base::Sys.time()
[11:41:48.479]             {
[11:41:48.479]                 {
[11:41:48.479]                   {
[11:41:48.479]                     {
[11:41:48.479]                       {
[11:41:48.479]                         base::local({
[11:41:48.479]                           has_future <- base::requireNamespace("future", 
[11:41:48.479]                             quietly = TRUE)
[11:41:48.479]                           if (has_future) {
[11:41:48.479]                             ns <- base::getNamespace("future")
[11:41:48.479]                             version <- ns[[".package"]][["version"]]
[11:41:48.479]                             if (is.null(version)) 
[11:41:48.479]                               version <- utils::packageVersion("future")
[11:41:48.479]                           }
[11:41:48.479]                           else {
[11:41:48.479]                             version <- NULL
[11:41:48.479]                           }
[11:41:48.479]                           if (!has_future || version < "1.8.0") {
[11:41:48.479]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:48.479]                               "", base::R.version$version.string), 
[11:41:48.479]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:48.479]                                 base::R.version$platform, 8 * 
[11:41:48.479]                                   base::.Machine$sizeof.pointer), 
[11:41:48.479]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:48.479]                                 "release", "version")], collapse = " "), 
[11:41:48.479]                               hostname = base::Sys.info()[["nodename"]])
[11:41:48.479]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:48.479]                               info)
[11:41:48.479]                             info <- base::paste(info, collapse = "; ")
[11:41:48.479]                             if (!has_future) {
[11:41:48.479]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:48.479]                                 info)
[11:41:48.479]                             }
[11:41:48.479]                             else {
[11:41:48.479]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:48.479]                                 info, version)
[11:41:48.479]                             }
[11:41:48.479]                             base::stop(msg)
[11:41:48.479]                           }
[11:41:48.479]                         })
[11:41:48.479]                       }
[11:41:48.479]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:48.479]                       base::options(mc.cores = 1L)
[11:41:48.479]                     }
[11:41:48.479]                     base::local({
[11:41:48.479]                       for (pkg in "mlr3") {
[11:41:48.479]                         base::loadNamespace(pkg)
[11:41:48.479]                         base::library(pkg, character.only = TRUE)
[11:41:48.479]                       }
[11:41:48.479]                     })
[11:41:48.479]                   }
[11:41:48.479]                   options(future.plan = NULL)
[11:41:48.479]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:48.479]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:48.479]                 }
[11:41:48.479]                 ...future.workdir <- getwd()
[11:41:48.479]             }
[11:41:48.479]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:48.479]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:48.479]         }
[11:41:48.479]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:48.479]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:48.479]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:48.479]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:48.479]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:48.479]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:48.479]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:48.479]             base::names(...future.oldOptions))
[11:41:48.479]     }
[11:41:48.479]     if (FALSE) {
[11:41:48.479]     }
[11:41:48.479]     else {
[11:41:48.479]         if (TRUE) {
[11:41:48.479]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:48.479]                 open = "w")
[11:41:48.479]         }
[11:41:48.479]         else {
[11:41:48.479]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:48.479]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:48.479]         }
[11:41:48.479]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:48.479]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:48.479]             base::sink(type = "output", split = FALSE)
[11:41:48.479]             base::close(...future.stdout)
[11:41:48.479]         }, add = TRUE)
[11:41:48.479]     }
[11:41:48.479]     ...future.frame <- base::sys.nframe()
[11:41:48.479]     ...future.conditions <- base::list()
[11:41:48.479]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:48.479]     if (FALSE) {
[11:41:48.479]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:48.479]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:48.479]     }
[11:41:48.479]     ...future.result <- base::tryCatch({
[11:41:48.479]         base::withCallingHandlers({
[11:41:48.479]             ...future.value <- base::withVisible(base::local({
[11:41:48.479]                 ...future.makeSendCondition <- local({
[11:41:48.479]                   sendCondition <- NULL
[11:41:48.479]                   function(frame = 1L) {
[11:41:48.479]                     if (is.function(sendCondition)) 
[11:41:48.479]                       return(sendCondition)
[11:41:48.479]                     ns <- getNamespace("parallel")
[11:41:48.479]                     if (exists("sendData", mode = "function", 
[11:41:48.479]                       envir = ns)) {
[11:41:48.479]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:48.479]                         envir = ns)
[11:41:48.479]                       envir <- sys.frame(frame)
[11:41:48.479]                       master <- NULL
[11:41:48.479]                       while (!identical(envir, .GlobalEnv) && 
[11:41:48.479]                         !identical(envir, emptyenv())) {
[11:41:48.479]                         if (exists("master", mode = "list", envir = envir, 
[11:41:48.479]                           inherits = FALSE)) {
[11:41:48.479]                           master <- get("master", mode = "list", 
[11:41:48.479]                             envir = envir, inherits = FALSE)
[11:41:48.479]                           if (inherits(master, c("SOCKnode", 
[11:41:48.479]                             "SOCK0node"))) {
[11:41:48.479]                             sendCondition <<- function(cond) {
[11:41:48.479]                               data <- list(type = "VALUE", value = cond, 
[11:41:48.479]                                 success = TRUE)
[11:41:48.479]                               parallel_sendData(master, data)
[11:41:48.479]                             }
[11:41:48.479]                             return(sendCondition)
[11:41:48.479]                           }
[11:41:48.479]                         }
[11:41:48.479]                         frame <- frame + 1L
[11:41:48.479]                         envir <- sys.frame(frame)
[11:41:48.479]                       }
[11:41:48.479]                     }
[11:41:48.479]                     sendCondition <<- function(cond) NULL
[11:41:48.479]                   }
[11:41:48.479]                 })
[11:41:48.479]                 withCallingHandlers({
[11:41:48.479]                   {
[11:41:48.479]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:48.479]                     if (!identical(...future.globals.maxSize.org, 
[11:41:48.479]                       ...future.globals.maxSize)) {
[11:41:48.479]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:48.479]                       on.exit(options(oopts), add = TRUE)
[11:41:48.479]                     }
[11:41:48.479]                     {
[11:41:48.479]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:48.479]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:48.479]                           envir = globalenv(), inherits = FALSE)
[11:41:48.479]                         ...future.FUN(...)
[11:41:48.479]                       }
[11:41:48.479]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:48.479]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:48.479]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:48.479]                         USE.NAMES = FALSE)
[11:41:48.479]                       do.call(mapply, args = args)
[11:41:48.479]                     }
[11:41:48.479]                   }
[11:41:48.479]                 }, immediateCondition = function(cond) {
[11:41:48.479]                   sendCondition <- ...future.makeSendCondition()
[11:41:48.479]                   sendCondition(cond)
[11:41:48.479]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:48.479]                   {
[11:41:48.479]                     inherits <- base::inherits
[11:41:48.479]                     invokeRestart <- base::invokeRestart
[11:41:48.479]                     is.null <- base::is.null
[11:41:48.479]                     muffled <- FALSE
[11:41:48.479]                     if (inherits(cond, "message")) {
[11:41:48.479]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:48.479]                       if (muffled) 
[11:41:48.479]                         invokeRestart("muffleMessage")
[11:41:48.479]                     }
[11:41:48.479]                     else if (inherits(cond, "warning")) {
[11:41:48.479]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:48.479]                       if (muffled) 
[11:41:48.479]                         invokeRestart("muffleWarning")
[11:41:48.479]                     }
[11:41:48.479]                     else if (inherits(cond, "condition")) {
[11:41:48.479]                       if (!is.null(pattern)) {
[11:41:48.479]                         computeRestarts <- base::computeRestarts
[11:41:48.479]                         grepl <- base::grepl
[11:41:48.479]                         restarts <- computeRestarts(cond)
[11:41:48.479]                         for (restart in restarts) {
[11:41:48.479]                           name <- restart$name
[11:41:48.479]                           if (is.null(name)) 
[11:41:48.479]                             next
[11:41:48.479]                           if (!grepl(pattern, name)) 
[11:41:48.479]                             next
[11:41:48.479]                           invokeRestart(restart)
[11:41:48.479]                           muffled <- TRUE
[11:41:48.479]                           break
[11:41:48.479]                         }
[11:41:48.479]                       }
[11:41:48.479]                     }
[11:41:48.479]                     invisible(muffled)
[11:41:48.479]                   }
[11:41:48.479]                   muffleCondition(cond)
[11:41:48.479]                 })
[11:41:48.479]             }))
[11:41:48.479]             future::FutureResult(value = ...future.value$value, 
[11:41:48.479]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:48.479]                   ...future.rng), globalenv = if (FALSE) 
[11:41:48.479]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:48.479]                     ...future.globalenv.names))
[11:41:48.479]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:48.479]         }, condition = base::local({
[11:41:48.479]             c <- base::c
[11:41:48.479]             inherits <- base::inherits
[11:41:48.479]             invokeRestart <- base::invokeRestart
[11:41:48.479]             length <- base::length
[11:41:48.479]             list <- base::list
[11:41:48.479]             seq.int <- base::seq.int
[11:41:48.479]             signalCondition <- base::signalCondition
[11:41:48.479]             sys.calls <- base::sys.calls
[11:41:48.479]             `[[` <- base::`[[`
[11:41:48.479]             `+` <- base::`+`
[11:41:48.479]             `<<-` <- base::`<<-`
[11:41:48.479]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:48.479]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:48.479]                   3L)]
[11:41:48.479]             }
[11:41:48.479]             function(cond) {
[11:41:48.479]                 is_error <- inherits(cond, "error")
[11:41:48.479]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:48.479]                   NULL)
[11:41:48.479]                 if (is_error) {
[11:41:48.479]                   sessionInformation <- function() {
[11:41:48.479]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:48.479]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:48.479]                       search = base::search(), system = base::Sys.info())
[11:41:48.479]                   }
[11:41:48.479]                   ...future.conditions[[length(...future.conditions) + 
[11:41:48.479]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:48.479]                     cond$call), session = sessionInformation(), 
[11:41:48.479]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:48.479]                   signalCondition(cond)
[11:41:48.479]                 }
[11:41:48.479]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:48.479]                 "immediateCondition"))) {
[11:41:48.479]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:48.479]                   ...future.conditions[[length(...future.conditions) + 
[11:41:48.479]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:48.479]                   if (TRUE && !signal) {
[11:41:48.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:48.479]                     {
[11:41:48.479]                       inherits <- base::inherits
[11:41:48.479]                       invokeRestart <- base::invokeRestart
[11:41:48.479]                       is.null <- base::is.null
[11:41:48.479]                       muffled <- FALSE
[11:41:48.479]                       if (inherits(cond, "message")) {
[11:41:48.479]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:48.479]                         if (muffled) 
[11:41:48.479]                           invokeRestart("muffleMessage")
[11:41:48.479]                       }
[11:41:48.479]                       else if (inherits(cond, "warning")) {
[11:41:48.479]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:48.479]                         if (muffled) 
[11:41:48.479]                           invokeRestart("muffleWarning")
[11:41:48.479]                       }
[11:41:48.479]                       else if (inherits(cond, "condition")) {
[11:41:48.479]                         if (!is.null(pattern)) {
[11:41:48.479]                           computeRestarts <- base::computeRestarts
[11:41:48.479]                           grepl <- base::grepl
[11:41:48.479]                           restarts <- computeRestarts(cond)
[11:41:48.479]                           for (restart in restarts) {
[11:41:48.479]                             name <- restart$name
[11:41:48.479]                             if (is.null(name)) 
[11:41:48.479]                               next
[11:41:48.479]                             if (!grepl(pattern, name)) 
[11:41:48.479]                               next
[11:41:48.479]                             invokeRestart(restart)
[11:41:48.479]                             muffled <- TRUE
[11:41:48.479]                             break
[11:41:48.479]                           }
[11:41:48.479]                         }
[11:41:48.479]                       }
[11:41:48.479]                       invisible(muffled)
[11:41:48.479]                     }
[11:41:48.479]                     muffleCondition(cond, pattern = "^muffle")
[11:41:48.479]                   }
[11:41:48.479]                 }
[11:41:48.479]                 else {
[11:41:48.479]                   if (TRUE) {
[11:41:48.479]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:48.479]                     {
[11:41:48.479]                       inherits <- base::inherits
[11:41:48.479]                       invokeRestart <- base::invokeRestart
[11:41:48.479]                       is.null <- base::is.null
[11:41:48.479]                       muffled <- FALSE
[11:41:48.479]                       if (inherits(cond, "message")) {
[11:41:48.479]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:48.479]                         if (muffled) 
[11:41:48.479]                           invokeRestart("muffleMessage")
[11:41:48.479]                       }
[11:41:48.479]                       else if (inherits(cond, "warning")) {
[11:41:48.479]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:48.479]                         if (muffled) 
[11:41:48.479]                           invokeRestart("muffleWarning")
[11:41:48.479]                       }
[11:41:48.479]                       else if (inherits(cond, "condition")) {
[11:41:48.479]                         if (!is.null(pattern)) {
[11:41:48.479]                           computeRestarts <- base::computeRestarts
[11:41:48.479]                           grepl <- base::grepl
[11:41:48.479]                           restarts <- computeRestarts(cond)
[11:41:48.479]                           for (restart in restarts) {
[11:41:48.479]                             name <- restart$name
[11:41:48.479]                             if (is.null(name)) 
[11:41:48.479]                               next
[11:41:48.479]                             if (!grepl(pattern, name)) 
[11:41:48.479]                               next
[11:41:48.479]                             invokeRestart(restart)
[11:41:48.479]                             muffled <- TRUE
[11:41:48.479]                             break
[11:41:48.479]                           }
[11:41:48.479]                         }
[11:41:48.479]                       }
[11:41:48.479]                       invisible(muffled)
[11:41:48.479]                     }
[11:41:48.479]                     muffleCondition(cond, pattern = "^muffle")
[11:41:48.479]                   }
[11:41:48.479]                 }
[11:41:48.479]             }
[11:41:48.479]         }))
[11:41:48.479]     }, error = function(ex) {
[11:41:48.479]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:48.479]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:48.479]                 ...future.rng), started = ...future.startTime, 
[11:41:48.479]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:48.479]             version = "1.8"), class = "FutureResult")
[11:41:48.479]     }, finally = {
[11:41:48.479]         if (!identical(...future.workdir, getwd())) 
[11:41:48.479]             setwd(...future.workdir)
[11:41:48.479]         {
[11:41:48.479]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:48.479]                 ...future.oldOptions$nwarnings <- NULL
[11:41:48.479]             }
[11:41:48.479]             base::options(...future.oldOptions)
[11:41:48.479]             if (.Platform$OS.type == "windows") {
[11:41:48.479]                 old_names <- names(...future.oldEnvVars)
[11:41:48.479]                 envs <- base::Sys.getenv()
[11:41:48.479]                 names <- names(envs)
[11:41:48.479]                 common <- intersect(names, old_names)
[11:41:48.479]                 added <- setdiff(names, old_names)
[11:41:48.479]                 removed <- setdiff(old_names, names)
[11:41:48.479]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:48.479]                   envs[common]]
[11:41:48.479]                 NAMES <- toupper(changed)
[11:41:48.479]                 args <- list()
[11:41:48.479]                 for (kk in seq_along(NAMES)) {
[11:41:48.479]                   name <- changed[[kk]]
[11:41:48.479]                   NAME <- NAMES[[kk]]
[11:41:48.479]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:48.479]                     next
[11:41:48.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:48.479]                 }
[11:41:48.479]                 NAMES <- toupper(added)
[11:41:48.479]                 for (kk in seq_along(NAMES)) {
[11:41:48.479]                   name <- added[[kk]]
[11:41:48.479]                   NAME <- NAMES[[kk]]
[11:41:48.479]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:48.479]                     next
[11:41:48.479]                   args[[name]] <- ""
[11:41:48.479]                 }
[11:41:48.479]                 NAMES <- toupper(removed)
[11:41:48.479]                 for (kk in seq_along(NAMES)) {
[11:41:48.479]                   name <- removed[[kk]]
[11:41:48.479]                   NAME <- NAMES[[kk]]
[11:41:48.479]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:48.479]                     next
[11:41:48.479]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:48.479]                 }
[11:41:48.479]                 if (length(args) > 0) 
[11:41:48.479]                   base::do.call(base::Sys.setenv, args = args)
[11:41:48.479]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:48.479]             }
[11:41:48.479]             else {
[11:41:48.479]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:48.479]             }
[11:41:48.479]             {
[11:41:48.479]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:48.479]                   0L) {
[11:41:48.479]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:48.479]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:48.479]                   base::options(opts)
[11:41:48.479]                 }
[11:41:48.479]                 {
[11:41:48.479]                   {
[11:41:48.479]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:48.479]                     NULL
[11:41:48.479]                   }
[11:41:48.479]                   options(future.plan = NULL)
[11:41:48.479]                   if (is.na(NA_character_)) 
[11:41:48.479]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:48.479]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:48.479]                   future::plan(list(function (..., workers = 2, 
[11:41:48.479]                     envir = parent.frame()) 
[11:41:48.479]                   strategy(..., workers = workers, envir = envir)), 
[11:41:48.479]                     .cleanup = FALSE, .init = FALSE)
[11:41:48.479]                 }
[11:41:48.479]             }
[11:41:48.479]         }
[11:41:48.479]     })
[11:41:48.479]     if (TRUE) {
[11:41:48.479]         base::sink(type = "output", split = FALSE)
[11:41:48.479]         if (TRUE) {
[11:41:48.479]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:48.479]         }
[11:41:48.479]         else {
[11:41:48.479]             ...future.result["stdout"] <- base::list(NULL)
[11:41:48.479]         }
[11:41:48.479]         base::close(...future.stdout)
[11:41:48.479]         ...future.stdout <- NULL
[11:41:48.479]     }
[11:41:48.479]     ...future.result$conditions <- ...future.conditions
[11:41:48.479]     ...future.result$finished <- base::Sys.time()
[11:41:48.479]     ...future.result
[11:41:48.479] }
[11:41:48.481] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:48.492] receiveMessageFromWorker() for ClusterFuture ...
[11:41:48.492] - Validating connection of MultisessionFuture
[11:41:48.492] - received message: FutureResult
[11:41:48.492] - Received FutureResult
[11:41:48.492] - Erased future from FutureRegistry
[11:41:48.492] result() for ClusterFuture ...
[11:41:48.492] - result already collected: FutureResult
[11:41:48.493] result() for ClusterFuture ... done
[11:41:48.493] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:48.493] result() for ClusterFuture ...
[11:41:48.493] - result already collected: FutureResult
[11:41:48.493] result() for ClusterFuture ... done
[11:41:48.493] result() for ClusterFuture ...
[11:41:48.493] - result already collected: FutureResult
[11:41:48.493] result() for ClusterFuture ... done
[11:41:48.494] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:48.494] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:48.538] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:48.547] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:48.550] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:48.550] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:48.594] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:48.595] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:48.597] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:48.598] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:48.599] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:48.600] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:48.601] MultisessionFuture started
[11:41:48.601] - Launch lazy future ... done
[11:41:48.602] run() for ‘MultisessionFuture’ ... done
[11:41:48.602] Created future:
[11:41:48.602] MultisessionFuture:
[11:41:48.602] Label: ‘future_mapply-15’
[11:41:48.602] Expression:
[11:41:48.602] {
[11:41:48.602]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:48.602]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:48.602]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:48.602]         on.exit(options(oopts), add = TRUE)
[11:41:48.602]     }
[11:41:48.602]     {
[11:41:48.602]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:48.602]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:48.602]                 inherits = FALSE)
[11:41:48.602]             ...future.FUN(...)
[11:41:48.602]         }
[11:41:48.602]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:48.602]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:48.602]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:48.602]         do.call(mapply, args = args)
[11:41:48.602]     }
[11:41:48.602] }
[11:41:48.602] Lazy evaluation: FALSE
[11:41:48.602] Asynchronous evaluation: TRUE
[11:41:48.602] Local evaluation: TRUE
[11:41:48.602] Environment: 0x560ef58e1768
[11:41:48.602] Capture standard output: TRUE
[11:41:48.602] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:48.602] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:48.602] Packages: 1 packages (‘mlr3’)
[11:41:48.602] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:48.602] Resolved: FALSE
[11:41:48.602] Value: <not collected>
[11:41:48.602] Conditions captured: <none>
[11:41:48.602] Early signaling: FALSE
[11:41:48.602] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:48.602] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:48.620] Chunk #15 of 90 ... DONE
[11:41:48.621] Chunk #16 of 90 ...
[11:41:48.621]  - seeds: [1] <seeds>
[11:41:48.621] getGlobalsAndPackages() ...
[11:41:48.621] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:48.621] Resolving globals: FALSE
[11:41:48.622] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:48.622] - packages: [1] ‘mlr3’
[11:41:48.623] getGlobalsAndPackages() ... DONE
[11:41:48.623] run() for ‘Future’ ...
[11:41:48.623] - state: ‘created’
[11:41:48.623] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:48.638] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:48.638] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:48.638]   - Field: ‘node’
[11:41:48.638]   - Field: ‘label’
[11:41:48.639]   - Field: ‘local’
[11:41:48.639]   - Field: ‘owner’
[11:41:48.639]   - Field: ‘envir’
[11:41:48.639]   - Field: ‘workers’
[11:41:48.639]   - Field: ‘packages’
[11:41:48.639]   - Field: ‘gc’
[11:41:48.639]   - Field: ‘conditions’
[11:41:48.639]   - Field: ‘persistent’
[11:41:48.639]   - Field: ‘expr’
[11:41:48.639]   - Field: ‘uuid’
[11:41:48.640]   - Field: ‘seed’
[11:41:48.640]   - Field: ‘version’
[11:41:48.640]   - Field: ‘result’
[11:41:48.640]   - Field: ‘asynchronous’
[11:41:48.640]   - Field: ‘calls’
[11:41:48.640]   - Field: ‘globals’
[11:41:48.640]   - Field: ‘stdout’
[11:41:48.640]   - Field: ‘earlySignal’
[11:41:48.640]   - Field: ‘lazy’
[11:41:48.640]   - Field: ‘state’
[11:41:48.640] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:48.641] - Launch lazy future ...
[11:41:48.641] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:48.641] Packages needed by future strategies (n = 0): <none>
[11:41:48.642] {
[11:41:48.642]     {
[11:41:48.642]         {
[11:41:48.642]             ...future.startTime <- base::Sys.time()
[11:41:48.642]             {
[11:41:48.642]                 {
[11:41:48.642]                   {
[11:41:48.642]                     {
[11:41:48.642]                       {
[11:41:48.642]                         base::local({
[11:41:48.642]                           has_future <- base::requireNamespace("future", 
[11:41:48.642]                             quietly = TRUE)
[11:41:48.642]                           if (has_future) {
[11:41:48.642]                             ns <- base::getNamespace("future")
[11:41:48.642]                             version <- ns[[".package"]][["version"]]
[11:41:48.642]                             if (is.null(version)) 
[11:41:48.642]                               version <- utils::packageVersion("future")
[11:41:48.642]                           }
[11:41:48.642]                           else {
[11:41:48.642]                             version <- NULL
[11:41:48.642]                           }
[11:41:48.642]                           if (!has_future || version < "1.8.0") {
[11:41:48.642]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:48.642]                               "", base::R.version$version.string), 
[11:41:48.642]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:48.642]                                 base::R.version$platform, 8 * 
[11:41:48.642]                                   base::.Machine$sizeof.pointer), 
[11:41:48.642]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:48.642]                                 "release", "version")], collapse = " "), 
[11:41:48.642]                               hostname = base::Sys.info()[["nodename"]])
[11:41:48.642]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:48.642]                               info)
[11:41:48.642]                             info <- base::paste(info, collapse = "; ")
[11:41:48.642]                             if (!has_future) {
[11:41:48.642]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:48.642]                                 info)
[11:41:48.642]                             }
[11:41:48.642]                             else {
[11:41:48.642]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:48.642]                                 info, version)
[11:41:48.642]                             }
[11:41:48.642]                             base::stop(msg)
[11:41:48.642]                           }
[11:41:48.642]                         })
[11:41:48.642]                       }
[11:41:48.642]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:48.642]                       base::options(mc.cores = 1L)
[11:41:48.642]                     }
[11:41:48.642]                     base::local({
[11:41:48.642]                       for (pkg in "mlr3") {
[11:41:48.642]                         base::loadNamespace(pkg)
[11:41:48.642]                         base::library(pkg, character.only = TRUE)
[11:41:48.642]                       }
[11:41:48.642]                     })
[11:41:48.642]                   }
[11:41:48.642]                   options(future.plan = NULL)
[11:41:48.642]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:48.642]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:48.642]                 }
[11:41:48.642]                 ...future.workdir <- getwd()
[11:41:48.642]             }
[11:41:48.642]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:48.642]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:48.642]         }
[11:41:48.642]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:48.642]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:48.642]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:48.642]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:48.642]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:48.642]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:48.642]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:48.642]             base::names(...future.oldOptions))
[11:41:48.642]     }
[11:41:48.642]     if (FALSE) {
[11:41:48.642]     }
[11:41:48.642]     else {
[11:41:48.642]         if (TRUE) {
[11:41:48.642]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:48.642]                 open = "w")
[11:41:48.642]         }
[11:41:48.642]         else {
[11:41:48.642]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:48.642]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:48.642]         }
[11:41:48.642]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:48.642]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:48.642]             base::sink(type = "output", split = FALSE)
[11:41:48.642]             base::close(...future.stdout)
[11:41:48.642]         }, add = TRUE)
[11:41:48.642]     }
[11:41:48.642]     ...future.frame <- base::sys.nframe()
[11:41:48.642]     ...future.conditions <- base::list()
[11:41:48.642]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:48.642]     if (FALSE) {
[11:41:48.642]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:48.642]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:48.642]     }
[11:41:48.642]     ...future.result <- base::tryCatch({
[11:41:48.642]         base::withCallingHandlers({
[11:41:48.642]             ...future.value <- base::withVisible(base::local({
[11:41:48.642]                 ...future.makeSendCondition <- local({
[11:41:48.642]                   sendCondition <- NULL
[11:41:48.642]                   function(frame = 1L) {
[11:41:48.642]                     if (is.function(sendCondition)) 
[11:41:48.642]                       return(sendCondition)
[11:41:48.642]                     ns <- getNamespace("parallel")
[11:41:48.642]                     if (exists("sendData", mode = "function", 
[11:41:48.642]                       envir = ns)) {
[11:41:48.642]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:48.642]                         envir = ns)
[11:41:48.642]                       envir <- sys.frame(frame)
[11:41:48.642]                       master <- NULL
[11:41:48.642]                       while (!identical(envir, .GlobalEnv) && 
[11:41:48.642]                         !identical(envir, emptyenv())) {
[11:41:48.642]                         if (exists("master", mode = "list", envir = envir, 
[11:41:48.642]                           inherits = FALSE)) {
[11:41:48.642]                           master <- get("master", mode = "list", 
[11:41:48.642]                             envir = envir, inherits = FALSE)
[11:41:48.642]                           if (inherits(master, c("SOCKnode", 
[11:41:48.642]                             "SOCK0node"))) {
[11:41:48.642]                             sendCondition <<- function(cond) {
[11:41:48.642]                               data <- list(type = "VALUE", value = cond, 
[11:41:48.642]                                 success = TRUE)
[11:41:48.642]                               parallel_sendData(master, data)
[11:41:48.642]                             }
[11:41:48.642]                             return(sendCondition)
[11:41:48.642]                           }
[11:41:48.642]                         }
[11:41:48.642]                         frame <- frame + 1L
[11:41:48.642]                         envir <- sys.frame(frame)
[11:41:48.642]                       }
[11:41:48.642]                     }
[11:41:48.642]                     sendCondition <<- function(cond) NULL
[11:41:48.642]                   }
[11:41:48.642]                 })
[11:41:48.642]                 withCallingHandlers({
[11:41:48.642]                   {
[11:41:48.642]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:48.642]                     if (!identical(...future.globals.maxSize.org, 
[11:41:48.642]                       ...future.globals.maxSize)) {
[11:41:48.642]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:48.642]                       on.exit(options(oopts), add = TRUE)
[11:41:48.642]                     }
[11:41:48.642]                     {
[11:41:48.642]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:48.642]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:48.642]                           envir = globalenv(), inherits = FALSE)
[11:41:48.642]                         ...future.FUN(...)
[11:41:48.642]                       }
[11:41:48.642]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:48.642]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:48.642]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:48.642]                         USE.NAMES = FALSE)
[11:41:48.642]                       do.call(mapply, args = args)
[11:41:48.642]                     }
[11:41:48.642]                   }
[11:41:48.642]                 }, immediateCondition = function(cond) {
[11:41:48.642]                   sendCondition <- ...future.makeSendCondition()
[11:41:48.642]                   sendCondition(cond)
[11:41:48.642]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:48.642]                   {
[11:41:48.642]                     inherits <- base::inherits
[11:41:48.642]                     invokeRestart <- base::invokeRestart
[11:41:48.642]                     is.null <- base::is.null
[11:41:48.642]                     muffled <- FALSE
[11:41:48.642]                     if (inherits(cond, "message")) {
[11:41:48.642]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:48.642]                       if (muffled) 
[11:41:48.642]                         invokeRestart("muffleMessage")
[11:41:48.642]                     }
[11:41:48.642]                     else if (inherits(cond, "warning")) {
[11:41:48.642]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:48.642]                       if (muffled) 
[11:41:48.642]                         invokeRestart("muffleWarning")
[11:41:48.642]                     }
[11:41:48.642]                     else if (inherits(cond, "condition")) {
[11:41:48.642]                       if (!is.null(pattern)) {
[11:41:48.642]                         computeRestarts <- base::computeRestarts
[11:41:48.642]                         grepl <- base::grepl
[11:41:48.642]                         restarts <- computeRestarts(cond)
[11:41:48.642]                         for (restart in restarts) {
[11:41:48.642]                           name <- restart$name
[11:41:48.642]                           if (is.null(name)) 
[11:41:48.642]                             next
[11:41:48.642]                           if (!grepl(pattern, name)) 
[11:41:48.642]                             next
[11:41:48.642]                           invokeRestart(restart)
[11:41:48.642]                           muffled <- TRUE
[11:41:48.642]                           break
[11:41:48.642]                         }
[11:41:48.642]                       }
[11:41:48.642]                     }
[11:41:48.642]                     invisible(muffled)
[11:41:48.642]                   }
[11:41:48.642]                   muffleCondition(cond)
[11:41:48.642]                 })
[11:41:48.642]             }))
[11:41:48.642]             future::FutureResult(value = ...future.value$value, 
[11:41:48.642]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:48.642]                   ...future.rng), globalenv = if (FALSE) 
[11:41:48.642]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:48.642]                     ...future.globalenv.names))
[11:41:48.642]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:48.642]         }, condition = base::local({
[11:41:48.642]             c <- base::c
[11:41:48.642]             inherits <- base::inherits
[11:41:48.642]             invokeRestart <- base::invokeRestart
[11:41:48.642]             length <- base::length
[11:41:48.642]             list <- base::list
[11:41:48.642]             seq.int <- base::seq.int
[11:41:48.642]             signalCondition <- base::signalCondition
[11:41:48.642]             sys.calls <- base::sys.calls
[11:41:48.642]             `[[` <- base::`[[`
[11:41:48.642]             `+` <- base::`+`
[11:41:48.642]             `<<-` <- base::`<<-`
[11:41:48.642]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:48.642]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:48.642]                   3L)]
[11:41:48.642]             }
[11:41:48.642]             function(cond) {
[11:41:48.642]                 is_error <- inherits(cond, "error")
[11:41:48.642]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:48.642]                   NULL)
[11:41:48.642]                 if (is_error) {
[11:41:48.642]                   sessionInformation <- function() {
[11:41:48.642]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:48.642]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:48.642]                       search = base::search(), system = base::Sys.info())
[11:41:48.642]                   }
[11:41:48.642]                   ...future.conditions[[length(...future.conditions) + 
[11:41:48.642]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:48.642]                     cond$call), session = sessionInformation(), 
[11:41:48.642]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:48.642]                   signalCondition(cond)
[11:41:48.642]                 }
[11:41:48.642]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:48.642]                 "immediateCondition"))) {
[11:41:48.642]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:48.642]                   ...future.conditions[[length(...future.conditions) + 
[11:41:48.642]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:48.642]                   if (TRUE && !signal) {
[11:41:48.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:48.642]                     {
[11:41:48.642]                       inherits <- base::inherits
[11:41:48.642]                       invokeRestart <- base::invokeRestart
[11:41:48.642]                       is.null <- base::is.null
[11:41:48.642]                       muffled <- FALSE
[11:41:48.642]                       if (inherits(cond, "message")) {
[11:41:48.642]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:48.642]                         if (muffled) 
[11:41:48.642]                           invokeRestart("muffleMessage")
[11:41:48.642]                       }
[11:41:48.642]                       else if (inherits(cond, "warning")) {
[11:41:48.642]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:48.642]                         if (muffled) 
[11:41:48.642]                           invokeRestart("muffleWarning")
[11:41:48.642]                       }
[11:41:48.642]                       else if (inherits(cond, "condition")) {
[11:41:48.642]                         if (!is.null(pattern)) {
[11:41:48.642]                           computeRestarts <- base::computeRestarts
[11:41:48.642]                           grepl <- base::grepl
[11:41:48.642]                           restarts <- computeRestarts(cond)
[11:41:48.642]                           for (restart in restarts) {
[11:41:48.642]                             name <- restart$name
[11:41:48.642]                             if (is.null(name)) 
[11:41:48.642]                               next
[11:41:48.642]                             if (!grepl(pattern, name)) 
[11:41:48.642]                               next
[11:41:48.642]                             invokeRestart(restart)
[11:41:48.642]                             muffled <- TRUE
[11:41:48.642]                             break
[11:41:48.642]                           }
[11:41:48.642]                         }
[11:41:48.642]                       }
[11:41:48.642]                       invisible(muffled)
[11:41:48.642]                     }
[11:41:48.642]                     muffleCondition(cond, pattern = "^muffle")
[11:41:48.642]                   }
[11:41:48.642]                 }
[11:41:48.642]                 else {
[11:41:48.642]                   if (TRUE) {
[11:41:48.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:48.642]                     {
[11:41:48.642]                       inherits <- base::inherits
[11:41:48.642]                       invokeRestart <- base::invokeRestart
[11:41:48.642]                       is.null <- base::is.null
[11:41:48.642]                       muffled <- FALSE
[11:41:48.642]                       if (inherits(cond, "message")) {
[11:41:48.642]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:48.642]                         if (muffled) 
[11:41:48.642]                           invokeRestart("muffleMessage")
[11:41:48.642]                       }
[11:41:48.642]                       else if (inherits(cond, "warning")) {
[11:41:48.642]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:48.642]                         if (muffled) 
[11:41:48.642]                           invokeRestart("muffleWarning")
[11:41:48.642]                       }
[11:41:48.642]                       else if (inherits(cond, "condition")) {
[11:41:48.642]                         if (!is.null(pattern)) {
[11:41:48.642]                           computeRestarts <- base::computeRestarts
[11:41:48.642]                           grepl <- base::grepl
[11:41:48.642]                           restarts <- computeRestarts(cond)
[11:41:48.642]                           for (restart in restarts) {
[11:41:48.642]                             name <- restart$name
[11:41:48.642]                             if (is.null(name)) 
[11:41:48.642]                               next
[11:41:48.642]                             if (!grepl(pattern, name)) 
[11:41:48.642]                               next
[11:41:48.642]                             invokeRestart(restart)
[11:41:48.642]                             muffled <- TRUE
[11:41:48.642]                             break
[11:41:48.642]                           }
[11:41:48.642]                         }
[11:41:48.642]                       }
[11:41:48.642]                       invisible(muffled)
[11:41:48.642]                     }
[11:41:48.642]                     muffleCondition(cond, pattern = "^muffle")
[11:41:48.642]                   }
[11:41:48.642]                 }
[11:41:48.642]             }
[11:41:48.642]         }))
[11:41:48.642]     }, error = function(ex) {
[11:41:48.642]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:48.642]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:48.642]                 ...future.rng), started = ...future.startTime, 
[11:41:48.642]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:48.642]             version = "1.8"), class = "FutureResult")
[11:41:48.642]     }, finally = {
[11:41:48.642]         if (!identical(...future.workdir, getwd())) 
[11:41:48.642]             setwd(...future.workdir)
[11:41:48.642]         {
[11:41:48.642]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:48.642]                 ...future.oldOptions$nwarnings <- NULL
[11:41:48.642]             }
[11:41:48.642]             base::options(...future.oldOptions)
[11:41:48.642]             if (.Platform$OS.type == "windows") {
[11:41:48.642]                 old_names <- names(...future.oldEnvVars)
[11:41:48.642]                 envs <- base::Sys.getenv()
[11:41:48.642]                 names <- names(envs)
[11:41:48.642]                 common <- intersect(names, old_names)
[11:41:48.642]                 added <- setdiff(names, old_names)
[11:41:48.642]                 removed <- setdiff(old_names, names)
[11:41:48.642]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:48.642]                   envs[common]]
[11:41:48.642]                 NAMES <- toupper(changed)
[11:41:48.642]                 args <- list()
[11:41:48.642]                 for (kk in seq_along(NAMES)) {
[11:41:48.642]                   name <- changed[[kk]]
[11:41:48.642]                   NAME <- NAMES[[kk]]
[11:41:48.642]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:48.642]                     next
[11:41:48.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:48.642]                 }
[11:41:48.642]                 NAMES <- toupper(added)
[11:41:48.642]                 for (kk in seq_along(NAMES)) {
[11:41:48.642]                   name <- added[[kk]]
[11:41:48.642]                   NAME <- NAMES[[kk]]
[11:41:48.642]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:48.642]                     next
[11:41:48.642]                   args[[name]] <- ""
[11:41:48.642]                 }
[11:41:48.642]                 NAMES <- toupper(removed)
[11:41:48.642]                 for (kk in seq_along(NAMES)) {
[11:41:48.642]                   name <- removed[[kk]]
[11:41:48.642]                   NAME <- NAMES[[kk]]
[11:41:48.642]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:48.642]                     next
[11:41:48.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:48.642]                 }
[11:41:48.642]                 if (length(args) > 0) 
[11:41:48.642]                   base::do.call(base::Sys.setenv, args = args)
[11:41:48.642]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:48.642]             }
[11:41:48.642]             else {
[11:41:48.642]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:48.642]             }
[11:41:48.642]             {
[11:41:48.642]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:48.642]                   0L) {
[11:41:48.642]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:48.642]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:48.642]                   base::options(opts)
[11:41:48.642]                 }
[11:41:48.642]                 {
[11:41:48.642]                   {
[11:41:48.642]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:48.642]                     NULL
[11:41:48.642]                   }
[11:41:48.642]                   options(future.plan = NULL)
[11:41:48.642]                   if (is.na(NA_character_)) 
[11:41:48.642]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:48.642]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:48.642]                   future::plan(list(function (..., workers = 2, 
[11:41:48.642]                     envir = parent.frame()) 
[11:41:48.642]                   strategy(..., workers = workers, envir = envir)), 
[11:41:48.642]                     .cleanup = FALSE, .init = FALSE)
[11:41:48.642]                 }
[11:41:48.642]             }
[11:41:48.642]         }
[11:41:48.642]     })
[11:41:48.642]     if (TRUE) {
[11:41:48.642]         base::sink(type = "output", split = FALSE)
[11:41:48.642]         if (TRUE) {
[11:41:48.642]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:48.642]         }
[11:41:48.642]         else {
[11:41:48.642]             ...future.result["stdout"] <- base::list(NULL)
[11:41:48.642]         }
[11:41:48.642]         base::close(...future.stdout)
[11:41:48.642]         ...future.stdout <- NULL
[11:41:48.642]     }
[11:41:48.642]     ...future.result$conditions <- ...future.conditions
[11:41:48.642]     ...future.result$finished <- base::Sys.time()
[11:41:48.642]     ...future.result
[11:41:48.642] }
[11:41:48.644] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:48.655] receiveMessageFromWorker() for ClusterFuture ...
[11:41:48.655] - Validating connection of MultisessionFuture
[11:41:48.655] - received message: FutureResult
[11:41:48.656] - Received FutureResult
[11:41:48.656] - Erased future from FutureRegistry
[11:41:48.656] result() for ClusterFuture ...
[11:41:48.656] - result already collected: FutureResult
[11:41:48.656] result() for ClusterFuture ... done
[11:41:48.656] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:48.656] result() for ClusterFuture ...
[11:41:48.656] - result already collected: FutureResult
[11:41:48.656] result() for ClusterFuture ... done
[11:41:48.656] result() for ClusterFuture ...
[11:41:48.656] - result already collected: FutureResult
[11:41:48.657] result() for ClusterFuture ... done
[11:41:48.657] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:48.658] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:48.706] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:48.715] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:48.762] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:48.763] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:48.814] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:48.815] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:48.816] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:48.817] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:48.818] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:48.818] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:48.820] MultisessionFuture started
[11:41:48.820] - Launch lazy future ... done
[11:41:48.820] run() for ‘MultisessionFuture’ ... done
[11:41:48.820] Created future:
[11:41:48.820] MultisessionFuture:
[11:41:48.820] Label: ‘future_mapply-16’
[11:41:48.820] Expression:
[11:41:48.820] {
[11:41:48.820]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:48.820]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:48.820]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:48.820]         on.exit(options(oopts), add = TRUE)
[11:41:48.820]     }
[11:41:48.820]     {
[11:41:48.820]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:48.820]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:48.820]                 inherits = FALSE)
[11:41:48.820]             ...future.FUN(...)
[11:41:48.820]         }
[11:41:48.820]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:48.820]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:48.820]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:48.820]         do.call(mapply, args = args)
[11:41:48.820]     }
[11:41:48.820] }
[11:41:48.820] Lazy evaluation: FALSE
[11:41:48.820] Asynchronous evaluation: TRUE
[11:41:48.820] Local evaluation: TRUE
[11:41:48.820] Environment: 0x560ef58e1768
[11:41:48.820] Capture standard output: TRUE
[11:41:48.820] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:48.820] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:48.820] Packages: 1 packages (‘mlr3’)
[11:41:48.820] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:48.820] Resolved: FALSE
[11:41:48.820] Value: <not collected>
[11:41:48.820] Conditions captured: <none>
[11:41:48.820] Early signaling: FALSE
[11:41:48.820] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:48.820] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:48.838] Chunk #16 of 90 ... DONE
[11:41:48.839] Chunk #17 of 90 ...
[11:41:48.839]  - seeds: [1] <seeds>
[11:41:48.839] getGlobalsAndPackages() ...
[11:41:48.839] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:48.840] Resolving globals: FALSE
[11:41:48.840] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:48.840] - packages: [1] ‘mlr3’
[11:41:48.841] getGlobalsAndPackages() ... DONE
[11:41:48.841] run() for ‘Future’ ...
[11:41:48.841] - state: ‘created’
[11:41:48.841] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:48.851] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:48.851] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:48.852]   - Field: ‘node’
[11:41:48.852]   - Field: ‘label’
[11:41:48.852]   - Field: ‘local’
[11:41:48.852]   - Field: ‘owner’
[11:41:48.852]   - Field: ‘envir’
[11:41:48.852]   - Field: ‘workers’
[11:41:48.852]   - Field: ‘packages’
[11:41:48.852]   - Field: ‘gc’
[11:41:48.852]   - Field: ‘conditions’
[11:41:48.852]   - Field: ‘persistent’
[11:41:48.852]   - Field: ‘expr’
[11:41:48.852]   - Field: ‘uuid’
[11:41:48.852]   - Field: ‘seed’
[11:41:48.852]   - Field: ‘version’
[11:41:48.852]   - Field: ‘result’
[11:41:48.852]   - Field: ‘asynchronous’
[11:41:48.852]   - Field: ‘calls’
[11:41:48.852]   - Field: ‘globals’
[11:41:48.852]   - Field: ‘stdout’
[11:41:48.852]   - Field: ‘earlySignal’
[11:41:48.852]   - Field: ‘lazy’
[11:41:48.852]   - Field: ‘state’
[11:41:48.852] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:48.852] - Launch lazy future ...
[11:41:48.853] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:48.853] Packages needed by future strategies (n = 0): <none>
[11:41:48.853] {
[11:41:48.853]     {
[11:41:48.853]         {
[11:41:48.853]             ...future.startTime <- base::Sys.time()
[11:41:48.853]             {
[11:41:48.853]                 {
[11:41:48.853]                   {
[11:41:48.853]                     {
[11:41:48.853]                       {
[11:41:48.853]                         base::local({
[11:41:48.853]                           has_future <- base::requireNamespace("future", 
[11:41:48.853]                             quietly = TRUE)
[11:41:48.853]                           if (has_future) {
[11:41:48.853]                             ns <- base::getNamespace("future")
[11:41:48.853]                             version <- ns[[".package"]][["version"]]
[11:41:48.853]                             if (is.null(version)) 
[11:41:48.853]                               version <- utils::packageVersion("future")
[11:41:48.853]                           }
[11:41:48.853]                           else {
[11:41:48.853]                             version <- NULL
[11:41:48.853]                           }
[11:41:48.853]                           if (!has_future || version < "1.8.0") {
[11:41:48.853]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:48.853]                               "", base::R.version$version.string), 
[11:41:48.853]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:48.853]                                 base::R.version$platform, 8 * 
[11:41:48.853]                                   base::.Machine$sizeof.pointer), 
[11:41:48.853]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:48.853]                                 "release", "version")], collapse = " "), 
[11:41:48.853]                               hostname = base::Sys.info()[["nodename"]])
[11:41:48.853]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:48.853]                               info)
[11:41:48.853]                             info <- base::paste(info, collapse = "; ")
[11:41:48.853]                             if (!has_future) {
[11:41:48.853]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:48.853]                                 info)
[11:41:48.853]                             }
[11:41:48.853]                             else {
[11:41:48.853]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:48.853]                                 info, version)
[11:41:48.853]                             }
[11:41:48.853]                             base::stop(msg)
[11:41:48.853]                           }
[11:41:48.853]                         })
[11:41:48.853]                       }
[11:41:48.853]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:48.853]                       base::options(mc.cores = 1L)
[11:41:48.853]                     }
[11:41:48.853]                     base::local({
[11:41:48.853]                       for (pkg in "mlr3") {
[11:41:48.853]                         base::loadNamespace(pkg)
[11:41:48.853]                         base::library(pkg, character.only = TRUE)
[11:41:48.853]                       }
[11:41:48.853]                     })
[11:41:48.853]                   }
[11:41:48.853]                   options(future.plan = NULL)
[11:41:48.853]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:48.853]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:48.853]                 }
[11:41:48.853]                 ...future.workdir <- getwd()
[11:41:48.853]             }
[11:41:48.853]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:48.853]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:48.853]         }
[11:41:48.853]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:48.853]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:48.853]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:48.853]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:48.853]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:48.853]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:48.853]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:48.853]             base::names(...future.oldOptions))
[11:41:48.853]     }
[11:41:48.853]     if (FALSE) {
[11:41:48.853]     }
[11:41:48.853]     else {
[11:41:48.853]         if (TRUE) {
[11:41:48.853]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:48.853]                 open = "w")
[11:41:48.853]         }
[11:41:48.853]         else {
[11:41:48.853]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:48.853]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:48.853]         }
[11:41:48.853]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:48.853]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:48.853]             base::sink(type = "output", split = FALSE)
[11:41:48.853]             base::close(...future.stdout)
[11:41:48.853]         }, add = TRUE)
[11:41:48.853]     }
[11:41:48.853]     ...future.frame <- base::sys.nframe()
[11:41:48.853]     ...future.conditions <- base::list()
[11:41:48.853]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:48.853]     if (FALSE) {
[11:41:48.853]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:48.853]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:48.853]     }
[11:41:48.853]     ...future.result <- base::tryCatch({
[11:41:48.853]         base::withCallingHandlers({
[11:41:48.853]             ...future.value <- base::withVisible(base::local({
[11:41:48.853]                 ...future.makeSendCondition <- local({
[11:41:48.853]                   sendCondition <- NULL
[11:41:48.853]                   function(frame = 1L) {
[11:41:48.853]                     if (is.function(sendCondition)) 
[11:41:48.853]                       return(sendCondition)
[11:41:48.853]                     ns <- getNamespace("parallel")
[11:41:48.853]                     if (exists("sendData", mode = "function", 
[11:41:48.853]                       envir = ns)) {
[11:41:48.853]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:48.853]                         envir = ns)
[11:41:48.853]                       envir <- sys.frame(frame)
[11:41:48.853]                       master <- NULL
[11:41:48.853]                       while (!identical(envir, .GlobalEnv) && 
[11:41:48.853]                         !identical(envir, emptyenv())) {
[11:41:48.853]                         if (exists("master", mode = "list", envir = envir, 
[11:41:48.853]                           inherits = FALSE)) {
[11:41:48.853]                           master <- get("master", mode = "list", 
[11:41:48.853]                             envir = envir, inherits = FALSE)
[11:41:48.853]                           if (inherits(master, c("SOCKnode", 
[11:41:48.853]                             "SOCK0node"))) {
[11:41:48.853]                             sendCondition <<- function(cond) {
[11:41:48.853]                               data <- list(type = "VALUE", value = cond, 
[11:41:48.853]                                 success = TRUE)
[11:41:48.853]                               parallel_sendData(master, data)
[11:41:48.853]                             }
[11:41:48.853]                             return(sendCondition)
[11:41:48.853]                           }
[11:41:48.853]                         }
[11:41:48.853]                         frame <- frame + 1L
[11:41:48.853]                         envir <- sys.frame(frame)
[11:41:48.853]                       }
[11:41:48.853]                     }
[11:41:48.853]                     sendCondition <<- function(cond) NULL
[11:41:48.853]                   }
[11:41:48.853]                 })
[11:41:48.853]                 withCallingHandlers({
[11:41:48.853]                   {
[11:41:48.853]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:48.853]                     if (!identical(...future.globals.maxSize.org, 
[11:41:48.853]                       ...future.globals.maxSize)) {
[11:41:48.853]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:48.853]                       on.exit(options(oopts), add = TRUE)
[11:41:48.853]                     }
[11:41:48.853]                     {
[11:41:48.853]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:48.853]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:48.853]                           envir = globalenv(), inherits = FALSE)
[11:41:48.853]                         ...future.FUN(...)
[11:41:48.853]                       }
[11:41:48.853]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:48.853]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:48.853]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:48.853]                         USE.NAMES = FALSE)
[11:41:48.853]                       do.call(mapply, args = args)
[11:41:48.853]                     }
[11:41:48.853]                   }
[11:41:48.853]                 }, immediateCondition = function(cond) {
[11:41:48.853]                   sendCondition <- ...future.makeSendCondition()
[11:41:48.853]                   sendCondition(cond)
[11:41:48.853]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:48.853]                   {
[11:41:48.853]                     inherits <- base::inherits
[11:41:48.853]                     invokeRestart <- base::invokeRestart
[11:41:48.853]                     is.null <- base::is.null
[11:41:48.853]                     muffled <- FALSE
[11:41:48.853]                     if (inherits(cond, "message")) {
[11:41:48.853]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:48.853]                       if (muffled) 
[11:41:48.853]                         invokeRestart("muffleMessage")
[11:41:48.853]                     }
[11:41:48.853]                     else if (inherits(cond, "warning")) {
[11:41:48.853]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:48.853]                       if (muffled) 
[11:41:48.853]                         invokeRestart("muffleWarning")
[11:41:48.853]                     }
[11:41:48.853]                     else if (inherits(cond, "condition")) {
[11:41:48.853]                       if (!is.null(pattern)) {
[11:41:48.853]                         computeRestarts <- base::computeRestarts
[11:41:48.853]                         grepl <- base::grepl
[11:41:48.853]                         restarts <- computeRestarts(cond)
[11:41:48.853]                         for (restart in restarts) {
[11:41:48.853]                           name <- restart$name
[11:41:48.853]                           if (is.null(name)) 
[11:41:48.853]                             next
[11:41:48.853]                           if (!grepl(pattern, name)) 
[11:41:48.853]                             next
[11:41:48.853]                           invokeRestart(restart)
[11:41:48.853]                           muffled <- TRUE
[11:41:48.853]                           break
[11:41:48.853]                         }
[11:41:48.853]                       }
[11:41:48.853]                     }
[11:41:48.853]                     invisible(muffled)
[11:41:48.853]                   }
[11:41:48.853]                   muffleCondition(cond)
[11:41:48.853]                 })
[11:41:48.853]             }))
[11:41:48.853]             future::FutureResult(value = ...future.value$value, 
[11:41:48.853]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:48.853]                   ...future.rng), globalenv = if (FALSE) 
[11:41:48.853]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:48.853]                     ...future.globalenv.names))
[11:41:48.853]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:48.853]         }, condition = base::local({
[11:41:48.853]             c <- base::c
[11:41:48.853]             inherits <- base::inherits
[11:41:48.853]             invokeRestart <- base::invokeRestart
[11:41:48.853]             length <- base::length
[11:41:48.853]             list <- base::list
[11:41:48.853]             seq.int <- base::seq.int
[11:41:48.853]             signalCondition <- base::signalCondition
[11:41:48.853]             sys.calls <- base::sys.calls
[11:41:48.853]             `[[` <- base::`[[`
[11:41:48.853]             `+` <- base::`+`
[11:41:48.853]             `<<-` <- base::`<<-`
[11:41:48.853]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:48.853]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:48.853]                   3L)]
[11:41:48.853]             }
[11:41:48.853]             function(cond) {
[11:41:48.853]                 is_error <- inherits(cond, "error")
[11:41:48.853]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:48.853]                   NULL)
[11:41:48.853]                 if (is_error) {
[11:41:48.853]                   sessionInformation <- function() {
[11:41:48.853]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:48.853]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:48.853]                       search = base::search(), system = base::Sys.info())
[11:41:48.853]                   }
[11:41:48.853]                   ...future.conditions[[length(...future.conditions) + 
[11:41:48.853]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:48.853]                     cond$call), session = sessionInformation(), 
[11:41:48.853]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:48.853]                   signalCondition(cond)
[11:41:48.853]                 }
[11:41:48.853]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:48.853]                 "immediateCondition"))) {
[11:41:48.853]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:48.853]                   ...future.conditions[[length(...future.conditions) + 
[11:41:48.853]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:48.853]                   if (TRUE && !signal) {
[11:41:48.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:48.853]                     {
[11:41:48.853]                       inherits <- base::inherits
[11:41:48.853]                       invokeRestart <- base::invokeRestart
[11:41:48.853]                       is.null <- base::is.null
[11:41:48.853]                       muffled <- FALSE
[11:41:48.853]                       if (inherits(cond, "message")) {
[11:41:48.853]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:48.853]                         if (muffled) 
[11:41:48.853]                           invokeRestart("muffleMessage")
[11:41:48.853]                       }
[11:41:48.853]                       else if (inherits(cond, "warning")) {
[11:41:48.853]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:48.853]                         if (muffled) 
[11:41:48.853]                           invokeRestart("muffleWarning")
[11:41:48.853]                       }
[11:41:48.853]                       else if (inherits(cond, "condition")) {
[11:41:48.853]                         if (!is.null(pattern)) {
[11:41:48.853]                           computeRestarts <- base::computeRestarts
[11:41:48.853]                           grepl <- base::grepl
[11:41:48.853]                           restarts <- computeRestarts(cond)
[11:41:48.853]                           for (restart in restarts) {
[11:41:48.853]                             name <- restart$name
[11:41:48.853]                             if (is.null(name)) 
[11:41:48.853]                               next
[11:41:48.853]                             if (!grepl(pattern, name)) 
[11:41:48.853]                               next
[11:41:48.853]                             invokeRestart(restart)
[11:41:48.853]                             muffled <- TRUE
[11:41:48.853]                             break
[11:41:48.853]                           }
[11:41:48.853]                         }
[11:41:48.853]                       }
[11:41:48.853]                       invisible(muffled)
[11:41:48.853]                     }
[11:41:48.853]                     muffleCondition(cond, pattern = "^muffle")
[11:41:48.853]                   }
[11:41:48.853]                 }
[11:41:48.853]                 else {
[11:41:48.853]                   if (TRUE) {
[11:41:48.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:48.853]                     {
[11:41:48.853]                       inherits <- base::inherits
[11:41:48.853]                       invokeRestart <- base::invokeRestart
[11:41:48.853]                       is.null <- base::is.null
[11:41:48.853]                       muffled <- FALSE
[11:41:48.853]                       if (inherits(cond, "message")) {
[11:41:48.853]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:48.853]                         if (muffled) 
[11:41:48.853]                           invokeRestart("muffleMessage")
[11:41:48.853]                       }
[11:41:48.853]                       else if (inherits(cond, "warning")) {
[11:41:48.853]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:48.853]                         if (muffled) 
[11:41:48.853]                           invokeRestart("muffleWarning")
[11:41:48.853]                       }
[11:41:48.853]                       else if (inherits(cond, "condition")) {
[11:41:48.853]                         if (!is.null(pattern)) {
[11:41:48.853]                           computeRestarts <- base::computeRestarts
[11:41:48.853]                           grepl <- base::grepl
[11:41:48.853]                           restarts <- computeRestarts(cond)
[11:41:48.853]                           for (restart in restarts) {
[11:41:48.853]                             name <- restart$name
[11:41:48.853]                             if (is.null(name)) 
[11:41:48.853]                               next
[11:41:48.853]                             if (!grepl(pattern, name)) 
[11:41:48.853]                               next
[11:41:48.853]                             invokeRestart(restart)
[11:41:48.853]                             muffled <- TRUE
[11:41:48.853]                             break
[11:41:48.853]                           }
[11:41:48.853]                         }
[11:41:48.853]                       }
[11:41:48.853]                       invisible(muffled)
[11:41:48.853]                     }
[11:41:48.853]                     muffleCondition(cond, pattern = "^muffle")
[11:41:48.853]                   }
[11:41:48.853]                 }
[11:41:48.853]             }
[11:41:48.853]         }))
[11:41:48.853]     }, error = function(ex) {
[11:41:48.853]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:48.853]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:48.853]                 ...future.rng), started = ...future.startTime, 
[11:41:48.853]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:48.853]             version = "1.8"), class = "FutureResult")
[11:41:48.853]     }, finally = {
[11:41:48.853]         if (!identical(...future.workdir, getwd())) 
[11:41:48.853]             setwd(...future.workdir)
[11:41:48.853]         {
[11:41:48.853]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:48.853]                 ...future.oldOptions$nwarnings <- NULL
[11:41:48.853]             }
[11:41:48.853]             base::options(...future.oldOptions)
[11:41:48.853]             if (.Platform$OS.type == "windows") {
[11:41:48.853]                 old_names <- names(...future.oldEnvVars)
[11:41:48.853]                 envs <- base::Sys.getenv()
[11:41:48.853]                 names <- names(envs)
[11:41:48.853]                 common <- intersect(names, old_names)
[11:41:48.853]                 added <- setdiff(names, old_names)
[11:41:48.853]                 removed <- setdiff(old_names, names)
[11:41:48.853]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:48.853]                   envs[common]]
[11:41:48.853]                 NAMES <- toupper(changed)
[11:41:48.853]                 args <- list()
[11:41:48.853]                 for (kk in seq_along(NAMES)) {
[11:41:48.853]                   name <- changed[[kk]]
[11:41:48.853]                   NAME <- NAMES[[kk]]
[11:41:48.853]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:48.853]                     next
[11:41:48.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:48.853]                 }
[11:41:48.853]                 NAMES <- toupper(added)
[11:41:48.853]                 for (kk in seq_along(NAMES)) {
[11:41:48.853]                   name <- added[[kk]]
[11:41:48.853]                   NAME <- NAMES[[kk]]
[11:41:48.853]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:48.853]                     next
[11:41:48.853]                   args[[name]] <- ""
[11:41:48.853]                 }
[11:41:48.853]                 NAMES <- toupper(removed)
[11:41:48.853]                 for (kk in seq_along(NAMES)) {
[11:41:48.853]                   name <- removed[[kk]]
[11:41:48.853]                   NAME <- NAMES[[kk]]
[11:41:48.853]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:48.853]                     next
[11:41:48.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:48.853]                 }
[11:41:48.853]                 if (length(args) > 0) 
[11:41:48.853]                   base::do.call(base::Sys.setenv, args = args)
[11:41:48.853]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:48.853]             }
[11:41:48.853]             else {
[11:41:48.853]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:48.853]             }
[11:41:48.853]             {
[11:41:48.853]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:48.853]                   0L) {
[11:41:48.853]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:48.853]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:48.853]                   base::options(opts)
[11:41:48.853]                 }
[11:41:48.853]                 {
[11:41:48.853]                   {
[11:41:48.853]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:48.853]                     NULL
[11:41:48.853]                   }
[11:41:48.853]                   options(future.plan = NULL)
[11:41:48.853]                   if (is.na(NA_character_)) 
[11:41:48.853]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:48.853]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:48.853]                   future::plan(list(function (..., workers = 2, 
[11:41:48.853]                     envir = parent.frame()) 
[11:41:48.853]                   strategy(..., workers = workers, envir = envir)), 
[11:41:48.853]                     .cleanup = FALSE, .init = FALSE)
[11:41:48.853]                 }
[11:41:48.853]             }
[11:41:48.853]         }
[11:41:48.853]     })
[11:41:48.853]     if (TRUE) {
[11:41:48.853]         base::sink(type = "output", split = FALSE)
[11:41:48.853]         if (TRUE) {
[11:41:48.853]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:48.853]         }
[11:41:48.853]         else {
[11:41:48.853]             ...future.result["stdout"] <- base::list(NULL)
[11:41:48.853]         }
[11:41:48.853]         base::close(...future.stdout)
[11:41:48.853]         ...future.stdout <- NULL
[11:41:48.853]     }
[11:41:48.853]     ...future.result$conditions <- ...future.conditions
[11:41:48.853]     ...future.result$finished <- base::Sys.time()
[11:41:48.853]     ...future.result
[11:41:48.853] }
[11:41:48.854] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:48.866] receiveMessageFromWorker() for ClusterFuture ...
[11:41:48.866] - Validating connection of MultisessionFuture
[11:41:48.866] - received message: FutureResult
[11:41:48.867] - Received FutureResult
[11:41:48.867] - Erased future from FutureRegistry
[11:41:48.867] result() for ClusterFuture ...
[11:41:48.867] - result already collected: FutureResult
[11:41:48.867] result() for ClusterFuture ... done
[11:41:48.867] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:48.867] result() for ClusterFuture ...
[11:41:48.867] - result already collected: FutureResult
[11:41:48.867] result() for ClusterFuture ... done
[11:41:48.868] result() for ClusterFuture ...
[11:41:48.868] - result already collected: FutureResult
[11:41:48.868] result() for ClusterFuture ... done
[11:41:48.869] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:48.869] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:48.914] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:48.921] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:48.966] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:48.967] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:49.014] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:49.015] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:49.016] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:49.017] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:49.018] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:49.019] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:49.020] MultisessionFuture started
[11:41:49.020] - Launch lazy future ... done
[11:41:49.021] run() for ‘MultisessionFuture’ ... done
[11:41:49.021] Created future:
[11:41:49.021] MultisessionFuture:
[11:41:49.021] Label: ‘future_mapply-17’
[11:41:49.021] Expression:
[11:41:49.021] {
[11:41:49.021]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:49.021]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:49.021]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:49.021]         on.exit(options(oopts), add = TRUE)
[11:41:49.021]     }
[11:41:49.021]     {
[11:41:49.021]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:49.021]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:49.021]                 inherits = FALSE)
[11:41:49.021]             ...future.FUN(...)
[11:41:49.021]         }
[11:41:49.021]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:49.021]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:49.021]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:49.021]         do.call(mapply, args = args)
[11:41:49.021]     }
[11:41:49.021] }
[11:41:49.021] Lazy evaluation: FALSE
[11:41:49.021] Asynchronous evaluation: TRUE
[11:41:49.021] Local evaluation: TRUE
[11:41:49.021] Environment: 0x560ef58e1768
[11:41:49.021] Capture standard output: TRUE
[11:41:49.021] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:49.021] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:49.021] Packages: 1 packages (‘mlr3’)
[11:41:49.021] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:49.021] Resolved: FALSE
[11:41:49.021] Value: <not collected>
[11:41:49.021] Conditions captured: <none>
[11:41:49.021] Early signaling: FALSE
[11:41:49.021] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:49.021] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:49.040] Chunk #17 of 90 ... DONE
[11:41:49.040] Chunk #18 of 90 ...
[11:41:49.040]  - seeds: [1] <seeds>
[11:41:49.040] getGlobalsAndPackages() ...
[11:41:49.040] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:49.041] Resolving globals: FALSE
[11:41:49.041] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:49.042] - packages: [1] ‘mlr3’
[11:41:49.042] getGlobalsAndPackages() ... DONE
[11:41:49.042] run() for ‘Future’ ...
[11:41:49.042] - state: ‘created’
[11:41:49.042] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:49.057] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:49.057] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:49.057]   - Field: ‘node’
[11:41:49.057]   - Field: ‘label’
[11:41:49.058]   - Field: ‘local’
[11:41:49.058]   - Field: ‘owner’
[11:41:49.058]   - Field: ‘envir’
[11:41:49.058]   - Field: ‘workers’
[11:41:49.058]   - Field: ‘packages’
[11:41:49.058]   - Field: ‘gc’
[11:41:49.058]   - Field: ‘conditions’
[11:41:49.058]   - Field: ‘persistent’
[11:41:49.058]   - Field: ‘expr’
[11:41:49.058]   - Field: ‘uuid’
[11:41:49.058]   - Field: ‘seed’
[11:41:49.058]   - Field: ‘version’
[11:41:49.058]   - Field: ‘result’
[11:41:49.058]   - Field: ‘asynchronous’
[11:41:49.058]   - Field: ‘calls’
[11:41:49.058]   - Field: ‘globals’
[11:41:49.058]   - Field: ‘stdout’
[11:41:49.058]   - Field: ‘earlySignal’
[11:41:49.058]   - Field: ‘lazy’
[11:41:49.058]   - Field: ‘state’
[11:41:49.058] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:49.058] - Launch lazy future ...
[11:41:49.059] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:49.059] Packages needed by future strategies (n = 0): <none>
[11:41:49.059] {
[11:41:49.059]     {
[11:41:49.059]         {
[11:41:49.059]             ...future.startTime <- base::Sys.time()
[11:41:49.059]             {
[11:41:49.059]                 {
[11:41:49.059]                   {
[11:41:49.059]                     {
[11:41:49.059]                       {
[11:41:49.059]                         base::local({
[11:41:49.059]                           has_future <- base::requireNamespace("future", 
[11:41:49.059]                             quietly = TRUE)
[11:41:49.059]                           if (has_future) {
[11:41:49.059]                             ns <- base::getNamespace("future")
[11:41:49.059]                             version <- ns[[".package"]][["version"]]
[11:41:49.059]                             if (is.null(version)) 
[11:41:49.059]                               version <- utils::packageVersion("future")
[11:41:49.059]                           }
[11:41:49.059]                           else {
[11:41:49.059]                             version <- NULL
[11:41:49.059]                           }
[11:41:49.059]                           if (!has_future || version < "1.8.0") {
[11:41:49.059]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:49.059]                               "", base::R.version$version.string), 
[11:41:49.059]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:49.059]                                 base::R.version$platform, 8 * 
[11:41:49.059]                                   base::.Machine$sizeof.pointer), 
[11:41:49.059]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:49.059]                                 "release", "version")], collapse = " "), 
[11:41:49.059]                               hostname = base::Sys.info()[["nodename"]])
[11:41:49.059]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:49.059]                               info)
[11:41:49.059]                             info <- base::paste(info, collapse = "; ")
[11:41:49.059]                             if (!has_future) {
[11:41:49.059]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:49.059]                                 info)
[11:41:49.059]                             }
[11:41:49.059]                             else {
[11:41:49.059]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:49.059]                                 info, version)
[11:41:49.059]                             }
[11:41:49.059]                             base::stop(msg)
[11:41:49.059]                           }
[11:41:49.059]                         })
[11:41:49.059]                       }
[11:41:49.059]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:49.059]                       base::options(mc.cores = 1L)
[11:41:49.059]                     }
[11:41:49.059]                     base::local({
[11:41:49.059]                       for (pkg in "mlr3") {
[11:41:49.059]                         base::loadNamespace(pkg)
[11:41:49.059]                         base::library(pkg, character.only = TRUE)
[11:41:49.059]                       }
[11:41:49.059]                     })
[11:41:49.059]                   }
[11:41:49.059]                   options(future.plan = NULL)
[11:41:49.059]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:49.059]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:49.059]                 }
[11:41:49.059]                 ...future.workdir <- getwd()
[11:41:49.059]             }
[11:41:49.059]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:49.059]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:49.059]         }
[11:41:49.059]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:49.059]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:49.059]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:49.059]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:49.059]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:49.059]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:49.059]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:49.059]             base::names(...future.oldOptions))
[11:41:49.059]     }
[11:41:49.059]     if (FALSE) {
[11:41:49.059]     }
[11:41:49.059]     else {
[11:41:49.059]         if (TRUE) {
[11:41:49.059]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:49.059]                 open = "w")
[11:41:49.059]         }
[11:41:49.059]         else {
[11:41:49.059]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:49.059]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:49.059]         }
[11:41:49.059]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:49.059]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:49.059]             base::sink(type = "output", split = FALSE)
[11:41:49.059]             base::close(...future.stdout)
[11:41:49.059]         }, add = TRUE)
[11:41:49.059]     }
[11:41:49.059]     ...future.frame <- base::sys.nframe()
[11:41:49.059]     ...future.conditions <- base::list()
[11:41:49.059]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:49.059]     if (FALSE) {
[11:41:49.059]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:49.059]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:49.059]     }
[11:41:49.059]     ...future.result <- base::tryCatch({
[11:41:49.059]         base::withCallingHandlers({
[11:41:49.059]             ...future.value <- base::withVisible(base::local({
[11:41:49.059]                 ...future.makeSendCondition <- local({
[11:41:49.059]                   sendCondition <- NULL
[11:41:49.059]                   function(frame = 1L) {
[11:41:49.059]                     if (is.function(sendCondition)) 
[11:41:49.059]                       return(sendCondition)
[11:41:49.059]                     ns <- getNamespace("parallel")
[11:41:49.059]                     if (exists("sendData", mode = "function", 
[11:41:49.059]                       envir = ns)) {
[11:41:49.059]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:49.059]                         envir = ns)
[11:41:49.059]                       envir <- sys.frame(frame)
[11:41:49.059]                       master <- NULL
[11:41:49.059]                       while (!identical(envir, .GlobalEnv) && 
[11:41:49.059]                         !identical(envir, emptyenv())) {
[11:41:49.059]                         if (exists("master", mode = "list", envir = envir, 
[11:41:49.059]                           inherits = FALSE)) {
[11:41:49.059]                           master <- get("master", mode = "list", 
[11:41:49.059]                             envir = envir, inherits = FALSE)
[11:41:49.059]                           if (inherits(master, c("SOCKnode", 
[11:41:49.059]                             "SOCK0node"))) {
[11:41:49.059]                             sendCondition <<- function(cond) {
[11:41:49.059]                               data <- list(type = "VALUE", value = cond, 
[11:41:49.059]                                 success = TRUE)
[11:41:49.059]                               parallel_sendData(master, data)
[11:41:49.059]                             }
[11:41:49.059]                             return(sendCondition)
[11:41:49.059]                           }
[11:41:49.059]                         }
[11:41:49.059]                         frame <- frame + 1L
[11:41:49.059]                         envir <- sys.frame(frame)
[11:41:49.059]                       }
[11:41:49.059]                     }
[11:41:49.059]                     sendCondition <<- function(cond) NULL
[11:41:49.059]                   }
[11:41:49.059]                 })
[11:41:49.059]                 withCallingHandlers({
[11:41:49.059]                   {
[11:41:49.059]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:49.059]                     if (!identical(...future.globals.maxSize.org, 
[11:41:49.059]                       ...future.globals.maxSize)) {
[11:41:49.059]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:49.059]                       on.exit(options(oopts), add = TRUE)
[11:41:49.059]                     }
[11:41:49.059]                     {
[11:41:49.059]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:49.059]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:49.059]                           envir = globalenv(), inherits = FALSE)
[11:41:49.059]                         ...future.FUN(...)
[11:41:49.059]                       }
[11:41:49.059]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:49.059]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:49.059]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:49.059]                         USE.NAMES = FALSE)
[11:41:49.059]                       do.call(mapply, args = args)
[11:41:49.059]                     }
[11:41:49.059]                   }
[11:41:49.059]                 }, immediateCondition = function(cond) {
[11:41:49.059]                   sendCondition <- ...future.makeSendCondition()
[11:41:49.059]                   sendCondition(cond)
[11:41:49.059]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:49.059]                   {
[11:41:49.059]                     inherits <- base::inherits
[11:41:49.059]                     invokeRestart <- base::invokeRestart
[11:41:49.059]                     is.null <- base::is.null
[11:41:49.059]                     muffled <- FALSE
[11:41:49.059]                     if (inherits(cond, "message")) {
[11:41:49.059]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:49.059]                       if (muffled) 
[11:41:49.059]                         invokeRestart("muffleMessage")
[11:41:49.059]                     }
[11:41:49.059]                     else if (inherits(cond, "warning")) {
[11:41:49.059]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:49.059]                       if (muffled) 
[11:41:49.059]                         invokeRestart("muffleWarning")
[11:41:49.059]                     }
[11:41:49.059]                     else if (inherits(cond, "condition")) {
[11:41:49.059]                       if (!is.null(pattern)) {
[11:41:49.059]                         computeRestarts <- base::computeRestarts
[11:41:49.059]                         grepl <- base::grepl
[11:41:49.059]                         restarts <- computeRestarts(cond)
[11:41:49.059]                         for (restart in restarts) {
[11:41:49.059]                           name <- restart$name
[11:41:49.059]                           if (is.null(name)) 
[11:41:49.059]                             next
[11:41:49.059]                           if (!grepl(pattern, name)) 
[11:41:49.059]                             next
[11:41:49.059]                           invokeRestart(restart)
[11:41:49.059]                           muffled <- TRUE
[11:41:49.059]                           break
[11:41:49.059]                         }
[11:41:49.059]                       }
[11:41:49.059]                     }
[11:41:49.059]                     invisible(muffled)
[11:41:49.059]                   }
[11:41:49.059]                   muffleCondition(cond)
[11:41:49.059]                 })
[11:41:49.059]             }))
[11:41:49.059]             future::FutureResult(value = ...future.value$value, 
[11:41:49.059]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:49.059]                   ...future.rng), globalenv = if (FALSE) 
[11:41:49.059]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:49.059]                     ...future.globalenv.names))
[11:41:49.059]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:49.059]         }, condition = base::local({
[11:41:49.059]             c <- base::c
[11:41:49.059]             inherits <- base::inherits
[11:41:49.059]             invokeRestart <- base::invokeRestart
[11:41:49.059]             length <- base::length
[11:41:49.059]             list <- base::list
[11:41:49.059]             seq.int <- base::seq.int
[11:41:49.059]             signalCondition <- base::signalCondition
[11:41:49.059]             sys.calls <- base::sys.calls
[11:41:49.059]             `[[` <- base::`[[`
[11:41:49.059]             `+` <- base::`+`
[11:41:49.059]             `<<-` <- base::`<<-`
[11:41:49.059]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:49.059]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:49.059]                   3L)]
[11:41:49.059]             }
[11:41:49.059]             function(cond) {
[11:41:49.059]                 is_error <- inherits(cond, "error")
[11:41:49.059]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:49.059]                   NULL)
[11:41:49.059]                 if (is_error) {
[11:41:49.059]                   sessionInformation <- function() {
[11:41:49.059]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:49.059]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:49.059]                       search = base::search(), system = base::Sys.info())
[11:41:49.059]                   }
[11:41:49.059]                   ...future.conditions[[length(...future.conditions) + 
[11:41:49.059]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:49.059]                     cond$call), session = sessionInformation(), 
[11:41:49.059]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:49.059]                   signalCondition(cond)
[11:41:49.059]                 }
[11:41:49.059]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:49.059]                 "immediateCondition"))) {
[11:41:49.059]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:49.059]                   ...future.conditions[[length(...future.conditions) + 
[11:41:49.059]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:49.059]                   if (TRUE && !signal) {
[11:41:49.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:49.059]                     {
[11:41:49.059]                       inherits <- base::inherits
[11:41:49.059]                       invokeRestart <- base::invokeRestart
[11:41:49.059]                       is.null <- base::is.null
[11:41:49.059]                       muffled <- FALSE
[11:41:49.059]                       if (inherits(cond, "message")) {
[11:41:49.059]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:49.059]                         if (muffled) 
[11:41:49.059]                           invokeRestart("muffleMessage")
[11:41:49.059]                       }
[11:41:49.059]                       else if (inherits(cond, "warning")) {
[11:41:49.059]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:49.059]                         if (muffled) 
[11:41:49.059]                           invokeRestart("muffleWarning")
[11:41:49.059]                       }
[11:41:49.059]                       else if (inherits(cond, "condition")) {
[11:41:49.059]                         if (!is.null(pattern)) {
[11:41:49.059]                           computeRestarts <- base::computeRestarts
[11:41:49.059]                           grepl <- base::grepl
[11:41:49.059]                           restarts <- computeRestarts(cond)
[11:41:49.059]                           for (restart in restarts) {
[11:41:49.059]                             name <- restart$name
[11:41:49.059]                             if (is.null(name)) 
[11:41:49.059]                               next
[11:41:49.059]                             if (!grepl(pattern, name)) 
[11:41:49.059]                               next
[11:41:49.059]                             invokeRestart(restart)
[11:41:49.059]                             muffled <- TRUE
[11:41:49.059]                             break
[11:41:49.059]                           }
[11:41:49.059]                         }
[11:41:49.059]                       }
[11:41:49.059]                       invisible(muffled)
[11:41:49.059]                     }
[11:41:49.059]                     muffleCondition(cond, pattern = "^muffle")
[11:41:49.059]                   }
[11:41:49.059]                 }
[11:41:49.059]                 else {
[11:41:49.059]                   if (TRUE) {
[11:41:49.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:49.059]                     {
[11:41:49.059]                       inherits <- base::inherits
[11:41:49.059]                       invokeRestart <- base::invokeRestart
[11:41:49.059]                       is.null <- base::is.null
[11:41:49.059]                       muffled <- FALSE
[11:41:49.059]                       if (inherits(cond, "message")) {
[11:41:49.059]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:49.059]                         if (muffled) 
[11:41:49.059]                           invokeRestart("muffleMessage")
[11:41:49.059]                       }
[11:41:49.059]                       else if (inherits(cond, "warning")) {
[11:41:49.059]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:49.059]                         if (muffled) 
[11:41:49.059]                           invokeRestart("muffleWarning")
[11:41:49.059]                       }
[11:41:49.059]                       else if (inherits(cond, "condition")) {
[11:41:49.059]                         if (!is.null(pattern)) {
[11:41:49.059]                           computeRestarts <- base::computeRestarts
[11:41:49.059]                           grepl <- base::grepl
[11:41:49.059]                           restarts <- computeRestarts(cond)
[11:41:49.059]                           for (restart in restarts) {
[11:41:49.059]                             name <- restart$name
[11:41:49.059]                             if (is.null(name)) 
[11:41:49.059]                               next
[11:41:49.059]                             if (!grepl(pattern, name)) 
[11:41:49.059]                               next
[11:41:49.059]                             invokeRestart(restart)
[11:41:49.059]                             muffled <- TRUE
[11:41:49.059]                             break
[11:41:49.059]                           }
[11:41:49.059]                         }
[11:41:49.059]                       }
[11:41:49.059]                       invisible(muffled)
[11:41:49.059]                     }
[11:41:49.059]                     muffleCondition(cond, pattern = "^muffle")
[11:41:49.059]                   }
[11:41:49.059]                 }
[11:41:49.059]             }
[11:41:49.059]         }))
[11:41:49.059]     }, error = function(ex) {
[11:41:49.059]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:49.059]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:49.059]                 ...future.rng), started = ...future.startTime, 
[11:41:49.059]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:49.059]             version = "1.8"), class = "FutureResult")
[11:41:49.059]     }, finally = {
[11:41:49.059]         if (!identical(...future.workdir, getwd())) 
[11:41:49.059]             setwd(...future.workdir)
[11:41:49.059]         {
[11:41:49.059]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:49.059]                 ...future.oldOptions$nwarnings <- NULL
[11:41:49.059]             }
[11:41:49.059]             base::options(...future.oldOptions)
[11:41:49.059]             if (.Platform$OS.type == "windows") {
[11:41:49.059]                 old_names <- names(...future.oldEnvVars)
[11:41:49.059]                 envs <- base::Sys.getenv()
[11:41:49.059]                 names <- names(envs)
[11:41:49.059]                 common <- intersect(names, old_names)
[11:41:49.059]                 added <- setdiff(names, old_names)
[11:41:49.059]                 removed <- setdiff(old_names, names)
[11:41:49.059]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:49.059]                   envs[common]]
[11:41:49.059]                 NAMES <- toupper(changed)
[11:41:49.059]                 args <- list()
[11:41:49.059]                 for (kk in seq_along(NAMES)) {
[11:41:49.059]                   name <- changed[[kk]]
[11:41:49.059]                   NAME <- NAMES[[kk]]
[11:41:49.059]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:49.059]                     next
[11:41:49.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:49.059]                 }
[11:41:49.059]                 NAMES <- toupper(added)
[11:41:49.059]                 for (kk in seq_along(NAMES)) {
[11:41:49.059]                   name <- added[[kk]]
[11:41:49.059]                   NAME <- NAMES[[kk]]
[11:41:49.059]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:49.059]                     next
[11:41:49.059]                   args[[name]] <- ""
[11:41:49.059]                 }
[11:41:49.059]                 NAMES <- toupper(removed)
[11:41:49.059]                 for (kk in seq_along(NAMES)) {
[11:41:49.059]                   name <- removed[[kk]]
[11:41:49.059]                   NAME <- NAMES[[kk]]
[11:41:49.059]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:49.059]                     next
[11:41:49.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:49.059]                 }
[11:41:49.059]                 if (length(args) > 0) 
[11:41:49.059]                   base::do.call(base::Sys.setenv, args = args)
[11:41:49.059]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:49.059]             }
[11:41:49.059]             else {
[11:41:49.059]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:49.059]             }
[11:41:49.059]             {
[11:41:49.059]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:49.059]                   0L) {
[11:41:49.059]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:49.059]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:49.059]                   base::options(opts)
[11:41:49.059]                 }
[11:41:49.059]                 {
[11:41:49.059]                   {
[11:41:49.059]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:49.059]                     NULL
[11:41:49.059]                   }
[11:41:49.059]                   options(future.plan = NULL)
[11:41:49.059]                   if (is.na(NA_character_)) 
[11:41:49.059]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:49.059]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:49.059]                   future::plan(list(function (..., workers = 2, 
[11:41:49.059]                     envir = parent.frame()) 
[11:41:49.059]                   strategy(..., workers = workers, envir = envir)), 
[11:41:49.059]                     .cleanup = FALSE, .init = FALSE)
[11:41:49.059]                 }
[11:41:49.059]             }
[11:41:49.059]         }
[11:41:49.059]     })
[11:41:49.059]     if (TRUE) {
[11:41:49.059]         base::sink(type = "output", split = FALSE)
[11:41:49.059]         if (TRUE) {
[11:41:49.059]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:49.059]         }
[11:41:49.059]         else {
[11:41:49.059]             ...future.result["stdout"] <- base::list(NULL)
[11:41:49.059]         }
[11:41:49.059]         base::close(...future.stdout)
[11:41:49.059]         ...future.stdout <- NULL
[11:41:49.059]     }
[11:41:49.059]     ...future.result$conditions <- ...future.conditions
[11:41:49.059]     ...future.result$finished <- base::Sys.time()
[11:41:49.059]     ...future.result
[11:41:49.059] }
[11:41:49.060] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:49.071] receiveMessageFromWorker() for ClusterFuture ...
[11:41:49.072] - Validating connection of MultisessionFuture
[11:41:49.072] - received message: FutureResult
[11:41:49.072] - Received FutureResult
[11:41:49.072] - Erased future from FutureRegistry
[11:41:49.072] result() for ClusterFuture ...
[11:41:49.072] - result already collected: FutureResult
[11:41:49.072] result() for ClusterFuture ... done
[11:41:49.072] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:49.073] result() for ClusterFuture ...
[11:41:49.073] - result already collected: FutureResult
[11:41:49.073] result() for ClusterFuture ... done
[11:41:49.073] result() for ClusterFuture ...
[11:41:49.073] - result already collected: FutureResult
[11:41:49.073] result() for ClusterFuture ... done
[11:41:49.074] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:49.074] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:49.118] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:49.128] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:49.174] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:49.175] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:49.226] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:49.226] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:49.228] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:49.228] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:49.229] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:49.230] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:49.231] MultisessionFuture started
[11:41:49.236] - Launch lazy future ... done
[11:41:49.236] run() for ‘MultisessionFuture’ ... done
[11:41:49.236] Created future:
[11:41:49.236] MultisessionFuture:
[11:41:49.236] Label: ‘future_mapply-18’
[11:41:49.236] Expression:
[11:41:49.236] {
[11:41:49.236]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:49.236]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:49.236]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:49.236]         on.exit(options(oopts), add = TRUE)
[11:41:49.236]     }
[11:41:49.236]     {
[11:41:49.236]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:49.236]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:49.236]                 inherits = FALSE)
[11:41:49.236]             ...future.FUN(...)
[11:41:49.236]         }
[11:41:49.236]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:49.236]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:49.236]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:49.236]         do.call(mapply, args = args)
[11:41:49.236]     }
[11:41:49.236] }
[11:41:49.236] Lazy evaluation: FALSE
[11:41:49.236] Asynchronous evaluation: TRUE
[11:41:49.236] Local evaluation: TRUE
[11:41:49.236] Environment: 0x560ef58e1768
[11:41:49.236] Capture standard output: TRUE
[11:41:49.236] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:49.236] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:49.236] Packages: 1 packages (‘mlr3’)
[11:41:49.236] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:49.236] Resolved: FALSE
[11:41:49.236] Value: <not collected>
[11:41:49.236] Conditions captured: <none>
[11:41:49.236] Early signaling: FALSE
[11:41:49.236] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:49.236] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:49.251] Chunk #18 of 90 ... DONE
[11:41:49.251] Chunk #19 of 90 ...
[11:41:49.251]  - seeds: [1] <seeds>
[11:41:49.251] getGlobalsAndPackages() ...
[11:41:49.251] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:49.251] Resolving globals: FALSE
[11:41:49.252] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:49.252] - packages: [1] ‘mlr3’
[11:41:49.252] getGlobalsAndPackages() ... DONE
[11:41:49.252] run() for ‘Future’ ...
[11:41:49.252] - state: ‘created’
[11:41:49.252] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:49.261] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:49.261] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:49.261]   - Field: ‘node’
[11:41:49.261]   - Field: ‘label’
[11:41:49.261]   - Field: ‘local’
[11:41:49.261]   - Field: ‘owner’
[11:41:49.261]   - Field: ‘envir’
[11:41:49.261]   - Field: ‘workers’
[11:41:49.261]   - Field: ‘packages’
[11:41:49.261]   - Field: ‘gc’
[11:41:49.261]   - Field: ‘conditions’
[11:41:49.261]   - Field: ‘persistent’
[11:41:49.261]   - Field: ‘expr’
[11:41:49.261]   - Field: ‘uuid’
[11:41:49.261]   - Field: ‘seed’
[11:41:49.261]   - Field: ‘version’
[11:41:49.261]   - Field: ‘result’
[11:41:49.261]   - Field: ‘asynchronous’
[11:41:49.261]   - Field: ‘calls’
[11:41:49.262]   - Field: ‘globals’
[11:41:49.262]   - Field: ‘stdout’
[11:41:49.262]   - Field: ‘earlySignal’
[11:41:49.262]   - Field: ‘lazy’
[11:41:49.262]   - Field: ‘state’
[11:41:49.262] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:49.262] - Launch lazy future ...
[11:41:49.262] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:49.262] Packages needed by future strategies (n = 0): <none>
[11:41:49.262] {
[11:41:49.262]     {
[11:41:49.262]         {
[11:41:49.262]             ...future.startTime <- base::Sys.time()
[11:41:49.262]             {
[11:41:49.262]                 {
[11:41:49.262]                   {
[11:41:49.262]                     {
[11:41:49.262]                       {
[11:41:49.262]                         base::local({
[11:41:49.262]                           has_future <- base::requireNamespace("future", 
[11:41:49.262]                             quietly = TRUE)
[11:41:49.262]                           if (has_future) {
[11:41:49.262]                             ns <- base::getNamespace("future")
[11:41:49.262]                             version <- ns[[".package"]][["version"]]
[11:41:49.262]                             if (is.null(version)) 
[11:41:49.262]                               version <- utils::packageVersion("future")
[11:41:49.262]                           }
[11:41:49.262]                           else {
[11:41:49.262]                             version <- NULL
[11:41:49.262]                           }
[11:41:49.262]                           if (!has_future || version < "1.8.0") {
[11:41:49.262]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:49.262]                               "", base::R.version$version.string), 
[11:41:49.262]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:49.262]                                 base::R.version$platform, 8 * 
[11:41:49.262]                                   base::.Machine$sizeof.pointer), 
[11:41:49.262]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:49.262]                                 "release", "version")], collapse = " "), 
[11:41:49.262]                               hostname = base::Sys.info()[["nodename"]])
[11:41:49.262]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:49.262]                               info)
[11:41:49.262]                             info <- base::paste(info, collapse = "; ")
[11:41:49.262]                             if (!has_future) {
[11:41:49.262]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:49.262]                                 info)
[11:41:49.262]                             }
[11:41:49.262]                             else {
[11:41:49.262]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:49.262]                                 info, version)
[11:41:49.262]                             }
[11:41:49.262]                             base::stop(msg)
[11:41:49.262]                           }
[11:41:49.262]                         })
[11:41:49.262]                       }
[11:41:49.262]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:49.262]                       base::options(mc.cores = 1L)
[11:41:49.262]                     }
[11:41:49.262]                     base::local({
[11:41:49.262]                       for (pkg in "mlr3") {
[11:41:49.262]                         base::loadNamespace(pkg)
[11:41:49.262]                         base::library(pkg, character.only = TRUE)
[11:41:49.262]                       }
[11:41:49.262]                     })
[11:41:49.262]                   }
[11:41:49.262]                   options(future.plan = NULL)
[11:41:49.262]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:49.262]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:49.262]                 }
[11:41:49.262]                 ...future.workdir <- getwd()
[11:41:49.262]             }
[11:41:49.262]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:49.262]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:49.262]         }
[11:41:49.262]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:49.262]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:49.262]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:49.262]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:49.262]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:49.262]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:49.262]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:49.262]             base::names(...future.oldOptions))
[11:41:49.262]     }
[11:41:49.262]     if (FALSE) {
[11:41:49.262]     }
[11:41:49.262]     else {
[11:41:49.262]         if (TRUE) {
[11:41:49.262]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:49.262]                 open = "w")
[11:41:49.262]         }
[11:41:49.262]         else {
[11:41:49.262]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:49.262]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:49.262]         }
[11:41:49.262]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:49.262]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:49.262]             base::sink(type = "output", split = FALSE)
[11:41:49.262]             base::close(...future.stdout)
[11:41:49.262]         }, add = TRUE)
[11:41:49.262]     }
[11:41:49.262]     ...future.frame <- base::sys.nframe()
[11:41:49.262]     ...future.conditions <- base::list()
[11:41:49.262]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:49.262]     if (FALSE) {
[11:41:49.262]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:49.262]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:49.262]     }
[11:41:49.262]     ...future.result <- base::tryCatch({
[11:41:49.262]         base::withCallingHandlers({
[11:41:49.262]             ...future.value <- base::withVisible(base::local({
[11:41:49.262]                 ...future.makeSendCondition <- local({
[11:41:49.262]                   sendCondition <- NULL
[11:41:49.262]                   function(frame = 1L) {
[11:41:49.262]                     if (is.function(sendCondition)) 
[11:41:49.262]                       return(sendCondition)
[11:41:49.262]                     ns <- getNamespace("parallel")
[11:41:49.262]                     if (exists("sendData", mode = "function", 
[11:41:49.262]                       envir = ns)) {
[11:41:49.262]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:49.262]                         envir = ns)
[11:41:49.262]                       envir <- sys.frame(frame)
[11:41:49.262]                       master <- NULL
[11:41:49.262]                       while (!identical(envir, .GlobalEnv) && 
[11:41:49.262]                         !identical(envir, emptyenv())) {
[11:41:49.262]                         if (exists("master", mode = "list", envir = envir, 
[11:41:49.262]                           inherits = FALSE)) {
[11:41:49.262]                           master <- get("master", mode = "list", 
[11:41:49.262]                             envir = envir, inherits = FALSE)
[11:41:49.262]                           if (inherits(master, c("SOCKnode", 
[11:41:49.262]                             "SOCK0node"))) {
[11:41:49.262]                             sendCondition <<- function(cond) {
[11:41:49.262]                               data <- list(type = "VALUE", value = cond, 
[11:41:49.262]                                 success = TRUE)
[11:41:49.262]                               parallel_sendData(master, data)
[11:41:49.262]                             }
[11:41:49.262]                             return(sendCondition)
[11:41:49.262]                           }
[11:41:49.262]                         }
[11:41:49.262]                         frame <- frame + 1L
[11:41:49.262]                         envir <- sys.frame(frame)
[11:41:49.262]                       }
[11:41:49.262]                     }
[11:41:49.262]                     sendCondition <<- function(cond) NULL
[11:41:49.262]                   }
[11:41:49.262]                 })
[11:41:49.262]                 withCallingHandlers({
[11:41:49.262]                   {
[11:41:49.262]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:49.262]                     if (!identical(...future.globals.maxSize.org, 
[11:41:49.262]                       ...future.globals.maxSize)) {
[11:41:49.262]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:49.262]                       on.exit(options(oopts), add = TRUE)
[11:41:49.262]                     }
[11:41:49.262]                     {
[11:41:49.262]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:49.262]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:49.262]                           envir = globalenv(), inherits = FALSE)
[11:41:49.262]                         ...future.FUN(...)
[11:41:49.262]                       }
[11:41:49.262]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:49.262]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:49.262]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:49.262]                         USE.NAMES = FALSE)
[11:41:49.262]                       do.call(mapply, args = args)
[11:41:49.262]                     }
[11:41:49.262]                   }
[11:41:49.262]                 }, immediateCondition = function(cond) {
[11:41:49.262]                   sendCondition <- ...future.makeSendCondition()
[11:41:49.262]                   sendCondition(cond)
[11:41:49.262]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:49.262]                   {
[11:41:49.262]                     inherits <- base::inherits
[11:41:49.262]                     invokeRestart <- base::invokeRestart
[11:41:49.262]                     is.null <- base::is.null
[11:41:49.262]                     muffled <- FALSE
[11:41:49.262]                     if (inherits(cond, "message")) {
[11:41:49.262]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:49.262]                       if (muffled) 
[11:41:49.262]                         invokeRestart("muffleMessage")
[11:41:49.262]                     }
[11:41:49.262]                     else if (inherits(cond, "warning")) {
[11:41:49.262]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:49.262]                       if (muffled) 
[11:41:49.262]                         invokeRestart("muffleWarning")
[11:41:49.262]                     }
[11:41:49.262]                     else if (inherits(cond, "condition")) {
[11:41:49.262]                       if (!is.null(pattern)) {
[11:41:49.262]                         computeRestarts <- base::computeRestarts
[11:41:49.262]                         grepl <- base::grepl
[11:41:49.262]                         restarts <- computeRestarts(cond)
[11:41:49.262]                         for (restart in restarts) {
[11:41:49.262]                           name <- restart$name
[11:41:49.262]                           if (is.null(name)) 
[11:41:49.262]                             next
[11:41:49.262]                           if (!grepl(pattern, name)) 
[11:41:49.262]                             next
[11:41:49.262]                           invokeRestart(restart)
[11:41:49.262]                           muffled <- TRUE
[11:41:49.262]                           break
[11:41:49.262]                         }
[11:41:49.262]                       }
[11:41:49.262]                     }
[11:41:49.262]                     invisible(muffled)
[11:41:49.262]                   }
[11:41:49.262]                   muffleCondition(cond)
[11:41:49.262]                 })
[11:41:49.262]             }))
[11:41:49.262]             future::FutureResult(value = ...future.value$value, 
[11:41:49.262]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:49.262]                   ...future.rng), globalenv = if (FALSE) 
[11:41:49.262]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:49.262]                     ...future.globalenv.names))
[11:41:49.262]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:49.262]         }, condition = base::local({
[11:41:49.262]             c <- base::c
[11:41:49.262]             inherits <- base::inherits
[11:41:49.262]             invokeRestart <- base::invokeRestart
[11:41:49.262]             length <- base::length
[11:41:49.262]             list <- base::list
[11:41:49.262]             seq.int <- base::seq.int
[11:41:49.262]             signalCondition <- base::signalCondition
[11:41:49.262]             sys.calls <- base::sys.calls
[11:41:49.262]             `[[` <- base::`[[`
[11:41:49.262]             `+` <- base::`+`
[11:41:49.262]             `<<-` <- base::`<<-`
[11:41:49.262]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:49.262]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:49.262]                   3L)]
[11:41:49.262]             }
[11:41:49.262]             function(cond) {
[11:41:49.262]                 is_error <- inherits(cond, "error")
[11:41:49.262]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:49.262]                   NULL)
[11:41:49.262]                 if (is_error) {
[11:41:49.262]                   sessionInformation <- function() {
[11:41:49.262]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:49.262]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:49.262]                       search = base::search(), system = base::Sys.info())
[11:41:49.262]                   }
[11:41:49.262]                   ...future.conditions[[length(...future.conditions) + 
[11:41:49.262]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:49.262]                     cond$call), session = sessionInformation(), 
[11:41:49.262]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:49.262]                   signalCondition(cond)
[11:41:49.262]                 }
[11:41:49.262]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:49.262]                 "immediateCondition"))) {
[11:41:49.262]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:49.262]                   ...future.conditions[[length(...future.conditions) + 
[11:41:49.262]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:49.262]                   if (TRUE && !signal) {
[11:41:49.262]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:49.262]                     {
[11:41:49.262]                       inherits <- base::inherits
[11:41:49.262]                       invokeRestart <- base::invokeRestart
[11:41:49.262]                       is.null <- base::is.null
[11:41:49.262]                       muffled <- FALSE
[11:41:49.262]                       if (inherits(cond, "message")) {
[11:41:49.262]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:49.262]                         if (muffled) 
[11:41:49.262]                           invokeRestart("muffleMessage")
[11:41:49.262]                       }
[11:41:49.262]                       else if (inherits(cond, "warning")) {
[11:41:49.262]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:49.262]                         if (muffled) 
[11:41:49.262]                           invokeRestart("muffleWarning")
[11:41:49.262]                       }
[11:41:49.262]                       else if (inherits(cond, "condition")) {
[11:41:49.262]                         if (!is.null(pattern)) {
[11:41:49.262]                           computeRestarts <- base::computeRestarts
[11:41:49.262]                           grepl <- base::grepl
[11:41:49.262]                           restarts <- computeRestarts(cond)
[11:41:49.262]                           for (restart in restarts) {
[11:41:49.262]                             name <- restart$name
[11:41:49.262]                             if (is.null(name)) 
[11:41:49.262]                               next
[11:41:49.262]                             if (!grepl(pattern, name)) 
[11:41:49.262]                               next
[11:41:49.262]                             invokeRestart(restart)
[11:41:49.262]                             muffled <- TRUE
[11:41:49.262]                             break
[11:41:49.262]                           }
[11:41:49.262]                         }
[11:41:49.262]                       }
[11:41:49.262]                       invisible(muffled)
[11:41:49.262]                     }
[11:41:49.262]                     muffleCondition(cond, pattern = "^muffle")
[11:41:49.262]                   }
[11:41:49.262]                 }
[11:41:49.262]                 else {
[11:41:49.262]                   if (TRUE) {
[11:41:49.262]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:49.262]                     {
[11:41:49.262]                       inherits <- base::inherits
[11:41:49.262]                       invokeRestart <- base::invokeRestart
[11:41:49.262]                       is.null <- base::is.null
[11:41:49.262]                       muffled <- FALSE
[11:41:49.262]                       if (inherits(cond, "message")) {
[11:41:49.262]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:49.262]                         if (muffled) 
[11:41:49.262]                           invokeRestart("muffleMessage")
[11:41:49.262]                       }
[11:41:49.262]                       else if (inherits(cond, "warning")) {
[11:41:49.262]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:49.262]                         if (muffled) 
[11:41:49.262]                           invokeRestart("muffleWarning")
[11:41:49.262]                       }
[11:41:49.262]                       else if (inherits(cond, "condition")) {
[11:41:49.262]                         if (!is.null(pattern)) {
[11:41:49.262]                           computeRestarts <- base::computeRestarts
[11:41:49.262]                           grepl <- base::grepl
[11:41:49.262]                           restarts <- computeRestarts(cond)
[11:41:49.262]                           for (restart in restarts) {
[11:41:49.262]                             name <- restart$name
[11:41:49.262]                             if (is.null(name)) 
[11:41:49.262]                               next
[11:41:49.262]                             if (!grepl(pattern, name)) 
[11:41:49.262]                               next
[11:41:49.262]                             invokeRestart(restart)
[11:41:49.262]                             muffled <- TRUE
[11:41:49.262]                             break
[11:41:49.262]                           }
[11:41:49.262]                         }
[11:41:49.262]                       }
[11:41:49.262]                       invisible(muffled)
[11:41:49.262]                     }
[11:41:49.262]                     muffleCondition(cond, pattern = "^muffle")
[11:41:49.262]                   }
[11:41:49.262]                 }
[11:41:49.262]             }
[11:41:49.262]         }))
[11:41:49.262]     }, error = function(ex) {
[11:41:49.262]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:49.262]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:49.262]                 ...future.rng), started = ...future.startTime, 
[11:41:49.262]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:49.262]             version = "1.8"), class = "FutureResult")
[11:41:49.262]     }, finally = {
[11:41:49.262]         if (!identical(...future.workdir, getwd())) 
[11:41:49.262]             setwd(...future.workdir)
[11:41:49.262]         {
[11:41:49.262]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:49.262]                 ...future.oldOptions$nwarnings <- NULL
[11:41:49.262]             }
[11:41:49.262]             base::options(...future.oldOptions)
[11:41:49.262]             if (.Platform$OS.type == "windows") {
[11:41:49.262]                 old_names <- names(...future.oldEnvVars)
[11:41:49.262]                 envs <- base::Sys.getenv()
[11:41:49.262]                 names <- names(envs)
[11:41:49.262]                 common <- intersect(names, old_names)
[11:41:49.262]                 added <- setdiff(names, old_names)
[11:41:49.262]                 removed <- setdiff(old_names, names)
[11:41:49.262]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:49.262]                   envs[common]]
[11:41:49.262]                 NAMES <- toupper(changed)
[11:41:49.262]                 args <- list()
[11:41:49.262]                 for (kk in seq_along(NAMES)) {
[11:41:49.262]                   name <- changed[[kk]]
[11:41:49.262]                   NAME <- NAMES[[kk]]
[11:41:49.262]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:49.262]                     next
[11:41:49.262]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:49.262]                 }
[11:41:49.262]                 NAMES <- toupper(added)
[11:41:49.262]                 for (kk in seq_along(NAMES)) {
[11:41:49.262]                   name <- added[[kk]]
[11:41:49.262]                   NAME <- NAMES[[kk]]
[11:41:49.262]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:49.262]                     next
[11:41:49.262]                   args[[name]] <- ""
[11:41:49.262]                 }
[11:41:49.262]                 NAMES <- toupper(removed)
[11:41:49.262]                 for (kk in seq_along(NAMES)) {
[11:41:49.262]                   name <- removed[[kk]]
[11:41:49.262]                   NAME <- NAMES[[kk]]
[11:41:49.262]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:49.262]                     next
[11:41:49.262]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:49.262]                 }
[11:41:49.262]                 if (length(args) > 0) 
[11:41:49.262]                   base::do.call(base::Sys.setenv, args = args)
[11:41:49.262]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:49.262]             }
[11:41:49.262]             else {
[11:41:49.262]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:49.262]             }
[11:41:49.262]             {
[11:41:49.262]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:49.262]                   0L) {
[11:41:49.262]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:49.262]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:49.262]                   base::options(opts)
[11:41:49.262]                 }
[11:41:49.262]                 {
[11:41:49.262]                   {
[11:41:49.262]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:49.262]                     NULL
[11:41:49.262]                   }
[11:41:49.262]                   options(future.plan = NULL)
[11:41:49.262]                   if (is.na(NA_character_)) 
[11:41:49.262]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:49.262]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:49.262]                   future::plan(list(function (..., workers = 2, 
[11:41:49.262]                     envir = parent.frame()) 
[11:41:49.262]                   strategy(..., workers = workers, envir = envir)), 
[11:41:49.262]                     .cleanup = FALSE, .init = FALSE)
[11:41:49.262]                 }
[11:41:49.262]             }
[11:41:49.262]         }
[11:41:49.262]     })
[11:41:49.262]     if (TRUE) {
[11:41:49.262]         base::sink(type = "output", split = FALSE)
[11:41:49.262]         if (TRUE) {
[11:41:49.262]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:49.262]         }
[11:41:49.262]         else {
[11:41:49.262]             ...future.result["stdout"] <- base::list(NULL)
[11:41:49.262]         }
[11:41:49.262]         base::close(...future.stdout)
[11:41:49.262]         ...future.stdout <- NULL
[11:41:49.262]     }
[11:41:49.262]     ...future.result$conditions <- ...future.conditions
[11:41:49.262]     ...future.result$finished <- base::Sys.time()
[11:41:49.262]     ...future.result
[11:41:49.262] }
[11:41:49.264] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:49.274] receiveMessageFromWorker() for ClusterFuture ...
[11:41:49.275] - Validating connection of MultisessionFuture
[11:41:49.275] - received message: FutureResult
[11:41:49.275] - Received FutureResult
[11:41:49.275] - Erased future from FutureRegistry
[11:41:49.275] result() for ClusterFuture ...
[11:41:49.275] - result already collected: FutureResult
[11:41:49.275] result() for ClusterFuture ... done
[11:41:49.275] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:49.275] result() for ClusterFuture ...
[11:41:49.275] - result already collected: FutureResult
[11:41:49.275] result() for ClusterFuture ... done
[11:41:49.275] result() for ClusterFuture ...
[11:41:49.275] - result already collected: FutureResult
[11:41:49.275] result() for ClusterFuture ... done
[11:41:49.276] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:49.277] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:49.322] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:49.329] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:49.332] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:49.332] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:49.378] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:49.379] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:49.380] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:49.381] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:49.382] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:49.383] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:49.384] MultisessionFuture started
[11:41:49.384] - Launch lazy future ... done
[11:41:49.384] run() for ‘MultisessionFuture’ ... done
[11:41:49.385] Created future:
[11:41:49.385] MultisessionFuture:
[11:41:49.385] Label: ‘future_mapply-19’
[11:41:49.385] Expression:
[11:41:49.385] {
[11:41:49.385]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:49.385]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:49.385]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:49.385]         on.exit(options(oopts), add = TRUE)
[11:41:49.385]     }
[11:41:49.385]     {
[11:41:49.385]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:49.385]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:49.385]                 inherits = FALSE)
[11:41:49.385]             ...future.FUN(...)
[11:41:49.385]         }
[11:41:49.385]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:49.385]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:49.385]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:49.385]         do.call(mapply, args = args)
[11:41:49.385]     }
[11:41:49.385] }
[11:41:49.385] Lazy evaluation: FALSE
[11:41:49.385] Asynchronous evaluation: TRUE
[11:41:49.385] Local evaluation: TRUE
[11:41:49.385] Environment: 0x560ef58e1768
[11:41:49.385] Capture standard output: TRUE
[11:41:49.385] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:49.385] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:49.385] Packages: 1 packages (‘mlr3’)
[11:41:49.385] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:49.385] Resolved: FALSE
[11:41:49.385] Value: <not collected>
[11:41:49.385] Conditions captured: <none>
[11:41:49.385] Early signaling: FALSE
[11:41:49.385] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:49.385] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:49.403] Chunk #19 of 90 ... DONE
[11:41:49.404] Chunk #20 of 90 ...
[11:41:49.404]  - seeds: [1] <seeds>
[11:41:49.404] getGlobalsAndPackages() ...
[11:41:49.404] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:49.404] Resolving globals: FALSE
[11:41:49.405] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:49.405] - packages: [1] ‘mlr3’
[11:41:49.405] getGlobalsAndPackages() ... DONE
[11:41:49.406] run() for ‘Future’ ...
[11:41:49.406] - state: ‘created’
[11:41:49.406] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:49.421] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:49.422] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:49.422]   - Field: ‘node’
[11:41:49.422]   - Field: ‘label’
[11:41:49.422]   - Field: ‘local’
[11:41:49.422]   - Field: ‘owner’
[11:41:49.422]   - Field: ‘envir’
[11:41:49.422]   - Field: ‘workers’
[11:41:49.422]   - Field: ‘packages’
[11:41:49.423]   - Field: ‘gc’
[11:41:49.423]   - Field: ‘conditions’
[11:41:49.423]   - Field: ‘persistent’
[11:41:49.423]   - Field: ‘expr’
[11:41:49.423]   - Field: ‘uuid’
[11:41:49.423]   - Field: ‘seed’
[11:41:49.423]   - Field: ‘version’
[11:41:49.423]   - Field: ‘result’
[11:41:49.423]   - Field: ‘asynchronous’
[11:41:49.424]   - Field: ‘calls’
[11:41:49.424]   - Field: ‘globals’
[11:41:49.424]   - Field: ‘stdout’
[11:41:49.424]   - Field: ‘earlySignal’
[11:41:49.424]   - Field: ‘lazy’
[11:41:49.424]   - Field: ‘state’
[11:41:49.424] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:49.424] - Launch lazy future ...
[11:41:49.425] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:49.425] Packages needed by future strategies (n = 0): <none>
[11:41:49.426] {
[11:41:49.426]     {
[11:41:49.426]         {
[11:41:49.426]             ...future.startTime <- base::Sys.time()
[11:41:49.426]             {
[11:41:49.426]                 {
[11:41:49.426]                   {
[11:41:49.426]                     {
[11:41:49.426]                       {
[11:41:49.426]                         base::local({
[11:41:49.426]                           has_future <- base::requireNamespace("future", 
[11:41:49.426]                             quietly = TRUE)
[11:41:49.426]                           if (has_future) {
[11:41:49.426]                             ns <- base::getNamespace("future")
[11:41:49.426]                             version <- ns[[".package"]][["version"]]
[11:41:49.426]                             if (is.null(version)) 
[11:41:49.426]                               version <- utils::packageVersion("future")
[11:41:49.426]                           }
[11:41:49.426]                           else {
[11:41:49.426]                             version <- NULL
[11:41:49.426]                           }
[11:41:49.426]                           if (!has_future || version < "1.8.0") {
[11:41:49.426]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:49.426]                               "", base::R.version$version.string), 
[11:41:49.426]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:49.426]                                 base::R.version$platform, 8 * 
[11:41:49.426]                                   base::.Machine$sizeof.pointer), 
[11:41:49.426]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:49.426]                                 "release", "version")], collapse = " "), 
[11:41:49.426]                               hostname = base::Sys.info()[["nodename"]])
[11:41:49.426]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:49.426]                               info)
[11:41:49.426]                             info <- base::paste(info, collapse = "; ")
[11:41:49.426]                             if (!has_future) {
[11:41:49.426]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:49.426]                                 info)
[11:41:49.426]                             }
[11:41:49.426]                             else {
[11:41:49.426]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:49.426]                                 info, version)
[11:41:49.426]                             }
[11:41:49.426]                             base::stop(msg)
[11:41:49.426]                           }
[11:41:49.426]                         })
[11:41:49.426]                       }
[11:41:49.426]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:49.426]                       base::options(mc.cores = 1L)
[11:41:49.426]                     }
[11:41:49.426]                     base::local({
[11:41:49.426]                       for (pkg in "mlr3") {
[11:41:49.426]                         base::loadNamespace(pkg)
[11:41:49.426]                         base::library(pkg, character.only = TRUE)
[11:41:49.426]                       }
[11:41:49.426]                     })
[11:41:49.426]                   }
[11:41:49.426]                   options(future.plan = NULL)
[11:41:49.426]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:49.426]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:49.426]                 }
[11:41:49.426]                 ...future.workdir <- getwd()
[11:41:49.426]             }
[11:41:49.426]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:49.426]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:49.426]         }
[11:41:49.426]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:49.426]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:49.426]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:49.426]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:49.426]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:49.426]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:49.426]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:49.426]             base::names(...future.oldOptions))
[11:41:49.426]     }
[11:41:49.426]     if (FALSE) {
[11:41:49.426]     }
[11:41:49.426]     else {
[11:41:49.426]         if (TRUE) {
[11:41:49.426]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:49.426]                 open = "w")
[11:41:49.426]         }
[11:41:49.426]         else {
[11:41:49.426]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:49.426]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:49.426]         }
[11:41:49.426]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:49.426]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:49.426]             base::sink(type = "output", split = FALSE)
[11:41:49.426]             base::close(...future.stdout)
[11:41:49.426]         }, add = TRUE)
[11:41:49.426]     }
[11:41:49.426]     ...future.frame <- base::sys.nframe()
[11:41:49.426]     ...future.conditions <- base::list()
[11:41:49.426]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:49.426]     if (FALSE) {
[11:41:49.426]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:49.426]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:49.426]     }
[11:41:49.426]     ...future.result <- base::tryCatch({
[11:41:49.426]         base::withCallingHandlers({
[11:41:49.426]             ...future.value <- base::withVisible(base::local({
[11:41:49.426]                 ...future.makeSendCondition <- local({
[11:41:49.426]                   sendCondition <- NULL
[11:41:49.426]                   function(frame = 1L) {
[11:41:49.426]                     if (is.function(sendCondition)) 
[11:41:49.426]                       return(sendCondition)
[11:41:49.426]                     ns <- getNamespace("parallel")
[11:41:49.426]                     if (exists("sendData", mode = "function", 
[11:41:49.426]                       envir = ns)) {
[11:41:49.426]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:49.426]                         envir = ns)
[11:41:49.426]                       envir <- sys.frame(frame)
[11:41:49.426]                       master <- NULL
[11:41:49.426]                       while (!identical(envir, .GlobalEnv) && 
[11:41:49.426]                         !identical(envir, emptyenv())) {
[11:41:49.426]                         if (exists("master", mode = "list", envir = envir, 
[11:41:49.426]                           inherits = FALSE)) {
[11:41:49.426]                           master <- get("master", mode = "list", 
[11:41:49.426]                             envir = envir, inherits = FALSE)
[11:41:49.426]                           if (inherits(master, c("SOCKnode", 
[11:41:49.426]                             "SOCK0node"))) {
[11:41:49.426]                             sendCondition <<- function(cond) {
[11:41:49.426]                               data <- list(type = "VALUE", value = cond, 
[11:41:49.426]                                 success = TRUE)
[11:41:49.426]                               parallel_sendData(master, data)
[11:41:49.426]                             }
[11:41:49.426]                             return(sendCondition)
[11:41:49.426]                           }
[11:41:49.426]                         }
[11:41:49.426]                         frame <- frame + 1L
[11:41:49.426]                         envir <- sys.frame(frame)
[11:41:49.426]                       }
[11:41:49.426]                     }
[11:41:49.426]                     sendCondition <<- function(cond) NULL
[11:41:49.426]                   }
[11:41:49.426]                 })
[11:41:49.426]                 withCallingHandlers({
[11:41:49.426]                   {
[11:41:49.426]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:49.426]                     if (!identical(...future.globals.maxSize.org, 
[11:41:49.426]                       ...future.globals.maxSize)) {
[11:41:49.426]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:49.426]                       on.exit(options(oopts), add = TRUE)
[11:41:49.426]                     }
[11:41:49.426]                     {
[11:41:49.426]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:49.426]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:49.426]                           envir = globalenv(), inherits = FALSE)
[11:41:49.426]                         ...future.FUN(...)
[11:41:49.426]                       }
[11:41:49.426]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:49.426]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:49.426]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:49.426]                         USE.NAMES = FALSE)
[11:41:49.426]                       do.call(mapply, args = args)
[11:41:49.426]                     }
[11:41:49.426]                   }
[11:41:49.426]                 }, immediateCondition = function(cond) {
[11:41:49.426]                   sendCondition <- ...future.makeSendCondition()
[11:41:49.426]                   sendCondition(cond)
[11:41:49.426]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:49.426]                   {
[11:41:49.426]                     inherits <- base::inherits
[11:41:49.426]                     invokeRestart <- base::invokeRestart
[11:41:49.426]                     is.null <- base::is.null
[11:41:49.426]                     muffled <- FALSE
[11:41:49.426]                     if (inherits(cond, "message")) {
[11:41:49.426]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:49.426]                       if (muffled) 
[11:41:49.426]                         invokeRestart("muffleMessage")
[11:41:49.426]                     }
[11:41:49.426]                     else if (inherits(cond, "warning")) {
[11:41:49.426]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:49.426]                       if (muffled) 
[11:41:49.426]                         invokeRestart("muffleWarning")
[11:41:49.426]                     }
[11:41:49.426]                     else if (inherits(cond, "condition")) {
[11:41:49.426]                       if (!is.null(pattern)) {
[11:41:49.426]                         computeRestarts <- base::computeRestarts
[11:41:49.426]                         grepl <- base::grepl
[11:41:49.426]                         restarts <- computeRestarts(cond)
[11:41:49.426]                         for (restart in restarts) {
[11:41:49.426]                           name <- restart$name
[11:41:49.426]                           if (is.null(name)) 
[11:41:49.426]                             next
[11:41:49.426]                           if (!grepl(pattern, name)) 
[11:41:49.426]                             next
[11:41:49.426]                           invokeRestart(restart)
[11:41:49.426]                           muffled <- TRUE
[11:41:49.426]                           break
[11:41:49.426]                         }
[11:41:49.426]                       }
[11:41:49.426]                     }
[11:41:49.426]                     invisible(muffled)
[11:41:49.426]                   }
[11:41:49.426]                   muffleCondition(cond)
[11:41:49.426]                 })
[11:41:49.426]             }))
[11:41:49.426]             future::FutureResult(value = ...future.value$value, 
[11:41:49.426]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:49.426]                   ...future.rng), globalenv = if (FALSE) 
[11:41:49.426]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:49.426]                     ...future.globalenv.names))
[11:41:49.426]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:49.426]         }, condition = base::local({
[11:41:49.426]             c <- base::c
[11:41:49.426]             inherits <- base::inherits
[11:41:49.426]             invokeRestart <- base::invokeRestart
[11:41:49.426]             length <- base::length
[11:41:49.426]             list <- base::list
[11:41:49.426]             seq.int <- base::seq.int
[11:41:49.426]             signalCondition <- base::signalCondition
[11:41:49.426]             sys.calls <- base::sys.calls
[11:41:49.426]             `[[` <- base::`[[`
[11:41:49.426]             `+` <- base::`+`
[11:41:49.426]             `<<-` <- base::`<<-`
[11:41:49.426]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:49.426]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:49.426]                   3L)]
[11:41:49.426]             }
[11:41:49.426]             function(cond) {
[11:41:49.426]                 is_error <- inherits(cond, "error")
[11:41:49.426]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:49.426]                   NULL)
[11:41:49.426]                 if (is_error) {
[11:41:49.426]                   sessionInformation <- function() {
[11:41:49.426]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:49.426]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:49.426]                       search = base::search(), system = base::Sys.info())
[11:41:49.426]                   }
[11:41:49.426]                   ...future.conditions[[length(...future.conditions) + 
[11:41:49.426]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:49.426]                     cond$call), session = sessionInformation(), 
[11:41:49.426]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:49.426]                   signalCondition(cond)
[11:41:49.426]                 }
[11:41:49.426]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:49.426]                 "immediateCondition"))) {
[11:41:49.426]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:49.426]                   ...future.conditions[[length(...future.conditions) + 
[11:41:49.426]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:49.426]                   if (TRUE && !signal) {
[11:41:49.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:49.426]                     {
[11:41:49.426]                       inherits <- base::inherits
[11:41:49.426]                       invokeRestart <- base::invokeRestart
[11:41:49.426]                       is.null <- base::is.null
[11:41:49.426]                       muffled <- FALSE
[11:41:49.426]                       if (inherits(cond, "message")) {
[11:41:49.426]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:49.426]                         if (muffled) 
[11:41:49.426]                           invokeRestart("muffleMessage")
[11:41:49.426]                       }
[11:41:49.426]                       else if (inherits(cond, "warning")) {
[11:41:49.426]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:49.426]                         if (muffled) 
[11:41:49.426]                           invokeRestart("muffleWarning")
[11:41:49.426]                       }
[11:41:49.426]                       else if (inherits(cond, "condition")) {
[11:41:49.426]                         if (!is.null(pattern)) {
[11:41:49.426]                           computeRestarts <- base::computeRestarts
[11:41:49.426]                           grepl <- base::grepl
[11:41:49.426]                           restarts <- computeRestarts(cond)
[11:41:49.426]                           for (restart in restarts) {
[11:41:49.426]                             name <- restart$name
[11:41:49.426]                             if (is.null(name)) 
[11:41:49.426]                               next
[11:41:49.426]                             if (!grepl(pattern, name)) 
[11:41:49.426]                               next
[11:41:49.426]                             invokeRestart(restart)
[11:41:49.426]                             muffled <- TRUE
[11:41:49.426]                             break
[11:41:49.426]                           }
[11:41:49.426]                         }
[11:41:49.426]                       }
[11:41:49.426]                       invisible(muffled)
[11:41:49.426]                     }
[11:41:49.426]                     muffleCondition(cond, pattern = "^muffle")
[11:41:49.426]                   }
[11:41:49.426]                 }
[11:41:49.426]                 else {
[11:41:49.426]                   if (TRUE) {
[11:41:49.426]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:49.426]                     {
[11:41:49.426]                       inherits <- base::inherits
[11:41:49.426]                       invokeRestart <- base::invokeRestart
[11:41:49.426]                       is.null <- base::is.null
[11:41:49.426]                       muffled <- FALSE
[11:41:49.426]                       if (inherits(cond, "message")) {
[11:41:49.426]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:49.426]                         if (muffled) 
[11:41:49.426]                           invokeRestart("muffleMessage")
[11:41:49.426]                       }
[11:41:49.426]                       else if (inherits(cond, "warning")) {
[11:41:49.426]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:49.426]                         if (muffled) 
[11:41:49.426]                           invokeRestart("muffleWarning")
[11:41:49.426]                       }
[11:41:49.426]                       else if (inherits(cond, "condition")) {
[11:41:49.426]                         if (!is.null(pattern)) {
[11:41:49.426]                           computeRestarts <- base::computeRestarts
[11:41:49.426]                           grepl <- base::grepl
[11:41:49.426]                           restarts <- computeRestarts(cond)
[11:41:49.426]                           for (restart in restarts) {
[11:41:49.426]                             name <- restart$name
[11:41:49.426]                             if (is.null(name)) 
[11:41:49.426]                               next
[11:41:49.426]                             if (!grepl(pattern, name)) 
[11:41:49.426]                               next
[11:41:49.426]                             invokeRestart(restart)
[11:41:49.426]                             muffled <- TRUE
[11:41:49.426]                             break
[11:41:49.426]                           }
[11:41:49.426]                         }
[11:41:49.426]                       }
[11:41:49.426]                       invisible(muffled)
[11:41:49.426]                     }
[11:41:49.426]                     muffleCondition(cond, pattern = "^muffle")
[11:41:49.426]                   }
[11:41:49.426]                 }
[11:41:49.426]             }
[11:41:49.426]         }))
[11:41:49.426]     }, error = function(ex) {
[11:41:49.426]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:49.426]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:49.426]                 ...future.rng), started = ...future.startTime, 
[11:41:49.426]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:49.426]             version = "1.8"), class = "FutureResult")
[11:41:49.426]     }, finally = {
[11:41:49.426]         if (!identical(...future.workdir, getwd())) 
[11:41:49.426]             setwd(...future.workdir)
[11:41:49.426]         {
[11:41:49.426]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:49.426]                 ...future.oldOptions$nwarnings <- NULL
[11:41:49.426]             }
[11:41:49.426]             base::options(...future.oldOptions)
[11:41:49.426]             if (.Platform$OS.type == "windows") {
[11:41:49.426]                 old_names <- names(...future.oldEnvVars)
[11:41:49.426]                 envs <- base::Sys.getenv()
[11:41:49.426]                 names <- names(envs)
[11:41:49.426]                 common <- intersect(names, old_names)
[11:41:49.426]                 added <- setdiff(names, old_names)
[11:41:49.426]                 removed <- setdiff(old_names, names)
[11:41:49.426]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:49.426]                   envs[common]]
[11:41:49.426]                 NAMES <- toupper(changed)
[11:41:49.426]                 args <- list()
[11:41:49.426]                 for (kk in seq_along(NAMES)) {
[11:41:49.426]                   name <- changed[[kk]]
[11:41:49.426]                   NAME <- NAMES[[kk]]
[11:41:49.426]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:49.426]                     next
[11:41:49.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:49.426]                 }
[11:41:49.426]                 NAMES <- toupper(added)
[11:41:49.426]                 for (kk in seq_along(NAMES)) {
[11:41:49.426]                   name <- added[[kk]]
[11:41:49.426]                   NAME <- NAMES[[kk]]
[11:41:49.426]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:49.426]                     next
[11:41:49.426]                   args[[name]] <- ""
[11:41:49.426]                 }
[11:41:49.426]                 NAMES <- toupper(removed)
[11:41:49.426]                 for (kk in seq_along(NAMES)) {
[11:41:49.426]                   name <- removed[[kk]]
[11:41:49.426]                   NAME <- NAMES[[kk]]
[11:41:49.426]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:49.426]                     next
[11:41:49.426]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:49.426]                 }
[11:41:49.426]                 if (length(args) > 0) 
[11:41:49.426]                   base::do.call(base::Sys.setenv, args = args)
[11:41:49.426]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:49.426]             }
[11:41:49.426]             else {
[11:41:49.426]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:49.426]             }
[11:41:49.426]             {
[11:41:49.426]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:49.426]                   0L) {
[11:41:49.426]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:49.426]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:49.426]                   base::options(opts)
[11:41:49.426]                 }
[11:41:49.426]                 {
[11:41:49.426]                   {
[11:41:49.426]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:49.426]                     NULL
[11:41:49.426]                   }
[11:41:49.426]                   options(future.plan = NULL)
[11:41:49.426]                   if (is.na(NA_character_)) 
[11:41:49.426]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:49.426]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:49.426]                   future::plan(list(function (..., workers = 2, 
[11:41:49.426]                     envir = parent.frame()) 
[11:41:49.426]                   strategy(..., workers = workers, envir = envir)), 
[11:41:49.426]                     .cleanup = FALSE, .init = FALSE)
[11:41:49.426]                 }
[11:41:49.426]             }
[11:41:49.426]         }
[11:41:49.426]     })
[11:41:49.426]     if (TRUE) {
[11:41:49.426]         base::sink(type = "output", split = FALSE)
[11:41:49.426]         if (TRUE) {
[11:41:49.426]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:49.426]         }
[11:41:49.426]         else {
[11:41:49.426]             ...future.result["stdout"] <- base::list(NULL)
[11:41:49.426]         }
[11:41:49.426]         base::close(...future.stdout)
[11:41:49.426]         ...future.stdout <- NULL
[11:41:49.426]     }
[11:41:49.426]     ...future.result$conditions <- ...future.conditions
[11:41:49.426]     ...future.result$finished <- base::Sys.time()
[11:41:49.426]     ...future.result
[11:41:49.426] }
[11:41:49.429] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:49.440] receiveMessageFromWorker() for ClusterFuture ...
[11:41:49.440] - Validating connection of MultisessionFuture
[11:41:49.441] - received message: FutureResult
[11:41:49.441] - Received FutureResult
[11:41:49.441] - Erased future from FutureRegistry
[11:41:49.441] result() for ClusterFuture ...
[11:41:49.441] - result already collected: FutureResult
[11:41:49.441] result() for ClusterFuture ... done
[11:41:49.441] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:49.441] result() for ClusterFuture ...
[11:41:49.441] - result already collected: FutureResult
[11:41:49.441] result() for ClusterFuture ... done
[11:41:49.441] result() for ClusterFuture ...
[11:41:49.442] - result already collected: FutureResult
[11:41:49.442] result() for ClusterFuture ... done
[11:41:49.442] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:49.442] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:49.486] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:49.492] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:49.534] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:49.535] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:49.582] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:49.583] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:49.584] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:49.584] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:49.585] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:49.585] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:49.587] MultisessionFuture started
[11:41:49.587] - Launch lazy future ... done
[11:41:49.587] run() for ‘MultisessionFuture’ ... done
[11:41:49.587] Created future:
[11:41:49.587] MultisessionFuture:
[11:41:49.587] Label: ‘future_mapply-20’
[11:41:49.587] Expression:
[11:41:49.587] {
[11:41:49.587]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:49.587]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:49.587]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:49.587]         on.exit(options(oopts), add = TRUE)
[11:41:49.587]     }
[11:41:49.587]     {
[11:41:49.587]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:49.587]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:49.587]                 inherits = FALSE)
[11:41:49.587]             ...future.FUN(...)
[11:41:49.587]         }
[11:41:49.587]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:49.587]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:49.587]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:49.587]         do.call(mapply, args = args)
[11:41:49.587]     }
[11:41:49.587] }
[11:41:49.587] Lazy evaluation: FALSE
[11:41:49.587] Asynchronous evaluation: TRUE
[11:41:49.587] Local evaluation: TRUE
[11:41:49.587] Environment: 0x560ef58e1768
[11:41:49.587] Capture standard output: TRUE
[11:41:49.587] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:49.587] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:49.587] Packages: 1 packages (‘mlr3’)
[11:41:49.587] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:49.587] Resolved: FALSE
[11:41:49.587] Value: <not collected>
[11:41:49.587] Conditions captured: <none>
[11:41:49.587] Early signaling: FALSE
[11:41:49.587] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:49.587] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:49.604] Chunk #20 of 90 ... DONE
[11:41:49.605] Chunk #21 of 90 ...
[11:41:49.605]  - seeds: [1] <seeds>
[11:41:49.605] getGlobalsAndPackages() ...
[11:41:49.605] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:49.605] Resolving globals: FALSE
[11:41:49.606] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:49.606] - packages: [1] ‘mlr3’
[11:41:49.606] getGlobalsAndPackages() ... DONE
[11:41:49.607] run() for ‘Future’ ...
[11:41:49.607] - state: ‘created’
[11:41:49.607] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:49.617] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:49.617] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:49.617]   - Field: ‘node’
[11:41:49.617]   - Field: ‘label’
[11:41:49.617]   - Field: ‘local’
[11:41:49.617]   - Field: ‘owner’
[11:41:49.617]   - Field: ‘envir’
[11:41:49.617]   - Field: ‘workers’
[11:41:49.617]   - Field: ‘packages’
[11:41:49.617]   - Field: ‘gc’
[11:41:49.617]   - Field: ‘conditions’
[11:41:49.617]   - Field: ‘persistent’
[11:41:49.618]   - Field: ‘expr’
[11:41:49.618]   - Field: ‘uuid’
[11:41:49.618]   - Field: ‘seed’
[11:41:49.618]   - Field: ‘version’
[11:41:49.618]   - Field: ‘result’
[11:41:49.618]   - Field: ‘asynchronous’
[11:41:49.618]   - Field: ‘calls’
[11:41:49.618]   - Field: ‘globals’
[11:41:49.618]   - Field: ‘stdout’
[11:41:49.618]   - Field: ‘earlySignal’
[11:41:49.618]   - Field: ‘lazy’
[11:41:49.618]   - Field: ‘state’
[11:41:49.618] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:49.618] - Launch lazy future ...
[11:41:49.618] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:49.618] Packages needed by future strategies (n = 0): <none>
[11:41:49.619] {
[11:41:49.619]     {
[11:41:49.619]         {
[11:41:49.619]             ...future.startTime <- base::Sys.time()
[11:41:49.619]             {
[11:41:49.619]                 {
[11:41:49.619]                   {
[11:41:49.619]                     {
[11:41:49.619]                       {
[11:41:49.619]                         base::local({
[11:41:49.619]                           has_future <- base::requireNamespace("future", 
[11:41:49.619]                             quietly = TRUE)
[11:41:49.619]                           if (has_future) {
[11:41:49.619]                             ns <- base::getNamespace("future")
[11:41:49.619]                             version <- ns[[".package"]][["version"]]
[11:41:49.619]                             if (is.null(version)) 
[11:41:49.619]                               version <- utils::packageVersion("future")
[11:41:49.619]                           }
[11:41:49.619]                           else {
[11:41:49.619]                             version <- NULL
[11:41:49.619]                           }
[11:41:49.619]                           if (!has_future || version < "1.8.0") {
[11:41:49.619]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:49.619]                               "", base::R.version$version.string), 
[11:41:49.619]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:49.619]                                 base::R.version$platform, 8 * 
[11:41:49.619]                                   base::.Machine$sizeof.pointer), 
[11:41:49.619]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:49.619]                                 "release", "version")], collapse = " "), 
[11:41:49.619]                               hostname = base::Sys.info()[["nodename"]])
[11:41:49.619]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:49.619]                               info)
[11:41:49.619]                             info <- base::paste(info, collapse = "; ")
[11:41:49.619]                             if (!has_future) {
[11:41:49.619]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:49.619]                                 info)
[11:41:49.619]                             }
[11:41:49.619]                             else {
[11:41:49.619]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:49.619]                                 info, version)
[11:41:49.619]                             }
[11:41:49.619]                             base::stop(msg)
[11:41:49.619]                           }
[11:41:49.619]                         })
[11:41:49.619]                       }
[11:41:49.619]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:49.619]                       base::options(mc.cores = 1L)
[11:41:49.619]                     }
[11:41:49.619]                     base::local({
[11:41:49.619]                       for (pkg in "mlr3") {
[11:41:49.619]                         base::loadNamespace(pkg)
[11:41:49.619]                         base::library(pkg, character.only = TRUE)
[11:41:49.619]                       }
[11:41:49.619]                     })
[11:41:49.619]                   }
[11:41:49.619]                   options(future.plan = NULL)
[11:41:49.619]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:49.619]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:49.619]                 }
[11:41:49.619]                 ...future.workdir <- getwd()
[11:41:49.619]             }
[11:41:49.619]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:49.619]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:49.619]         }
[11:41:49.619]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:49.619]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:49.619]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:49.619]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:49.619]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:49.619]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:49.619]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:49.619]             base::names(...future.oldOptions))
[11:41:49.619]     }
[11:41:49.619]     if (FALSE) {
[11:41:49.619]     }
[11:41:49.619]     else {
[11:41:49.619]         if (TRUE) {
[11:41:49.619]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:49.619]                 open = "w")
[11:41:49.619]         }
[11:41:49.619]         else {
[11:41:49.619]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:49.619]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:49.619]         }
[11:41:49.619]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:49.619]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:49.619]             base::sink(type = "output", split = FALSE)
[11:41:49.619]             base::close(...future.stdout)
[11:41:49.619]         }, add = TRUE)
[11:41:49.619]     }
[11:41:49.619]     ...future.frame <- base::sys.nframe()
[11:41:49.619]     ...future.conditions <- base::list()
[11:41:49.619]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:49.619]     if (FALSE) {
[11:41:49.619]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:49.619]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:49.619]     }
[11:41:49.619]     ...future.result <- base::tryCatch({
[11:41:49.619]         base::withCallingHandlers({
[11:41:49.619]             ...future.value <- base::withVisible(base::local({
[11:41:49.619]                 ...future.makeSendCondition <- local({
[11:41:49.619]                   sendCondition <- NULL
[11:41:49.619]                   function(frame = 1L) {
[11:41:49.619]                     if (is.function(sendCondition)) 
[11:41:49.619]                       return(sendCondition)
[11:41:49.619]                     ns <- getNamespace("parallel")
[11:41:49.619]                     if (exists("sendData", mode = "function", 
[11:41:49.619]                       envir = ns)) {
[11:41:49.619]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:49.619]                         envir = ns)
[11:41:49.619]                       envir <- sys.frame(frame)
[11:41:49.619]                       master <- NULL
[11:41:49.619]                       while (!identical(envir, .GlobalEnv) && 
[11:41:49.619]                         !identical(envir, emptyenv())) {
[11:41:49.619]                         if (exists("master", mode = "list", envir = envir, 
[11:41:49.619]                           inherits = FALSE)) {
[11:41:49.619]                           master <- get("master", mode = "list", 
[11:41:49.619]                             envir = envir, inherits = FALSE)
[11:41:49.619]                           if (inherits(master, c("SOCKnode", 
[11:41:49.619]                             "SOCK0node"))) {
[11:41:49.619]                             sendCondition <<- function(cond) {
[11:41:49.619]                               data <- list(type = "VALUE", value = cond, 
[11:41:49.619]                                 success = TRUE)
[11:41:49.619]                               parallel_sendData(master, data)
[11:41:49.619]                             }
[11:41:49.619]                             return(sendCondition)
[11:41:49.619]                           }
[11:41:49.619]                         }
[11:41:49.619]                         frame <- frame + 1L
[11:41:49.619]                         envir <- sys.frame(frame)
[11:41:49.619]                       }
[11:41:49.619]                     }
[11:41:49.619]                     sendCondition <<- function(cond) NULL
[11:41:49.619]                   }
[11:41:49.619]                 })
[11:41:49.619]                 withCallingHandlers({
[11:41:49.619]                   {
[11:41:49.619]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:49.619]                     if (!identical(...future.globals.maxSize.org, 
[11:41:49.619]                       ...future.globals.maxSize)) {
[11:41:49.619]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:49.619]                       on.exit(options(oopts), add = TRUE)
[11:41:49.619]                     }
[11:41:49.619]                     {
[11:41:49.619]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:49.619]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:49.619]                           envir = globalenv(), inherits = FALSE)
[11:41:49.619]                         ...future.FUN(...)
[11:41:49.619]                       }
[11:41:49.619]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:49.619]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:49.619]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:49.619]                         USE.NAMES = FALSE)
[11:41:49.619]                       do.call(mapply, args = args)
[11:41:49.619]                     }
[11:41:49.619]                   }
[11:41:49.619]                 }, immediateCondition = function(cond) {
[11:41:49.619]                   sendCondition <- ...future.makeSendCondition()
[11:41:49.619]                   sendCondition(cond)
[11:41:49.619]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:49.619]                   {
[11:41:49.619]                     inherits <- base::inherits
[11:41:49.619]                     invokeRestart <- base::invokeRestart
[11:41:49.619]                     is.null <- base::is.null
[11:41:49.619]                     muffled <- FALSE
[11:41:49.619]                     if (inherits(cond, "message")) {
[11:41:49.619]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:49.619]                       if (muffled) 
[11:41:49.619]                         invokeRestart("muffleMessage")
[11:41:49.619]                     }
[11:41:49.619]                     else if (inherits(cond, "warning")) {
[11:41:49.619]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:49.619]                       if (muffled) 
[11:41:49.619]                         invokeRestart("muffleWarning")
[11:41:49.619]                     }
[11:41:49.619]                     else if (inherits(cond, "condition")) {
[11:41:49.619]                       if (!is.null(pattern)) {
[11:41:49.619]                         computeRestarts <- base::computeRestarts
[11:41:49.619]                         grepl <- base::grepl
[11:41:49.619]                         restarts <- computeRestarts(cond)
[11:41:49.619]                         for (restart in restarts) {
[11:41:49.619]                           name <- restart$name
[11:41:49.619]                           if (is.null(name)) 
[11:41:49.619]                             next
[11:41:49.619]                           if (!grepl(pattern, name)) 
[11:41:49.619]                             next
[11:41:49.619]                           invokeRestart(restart)
[11:41:49.619]                           muffled <- TRUE
[11:41:49.619]                           break
[11:41:49.619]                         }
[11:41:49.619]                       }
[11:41:49.619]                     }
[11:41:49.619]                     invisible(muffled)
[11:41:49.619]                   }
[11:41:49.619]                   muffleCondition(cond)
[11:41:49.619]                 })
[11:41:49.619]             }))
[11:41:49.619]             future::FutureResult(value = ...future.value$value, 
[11:41:49.619]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:49.619]                   ...future.rng), globalenv = if (FALSE) 
[11:41:49.619]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:49.619]                     ...future.globalenv.names))
[11:41:49.619]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:49.619]         }, condition = base::local({
[11:41:49.619]             c <- base::c
[11:41:49.619]             inherits <- base::inherits
[11:41:49.619]             invokeRestart <- base::invokeRestart
[11:41:49.619]             length <- base::length
[11:41:49.619]             list <- base::list
[11:41:49.619]             seq.int <- base::seq.int
[11:41:49.619]             signalCondition <- base::signalCondition
[11:41:49.619]             sys.calls <- base::sys.calls
[11:41:49.619]             `[[` <- base::`[[`
[11:41:49.619]             `+` <- base::`+`
[11:41:49.619]             `<<-` <- base::`<<-`
[11:41:49.619]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:49.619]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:49.619]                   3L)]
[11:41:49.619]             }
[11:41:49.619]             function(cond) {
[11:41:49.619]                 is_error <- inherits(cond, "error")
[11:41:49.619]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:49.619]                   NULL)
[11:41:49.619]                 if (is_error) {
[11:41:49.619]                   sessionInformation <- function() {
[11:41:49.619]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:49.619]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:49.619]                       search = base::search(), system = base::Sys.info())
[11:41:49.619]                   }
[11:41:49.619]                   ...future.conditions[[length(...future.conditions) + 
[11:41:49.619]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:49.619]                     cond$call), session = sessionInformation(), 
[11:41:49.619]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:49.619]                   signalCondition(cond)
[11:41:49.619]                 }
[11:41:49.619]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:49.619]                 "immediateCondition"))) {
[11:41:49.619]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:49.619]                   ...future.conditions[[length(...future.conditions) + 
[11:41:49.619]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:49.619]                   if (TRUE && !signal) {
[11:41:49.619]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:49.619]                     {
[11:41:49.619]                       inherits <- base::inherits
[11:41:49.619]                       invokeRestart <- base::invokeRestart
[11:41:49.619]                       is.null <- base::is.null
[11:41:49.619]                       muffled <- FALSE
[11:41:49.619]                       if (inherits(cond, "message")) {
[11:41:49.619]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:49.619]                         if (muffled) 
[11:41:49.619]                           invokeRestart("muffleMessage")
[11:41:49.619]                       }
[11:41:49.619]                       else if (inherits(cond, "warning")) {
[11:41:49.619]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:49.619]                         if (muffled) 
[11:41:49.619]                           invokeRestart("muffleWarning")
[11:41:49.619]                       }
[11:41:49.619]                       else if (inherits(cond, "condition")) {
[11:41:49.619]                         if (!is.null(pattern)) {
[11:41:49.619]                           computeRestarts <- base::computeRestarts
[11:41:49.619]                           grepl <- base::grepl
[11:41:49.619]                           restarts <- computeRestarts(cond)
[11:41:49.619]                           for (restart in restarts) {
[11:41:49.619]                             name <- restart$name
[11:41:49.619]                             if (is.null(name)) 
[11:41:49.619]                               next
[11:41:49.619]                             if (!grepl(pattern, name)) 
[11:41:49.619]                               next
[11:41:49.619]                             invokeRestart(restart)
[11:41:49.619]                             muffled <- TRUE
[11:41:49.619]                             break
[11:41:49.619]                           }
[11:41:49.619]                         }
[11:41:49.619]                       }
[11:41:49.619]                       invisible(muffled)
[11:41:49.619]                     }
[11:41:49.619]                     muffleCondition(cond, pattern = "^muffle")
[11:41:49.619]                   }
[11:41:49.619]                 }
[11:41:49.619]                 else {
[11:41:49.619]                   if (TRUE) {
[11:41:49.619]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:49.619]                     {
[11:41:49.619]                       inherits <- base::inherits
[11:41:49.619]                       invokeRestart <- base::invokeRestart
[11:41:49.619]                       is.null <- base::is.null
[11:41:49.619]                       muffled <- FALSE
[11:41:49.619]                       if (inherits(cond, "message")) {
[11:41:49.619]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:49.619]                         if (muffled) 
[11:41:49.619]                           invokeRestart("muffleMessage")
[11:41:49.619]                       }
[11:41:49.619]                       else if (inherits(cond, "warning")) {
[11:41:49.619]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:49.619]                         if (muffled) 
[11:41:49.619]                           invokeRestart("muffleWarning")
[11:41:49.619]                       }
[11:41:49.619]                       else if (inherits(cond, "condition")) {
[11:41:49.619]                         if (!is.null(pattern)) {
[11:41:49.619]                           computeRestarts <- base::computeRestarts
[11:41:49.619]                           grepl <- base::grepl
[11:41:49.619]                           restarts <- computeRestarts(cond)
[11:41:49.619]                           for (restart in restarts) {
[11:41:49.619]                             name <- restart$name
[11:41:49.619]                             if (is.null(name)) 
[11:41:49.619]                               next
[11:41:49.619]                             if (!grepl(pattern, name)) 
[11:41:49.619]                               next
[11:41:49.619]                             invokeRestart(restart)
[11:41:49.619]                             muffled <- TRUE
[11:41:49.619]                             break
[11:41:49.619]                           }
[11:41:49.619]                         }
[11:41:49.619]                       }
[11:41:49.619]                       invisible(muffled)
[11:41:49.619]                     }
[11:41:49.619]                     muffleCondition(cond, pattern = "^muffle")
[11:41:49.619]                   }
[11:41:49.619]                 }
[11:41:49.619]             }
[11:41:49.619]         }))
[11:41:49.619]     }, error = function(ex) {
[11:41:49.619]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:49.619]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:49.619]                 ...future.rng), started = ...future.startTime, 
[11:41:49.619]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:49.619]             version = "1.8"), class = "FutureResult")
[11:41:49.619]     }, finally = {
[11:41:49.619]         if (!identical(...future.workdir, getwd())) 
[11:41:49.619]             setwd(...future.workdir)
[11:41:49.619]         {
[11:41:49.619]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:49.619]                 ...future.oldOptions$nwarnings <- NULL
[11:41:49.619]             }
[11:41:49.619]             base::options(...future.oldOptions)
[11:41:49.619]             if (.Platform$OS.type == "windows") {
[11:41:49.619]                 old_names <- names(...future.oldEnvVars)
[11:41:49.619]                 envs <- base::Sys.getenv()
[11:41:49.619]                 names <- names(envs)
[11:41:49.619]                 common <- intersect(names, old_names)
[11:41:49.619]                 added <- setdiff(names, old_names)
[11:41:49.619]                 removed <- setdiff(old_names, names)
[11:41:49.619]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:49.619]                   envs[common]]
[11:41:49.619]                 NAMES <- toupper(changed)
[11:41:49.619]                 args <- list()
[11:41:49.619]                 for (kk in seq_along(NAMES)) {
[11:41:49.619]                   name <- changed[[kk]]
[11:41:49.619]                   NAME <- NAMES[[kk]]
[11:41:49.619]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:49.619]                     next
[11:41:49.619]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:49.619]                 }
[11:41:49.619]                 NAMES <- toupper(added)
[11:41:49.619]                 for (kk in seq_along(NAMES)) {
[11:41:49.619]                   name <- added[[kk]]
[11:41:49.619]                   NAME <- NAMES[[kk]]
[11:41:49.619]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:49.619]                     next
[11:41:49.619]                   args[[name]] <- ""
[11:41:49.619]                 }
[11:41:49.619]                 NAMES <- toupper(removed)
[11:41:49.619]                 for (kk in seq_along(NAMES)) {
[11:41:49.619]                   name <- removed[[kk]]
[11:41:49.619]                   NAME <- NAMES[[kk]]
[11:41:49.619]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:49.619]                     next
[11:41:49.619]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:49.619]                 }
[11:41:49.619]                 if (length(args) > 0) 
[11:41:49.619]                   base::do.call(base::Sys.setenv, args = args)
[11:41:49.619]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:49.619]             }
[11:41:49.619]             else {
[11:41:49.619]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:49.619]             }
[11:41:49.619]             {
[11:41:49.619]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:49.619]                   0L) {
[11:41:49.619]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:49.619]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:49.619]                   base::options(opts)
[11:41:49.619]                 }
[11:41:49.619]                 {
[11:41:49.619]                   {
[11:41:49.619]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:49.619]                     NULL
[11:41:49.619]                   }
[11:41:49.619]                   options(future.plan = NULL)
[11:41:49.619]                   if (is.na(NA_character_)) 
[11:41:49.619]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:49.619]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:49.619]                   future::plan(list(function (..., workers = 2, 
[11:41:49.619]                     envir = parent.frame()) 
[11:41:49.619]                   strategy(..., workers = workers, envir = envir)), 
[11:41:49.619]                     .cleanup = FALSE, .init = FALSE)
[11:41:49.619]                 }
[11:41:49.619]             }
[11:41:49.619]         }
[11:41:49.619]     })
[11:41:49.619]     if (TRUE) {
[11:41:49.619]         base::sink(type = "output", split = FALSE)
[11:41:49.619]         if (TRUE) {
[11:41:49.619]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:49.619]         }
[11:41:49.619]         else {
[11:41:49.619]             ...future.result["stdout"] <- base::list(NULL)
[11:41:49.619]         }
[11:41:49.619]         base::close(...future.stdout)
[11:41:49.619]         ...future.stdout <- NULL
[11:41:49.619]     }
[11:41:49.619]     ...future.result$conditions <- ...future.conditions
[11:41:49.619]     ...future.result$finished <- base::Sys.time()
[11:41:49.619]     ...future.result
[11:41:49.619] }
[11:41:49.620] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:49.631] receiveMessageFromWorker() for ClusterFuture ...
[11:41:49.632] - Validating connection of MultisessionFuture
[11:41:49.632] - received message: FutureResult
[11:41:49.633] - Received FutureResult
[11:41:49.633] - Erased future from FutureRegistry
[11:41:49.633] result() for ClusterFuture ...
[11:41:49.633] - result already collected: FutureResult
[11:41:49.633] result() for ClusterFuture ... done
[11:41:49.633] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:49.633] result() for ClusterFuture ...
[11:41:49.633] - result already collected: FutureResult
[11:41:49.634] result() for ClusterFuture ... done
[11:41:49.634] result() for ClusterFuture ...
[11:41:49.634] - result already collected: FutureResult
[11:41:49.634] result() for ClusterFuture ... done
[11:41:49.635] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:49.635] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:49.678] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:49.686] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:49.734] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:49.735] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:49.783] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:49.783] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:49.785] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:49.785] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:49.787] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:49.787] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:49.788] MultisessionFuture started
[11:41:49.789] - Launch lazy future ... done
[11:41:49.789] run() for ‘MultisessionFuture’ ... done
[11:41:49.789] Created future:
[11:41:49.789] MultisessionFuture:
[11:41:49.789] Label: ‘future_mapply-21’
[11:41:49.789] Expression:
[11:41:49.789] {
[11:41:49.789]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:49.789]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:49.789]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:49.789]         on.exit(options(oopts), add = TRUE)
[11:41:49.789]     }
[11:41:49.789]     {
[11:41:49.789]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:49.789]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:49.789]                 inherits = FALSE)
[11:41:49.789]             ...future.FUN(...)
[11:41:49.789]         }
[11:41:49.789]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:49.789]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:49.789]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:49.789]         do.call(mapply, args = args)
[11:41:49.789]     }
[11:41:49.789] }
[11:41:49.789] Lazy evaluation: FALSE
[11:41:49.789] Asynchronous evaluation: TRUE
[11:41:49.789] Local evaluation: TRUE
[11:41:49.789] Environment: 0x560ef58e1768
[11:41:49.789] Capture standard output: TRUE
[11:41:49.789] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:49.789] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:49.789] Packages: 1 packages (‘mlr3’)
[11:41:49.789] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:49.789] Resolved: FALSE
[11:41:49.789] Value: <not collected>
[11:41:49.789] Conditions captured: <none>
[11:41:49.789] Early signaling: FALSE
[11:41:49.789] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:49.789] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:49.807] Chunk #21 of 90 ... DONE
[11:41:49.808] Chunk #22 of 90 ...
[11:41:49.808]  - seeds: [1] <seeds>
[11:41:49.808] getGlobalsAndPackages() ...
[11:41:49.808] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:49.808] Resolving globals: FALSE
[11:41:49.809] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:49.809] - packages: [1] ‘mlr3’
[11:41:49.809] getGlobalsAndPackages() ... DONE
[11:41:49.810] run() for ‘Future’ ...
[11:41:49.810] - state: ‘created’
[11:41:49.810] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:49.820] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:49.820] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:49.820]   - Field: ‘node’
[11:41:49.820]   - Field: ‘label’
[11:41:49.821]   - Field: ‘local’
[11:41:49.821]   - Field: ‘owner’
[11:41:49.821]   - Field: ‘envir’
[11:41:49.821]   - Field: ‘workers’
[11:41:49.821]   - Field: ‘packages’
[11:41:49.821]   - Field: ‘gc’
[11:41:49.821]   - Field: ‘conditions’
[11:41:49.821]   - Field: ‘persistent’
[11:41:49.821]   - Field: ‘expr’
[11:41:49.821]   - Field: ‘uuid’
[11:41:49.821]   - Field: ‘seed’
[11:41:49.821]   - Field: ‘version’
[11:41:49.821]   - Field: ‘result’
[11:41:49.821]   - Field: ‘asynchronous’
[11:41:49.821]   - Field: ‘calls’
[11:41:49.821]   - Field: ‘globals’
[11:41:49.821]   - Field: ‘stdout’
[11:41:49.821]   - Field: ‘earlySignal’
[11:41:49.821]   - Field: ‘lazy’
[11:41:49.821]   - Field: ‘state’
[11:41:49.822] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:49.822] - Launch lazy future ...
[11:41:49.822] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:49.822] Packages needed by future strategies (n = 0): <none>
[11:41:49.825] {
[11:41:49.825]     {
[11:41:49.825]         {
[11:41:49.825]             ...future.startTime <- base::Sys.time()
[11:41:49.825]             {
[11:41:49.825]                 {
[11:41:49.825]                   {
[11:41:49.825]                     {
[11:41:49.825]                       {
[11:41:49.825]                         base::local({
[11:41:49.825]                           has_future <- base::requireNamespace("future", 
[11:41:49.825]                             quietly = TRUE)
[11:41:49.825]                           if (has_future) {
[11:41:49.825]                             ns <- base::getNamespace("future")
[11:41:49.825]                             version <- ns[[".package"]][["version"]]
[11:41:49.825]                             if (is.null(version)) 
[11:41:49.825]                               version <- utils::packageVersion("future")
[11:41:49.825]                           }
[11:41:49.825]                           else {
[11:41:49.825]                             version <- NULL
[11:41:49.825]                           }
[11:41:49.825]                           if (!has_future || version < "1.8.0") {
[11:41:49.825]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:49.825]                               "", base::R.version$version.string), 
[11:41:49.825]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:49.825]                                 base::R.version$platform, 8 * 
[11:41:49.825]                                   base::.Machine$sizeof.pointer), 
[11:41:49.825]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:49.825]                                 "release", "version")], collapse = " "), 
[11:41:49.825]                               hostname = base::Sys.info()[["nodename"]])
[11:41:49.825]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:49.825]                               info)
[11:41:49.825]                             info <- base::paste(info, collapse = "; ")
[11:41:49.825]                             if (!has_future) {
[11:41:49.825]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:49.825]                                 info)
[11:41:49.825]                             }
[11:41:49.825]                             else {
[11:41:49.825]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:49.825]                                 info, version)
[11:41:49.825]                             }
[11:41:49.825]                             base::stop(msg)
[11:41:49.825]                           }
[11:41:49.825]                         })
[11:41:49.825]                       }
[11:41:49.825]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:49.825]                       base::options(mc.cores = 1L)
[11:41:49.825]                     }
[11:41:49.825]                     base::local({
[11:41:49.825]                       for (pkg in "mlr3") {
[11:41:49.825]                         base::loadNamespace(pkg)
[11:41:49.825]                         base::library(pkg, character.only = TRUE)
[11:41:49.825]                       }
[11:41:49.825]                     })
[11:41:49.825]                   }
[11:41:49.825]                   options(future.plan = NULL)
[11:41:49.825]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:49.825]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:49.825]                 }
[11:41:49.825]                 ...future.workdir <- getwd()
[11:41:49.825]             }
[11:41:49.825]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:49.825]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:49.825]         }
[11:41:49.825]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:49.825]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:49.825]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:49.825]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:49.825]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:49.825]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:49.825]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:49.825]             base::names(...future.oldOptions))
[11:41:49.825]     }
[11:41:49.825]     if (FALSE) {
[11:41:49.825]     }
[11:41:49.825]     else {
[11:41:49.825]         if (TRUE) {
[11:41:49.825]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:49.825]                 open = "w")
[11:41:49.825]         }
[11:41:49.825]         else {
[11:41:49.825]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:49.825]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:49.825]         }
[11:41:49.825]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:49.825]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:49.825]             base::sink(type = "output", split = FALSE)
[11:41:49.825]             base::close(...future.stdout)
[11:41:49.825]         }, add = TRUE)
[11:41:49.825]     }
[11:41:49.825]     ...future.frame <- base::sys.nframe()
[11:41:49.825]     ...future.conditions <- base::list()
[11:41:49.825]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:49.825]     if (FALSE) {
[11:41:49.825]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:49.825]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:49.825]     }
[11:41:49.825]     ...future.result <- base::tryCatch({
[11:41:49.825]         base::withCallingHandlers({
[11:41:49.825]             ...future.value <- base::withVisible(base::local({
[11:41:49.825]                 ...future.makeSendCondition <- local({
[11:41:49.825]                   sendCondition <- NULL
[11:41:49.825]                   function(frame = 1L) {
[11:41:49.825]                     if (is.function(sendCondition)) 
[11:41:49.825]                       return(sendCondition)
[11:41:49.825]                     ns <- getNamespace("parallel")
[11:41:49.825]                     if (exists("sendData", mode = "function", 
[11:41:49.825]                       envir = ns)) {
[11:41:49.825]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:49.825]                         envir = ns)
[11:41:49.825]                       envir <- sys.frame(frame)
[11:41:49.825]                       master <- NULL
[11:41:49.825]                       while (!identical(envir, .GlobalEnv) && 
[11:41:49.825]                         !identical(envir, emptyenv())) {
[11:41:49.825]                         if (exists("master", mode = "list", envir = envir, 
[11:41:49.825]                           inherits = FALSE)) {
[11:41:49.825]                           master <- get("master", mode = "list", 
[11:41:49.825]                             envir = envir, inherits = FALSE)
[11:41:49.825]                           if (inherits(master, c("SOCKnode", 
[11:41:49.825]                             "SOCK0node"))) {
[11:41:49.825]                             sendCondition <<- function(cond) {
[11:41:49.825]                               data <- list(type = "VALUE", value = cond, 
[11:41:49.825]                                 success = TRUE)
[11:41:49.825]                               parallel_sendData(master, data)
[11:41:49.825]                             }
[11:41:49.825]                             return(sendCondition)
[11:41:49.825]                           }
[11:41:49.825]                         }
[11:41:49.825]                         frame <- frame + 1L
[11:41:49.825]                         envir <- sys.frame(frame)
[11:41:49.825]                       }
[11:41:49.825]                     }
[11:41:49.825]                     sendCondition <<- function(cond) NULL
[11:41:49.825]                   }
[11:41:49.825]                 })
[11:41:49.825]                 withCallingHandlers({
[11:41:49.825]                   {
[11:41:49.825]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:49.825]                     if (!identical(...future.globals.maxSize.org, 
[11:41:49.825]                       ...future.globals.maxSize)) {
[11:41:49.825]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:49.825]                       on.exit(options(oopts), add = TRUE)
[11:41:49.825]                     }
[11:41:49.825]                     {
[11:41:49.825]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:49.825]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:49.825]                           envir = globalenv(), inherits = FALSE)
[11:41:49.825]                         ...future.FUN(...)
[11:41:49.825]                       }
[11:41:49.825]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:49.825]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:49.825]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:49.825]                         USE.NAMES = FALSE)
[11:41:49.825]                       do.call(mapply, args = args)
[11:41:49.825]                     }
[11:41:49.825]                   }
[11:41:49.825]                 }, immediateCondition = function(cond) {
[11:41:49.825]                   sendCondition <- ...future.makeSendCondition()
[11:41:49.825]                   sendCondition(cond)
[11:41:49.825]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:49.825]                   {
[11:41:49.825]                     inherits <- base::inherits
[11:41:49.825]                     invokeRestart <- base::invokeRestart
[11:41:49.825]                     is.null <- base::is.null
[11:41:49.825]                     muffled <- FALSE
[11:41:49.825]                     if (inherits(cond, "message")) {
[11:41:49.825]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:49.825]                       if (muffled) 
[11:41:49.825]                         invokeRestart("muffleMessage")
[11:41:49.825]                     }
[11:41:49.825]                     else if (inherits(cond, "warning")) {
[11:41:49.825]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:49.825]                       if (muffled) 
[11:41:49.825]                         invokeRestart("muffleWarning")
[11:41:49.825]                     }
[11:41:49.825]                     else if (inherits(cond, "condition")) {
[11:41:49.825]                       if (!is.null(pattern)) {
[11:41:49.825]                         computeRestarts <- base::computeRestarts
[11:41:49.825]                         grepl <- base::grepl
[11:41:49.825]                         restarts <- computeRestarts(cond)
[11:41:49.825]                         for (restart in restarts) {
[11:41:49.825]                           name <- restart$name
[11:41:49.825]                           if (is.null(name)) 
[11:41:49.825]                             next
[11:41:49.825]                           if (!grepl(pattern, name)) 
[11:41:49.825]                             next
[11:41:49.825]                           invokeRestart(restart)
[11:41:49.825]                           muffled <- TRUE
[11:41:49.825]                           break
[11:41:49.825]                         }
[11:41:49.825]                       }
[11:41:49.825]                     }
[11:41:49.825]                     invisible(muffled)
[11:41:49.825]                   }
[11:41:49.825]                   muffleCondition(cond)
[11:41:49.825]                 })
[11:41:49.825]             }))
[11:41:49.825]             future::FutureResult(value = ...future.value$value, 
[11:41:49.825]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:49.825]                   ...future.rng), globalenv = if (FALSE) 
[11:41:49.825]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:49.825]                     ...future.globalenv.names))
[11:41:49.825]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:49.825]         }, condition = base::local({
[11:41:49.825]             c <- base::c
[11:41:49.825]             inherits <- base::inherits
[11:41:49.825]             invokeRestart <- base::invokeRestart
[11:41:49.825]             length <- base::length
[11:41:49.825]             list <- base::list
[11:41:49.825]             seq.int <- base::seq.int
[11:41:49.825]             signalCondition <- base::signalCondition
[11:41:49.825]             sys.calls <- base::sys.calls
[11:41:49.825]             `[[` <- base::`[[`
[11:41:49.825]             `+` <- base::`+`
[11:41:49.825]             `<<-` <- base::`<<-`
[11:41:49.825]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:49.825]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:49.825]                   3L)]
[11:41:49.825]             }
[11:41:49.825]             function(cond) {
[11:41:49.825]                 is_error <- inherits(cond, "error")
[11:41:49.825]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:49.825]                   NULL)
[11:41:49.825]                 if (is_error) {
[11:41:49.825]                   sessionInformation <- function() {
[11:41:49.825]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:49.825]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:49.825]                       search = base::search(), system = base::Sys.info())
[11:41:49.825]                   }
[11:41:49.825]                   ...future.conditions[[length(...future.conditions) + 
[11:41:49.825]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:49.825]                     cond$call), session = sessionInformation(), 
[11:41:49.825]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:49.825]                   signalCondition(cond)
[11:41:49.825]                 }
[11:41:49.825]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:49.825]                 "immediateCondition"))) {
[11:41:49.825]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:49.825]                   ...future.conditions[[length(...future.conditions) + 
[11:41:49.825]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:49.825]                   if (TRUE && !signal) {
[11:41:49.825]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:49.825]                     {
[11:41:49.825]                       inherits <- base::inherits
[11:41:49.825]                       invokeRestart <- base::invokeRestart
[11:41:49.825]                       is.null <- base::is.null
[11:41:49.825]                       muffled <- FALSE
[11:41:49.825]                       if (inherits(cond, "message")) {
[11:41:49.825]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:49.825]                         if (muffled) 
[11:41:49.825]                           invokeRestart("muffleMessage")
[11:41:49.825]                       }
[11:41:49.825]                       else if (inherits(cond, "warning")) {
[11:41:49.825]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:49.825]                         if (muffled) 
[11:41:49.825]                           invokeRestart("muffleWarning")
[11:41:49.825]                       }
[11:41:49.825]                       else if (inherits(cond, "condition")) {
[11:41:49.825]                         if (!is.null(pattern)) {
[11:41:49.825]                           computeRestarts <- base::computeRestarts
[11:41:49.825]                           grepl <- base::grepl
[11:41:49.825]                           restarts <- computeRestarts(cond)
[11:41:49.825]                           for (restart in restarts) {
[11:41:49.825]                             name <- restart$name
[11:41:49.825]                             if (is.null(name)) 
[11:41:49.825]                               next
[11:41:49.825]                             if (!grepl(pattern, name)) 
[11:41:49.825]                               next
[11:41:49.825]                             invokeRestart(restart)
[11:41:49.825]                             muffled <- TRUE
[11:41:49.825]                             break
[11:41:49.825]                           }
[11:41:49.825]                         }
[11:41:49.825]                       }
[11:41:49.825]                       invisible(muffled)
[11:41:49.825]                     }
[11:41:49.825]                     muffleCondition(cond, pattern = "^muffle")
[11:41:49.825]                   }
[11:41:49.825]                 }
[11:41:49.825]                 else {
[11:41:49.825]                   if (TRUE) {
[11:41:49.825]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:49.825]                     {
[11:41:49.825]                       inherits <- base::inherits
[11:41:49.825]                       invokeRestart <- base::invokeRestart
[11:41:49.825]                       is.null <- base::is.null
[11:41:49.825]                       muffled <- FALSE
[11:41:49.825]                       if (inherits(cond, "message")) {
[11:41:49.825]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:49.825]                         if (muffled) 
[11:41:49.825]                           invokeRestart("muffleMessage")
[11:41:49.825]                       }
[11:41:49.825]                       else if (inherits(cond, "warning")) {
[11:41:49.825]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:49.825]                         if (muffled) 
[11:41:49.825]                           invokeRestart("muffleWarning")
[11:41:49.825]                       }
[11:41:49.825]                       else if (inherits(cond, "condition")) {
[11:41:49.825]                         if (!is.null(pattern)) {
[11:41:49.825]                           computeRestarts <- base::computeRestarts
[11:41:49.825]                           grepl <- base::grepl
[11:41:49.825]                           restarts <- computeRestarts(cond)
[11:41:49.825]                           for (restart in restarts) {
[11:41:49.825]                             name <- restart$name
[11:41:49.825]                             if (is.null(name)) 
[11:41:49.825]                               next
[11:41:49.825]                             if (!grepl(pattern, name)) 
[11:41:49.825]                               next
[11:41:49.825]                             invokeRestart(restart)
[11:41:49.825]                             muffled <- TRUE
[11:41:49.825]                             break
[11:41:49.825]                           }
[11:41:49.825]                         }
[11:41:49.825]                       }
[11:41:49.825]                       invisible(muffled)
[11:41:49.825]                     }
[11:41:49.825]                     muffleCondition(cond, pattern = "^muffle")
[11:41:49.825]                   }
[11:41:49.825]                 }
[11:41:49.825]             }
[11:41:49.825]         }))
[11:41:49.825]     }, error = function(ex) {
[11:41:49.825]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:49.825]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:49.825]                 ...future.rng), started = ...future.startTime, 
[11:41:49.825]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:49.825]             version = "1.8"), class = "FutureResult")
[11:41:49.825]     }, finally = {
[11:41:49.825]         if (!identical(...future.workdir, getwd())) 
[11:41:49.825]             setwd(...future.workdir)
[11:41:49.825]         {
[11:41:49.825]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:49.825]                 ...future.oldOptions$nwarnings <- NULL
[11:41:49.825]             }
[11:41:49.825]             base::options(...future.oldOptions)
[11:41:49.825]             if (.Platform$OS.type == "windows") {
[11:41:49.825]                 old_names <- names(...future.oldEnvVars)
[11:41:49.825]                 envs <- base::Sys.getenv()
[11:41:49.825]                 names <- names(envs)
[11:41:49.825]                 common <- intersect(names, old_names)
[11:41:49.825]                 added <- setdiff(names, old_names)
[11:41:49.825]                 removed <- setdiff(old_names, names)
[11:41:49.825]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:49.825]                   envs[common]]
[11:41:49.825]                 NAMES <- toupper(changed)
[11:41:49.825]                 args <- list()
[11:41:49.825]                 for (kk in seq_along(NAMES)) {
[11:41:49.825]                   name <- changed[[kk]]
[11:41:49.825]                   NAME <- NAMES[[kk]]
[11:41:49.825]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:49.825]                     next
[11:41:49.825]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:49.825]                 }
[11:41:49.825]                 NAMES <- toupper(added)
[11:41:49.825]                 for (kk in seq_along(NAMES)) {
[11:41:49.825]                   name <- added[[kk]]
[11:41:49.825]                   NAME <- NAMES[[kk]]
[11:41:49.825]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:49.825]                     next
[11:41:49.825]                   args[[name]] <- ""
[11:41:49.825]                 }
[11:41:49.825]                 NAMES <- toupper(removed)
[11:41:49.825]                 for (kk in seq_along(NAMES)) {
[11:41:49.825]                   name <- removed[[kk]]
[11:41:49.825]                   NAME <- NAMES[[kk]]
[11:41:49.825]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:49.825]                     next
[11:41:49.825]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:49.825]                 }
[11:41:49.825]                 if (length(args) > 0) 
[11:41:49.825]                   base::do.call(base::Sys.setenv, args = args)
[11:41:49.825]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:49.825]             }
[11:41:49.825]             else {
[11:41:49.825]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:49.825]             }
[11:41:49.825]             {
[11:41:49.825]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:49.825]                   0L) {
[11:41:49.825]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:49.825]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:49.825]                   base::options(opts)
[11:41:49.825]                 }
[11:41:49.825]                 {
[11:41:49.825]                   {
[11:41:49.825]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:49.825]                     NULL
[11:41:49.825]                   }
[11:41:49.825]                   options(future.plan = NULL)
[11:41:49.825]                   if (is.na(NA_character_)) 
[11:41:49.825]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:49.825]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:49.825]                   future::plan(list(function (..., workers = 2, 
[11:41:49.825]                     envir = parent.frame()) 
[11:41:49.825]                   strategy(..., workers = workers, envir = envir)), 
[11:41:49.825]                     .cleanup = FALSE, .init = FALSE)
[11:41:49.825]                 }
[11:41:49.825]             }
[11:41:49.825]         }
[11:41:49.825]     })
[11:41:49.825]     if (TRUE) {
[11:41:49.825]         base::sink(type = "output", split = FALSE)
[11:41:49.825]         if (TRUE) {
[11:41:49.825]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:49.825]         }
[11:41:49.825]         else {
[11:41:49.825]             ...future.result["stdout"] <- base::list(NULL)
[11:41:49.825]         }
[11:41:49.825]         base::close(...future.stdout)
[11:41:49.825]         ...future.stdout <- NULL
[11:41:49.825]     }
[11:41:49.825]     ...future.result$conditions <- ...future.conditions
[11:41:49.825]     ...future.result$finished <- base::Sys.time()
[11:41:49.825]     ...future.result
[11:41:49.825] }
[11:41:49.827] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:49.838] receiveMessageFromWorker() for ClusterFuture ...
[11:41:49.838] - Validating connection of MultisessionFuture
[11:41:49.839] - received message: FutureResult
[11:41:49.839] - Received FutureResult
[11:41:49.839] - Erased future from FutureRegistry
[11:41:49.839] result() for ClusterFuture ...
[11:41:49.839] - result already collected: FutureResult
[11:41:49.839] result() for ClusterFuture ... done
[11:41:49.839] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:49.840] result() for ClusterFuture ...
[11:41:49.840] - result already collected: FutureResult
[11:41:49.840] result() for ClusterFuture ... done
[11:41:49.840] result() for ClusterFuture ...
[11:41:49.840] - result already collected: FutureResult
[11:41:49.840] result() for ClusterFuture ... done
[11:41:49.841] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:49.841] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:49.886] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:49.894] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:49.942] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:49.942] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:49.986] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:49.987] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:49.988] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:49.989] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:49.990] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:49.991] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:49.993] MultisessionFuture started
[11:41:49.993] - Launch lazy future ... done
[11:41:49.993] run() for ‘MultisessionFuture’ ... done
[11:41:49.993] Created future:
[11:41:49.994] MultisessionFuture:
[11:41:49.994] Label: ‘future_mapply-22’
[11:41:49.994] Expression:
[11:41:49.994] {
[11:41:49.994]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:49.994]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:49.994]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:49.994]         on.exit(options(oopts), add = TRUE)
[11:41:49.994]     }
[11:41:49.994]     {
[11:41:49.994]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:49.994]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:49.994]                 inherits = FALSE)
[11:41:49.994]             ...future.FUN(...)
[11:41:49.994]         }
[11:41:49.994]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:49.994]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:49.994]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:49.994]         do.call(mapply, args = args)
[11:41:49.994]     }
[11:41:49.994] }
[11:41:49.994] Lazy evaluation: FALSE
[11:41:49.994] Asynchronous evaluation: TRUE
[11:41:49.994] Local evaluation: TRUE
[11:41:49.994] Environment: 0x560ef58e1768
[11:41:49.994] Capture standard output: TRUE
[11:41:49.994] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:49.994] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:49.994] Packages: 1 packages (‘mlr3’)
[11:41:49.994] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:49.994] Resolved: FALSE
[11:41:49.994] Value: <not collected>
[11:41:49.994] Conditions captured: <none>
[11:41:49.994] Early signaling: FALSE
[11:41:49.994] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:49.994] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:50.010] Chunk #22 of 90 ... DONE
[11:41:50.010] Chunk #23 of 90 ...
[11:41:50.010]  - seeds: [1] <seeds>
[11:41:50.011] getGlobalsAndPackages() ...
[11:41:50.011] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:50.011] Resolving globals: FALSE
[11:41:50.012] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:50.012] - packages: [1] ‘mlr3’
[11:41:50.012] getGlobalsAndPackages() ... DONE
[11:41:50.013] run() for ‘Future’ ...
[11:41:50.013] - state: ‘created’
[11:41:50.013] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:50.024] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:50.024] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:50.024]   - Field: ‘node’
[11:41:50.024]   - Field: ‘label’
[11:41:50.024]   - Field: ‘local’
[11:41:50.024]   - Field: ‘owner’
[11:41:50.025]   - Field: ‘envir’
[11:41:50.025]   - Field: ‘workers’
[11:41:50.025]   - Field: ‘packages’
[11:41:50.025]   - Field: ‘gc’
[11:41:50.025]   - Field: ‘conditions’
[11:41:50.025]   - Field: ‘persistent’
[11:41:50.025]   - Field: ‘expr’
[11:41:50.025]   - Field: ‘uuid’
[11:41:50.025]   - Field: ‘seed’
[11:41:50.025]   - Field: ‘version’
[11:41:50.025]   - Field: ‘result’
[11:41:50.025]   - Field: ‘asynchronous’
[11:41:50.025]   - Field: ‘calls’
[11:41:50.025]   - Field: ‘globals’
[11:41:50.025]   - Field: ‘stdout’
[11:41:50.025]   - Field: ‘earlySignal’
[11:41:50.025]   - Field: ‘lazy’
[11:41:50.025]   - Field: ‘state’
[11:41:50.025] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:50.025] - Launch lazy future ...
[11:41:50.026] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:50.026] Packages needed by future strategies (n = 0): <none>
[11:41:50.026] {
[11:41:50.026]     {
[11:41:50.026]         {
[11:41:50.026]             ...future.startTime <- base::Sys.time()
[11:41:50.026]             {
[11:41:50.026]                 {
[11:41:50.026]                   {
[11:41:50.026]                     {
[11:41:50.026]                       {
[11:41:50.026]                         base::local({
[11:41:50.026]                           has_future <- base::requireNamespace("future", 
[11:41:50.026]                             quietly = TRUE)
[11:41:50.026]                           if (has_future) {
[11:41:50.026]                             ns <- base::getNamespace("future")
[11:41:50.026]                             version <- ns[[".package"]][["version"]]
[11:41:50.026]                             if (is.null(version)) 
[11:41:50.026]                               version <- utils::packageVersion("future")
[11:41:50.026]                           }
[11:41:50.026]                           else {
[11:41:50.026]                             version <- NULL
[11:41:50.026]                           }
[11:41:50.026]                           if (!has_future || version < "1.8.0") {
[11:41:50.026]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:50.026]                               "", base::R.version$version.string), 
[11:41:50.026]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:50.026]                                 base::R.version$platform, 8 * 
[11:41:50.026]                                   base::.Machine$sizeof.pointer), 
[11:41:50.026]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:50.026]                                 "release", "version")], collapse = " "), 
[11:41:50.026]                               hostname = base::Sys.info()[["nodename"]])
[11:41:50.026]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:50.026]                               info)
[11:41:50.026]                             info <- base::paste(info, collapse = "; ")
[11:41:50.026]                             if (!has_future) {
[11:41:50.026]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:50.026]                                 info)
[11:41:50.026]                             }
[11:41:50.026]                             else {
[11:41:50.026]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:50.026]                                 info, version)
[11:41:50.026]                             }
[11:41:50.026]                             base::stop(msg)
[11:41:50.026]                           }
[11:41:50.026]                         })
[11:41:50.026]                       }
[11:41:50.026]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:50.026]                       base::options(mc.cores = 1L)
[11:41:50.026]                     }
[11:41:50.026]                     base::local({
[11:41:50.026]                       for (pkg in "mlr3") {
[11:41:50.026]                         base::loadNamespace(pkg)
[11:41:50.026]                         base::library(pkg, character.only = TRUE)
[11:41:50.026]                       }
[11:41:50.026]                     })
[11:41:50.026]                   }
[11:41:50.026]                   options(future.plan = NULL)
[11:41:50.026]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:50.026]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:50.026]                 }
[11:41:50.026]                 ...future.workdir <- getwd()
[11:41:50.026]             }
[11:41:50.026]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:50.026]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:50.026]         }
[11:41:50.026]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:50.026]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:50.026]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:50.026]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:50.026]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:50.026]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:50.026]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:50.026]             base::names(...future.oldOptions))
[11:41:50.026]     }
[11:41:50.026]     if (FALSE) {
[11:41:50.026]     }
[11:41:50.026]     else {
[11:41:50.026]         if (TRUE) {
[11:41:50.026]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:50.026]                 open = "w")
[11:41:50.026]         }
[11:41:50.026]         else {
[11:41:50.026]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:50.026]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:50.026]         }
[11:41:50.026]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:50.026]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:50.026]             base::sink(type = "output", split = FALSE)
[11:41:50.026]             base::close(...future.stdout)
[11:41:50.026]         }, add = TRUE)
[11:41:50.026]     }
[11:41:50.026]     ...future.frame <- base::sys.nframe()
[11:41:50.026]     ...future.conditions <- base::list()
[11:41:50.026]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:50.026]     if (FALSE) {
[11:41:50.026]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:50.026]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:50.026]     }
[11:41:50.026]     ...future.result <- base::tryCatch({
[11:41:50.026]         base::withCallingHandlers({
[11:41:50.026]             ...future.value <- base::withVisible(base::local({
[11:41:50.026]                 ...future.makeSendCondition <- local({
[11:41:50.026]                   sendCondition <- NULL
[11:41:50.026]                   function(frame = 1L) {
[11:41:50.026]                     if (is.function(sendCondition)) 
[11:41:50.026]                       return(sendCondition)
[11:41:50.026]                     ns <- getNamespace("parallel")
[11:41:50.026]                     if (exists("sendData", mode = "function", 
[11:41:50.026]                       envir = ns)) {
[11:41:50.026]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:50.026]                         envir = ns)
[11:41:50.026]                       envir <- sys.frame(frame)
[11:41:50.026]                       master <- NULL
[11:41:50.026]                       while (!identical(envir, .GlobalEnv) && 
[11:41:50.026]                         !identical(envir, emptyenv())) {
[11:41:50.026]                         if (exists("master", mode = "list", envir = envir, 
[11:41:50.026]                           inherits = FALSE)) {
[11:41:50.026]                           master <- get("master", mode = "list", 
[11:41:50.026]                             envir = envir, inherits = FALSE)
[11:41:50.026]                           if (inherits(master, c("SOCKnode", 
[11:41:50.026]                             "SOCK0node"))) {
[11:41:50.026]                             sendCondition <<- function(cond) {
[11:41:50.026]                               data <- list(type = "VALUE", value = cond, 
[11:41:50.026]                                 success = TRUE)
[11:41:50.026]                               parallel_sendData(master, data)
[11:41:50.026]                             }
[11:41:50.026]                             return(sendCondition)
[11:41:50.026]                           }
[11:41:50.026]                         }
[11:41:50.026]                         frame <- frame + 1L
[11:41:50.026]                         envir <- sys.frame(frame)
[11:41:50.026]                       }
[11:41:50.026]                     }
[11:41:50.026]                     sendCondition <<- function(cond) NULL
[11:41:50.026]                   }
[11:41:50.026]                 })
[11:41:50.026]                 withCallingHandlers({
[11:41:50.026]                   {
[11:41:50.026]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:50.026]                     if (!identical(...future.globals.maxSize.org, 
[11:41:50.026]                       ...future.globals.maxSize)) {
[11:41:50.026]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:50.026]                       on.exit(options(oopts), add = TRUE)
[11:41:50.026]                     }
[11:41:50.026]                     {
[11:41:50.026]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:50.026]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:50.026]                           envir = globalenv(), inherits = FALSE)
[11:41:50.026]                         ...future.FUN(...)
[11:41:50.026]                       }
[11:41:50.026]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:50.026]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:50.026]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:50.026]                         USE.NAMES = FALSE)
[11:41:50.026]                       do.call(mapply, args = args)
[11:41:50.026]                     }
[11:41:50.026]                   }
[11:41:50.026]                 }, immediateCondition = function(cond) {
[11:41:50.026]                   sendCondition <- ...future.makeSendCondition()
[11:41:50.026]                   sendCondition(cond)
[11:41:50.026]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:50.026]                   {
[11:41:50.026]                     inherits <- base::inherits
[11:41:50.026]                     invokeRestart <- base::invokeRestart
[11:41:50.026]                     is.null <- base::is.null
[11:41:50.026]                     muffled <- FALSE
[11:41:50.026]                     if (inherits(cond, "message")) {
[11:41:50.026]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:50.026]                       if (muffled) 
[11:41:50.026]                         invokeRestart("muffleMessage")
[11:41:50.026]                     }
[11:41:50.026]                     else if (inherits(cond, "warning")) {
[11:41:50.026]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:50.026]                       if (muffled) 
[11:41:50.026]                         invokeRestart("muffleWarning")
[11:41:50.026]                     }
[11:41:50.026]                     else if (inherits(cond, "condition")) {
[11:41:50.026]                       if (!is.null(pattern)) {
[11:41:50.026]                         computeRestarts <- base::computeRestarts
[11:41:50.026]                         grepl <- base::grepl
[11:41:50.026]                         restarts <- computeRestarts(cond)
[11:41:50.026]                         for (restart in restarts) {
[11:41:50.026]                           name <- restart$name
[11:41:50.026]                           if (is.null(name)) 
[11:41:50.026]                             next
[11:41:50.026]                           if (!grepl(pattern, name)) 
[11:41:50.026]                             next
[11:41:50.026]                           invokeRestart(restart)
[11:41:50.026]                           muffled <- TRUE
[11:41:50.026]                           break
[11:41:50.026]                         }
[11:41:50.026]                       }
[11:41:50.026]                     }
[11:41:50.026]                     invisible(muffled)
[11:41:50.026]                   }
[11:41:50.026]                   muffleCondition(cond)
[11:41:50.026]                 })
[11:41:50.026]             }))
[11:41:50.026]             future::FutureResult(value = ...future.value$value, 
[11:41:50.026]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:50.026]                   ...future.rng), globalenv = if (FALSE) 
[11:41:50.026]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:50.026]                     ...future.globalenv.names))
[11:41:50.026]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:50.026]         }, condition = base::local({
[11:41:50.026]             c <- base::c
[11:41:50.026]             inherits <- base::inherits
[11:41:50.026]             invokeRestart <- base::invokeRestart
[11:41:50.026]             length <- base::length
[11:41:50.026]             list <- base::list
[11:41:50.026]             seq.int <- base::seq.int
[11:41:50.026]             signalCondition <- base::signalCondition
[11:41:50.026]             sys.calls <- base::sys.calls
[11:41:50.026]             `[[` <- base::`[[`
[11:41:50.026]             `+` <- base::`+`
[11:41:50.026]             `<<-` <- base::`<<-`
[11:41:50.026]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:50.026]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:50.026]                   3L)]
[11:41:50.026]             }
[11:41:50.026]             function(cond) {
[11:41:50.026]                 is_error <- inherits(cond, "error")
[11:41:50.026]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:50.026]                   NULL)
[11:41:50.026]                 if (is_error) {
[11:41:50.026]                   sessionInformation <- function() {
[11:41:50.026]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:50.026]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:50.026]                       search = base::search(), system = base::Sys.info())
[11:41:50.026]                   }
[11:41:50.026]                   ...future.conditions[[length(...future.conditions) + 
[11:41:50.026]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:50.026]                     cond$call), session = sessionInformation(), 
[11:41:50.026]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:50.026]                   signalCondition(cond)
[11:41:50.026]                 }
[11:41:50.026]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:50.026]                 "immediateCondition"))) {
[11:41:50.026]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:50.026]                   ...future.conditions[[length(...future.conditions) + 
[11:41:50.026]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:50.026]                   if (TRUE && !signal) {
[11:41:50.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:50.026]                     {
[11:41:50.026]                       inherits <- base::inherits
[11:41:50.026]                       invokeRestart <- base::invokeRestart
[11:41:50.026]                       is.null <- base::is.null
[11:41:50.026]                       muffled <- FALSE
[11:41:50.026]                       if (inherits(cond, "message")) {
[11:41:50.026]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:50.026]                         if (muffled) 
[11:41:50.026]                           invokeRestart("muffleMessage")
[11:41:50.026]                       }
[11:41:50.026]                       else if (inherits(cond, "warning")) {
[11:41:50.026]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:50.026]                         if (muffled) 
[11:41:50.026]                           invokeRestart("muffleWarning")
[11:41:50.026]                       }
[11:41:50.026]                       else if (inherits(cond, "condition")) {
[11:41:50.026]                         if (!is.null(pattern)) {
[11:41:50.026]                           computeRestarts <- base::computeRestarts
[11:41:50.026]                           grepl <- base::grepl
[11:41:50.026]                           restarts <- computeRestarts(cond)
[11:41:50.026]                           for (restart in restarts) {
[11:41:50.026]                             name <- restart$name
[11:41:50.026]                             if (is.null(name)) 
[11:41:50.026]                               next
[11:41:50.026]                             if (!grepl(pattern, name)) 
[11:41:50.026]                               next
[11:41:50.026]                             invokeRestart(restart)
[11:41:50.026]                             muffled <- TRUE
[11:41:50.026]                             break
[11:41:50.026]                           }
[11:41:50.026]                         }
[11:41:50.026]                       }
[11:41:50.026]                       invisible(muffled)
[11:41:50.026]                     }
[11:41:50.026]                     muffleCondition(cond, pattern = "^muffle")
[11:41:50.026]                   }
[11:41:50.026]                 }
[11:41:50.026]                 else {
[11:41:50.026]                   if (TRUE) {
[11:41:50.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:50.026]                     {
[11:41:50.026]                       inherits <- base::inherits
[11:41:50.026]                       invokeRestart <- base::invokeRestart
[11:41:50.026]                       is.null <- base::is.null
[11:41:50.026]                       muffled <- FALSE
[11:41:50.026]                       if (inherits(cond, "message")) {
[11:41:50.026]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:50.026]                         if (muffled) 
[11:41:50.026]                           invokeRestart("muffleMessage")
[11:41:50.026]                       }
[11:41:50.026]                       else if (inherits(cond, "warning")) {
[11:41:50.026]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:50.026]                         if (muffled) 
[11:41:50.026]                           invokeRestart("muffleWarning")
[11:41:50.026]                       }
[11:41:50.026]                       else if (inherits(cond, "condition")) {
[11:41:50.026]                         if (!is.null(pattern)) {
[11:41:50.026]                           computeRestarts <- base::computeRestarts
[11:41:50.026]                           grepl <- base::grepl
[11:41:50.026]                           restarts <- computeRestarts(cond)
[11:41:50.026]                           for (restart in restarts) {
[11:41:50.026]                             name <- restart$name
[11:41:50.026]                             if (is.null(name)) 
[11:41:50.026]                               next
[11:41:50.026]                             if (!grepl(pattern, name)) 
[11:41:50.026]                               next
[11:41:50.026]                             invokeRestart(restart)
[11:41:50.026]                             muffled <- TRUE
[11:41:50.026]                             break
[11:41:50.026]                           }
[11:41:50.026]                         }
[11:41:50.026]                       }
[11:41:50.026]                       invisible(muffled)
[11:41:50.026]                     }
[11:41:50.026]                     muffleCondition(cond, pattern = "^muffle")
[11:41:50.026]                   }
[11:41:50.026]                 }
[11:41:50.026]             }
[11:41:50.026]         }))
[11:41:50.026]     }, error = function(ex) {
[11:41:50.026]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:50.026]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:50.026]                 ...future.rng), started = ...future.startTime, 
[11:41:50.026]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:50.026]             version = "1.8"), class = "FutureResult")
[11:41:50.026]     }, finally = {
[11:41:50.026]         if (!identical(...future.workdir, getwd())) 
[11:41:50.026]             setwd(...future.workdir)
[11:41:50.026]         {
[11:41:50.026]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:50.026]                 ...future.oldOptions$nwarnings <- NULL
[11:41:50.026]             }
[11:41:50.026]             base::options(...future.oldOptions)
[11:41:50.026]             if (.Platform$OS.type == "windows") {
[11:41:50.026]                 old_names <- names(...future.oldEnvVars)
[11:41:50.026]                 envs <- base::Sys.getenv()
[11:41:50.026]                 names <- names(envs)
[11:41:50.026]                 common <- intersect(names, old_names)
[11:41:50.026]                 added <- setdiff(names, old_names)
[11:41:50.026]                 removed <- setdiff(old_names, names)
[11:41:50.026]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:50.026]                   envs[common]]
[11:41:50.026]                 NAMES <- toupper(changed)
[11:41:50.026]                 args <- list()
[11:41:50.026]                 for (kk in seq_along(NAMES)) {
[11:41:50.026]                   name <- changed[[kk]]
[11:41:50.026]                   NAME <- NAMES[[kk]]
[11:41:50.026]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:50.026]                     next
[11:41:50.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:50.026]                 }
[11:41:50.026]                 NAMES <- toupper(added)
[11:41:50.026]                 for (kk in seq_along(NAMES)) {
[11:41:50.026]                   name <- added[[kk]]
[11:41:50.026]                   NAME <- NAMES[[kk]]
[11:41:50.026]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:50.026]                     next
[11:41:50.026]                   args[[name]] <- ""
[11:41:50.026]                 }
[11:41:50.026]                 NAMES <- toupper(removed)
[11:41:50.026]                 for (kk in seq_along(NAMES)) {
[11:41:50.026]                   name <- removed[[kk]]
[11:41:50.026]                   NAME <- NAMES[[kk]]
[11:41:50.026]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:50.026]                     next
[11:41:50.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:50.026]                 }
[11:41:50.026]                 if (length(args) > 0) 
[11:41:50.026]                   base::do.call(base::Sys.setenv, args = args)
[11:41:50.026]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:50.026]             }
[11:41:50.026]             else {
[11:41:50.026]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:50.026]             }
[11:41:50.026]             {
[11:41:50.026]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:50.026]                   0L) {
[11:41:50.026]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:50.026]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:50.026]                   base::options(opts)
[11:41:50.026]                 }
[11:41:50.026]                 {
[11:41:50.026]                   {
[11:41:50.026]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:50.026]                     NULL
[11:41:50.026]                   }
[11:41:50.026]                   options(future.plan = NULL)
[11:41:50.026]                   if (is.na(NA_character_)) 
[11:41:50.026]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:50.026]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:50.026]                   future::plan(list(function (..., workers = 2, 
[11:41:50.026]                     envir = parent.frame()) 
[11:41:50.026]                   strategy(..., workers = workers, envir = envir)), 
[11:41:50.026]                     .cleanup = FALSE, .init = FALSE)
[11:41:50.026]                 }
[11:41:50.026]             }
[11:41:50.026]         }
[11:41:50.026]     })
[11:41:50.026]     if (TRUE) {
[11:41:50.026]         base::sink(type = "output", split = FALSE)
[11:41:50.026]         if (TRUE) {
[11:41:50.026]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:50.026]         }
[11:41:50.026]         else {
[11:41:50.026]             ...future.result["stdout"] <- base::list(NULL)
[11:41:50.026]         }
[11:41:50.026]         base::close(...future.stdout)
[11:41:50.026]         ...future.stdout <- NULL
[11:41:50.026]     }
[11:41:50.026]     ...future.result$conditions <- ...future.conditions
[11:41:50.026]     ...future.result$finished <- base::Sys.time()
[11:41:50.026]     ...future.result
[11:41:50.026] }
[11:41:50.028] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:50.039] receiveMessageFromWorker() for ClusterFuture ...
[11:41:50.040] - Validating connection of MultisessionFuture
[11:41:50.040] - received message: FutureResult
[11:41:50.040] - Received FutureResult
[11:41:50.040] - Erased future from FutureRegistry
[11:41:50.040] result() for ClusterFuture ...
[11:41:50.041] - result already collected: FutureResult
[11:41:50.041] result() for ClusterFuture ... done
[11:41:50.041] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:50.041] result() for ClusterFuture ...
[11:41:50.041] - result already collected: FutureResult
[11:41:50.041] result() for ClusterFuture ... done
[11:41:50.041] result() for ClusterFuture ...
[11:41:50.041] - result already collected: FutureResult
[11:41:50.041] result() for ClusterFuture ... done
[11:41:50.042] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:50.042] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:50.086] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:50.096] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:50.099] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:50.099] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:50.142] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:50.143] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:50.144] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:50.144] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:50.146] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:50.146] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:50.147] MultisessionFuture started
[11:41:50.147] - Launch lazy future ... done
[11:41:50.147] run() for ‘MultisessionFuture’ ... done
[11:41:50.148] Created future:
[11:41:50.148] MultisessionFuture:
[11:41:50.148] Label: ‘future_mapply-23’
[11:41:50.148] Expression:
[11:41:50.148] {
[11:41:50.148]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:50.148]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:50.148]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:50.148]         on.exit(options(oopts), add = TRUE)
[11:41:50.148]     }
[11:41:50.148]     {
[11:41:50.148]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:50.148]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:50.148]                 inherits = FALSE)
[11:41:50.148]             ...future.FUN(...)
[11:41:50.148]         }
[11:41:50.148]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:50.148]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:50.148]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:50.148]         do.call(mapply, args = args)
[11:41:50.148]     }
[11:41:50.148] }
[11:41:50.148] Lazy evaluation: FALSE
[11:41:50.148] Asynchronous evaluation: TRUE
[11:41:50.148] Local evaluation: TRUE
[11:41:50.148] Environment: 0x560ef58e1768
[11:41:50.148] Capture standard output: TRUE
[11:41:50.148] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:50.148] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:50.148] Packages: 1 packages (‘mlr3’)
[11:41:50.148] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:50.148] Resolved: FALSE
[11:41:50.148] Value: <not collected>
[11:41:50.148] Conditions captured: <none>
[11:41:50.148] Early signaling: FALSE
[11:41:50.148] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:50.148] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:50.165] Chunk #23 of 90 ... DONE
[11:41:50.165] Chunk #24 of 90 ...
[11:41:50.165]  - seeds: [1] <seeds>
[11:41:50.165] getGlobalsAndPackages() ...
[11:41:50.165] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:50.166] Resolving globals: FALSE
[11:41:50.166] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:50.166] - packages: [1] ‘mlr3’
[11:41:50.166] getGlobalsAndPackages() ... DONE
[11:41:50.167] run() for ‘Future’ ...
[11:41:50.167] - state: ‘created’
[11:41:50.167] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:50.177] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:50.177] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:50.177]   - Field: ‘node’
[11:41:50.177]   - Field: ‘label’
[11:41:50.177]   - Field: ‘local’
[11:41:50.177]   - Field: ‘owner’
[11:41:50.177]   - Field: ‘envir’
[11:41:50.177]   - Field: ‘workers’
[11:41:50.177]   - Field: ‘packages’
[11:41:50.177]   - Field: ‘gc’
[11:41:50.177]   - Field: ‘conditions’
[11:41:50.177]   - Field: ‘persistent’
[11:41:50.177]   - Field: ‘expr’
[11:41:50.177]   - Field: ‘uuid’
[11:41:50.177]   - Field: ‘seed’
[11:41:50.178]   - Field: ‘version’
[11:41:50.178]   - Field: ‘result’
[11:41:50.178]   - Field: ‘asynchronous’
[11:41:50.178]   - Field: ‘calls’
[11:41:50.178]   - Field: ‘globals’
[11:41:50.178]   - Field: ‘stdout’
[11:41:50.178]   - Field: ‘earlySignal’
[11:41:50.178]   - Field: ‘lazy’
[11:41:50.178]   - Field: ‘state’
[11:41:50.178] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:50.178] - Launch lazy future ...
[11:41:50.178] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:50.178] Packages needed by future strategies (n = 0): <none>
[11:41:50.179] {
[11:41:50.179]     {
[11:41:50.179]         {
[11:41:50.179]             ...future.startTime <- base::Sys.time()
[11:41:50.179]             {
[11:41:50.179]                 {
[11:41:50.179]                   {
[11:41:50.179]                     {
[11:41:50.179]                       {
[11:41:50.179]                         base::local({
[11:41:50.179]                           has_future <- base::requireNamespace("future", 
[11:41:50.179]                             quietly = TRUE)
[11:41:50.179]                           if (has_future) {
[11:41:50.179]                             ns <- base::getNamespace("future")
[11:41:50.179]                             version <- ns[[".package"]][["version"]]
[11:41:50.179]                             if (is.null(version)) 
[11:41:50.179]                               version <- utils::packageVersion("future")
[11:41:50.179]                           }
[11:41:50.179]                           else {
[11:41:50.179]                             version <- NULL
[11:41:50.179]                           }
[11:41:50.179]                           if (!has_future || version < "1.8.0") {
[11:41:50.179]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:50.179]                               "", base::R.version$version.string), 
[11:41:50.179]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:50.179]                                 base::R.version$platform, 8 * 
[11:41:50.179]                                   base::.Machine$sizeof.pointer), 
[11:41:50.179]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:50.179]                                 "release", "version")], collapse = " "), 
[11:41:50.179]                               hostname = base::Sys.info()[["nodename"]])
[11:41:50.179]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:50.179]                               info)
[11:41:50.179]                             info <- base::paste(info, collapse = "; ")
[11:41:50.179]                             if (!has_future) {
[11:41:50.179]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:50.179]                                 info)
[11:41:50.179]                             }
[11:41:50.179]                             else {
[11:41:50.179]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:50.179]                                 info, version)
[11:41:50.179]                             }
[11:41:50.179]                             base::stop(msg)
[11:41:50.179]                           }
[11:41:50.179]                         })
[11:41:50.179]                       }
[11:41:50.179]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:50.179]                       base::options(mc.cores = 1L)
[11:41:50.179]                     }
[11:41:50.179]                     base::local({
[11:41:50.179]                       for (pkg in "mlr3") {
[11:41:50.179]                         base::loadNamespace(pkg)
[11:41:50.179]                         base::library(pkg, character.only = TRUE)
[11:41:50.179]                       }
[11:41:50.179]                     })
[11:41:50.179]                   }
[11:41:50.179]                   options(future.plan = NULL)
[11:41:50.179]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:50.179]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:50.179]                 }
[11:41:50.179]                 ...future.workdir <- getwd()
[11:41:50.179]             }
[11:41:50.179]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:50.179]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:50.179]         }
[11:41:50.179]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:50.179]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:50.179]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:50.179]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:50.179]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:50.179]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:50.179]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:50.179]             base::names(...future.oldOptions))
[11:41:50.179]     }
[11:41:50.179]     if (FALSE) {
[11:41:50.179]     }
[11:41:50.179]     else {
[11:41:50.179]         if (TRUE) {
[11:41:50.179]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:50.179]                 open = "w")
[11:41:50.179]         }
[11:41:50.179]         else {
[11:41:50.179]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:50.179]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:50.179]         }
[11:41:50.179]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:50.179]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:50.179]             base::sink(type = "output", split = FALSE)
[11:41:50.179]             base::close(...future.stdout)
[11:41:50.179]         }, add = TRUE)
[11:41:50.179]     }
[11:41:50.179]     ...future.frame <- base::sys.nframe()
[11:41:50.179]     ...future.conditions <- base::list()
[11:41:50.179]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:50.179]     if (FALSE) {
[11:41:50.179]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:50.179]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:50.179]     }
[11:41:50.179]     ...future.result <- base::tryCatch({
[11:41:50.179]         base::withCallingHandlers({
[11:41:50.179]             ...future.value <- base::withVisible(base::local({
[11:41:50.179]                 ...future.makeSendCondition <- local({
[11:41:50.179]                   sendCondition <- NULL
[11:41:50.179]                   function(frame = 1L) {
[11:41:50.179]                     if (is.function(sendCondition)) 
[11:41:50.179]                       return(sendCondition)
[11:41:50.179]                     ns <- getNamespace("parallel")
[11:41:50.179]                     if (exists("sendData", mode = "function", 
[11:41:50.179]                       envir = ns)) {
[11:41:50.179]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:50.179]                         envir = ns)
[11:41:50.179]                       envir <- sys.frame(frame)
[11:41:50.179]                       master <- NULL
[11:41:50.179]                       while (!identical(envir, .GlobalEnv) && 
[11:41:50.179]                         !identical(envir, emptyenv())) {
[11:41:50.179]                         if (exists("master", mode = "list", envir = envir, 
[11:41:50.179]                           inherits = FALSE)) {
[11:41:50.179]                           master <- get("master", mode = "list", 
[11:41:50.179]                             envir = envir, inherits = FALSE)
[11:41:50.179]                           if (inherits(master, c("SOCKnode", 
[11:41:50.179]                             "SOCK0node"))) {
[11:41:50.179]                             sendCondition <<- function(cond) {
[11:41:50.179]                               data <- list(type = "VALUE", value = cond, 
[11:41:50.179]                                 success = TRUE)
[11:41:50.179]                               parallel_sendData(master, data)
[11:41:50.179]                             }
[11:41:50.179]                             return(sendCondition)
[11:41:50.179]                           }
[11:41:50.179]                         }
[11:41:50.179]                         frame <- frame + 1L
[11:41:50.179]                         envir <- sys.frame(frame)
[11:41:50.179]                       }
[11:41:50.179]                     }
[11:41:50.179]                     sendCondition <<- function(cond) NULL
[11:41:50.179]                   }
[11:41:50.179]                 })
[11:41:50.179]                 withCallingHandlers({
[11:41:50.179]                   {
[11:41:50.179]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:50.179]                     if (!identical(...future.globals.maxSize.org, 
[11:41:50.179]                       ...future.globals.maxSize)) {
[11:41:50.179]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:50.179]                       on.exit(options(oopts), add = TRUE)
[11:41:50.179]                     }
[11:41:50.179]                     {
[11:41:50.179]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:50.179]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:50.179]                           envir = globalenv(), inherits = FALSE)
[11:41:50.179]                         ...future.FUN(...)
[11:41:50.179]                       }
[11:41:50.179]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:50.179]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:50.179]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:50.179]                         USE.NAMES = FALSE)
[11:41:50.179]                       do.call(mapply, args = args)
[11:41:50.179]                     }
[11:41:50.179]                   }
[11:41:50.179]                 }, immediateCondition = function(cond) {
[11:41:50.179]                   sendCondition <- ...future.makeSendCondition()
[11:41:50.179]                   sendCondition(cond)
[11:41:50.179]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:50.179]                   {
[11:41:50.179]                     inherits <- base::inherits
[11:41:50.179]                     invokeRestart <- base::invokeRestart
[11:41:50.179]                     is.null <- base::is.null
[11:41:50.179]                     muffled <- FALSE
[11:41:50.179]                     if (inherits(cond, "message")) {
[11:41:50.179]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:50.179]                       if (muffled) 
[11:41:50.179]                         invokeRestart("muffleMessage")
[11:41:50.179]                     }
[11:41:50.179]                     else if (inherits(cond, "warning")) {
[11:41:50.179]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:50.179]                       if (muffled) 
[11:41:50.179]                         invokeRestart("muffleWarning")
[11:41:50.179]                     }
[11:41:50.179]                     else if (inherits(cond, "condition")) {
[11:41:50.179]                       if (!is.null(pattern)) {
[11:41:50.179]                         computeRestarts <- base::computeRestarts
[11:41:50.179]                         grepl <- base::grepl
[11:41:50.179]                         restarts <- computeRestarts(cond)
[11:41:50.179]                         for (restart in restarts) {
[11:41:50.179]                           name <- restart$name
[11:41:50.179]                           if (is.null(name)) 
[11:41:50.179]                             next
[11:41:50.179]                           if (!grepl(pattern, name)) 
[11:41:50.179]                             next
[11:41:50.179]                           invokeRestart(restart)
[11:41:50.179]                           muffled <- TRUE
[11:41:50.179]                           break
[11:41:50.179]                         }
[11:41:50.179]                       }
[11:41:50.179]                     }
[11:41:50.179]                     invisible(muffled)
[11:41:50.179]                   }
[11:41:50.179]                   muffleCondition(cond)
[11:41:50.179]                 })
[11:41:50.179]             }))
[11:41:50.179]             future::FutureResult(value = ...future.value$value, 
[11:41:50.179]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:50.179]                   ...future.rng), globalenv = if (FALSE) 
[11:41:50.179]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:50.179]                     ...future.globalenv.names))
[11:41:50.179]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:50.179]         }, condition = base::local({
[11:41:50.179]             c <- base::c
[11:41:50.179]             inherits <- base::inherits
[11:41:50.179]             invokeRestart <- base::invokeRestart
[11:41:50.179]             length <- base::length
[11:41:50.179]             list <- base::list
[11:41:50.179]             seq.int <- base::seq.int
[11:41:50.179]             signalCondition <- base::signalCondition
[11:41:50.179]             sys.calls <- base::sys.calls
[11:41:50.179]             `[[` <- base::`[[`
[11:41:50.179]             `+` <- base::`+`
[11:41:50.179]             `<<-` <- base::`<<-`
[11:41:50.179]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:50.179]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:50.179]                   3L)]
[11:41:50.179]             }
[11:41:50.179]             function(cond) {
[11:41:50.179]                 is_error <- inherits(cond, "error")
[11:41:50.179]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:50.179]                   NULL)
[11:41:50.179]                 if (is_error) {
[11:41:50.179]                   sessionInformation <- function() {
[11:41:50.179]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:50.179]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:50.179]                       search = base::search(), system = base::Sys.info())
[11:41:50.179]                   }
[11:41:50.179]                   ...future.conditions[[length(...future.conditions) + 
[11:41:50.179]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:50.179]                     cond$call), session = sessionInformation(), 
[11:41:50.179]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:50.179]                   signalCondition(cond)
[11:41:50.179]                 }
[11:41:50.179]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:50.179]                 "immediateCondition"))) {
[11:41:50.179]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:50.179]                   ...future.conditions[[length(...future.conditions) + 
[11:41:50.179]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:50.179]                   if (TRUE && !signal) {
[11:41:50.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:50.179]                     {
[11:41:50.179]                       inherits <- base::inherits
[11:41:50.179]                       invokeRestart <- base::invokeRestart
[11:41:50.179]                       is.null <- base::is.null
[11:41:50.179]                       muffled <- FALSE
[11:41:50.179]                       if (inherits(cond, "message")) {
[11:41:50.179]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:50.179]                         if (muffled) 
[11:41:50.179]                           invokeRestart("muffleMessage")
[11:41:50.179]                       }
[11:41:50.179]                       else if (inherits(cond, "warning")) {
[11:41:50.179]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:50.179]                         if (muffled) 
[11:41:50.179]                           invokeRestart("muffleWarning")
[11:41:50.179]                       }
[11:41:50.179]                       else if (inherits(cond, "condition")) {
[11:41:50.179]                         if (!is.null(pattern)) {
[11:41:50.179]                           computeRestarts <- base::computeRestarts
[11:41:50.179]                           grepl <- base::grepl
[11:41:50.179]                           restarts <- computeRestarts(cond)
[11:41:50.179]                           for (restart in restarts) {
[11:41:50.179]                             name <- restart$name
[11:41:50.179]                             if (is.null(name)) 
[11:41:50.179]                               next
[11:41:50.179]                             if (!grepl(pattern, name)) 
[11:41:50.179]                               next
[11:41:50.179]                             invokeRestart(restart)
[11:41:50.179]                             muffled <- TRUE
[11:41:50.179]                             break
[11:41:50.179]                           }
[11:41:50.179]                         }
[11:41:50.179]                       }
[11:41:50.179]                       invisible(muffled)
[11:41:50.179]                     }
[11:41:50.179]                     muffleCondition(cond, pattern = "^muffle")
[11:41:50.179]                   }
[11:41:50.179]                 }
[11:41:50.179]                 else {
[11:41:50.179]                   if (TRUE) {
[11:41:50.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:50.179]                     {
[11:41:50.179]                       inherits <- base::inherits
[11:41:50.179]                       invokeRestart <- base::invokeRestart
[11:41:50.179]                       is.null <- base::is.null
[11:41:50.179]                       muffled <- FALSE
[11:41:50.179]                       if (inherits(cond, "message")) {
[11:41:50.179]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:50.179]                         if (muffled) 
[11:41:50.179]                           invokeRestart("muffleMessage")
[11:41:50.179]                       }
[11:41:50.179]                       else if (inherits(cond, "warning")) {
[11:41:50.179]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:50.179]                         if (muffled) 
[11:41:50.179]                           invokeRestart("muffleWarning")
[11:41:50.179]                       }
[11:41:50.179]                       else if (inherits(cond, "condition")) {
[11:41:50.179]                         if (!is.null(pattern)) {
[11:41:50.179]                           computeRestarts <- base::computeRestarts
[11:41:50.179]                           grepl <- base::grepl
[11:41:50.179]                           restarts <- computeRestarts(cond)
[11:41:50.179]                           for (restart in restarts) {
[11:41:50.179]                             name <- restart$name
[11:41:50.179]                             if (is.null(name)) 
[11:41:50.179]                               next
[11:41:50.179]                             if (!grepl(pattern, name)) 
[11:41:50.179]                               next
[11:41:50.179]                             invokeRestart(restart)
[11:41:50.179]                             muffled <- TRUE
[11:41:50.179]                             break
[11:41:50.179]                           }
[11:41:50.179]                         }
[11:41:50.179]                       }
[11:41:50.179]                       invisible(muffled)
[11:41:50.179]                     }
[11:41:50.179]                     muffleCondition(cond, pattern = "^muffle")
[11:41:50.179]                   }
[11:41:50.179]                 }
[11:41:50.179]             }
[11:41:50.179]         }))
[11:41:50.179]     }, error = function(ex) {
[11:41:50.179]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:50.179]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:50.179]                 ...future.rng), started = ...future.startTime, 
[11:41:50.179]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:50.179]             version = "1.8"), class = "FutureResult")
[11:41:50.179]     }, finally = {
[11:41:50.179]         if (!identical(...future.workdir, getwd())) 
[11:41:50.179]             setwd(...future.workdir)
[11:41:50.179]         {
[11:41:50.179]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:50.179]                 ...future.oldOptions$nwarnings <- NULL
[11:41:50.179]             }
[11:41:50.179]             base::options(...future.oldOptions)
[11:41:50.179]             if (.Platform$OS.type == "windows") {
[11:41:50.179]                 old_names <- names(...future.oldEnvVars)
[11:41:50.179]                 envs <- base::Sys.getenv()
[11:41:50.179]                 names <- names(envs)
[11:41:50.179]                 common <- intersect(names, old_names)
[11:41:50.179]                 added <- setdiff(names, old_names)
[11:41:50.179]                 removed <- setdiff(old_names, names)
[11:41:50.179]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:50.179]                   envs[common]]
[11:41:50.179]                 NAMES <- toupper(changed)
[11:41:50.179]                 args <- list()
[11:41:50.179]                 for (kk in seq_along(NAMES)) {
[11:41:50.179]                   name <- changed[[kk]]
[11:41:50.179]                   NAME <- NAMES[[kk]]
[11:41:50.179]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:50.179]                     next
[11:41:50.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:50.179]                 }
[11:41:50.179]                 NAMES <- toupper(added)
[11:41:50.179]                 for (kk in seq_along(NAMES)) {
[11:41:50.179]                   name <- added[[kk]]
[11:41:50.179]                   NAME <- NAMES[[kk]]
[11:41:50.179]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:50.179]                     next
[11:41:50.179]                   args[[name]] <- ""
[11:41:50.179]                 }
[11:41:50.179]                 NAMES <- toupper(removed)
[11:41:50.179]                 for (kk in seq_along(NAMES)) {
[11:41:50.179]                   name <- removed[[kk]]
[11:41:50.179]                   NAME <- NAMES[[kk]]
[11:41:50.179]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:50.179]                     next
[11:41:50.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:50.179]                 }
[11:41:50.179]                 if (length(args) > 0) 
[11:41:50.179]                   base::do.call(base::Sys.setenv, args = args)
[11:41:50.179]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:50.179]             }
[11:41:50.179]             else {
[11:41:50.179]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:50.179]             }
[11:41:50.179]             {
[11:41:50.179]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:50.179]                   0L) {
[11:41:50.179]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:50.179]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:50.179]                   base::options(opts)
[11:41:50.179]                 }
[11:41:50.179]                 {
[11:41:50.179]                   {
[11:41:50.179]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:50.179]                     NULL
[11:41:50.179]                   }
[11:41:50.179]                   options(future.plan = NULL)
[11:41:50.179]                   if (is.na(NA_character_)) 
[11:41:50.179]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:50.179]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:50.179]                   future::plan(list(function (..., workers = 2, 
[11:41:50.179]                     envir = parent.frame()) 
[11:41:50.179]                   strategy(..., workers = workers, envir = envir)), 
[11:41:50.179]                     .cleanup = FALSE, .init = FALSE)
[11:41:50.179]                 }
[11:41:50.179]             }
[11:41:50.179]         }
[11:41:50.179]     })
[11:41:50.179]     if (TRUE) {
[11:41:50.179]         base::sink(type = "output", split = FALSE)
[11:41:50.179]         if (TRUE) {
[11:41:50.179]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:50.179]         }
[11:41:50.179]         else {
[11:41:50.179]             ...future.result["stdout"] <- base::list(NULL)
[11:41:50.179]         }
[11:41:50.179]         base::close(...future.stdout)
[11:41:50.179]         ...future.stdout <- NULL
[11:41:50.179]     }
[11:41:50.179]     ...future.result$conditions <- ...future.conditions
[11:41:50.179]     ...future.result$finished <- base::Sys.time()
[11:41:50.179]     ...future.result
[11:41:50.179] }
[11:41:50.180] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:50.191] receiveMessageFromWorker() for ClusterFuture ...
[11:41:50.191] - Validating connection of MultisessionFuture
[11:41:50.191] - received message: FutureResult
[11:41:50.191] - Received FutureResult
[11:41:50.191] - Erased future from FutureRegistry
[11:41:50.191] result() for ClusterFuture ...
[11:41:50.191] - result already collected: FutureResult
[11:41:50.191] result() for ClusterFuture ... done
[11:41:50.191] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:50.192] result() for ClusterFuture ...
[11:41:50.192] - result already collected: FutureResult
[11:41:50.192] result() for ClusterFuture ... done
[11:41:50.192] result() for ClusterFuture ...
[11:41:50.192] - result already collected: FutureResult
[11:41:50.192] result() for ClusterFuture ... done
[11:41:50.193] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:50.194] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:50.242] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:50.249] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:50.251] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:50.251] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:50.294] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:50.294] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:50.296] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:50.296] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:50.297] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:50.298] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:50.299] MultisessionFuture started
[11:41:50.299] - Launch lazy future ... done
[11:41:50.299] run() for ‘MultisessionFuture’ ... done
[11:41:50.299] Created future:
[11:41:50.299] MultisessionFuture:
[11:41:50.299] Label: ‘future_mapply-24’
[11:41:50.299] Expression:
[11:41:50.299] {
[11:41:50.299]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:50.299]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:50.299]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:50.299]         on.exit(options(oopts), add = TRUE)
[11:41:50.299]     }
[11:41:50.299]     {
[11:41:50.299]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:50.299]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:50.299]                 inherits = FALSE)
[11:41:50.299]             ...future.FUN(...)
[11:41:50.299]         }
[11:41:50.299]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:50.299]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:50.299]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:50.299]         do.call(mapply, args = args)
[11:41:50.299]     }
[11:41:50.299] }
[11:41:50.299] Lazy evaluation: FALSE
[11:41:50.299] Asynchronous evaluation: TRUE
[11:41:50.299] Local evaluation: TRUE
[11:41:50.299] Environment: 0x560ef58e1768
[11:41:50.299] Capture standard output: TRUE
[11:41:50.299] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:50.299] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:50.299] Packages: 1 packages (‘mlr3’)
[11:41:50.299] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:50.299] Resolved: FALSE
[11:41:50.299] Value: <not collected>
[11:41:50.299] Conditions captured: <none>
[11:41:50.299] Early signaling: FALSE
[11:41:50.299] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:50.299] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:50.317] Chunk #24 of 90 ... DONE
[11:41:50.317] Chunk #25 of 90 ...
[11:41:50.317]  - seeds: [1] <seeds>
[11:41:50.317] getGlobalsAndPackages() ...
[11:41:50.317] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:50.318] Resolving globals: FALSE
[11:41:50.318] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:50.318] - packages: [1] ‘mlr3’
[11:41:50.319] getGlobalsAndPackages() ... DONE
[11:41:50.319] run() for ‘Future’ ...
[11:41:50.319] - state: ‘created’
[11:41:50.319] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:50.329] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:50.330] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:50.330]   - Field: ‘node’
[11:41:50.330]   - Field: ‘label’
[11:41:50.330]   - Field: ‘local’
[11:41:50.330]   - Field: ‘owner’
[11:41:50.330]   - Field: ‘envir’
[11:41:50.330]   - Field: ‘workers’
[11:41:50.330]   - Field: ‘packages’
[11:41:50.330]   - Field: ‘gc’
[11:41:50.330]   - Field: ‘conditions’
[11:41:50.330]   - Field: ‘persistent’
[11:41:50.330]   - Field: ‘expr’
[11:41:50.330]   - Field: ‘uuid’
[11:41:50.330]   - Field: ‘seed’
[11:41:50.330]   - Field: ‘version’
[11:41:50.330]   - Field: ‘result’
[11:41:50.330]   - Field: ‘asynchronous’
[11:41:50.330]   - Field: ‘calls’
[11:41:50.330]   - Field: ‘globals’
[11:41:50.330]   - Field: ‘stdout’
[11:41:50.330]   - Field: ‘earlySignal’
[11:41:50.330]   - Field: ‘lazy’
[11:41:50.331]   - Field: ‘state’
[11:41:50.331] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:50.331] - Launch lazy future ...
[11:41:50.331] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:50.331] Packages needed by future strategies (n = 0): <none>
[11:41:50.331] {
[11:41:50.331]     {
[11:41:50.331]         {
[11:41:50.331]             ...future.startTime <- base::Sys.time()
[11:41:50.331]             {
[11:41:50.331]                 {
[11:41:50.331]                   {
[11:41:50.331]                     {
[11:41:50.331]                       {
[11:41:50.331]                         base::local({
[11:41:50.331]                           has_future <- base::requireNamespace("future", 
[11:41:50.331]                             quietly = TRUE)
[11:41:50.331]                           if (has_future) {
[11:41:50.331]                             ns <- base::getNamespace("future")
[11:41:50.331]                             version <- ns[[".package"]][["version"]]
[11:41:50.331]                             if (is.null(version)) 
[11:41:50.331]                               version <- utils::packageVersion("future")
[11:41:50.331]                           }
[11:41:50.331]                           else {
[11:41:50.331]                             version <- NULL
[11:41:50.331]                           }
[11:41:50.331]                           if (!has_future || version < "1.8.0") {
[11:41:50.331]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:50.331]                               "", base::R.version$version.string), 
[11:41:50.331]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:50.331]                                 base::R.version$platform, 8 * 
[11:41:50.331]                                   base::.Machine$sizeof.pointer), 
[11:41:50.331]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:50.331]                                 "release", "version")], collapse = " "), 
[11:41:50.331]                               hostname = base::Sys.info()[["nodename"]])
[11:41:50.331]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:50.331]                               info)
[11:41:50.331]                             info <- base::paste(info, collapse = "; ")
[11:41:50.331]                             if (!has_future) {
[11:41:50.331]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:50.331]                                 info)
[11:41:50.331]                             }
[11:41:50.331]                             else {
[11:41:50.331]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:50.331]                                 info, version)
[11:41:50.331]                             }
[11:41:50.331]                             base::stop(msg)
[11:41:50.331]                           }
[11:41:50.331]                         })
[11:41:50.331]                       }
[11:41:50.331]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:50.331]                       base::options(mc.cores = 1L)
[11:41:50.331]                     }
[11:41:50.331]                     base::local({
[11:41:50.331]                       for (pkg in "mlr3") {
[11:41:50.331]                         base::loadNamespace(pkg)
[11:41:50.331]                         base::library(pkg, character.only = TRUE)
[11:41:50.331]                       }
[11:41:50.331]                     })
[11:41:50.331]                   }
[11:41:50.331]                   options(future.plan = NULL)
[11:41:50.331]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:50.331]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:50.331]                 }
[11:41:50.331]                 ...future.workdir <- getwd()
[11:41:50.331]             }
[11:41:50.331]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:50.331]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:50.331]         }
[11:41:50.331]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:50.331]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:50.331]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:50.331]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:50.331]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:50.331]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:50.331]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:50.331]             base::names(...future.oldOptions))
[11:41:50.331]     }
[11:41:50.331]     if (FALSE) {
[11:41:50.331]     }
[11:41:50.331]     else {
[11:41:50.331]         if (TRUE) {
[11:41:50.331]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:50.331]                 open = "w")
[11:41:50.331]         }
[11:41:50.331]         else {
[11:41:50.331]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:50.331]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:50.331]         }
[11:41:50.331]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:50.331]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:50.331]             base::sink(type = "output", split = FALSE)
[11:41:50.331]             base::close(...future.stdout)
[11:41:50.331]         }, add = TRUE)
[11:41:50.331]     }
[11:41:50.331]     ...future.frame <- base::sys.nframe()
[11:41:50.331]     ...future.conditions <- base::list()
[11:41:50.331]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:50.331]     if (FALSE) {
[11:41:50.331]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:50.331]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:50.331]     }
[11:41:50.331]     ...future.result <- base::tryCatch({
[11:41:50.331]         base::withCallingHandlers({
[11:41:50.331]             ...future.value <- base::withVisible(base::local({
[11:41:50.331]                 ...future.makeSendCondition <- local({
[11:41:50.331]                   sendCondition <- NULL
[11:41:50.331]                   function(frame = 1L) {
[11:41:50.331]                     if (is.function(sendCondition)) 
[11:41:50.331]                       return(sendCondition)
[11:41:50.331]                     ns <- getNamespace("parallel")
[11:41:50.331]                     if (exists("sendData", mode = "function", 
[11:41:50.331]                       envir = ns)) {
[11:41:50.331]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:50.331]                         envir = ns)
[11:41:50.331]                       envir <- sys.frame(frame)
[11:41:50.331]                       master <- NULL
[11:41:50.331]                       while (!identical(envir, .GlobalEnv) && 
[11:41:50.331]                         !identical(envir, emptyenv())) {
[11:41:50.331]                         if (exists("master", mode = "list", envir = envir, 
[11:41:50.331]                           inherits = FALSE)) {
[11:41:50.331]                           master <- get("master", mode = "list", 
[11:41:50.331]                             envir = envir, inherits = FALSE)
[11:41:50.331]                           if (inherits(master, c("SOCKnode", 
[11:41:50.331]                             "SOCK0node"))) {
[11:41:50.331]                             sendCondition <<- function(cond) {
[11:41:50.331]                               data <- list(type = "VALUE", value = cond, 
[11:41:50.331]                                 success = TRUE)
[11:41:50.331]                               parallel_sendData(master, data)
[11:41:50.331]                             }
[11:41:50.331]                             return(sendCondition)
[11:41:50.331]                           }
[11:41:50.331]                         }
[11:41:50.331]                         frame <- frame + 1L
[11:41:50.331]                         envir <- sys.frame(frame)
[11:41:50.331]                       }
[11:41:50.331]                     }
[11:41:50.331]                     sendCondition <<- function(cond) NULL
[11:41:50.331]                   }
[11:41:50.331]                 })
[11:41:50.331]                 withCallingHandlers({
[11:41:50.331]                   {
[11:41:50.331]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:50.331]                     if (!identical(...future.globals.maxSize.org, 
[11:41:50.331]                       ...future.globals.maxSize)) {
[11:41:50.331]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:50.331]                       on.exit(options(oopts), add = TRUE)
[11:41:50.331]                     }
[11:41:50.331]                     {
[11:41:50.331]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:50.331]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:50.331]                           envir = globalenv(), inherits = FALSE)
[11:41:50.331]                         ...future.FUN(...)
[11:41:50.331]                       }
[11:41:50.331]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:50.331]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:50.331]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:50.331]                         USE.NAMES = FALSE)
[11:41:50.331]                       do.call(mapply, args = args)
[11:41:50.331]                     }
[11:41:50.331]                   }
[11:41:50.331]                 }, immediateCondition = function(cond) {
[11:41:50.331]                   sendCondition <- ...future.makeSendCondition()
[11:41:50.331]                   sendCondition(cond)
[11:41:50.331]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:50.331]                   {
[11:41:50.331]                     inherits <- base::inherits
[11:41:50.331]                     invokeRestart <- base::invokeRestart
[11:41:50.331]                     is.null <- base::is.null
[11:41:50.331]                     muffled <- FALSE
[11:41:50.331]                     if (inherits(cond, "message")) {
[11:41:50.331]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:50.331]                       if (muffled) 
[11:41:50.331]                         invokeRestart("muffleMessage")
[11:41:50.331]                     }
[11:41:50.331]                     else if (inherits(cond, "warning")) {
[11:41:50.331]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:50.331]                       if (muffled) 
[11:41:50.331]                         invokeRestart("muffleWarning")
[11:41:50.331]                     }
[11:41:50.331]                     else if (inherits(cond, "condition")) {
[11:41:50.331]                       if (!is.null(pattern)) {
[11:41:50.331]                         computeRestarts <- base::computeRestarts
[11:41:50.331]                         grepl <- base::grepl
[11:41:50.331]                         restarts <- computeRestarts(cond)
[11:41:50.331]                         for (restart in restarts) {
[11:41:50.331]                           name <- restart$name
[11:41:50.331]                           if (is.null(name)) 
[11:41:50.331]                             next
[11:41:50.331]                           if (!grepl(pattern, name)) 
[11:41:50.331]                             next
[11:41:50.331]                           invokeRestart(restart)
[11:41:50.331]                           muffled <- TRUE
[11:41:50.331]                           break
[11:41:50.331]                         }
[11:41:50.331]                       }
[11:41:50.331]                     }
[11:41:50.331]                     invisible(muffled)
[11:41:50.331]                   }
[11:41:50.331]                   muffleCondition(cond)
[11:41:50.331]                 })
[11:41:50.331]             }))
[11:41:50.331]             future::FutureResult(value = ...future.value$value, 
[11:41:50.331]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:50.331]                   ...future.rng), globalenv = if (FALSE) 
[11:41:50.331]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:50.331]                     ...future.globalenv.names))
[11:41:50.331]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:50.331]         }, condition = base::local({
[11:41:50.331]             c <- base::c
[11:41:50.331]             inherits <- base::inherits
[11:41:50.331]             invokeRestart <- base::invokeRestart
[11:41:50.331]             length <- base::length
[11:41:50.331]             list <- base::list
[11:41:50.331]             seq.int <- base::seq.int
[11:41:50.331]             signalCondition <- base::signalCondition
[11:41:50.331]             sys.calls <- base::sys.calls
[11:41:50.331]             `[[` <- base::`[[`
[11:41:50.331]             `+` <- base::`+`
[11:41:50.331]             `<<-` <- base::`<<-`
[11:41:50.331]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:50.331]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:50.331]                   3L)]
[11:41:50.331]             }
[11:41:50.331]             function(cond) {
[11:41:50.331]                 is_error <- inherits(cond, "error")
[11:41:50.331]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:50.331]                   NULL)
[11:41:50.331]                 if (is_error) {
[11:41:50.331]                   sessionInformation <- function() {
[11:41:50.331]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:50.331]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:50.331]                       search = base::search(), system = base::Sys.info())
[11:41:50.331]                   }
[11:41:50.331]                   ...future.conditions[[length(...future.conditions) + 
[11:41:50.331]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:50.331]                     cond$call), session = sessionInformation(), 
[11:41:50.331]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:50.331]                   signalCondition(cond)
[11:41:50.331]                 }
[11:41:50.331]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:50.331]                 "immediateCondition"))) {
[11:41:50.331]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:50.331]                   ...future.conditions[[length(...future.conditions) + 
[11:41:50.331]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:50.331]                   if (TRUE && !signal) {
[11:41:50.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:50.331]                     {
[11:41:50.331]                       inherits <- base::inherits
[11:41:50.331]                       invokeRestart <- base::invokeRestart
[11:41:50.331]                       is.null <- base::is.null
[11:41:50.331]                       muffled <- FALSE
[11:41:50.331]                       if (inherits(cond, "message")) {
[11:41:50.331]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:50.331]                         if (muffled) 
[11:41:50.331]                           invokeRestart("muffleMessage")
[11:41:50.331]                       }
[11:41:50.331]                       else if (inherits(cond, "warning")) {
[11:41:50.331]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:50.331]                         if (muffled) 
[11:41:50.331]                           invokeRestart("muffleWarning")
[11:41:50.331]                       }
[11:41:50.331]                       else if (inherits(cond, "condition")) {
[11:41:50.331]                         if (!is.null(pattern)) {
[11:41:50.331]                           computeRestarts <- base::computeRestarts
[11:41:50.331]                           grepl <- base::grepl
[11:41:50.331]                           restarts <- computeRestarts(cond)
[11:41:50.331]                           for (restart in restarts) {
[11:41:50.331]                             name <- restart$name
[11:41:50.331]                             if (is.null(name)) 
[11:41:50.331]                               next
[11:41:50.331]                             if (!grepl(pattern, name)) 
[11:41:50.331]                               next
[11:41:50.331]                             invokeRestart(restart)
[11:41:50.331]                             muffled <- TRUE
[11:41:50.331]                             break
[11:41:50.331]                           }
[11:41:50.331]                         }
[11:41:50.331]                       }
[11:41:50.331]                       invisible(muffled)
[11:41:50.331]                     }
[11:41:50.331]                     muffleCondition(cond, pattern = "^muffle")
[11:41:50.331]                   }
[11:41:50.331]                 }
[11:41:50.331]                 else {
[11:41:50.331]                   if (TRUE) {
[11:41:50.331]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:50.331]                     {
[11:41:50.331]                       inherits <- base::inherits
[11:41:50.331]                       invokeRestart <- base::invokeRestart
[11:41:50.331]                       is.null <- base::is.null
[11:41:50.331]                       muffled <- FALSE
[11:41:50.331]                       if (inherits(cond, "message")) {
[11:41:50.331]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:50.331]                         if (muffled) 
[11:41:50.331]                           invokeRestart("muffleMessage")
[11:41:50.331]                       }
[11:41:50.331]                       else if (inherits(cond, "warning")) {
[11:41:50.331]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:50.331]                         if (muffled) 
[11:41:50.331]                           invokeRestart("muffleWarning")
[11:41:50.331]                       }
[11:41:50.331]                       else if (inherits(cond, "condition")) {
[11:41:50.331]                         if (!is.null(pattern)) {
[11:41:50.331]                           computeRestarts <- base::computeRestarts
[11:41:50.331]                           grepl <- base::grepl
[11:41:50.331]                           restarts <- computeRestarts(cond)
[11:41:50.331]                           for (restart in restarts) {
[11:41:50.331]                             name <- restart$name
[11:41:50.331]                             if (is.null(name)) 
[11:41:50.331]                               next
[11:41:50.331]                             if (!grepl(pattern, name)) 
[11:41:50.331]                               next
[11:41:50.331]                             invokeRestart(restart)
[11:41:50.331]                             muffled <- TRUE
[11:41:50.331]                             break
[11:41:50.331]                           }
[11:41:50.331]                         }
[11:41:50.331]                       }
[11:41:50.331]                       invisible(muffled)
[11:41:50.331]                     }
[11:41:50.331]                     muffleCondition(cond, pattern = "^muffle")
[11:41:50.331]                   }
[11:41:50.331]                 }
[11:41:50.331]             }
[11:41:50.331]         }))
[11:41:50.331]     }, error = function(ex) {
[11:41:50.331]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:50.331]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:50.331]                 ...future.rng), started = ...future.startTime, 
[11:41:50.331]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:50.331]             version = "1.8"), class = "FutureResult")
[11:41:50.331]     }, finally = {
[11:41:50.331]         if (!identical(...future.workdir, getwd())) 
[11:41:50.331]             setwd(...future.workdir)
[11:41:50.331]         {
[11:41:50.331]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:50.331]                 ...future.oldOptions$nwarnings <- NULL
[11:41:50.331]             }
[11:41:50.331]             base::options(...future.oldOptions)
[11:41:50.331]             if (.Platform$OS.type == "windows") {
[11:41:50.331]                 old_names <- names(...future.oldEnvVars)
[11:41:50.331]                 envs <- base::Sys.getenv()
[11:41:50.331]                 names <- names(envs)
[11:41:50.331]                 common <- intersect(names, old_names)
[11:41:50.331]                 added <- setdiff(names, old_names)
[11:41:50.331]                 removed <- setdiff(old_names, names)
[11:41:50.331]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:50.331]                   envs[common]]
[11:41:50.331]                 NAMES <- toupper(changed)
[11:41:50.331]                 args <- list()
[11:41:50.331]                 for (kk in seq_along(NAMES)) {
[11:41:50.331]                   name <- changed[[kk]]
[11:41:50.331]                   NAME <- NAMES[[kk]]
[11:41:50.331]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:50.331]                     next
[11:41:50.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:50.331]                 }
[11:41:50.331]                 NAMES <- toupper(added)
[11:41:50.331]                 for (kk in seq_along(NAMES)) {
[11:41:50.331]                   name <- added[[kk]]
[11:41:50.331]                   NAME <- NAMES[[kk]]
[11:41:50.331]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:50.331]                     next
[11:41:50.331]                   args[[name]] <- ""
[11:41:50.331]                 }
[11:41:50.331]                 NAMES <- toupper(removed)
[11:41:50.331]                 for (kk in seq_along(NAMES)) {
[11:41:50.331]                   name <- removed[[kk]]
[11:41:50.331]                   NAME <- NAMES[[kk]]
[11:41:50.331]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:50.331]                     next
[11:41:50.331]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:50.331]                 }
[11:41:50.331]                 if (length(args) > 0) 
[11:41:50.331]                   base::do.call(base::Sys.setenv, args = args)
[11:41:50.331]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:50.331]             }
[11:41:50.331]             else {
[11:41:50.331]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:50.331]             }
[11:41:50.331]             {
[11:41:50.331]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:50.331]                   0L) {
[11:41:50.331]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:50.331]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:50.331]                   base::options(opts)
[11:41:50.331]                 }
[11:41:50.331]                 {
[11:41:50.331]                   {
[11:41:50.331]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:50.331]                     NULL
[11:41:50.331]                   }
[11:41:50.331]                   options(future.plan = NULL)
[11:41:50.331]                   if (is.na(NA_character_)) 
[11:41:50.331]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:50.331]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:50.331]                   future::plan(list(function (..., workers = 2, 
[11:41:50.331]                     envir = parent.frame()) 
[11:41:50.331]                   strategy(..., workers = workers, envir = envir)), 
[11:41:50.331]                     .cleanup = FALSE, .init = FALSE)
[11:41:50.331]                 }
[11:41:50.331]             }
[11:41:50.331]         }
[11:41:50.331]     })
[11:41:50.331]     if (TRUE) {
[11:41:50.331]         base::sink(type = "output", split = FALSE)
[11:41:50.331]         if (TRUE) {
[11:41:50.331]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:50.331]         }
[11:41:50.331]         else {
[11:41:50.331]             ...future.result["stdout"] <- base::list(NULL)
[11:41:50.331]         }
[11:41:50.331]         base::close(...future.stdout)
[11:41:50.331]         ...future.stdout <- NULL
[11:41:50.331]     }
[11:41:50.331]     ...future.result$conditions <- ...future.conditions
[11:41:50.331]     ...future.result$finished <- base::Sys.time()
[11:41:50.331]     ...future.result
[11:41:50.331] }
[11:41:50.333] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:50.344] receiveMessageFromWorker() for ClusterFuture ...
[11:41:50.344] - Validating connection of MultisessionFuture
[11:41:50.344] - received message: FutureResult
[11:41:50.344] - Received FutureResult
[11:41:50.345] - Erased future from FutureRegistry
[11:41:50.345] result() for ClusterFuture ...
[11:41:50.345] - result already collected: FutureResult
[11:41:50.345] result() for ClusterFuture ... done
[11:41:50.345] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:50.345] result() for ClusterFuture ...
[11:41:50.346] - result already collected: FutureResult
[11:41:50.346] result() for ClusterFuture ... done
[11:41:50.346] result() for ClusterFuture ...
[11:41:50.346] - result already collected: FutureResult
[11:41:50.346] result() for ClusterFuture ... done
[11:41:50.347] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:50.347] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:50.390] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:50.397] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:50.399] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:50.399] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:50.441] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:50.442] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:50.443] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:50.443] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:50.444] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:50.444] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:50.445] MultisessionFuture started
[11:41:50.445] - Launch lazy future ... done
[11:41:50.445] run() for ‘MultisessionFuture’ ... done
[11:41:50.445] Created future:
[11:41:50.446] MultisessionFuture:
[11:41:50.446] Label: ‘future_mapply-25’
[11:41:50.446] Expression:
[11:41:50.446] {
[11:41:50.446]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:50.446]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:50.446]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:50.446]         on.exit(options(oopts), add = TRUE)
[11:41:50.446]     }
[11:41:50.446]     {
[11:41:50.446]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:50.446]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:50.446]                 inherits = FALSE)
[11:41:50.446]             ...future.FUN(...)
[11:41:50.446]         }
[11:41:50.446]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:50.446]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:50.446]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:50.446]         do.call(mapply, args = args)
[11:41:50.446]     }
[11:41:50.446] }
[11:41:50.446] Lazy evaluation: FALSE
[11:41:50.446] Asynchronous evaluation: TRUE
[11:41:50.446] Local evaluation: TRUE
[11:41:50.446] Environment: 0x560ef58e1768
[11:41:50.446] Capture standard output: TRUE
[11:41:50.446] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:50.446] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:50.446] Packages: 1 packages (‘mlr3’)
[11:41:50.446] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:50.446] Resolved: FALSE
[11:41:50.446] Value: <not collected>
[11:41:50.446] Conditions captured: <none>
[11:41:50.446] Early signaling: FALSE
[11:41:50.446] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:50.446] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:50.466] Chunk #25 of 90 ... DONE
[11:41:50.466] Chunk #26 of 90 ...
[11:41:50.466]  - seeds: [1] <seeds>
[11:41:50.466] getGlobalsAndPackages() ...
[11:41:50.466] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:50.466] Resolving globals: FALSE
[11:41:50.467] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:50.467] - packages: [1] ‘mlr3’
[11:41:50.467] getGlobalsAndPackages() ... DONE
[11:41:50.468] run() for ‘Future’ ...
[11:41:50.468] - state: ‘created’
[11:41:50.468] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:50.481] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:50.481] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:50.481]   - Field: ‘node’
[11:41:50.481]   - Field: ‘label’
[11:41:50.481]   - Field: ‘local’
[11:41:50.481]   - Field: ‘owner’
[11:41:50.481]   - Field: ‘envir’
[11:41:50.481]   - Field: ‘workers’
[11:41:50.481]   - Field: ‘packages’
[11:41:50.481]   - Field: ‘gc’
[11:41:50.481]   - Field: ‘conditions’
[11:41:50.482]   - Field: ‘persistent’
[11:41:50.482]   - Field: ‘expr’
[11:41:50.482]   - Field: ‘uuid’
[11:41:50.482]   - Field: ‘seed’
[11:41:50.482]   - Field: ‘version’
[11:41:50.482]   - Field: ‘result’
[11:41:50.482]   - Field: ‘asynchronous’
[11:41:50.482]   - Field: ‘calls’
[11:41:50.482]   - Field: ‘globals’
[11:41:50.482]   - Field: ‘stdout’
[11:41:50.482]   - Field: ‘earlySignal’
[11:41:50.482]   - Field: ‘lazy’
[11:41:50.482]   - Field: ‘state’
[11:41:50.482] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:50.482] - Launch lazy future ...
[11:41:50.482] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:50.483] Packages needed by future strategies (n = 0): <none>
[11:41:50.483] {
[11:41:50.483]     {
[11:41:50.483]         {
[11:41:50.483]             ...future.startTime <- base::Sys.time()
[11:41:50.483]             {
[11:41:50.483]                 {
[11:41:50.483]                   {
[11:41:50.483]                     {
[11:41:50.483]                       {
[11:41:50.483]                         base::local({
[11:41:50.483]                           has_future <- base::requireNamespace("future", 
[11:41:50.483]                             quietly = TRUE)
[11:41:50.483]                           if (has_future) {
[11:41:50.483]                             ns <- base::getNamespace("future")
[11:41:50.483]                             version <- ns[[".package"]][["version"]]
[11:41:50.483]                             if (is.null(version)) 
[11:41:50.483]                               version <- utils::packageVersion("future")
[11:41:50.483]                           }
[11:41:50.483]                           else {
[11:41:50.483]                             version <- NULL
[11:41:50.483]                           }
[11:41:50.483]                           if (!has_future || version < "1.8.0") {
[11:41:50.483]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:50.483]                               "", base::R.version$version.string), 
[11:41:50.483]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:50.483]                                 base::R.version$platform, 8 * 
[11:41:50.483]                                   base::.Machine$sizeof.pointer), 
[11:41:50.483]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:50.483]                                 "release", "version")], collapse = " "), 
[11:41:50.483]                               hostname = base::Sys.info()[["nodename"]])
[11:41:50.483]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:50.483]                               info)
[11:41:50.483]                             info <- base::paste(info, collapse = "; ")
[11:41:50.483]                             if (!has_future) {
[11:41:50.483]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:50.483]                                 info)
[11:41:50.483]                             }
[11:41:50.483]                             else {
[11:41:50.483]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:50.483]                                 info, version)
[11:41:50.483]                             }
[11:41:50.483]                             base::stop(msg)
[11:41:50.483]                           }
[11:41:50.483]                         })
[11:41:50.483]                       }
[11:41:50.483]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:50.483]                       base::options(mc.cores = 1L)
[11:41:50.483]                     }
[11:41:50.483]                     base::local({
[11:41:50.483]                       for (pkg in "mlr3") {
[11:41:50.483]                         base::loadNamespace(pkg)
[11:41:50.483]                         base::library(pkg, character.only = TRUE)
[11:41:50.483]                       }
[11:41:50.483]                     })
[11:41:50.483]                   }
[11:41:50.483]                   options(future.plan = NULL)
[11:41:50.483]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:50.483]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:50.483]                 }
[11:41:50.483]                 ...future.workdir <- getwd()
[11:41:50.483]             }
[11:41:50.483]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:50.483]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:50.483]         }
[11:41:50.483]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:50.483]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:50.483]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:50.483]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:50.483]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:50.483]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:50.483]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:50.483]             base::names(...future.oldOptions))
[11:41:50.483]     }
[11:41:50.483]     if (FALSE) {
[11:41:50.483]     }
[11:41:50.483]     else {
[11:41:50.483]         if (TRUE) {
[11:41:50.483]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:50.483]                 open = "w")
[11:41:50.483]         }
[11:41:50.483]         else {
[11:41:50.483]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:50.483]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:50.483]         }
[11:41:50.483]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:50.483]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:50.483]             base::sink(type = "output", split = FALSE)
[11:41:50.483]             base::close(...future.stdout)
[11:41:50.483]         }, add = TRUE)
[11:41:50.483]     }
[11:41:50.483]     ...future.frame <- base::sys.nframe()
[11:41:50.483]     ...future.conditions <- base::list()
[11:41:50.483]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:50.483]     if (FALSE) {
[11:41:50.483]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:50.483]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:50.483]     }
[11:41:50.483]     ...future.result <- base::tryCatch({
[11:41:50.483]         base::withCallingHandlers({
[11:41:50.483]             ...future.value <- base::withVisible(base::local({
[11:41:50.483]                 ...future.makeSendCondition <- local({
[11:41:50.483]                   sendCondition <- NULL
[11:41:50.483]                   function(frame = 1L) {
[11:41:50.483]                     if (is.function(sendCondition)) 
[11:41:50.483]                       return(sendCondition)
[11:41:50.483]                     ns <- getNamespace("parallel")
[11:41:50.483]                     if (exists("sendData", mode = "function", 
[11:41:50.483]                       envir = ns)) {
[11:41:50.483]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:50.483]                         envir = ns)
[11:41:50.483]                       envir <- sys.frame(frame)
[11:41:50.483]                       master <- NULL
[11:41:50.483]                       while (!identical(envir, .GlobalEnv) && 
[11:41:50.483]                         !identical(envir, emptyenv())) {
[11:41:50.483]                         if (exists("master", mode = "list", envir = envir, 
[11:41:50.483]                           inherits = FALSE)) {
[11:41:50.483]                           master <- get("master", mode = "list", 
[11:41:50.483]                             envir = envir, inherits = FALSE)
[11:41:50.483]                           if (inherits(master, c("SOCKnode", 
[11:41:50.483]                             "SOCK0node"))) {
[11:41:50.483]                             sendCondition <<- function(cond) {
[11:41:50.483]                               data <- list(type = "VALUE", value = cond, 
[11:41:50.483]                                 success = TRUE)
[11:41:50.483]                               parallel_sendData(master, data)
[11:41:50.483]                             }
[11:41:50.483]                             return(sendCondition)
[11:41:50.483]                           }
[11:41:50.483]                         }
[11:41:50.483]                         frame <- frame + 1L
[11:41:50.483]                         envir <- sys.frame(frame)
[11:41:50.483]                       }
[11:41:50.483]                     }
[11:41:50.483]                     sendCondition <<- function(cond) NULL
[11:41:50.483]                   }
[11:41:50.483]                 })
[11:41:50.483]                 withCallingHandlers({
[11:41:50.483]                   {
[11:41:50.483]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:50.483]                     if (!identical(...future.globals.maxSize.org, 
[11:41:50.483]                       ...future.globals.maxSize)) {
[11:41:50.483]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:50.483]                       on.exit(options(oopts), add = TRUE)
[11:41:50.483]                     }
[11:41:50.483]                     {
[11:41:50.483]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:50.483]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:50.483]                           envir = globalenv(), inherits = FALSE)
[11:41:50.483]                         ...future.FUN(...)
[11:41:50.483]                       }
[11:41:50.483]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:50.483]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:50.483]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:50.483]                         USE.NAMES = FALSE)
[11:41:50.483]                       do.call(mapply, args = args)
[11:41:50.483]                     }
[11:41:50.483]                   }
[11:41:50.483]                 }, immediateCondition = function(cond) {
[11:41:50.483]                   sendCondition <- ...future.makeSendCondition()
[11:41:50.483]                   sendCondition(cond)
[11:41:50.483]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:50.483]                   {
[11:41:50.483]                     inherits <- base::inherits
[11:41:50.483]                     invokeRestart <- base::invokeRestart
[11:41:50.483]                     is.null <- base::is.null
[11:41:50.483]                     muffled <- FALSE
[11:41:50.483]                     if (inherits(cond, "message")) {
[11:41:50.483]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:50.483]                       if (muffled) 
[11:41:50.483]                         invokeRestart("muffleMessage")
[11:41:50.483]                     }
[11:41:50.483]                     else if (inherits(cond, "warning")) {
[11:41:50.483]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:50.483]                       if (muffled) 
[11:41:50.483]                         invokeRestart("muffleWarning")
[11:41:50.483]                     }
[11:41:50.483]                     else if (inherits(cond, "condition")) {
[11:41:50.483]                       if (!is.null(pattern)) {
[11:41:50.483]                         computeRestarts <- base::computeRestarts
[11:41:50.483]                         grepl <- base::grepl
[11:41:50.483]                         restarts <- computeRestarts(cond)
[11:41:50.483]                         for (restart in restarts) {
[11:41:50.483]                           name <- restart$name
[11:41:50.483]                           if (is.null(name)) 
[11:41:50.483]                             next
[11:41:50.483]                           if (!grepl(pattern, name)) 
[11:41:50.483]                             next
[11:41:50.483]                           invokeRestart(restart)
[11:41:50.483]                           muffled <- TRUE
[11:41:50.483]                           break
[11:41:50.483]                         }
[11:41:50.483]                       }
[11:41:50.483]                     }
[11:41:50.483]                     invisible(muffled)
[11:41:50.483]                   }
[11:41:50.483]                   muffleCondition(cond)
[11:41:50.483]                 })
[11:41:50.483]             }))
[11:41:50.483]             future::FutureResult(value = ...future.value$value, 
[11:41:50.483]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:50.483]                   ...future.rng), globalenv = if (FALSE) 
[11:41:50.483]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:50.483]                     ...future.globalenv.names))
[11:41:50.483]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:50.483]         }, condition = base::local({
[11:41:50.483]             c <- base::c
[11:41:50.483]             inherits <- base::inherits
[11:41:50.483]             invokeRestart <- base::invokeRestart
[11:41:50.483]             length <- base::length
[11:41:50.483]             list <- base::list
[11:41:50.483]             seq.int <- base::seq.int
[11:41:50.483]             signalCondition <- base::signalCondition
[11:41:50.483]             sys.calls <- base::sys.calls
[11:41:50.483]             `[[` <- base::`[[`
[11:41:50.483]             `+` <- base::`+`
[11:41:50.483]             `<<-` <- base::`<<-`
[11:41:50.483]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:50.483]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:50.483]                   3L)]
[11:41:50.483]             }
[11:41:50.483]             function(cond) {
[11:41:50.483]                 is_error <- inherits(cond, "error")
[11:41:50.483]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:50.483]                   NULL)
[11:41:50.483]                 if (is_error) {
[11:41:50.483]                   sessionInformation <- function() {
[11:41:50.483]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:50.483]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:50.483]                       search = base::search(), system = base::Sys.info())
[11:41:50.483]                   }
[11:41:50.483]                   ...future.conditions[[length(...future.conditions) + 
[11:41:50.483]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:50.483]                     cond$call), session = sessionInformation(), 
[11:41:50.483]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:50.483]                   signalCondition(cond)
[11:41:50.483]                 }
[11:41:50.483]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:50.483]                 "immediateCondition"))) {
[11:41:50.483]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:50.483]                   ...future.conditions[[length(...future.conditions) + 
[11:41:50.483]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:50.483]                   if (TRUE && !signal) {
[11:41:50.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:50.483]                     {
[11:41:50.483]                       inherits <- base::inherits
[11:41:50.483]                       invokeRestart <- base::invokeRestart
[11:41:50.483]                       is.null <- base::is.null
[11:41:50.483]                       muffled <- FALSE
[11:41:50.483]                       if (inherits(cond, "message")) {
[11:41:50.483]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:50.483]                         if (muffled) 
[11:41:50.483]                           invokeRestart("muffleMessage")
[11:41:50.483]                       }
[11:41:50.483]                       else if (inherits(cond, "warning")) {
[11:41:50.483]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:50.483]                         if (muffled) 
[11:41:50.483]                           invokeRestart("muffleWarning")
[11:41:50.483]                       }
[11:41:50.483]                       else if (inherits(cond, "condition")) {
[11:41:50.483]                         if (!is.null(pattern)) {
[11:41:50.483]                           computeRestarts <- base::computeRestarts
[11:41:50.483]                           grepl <- base::grepl
[11:41:50.483]                           restarts <- computeRestarts(cond)
[11:41:50.483]                           for (restart in restarts) {
[11:41:50.483]                             name <- restart$name
[11:41:50.483]                             if (is.null(name)) 
[11:41:50.483]                               next
[11:41:50.483]                             if (!grepl(pattern, name)) 
[11:41:50.483]                               next
[11:41:50.483]                             invokeRestart(restart)
[11:41:50.483]                             muffled <- TRUE
[11:41:50.483]                             break
[11:41:50.483]                           }
[11:41:50.483]                         }
[11:41:50.483]                       }
[11:41:50.483]                       invisible(muffled)
[11:41:50.483]                     }
[11:41:50.483]                     muffleCondition(cond, pattern = "^muffle")
[11:41:50.483]                   }
[11:41:50.483]                 }
[11:41:50.483]                 else {
[11:41:50.483]                   if (TRUE) {
[11:41:50.483]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:50.483]                     {
[11:41:50.483]                       inherits <- base::inherits
[11:41:50.483]                       invokeRestart <- base::invokeRestart
[11:41:50.483]                       is.null <- base::is.null
[11:41:50.483]                       muffled <- FALSE
[11:41:50.483]                       if (inherits(cond, "message")) {
[11:41:50.483]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:50.483]                         if (muffled) 
[11:41:50.483]                           invokeRestart("muffleMessage")
[11:41:50.483]                       }
[11:41:50.483]                       else if (inherits(cond, "warning")) {
[11:41:50.483]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:50.483]                         if (muffled) 
[11:41:50.483]                           invokeRestart("muffleWarning")
[11:41:50.483]                       }
[11:41:50.483]                       else if (inherits(cond, "condition")) {
[11:41:50.483]                         if (!is.null(pattern)) {
[11:41:50.483]                           computeRestarts <- base::computeRestarts
[11:41:50.483]                           grepl <- base::grepl
[11:41:50.483]                           restarts <- computeRestarts(cond)
[11:41:50.483]                           for (restart in restarts) {
[11:41:50.483]                             name <- restart$name
[11:41:50.483]                             if (is.null(name)) 
[11:41:50.483]                               next
[11:41:50.483]                             if (!grepl(pattern, name)) 
[11:41:50.483]                               next
[11:41:50.483]                             invokeRestart(restart)
[11:41:50.483]                             muffled <- TRUE
[11:41:50.483]                             break
[11:41:50.483]                           }
[11:41:50.483]                         }
[11:41:50.483]                       }
[11:41:50.483]                       invisible(muffled)
[11:41:50.483]                     }
[11:41:50.483]                     muffleCondition(cond, pattern = "^muffle")
[11:41:50.483]                   }
[11:41:50.483]                 }
[11:41:50.483]             }
[11:41:50.483]         }))
[11:41:50.483]     }, error = function(ex) {
[11:41:50.483]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:50.483]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:50.483]                 ...future.rng), started = ...future.startTime, 
[11:41:50.483]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:50.483]             version = "1.8"), class = "FutureResult")
[11:41:50.483]     }, finally = {
[11:41:50.483]         if (!identical(...future.workdir, getwd())) 
[11:41:50.483]             setwd(...future.workdir)
[11:41:50.483]         {
[11:41:50.483]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:50.483]                 ...future.oldOptions$nwarnings <- NULL
[11:41:50.483]             }
[11:41:50.483]             base::options(...future.oldOptions)
[11:41:50.483]             if (.Platform$OS.type == "windows") {
[11:41:50.483]                 old_names <- names(...future.oldEnvVars)
[11:41:50.483]                 envs <- base::Sys.getenv()
[11:41:50.483]                 names <- names(envs)
[11:41:50.483]                 common <- intersect(names, old_names)
[11:41:50.483]                 added <- setdiff(names, old_names)
[11:41:50.483]                 removed <- setdiff(old_names, names)
[11:41:50.483]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:50.483]                   envs[common]]
[11:41:50.483]                 NAMES <- toupper(changed)
[11:41:50.483]                 args <- list()
[11:41:50.483]                 for (kk in seq_along(NAMES)) {
[11:41:50.483]                   name <- changed[[kk]]
[11:41:50.483]                   NAME <- NAMES[[kk]]
[11:41:50.483]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:50.483]                     next
[11:41:50.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:50.483]                 }
[11:41:50.483]                 NAMES <- toupper(added)
[11:41:50.483]                 for (kk in seq_along(NAMES)) {
[11:41:50.483]                   name <- added[[kk]]
[11:41:50.483]                   NAME <- NAMES[[kk]]
[11:41:50.483]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:50.483]                     next
[11:41:50.483]                   args[[name]] <- ""
[11:41:50.483]                 }
[11:41:50.483]                 NAMES <- toupper(removed)
[11:41:50.483]                 for (kk in seq_along(NAMES)) {
[11:41:50.483]                   name <- removed[[kk]]
[11:41:50.483]                   NAME <- NAMES[[kk]]
[11:41:50.483]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:50.483]                     next
[11:41:50.483]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:50.483]                 }
[11:41:50.483]                 if (length(args) > 0) 
[11:41:50.483]                   base::do.call(base::Sys.setenv, args = args)
[11:41:50.483]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:50.483]             }
[11:41:50.483]             else {
[11:41:50.483]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:50.483]             }
[11:41:50.483]             {
[11:41:50.483]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:50.483]                   0L) {
[11:41:50.483]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:50.483]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:50.483]                   base::options(opts)
[11:41:50.483]                 }
[11:41:50.483]                 {
[11:41:50.483]                   {
[11:41:50.483]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:50.483]                     NULL
[11:41:50.483]                   }
[11:41:50.483]                   options(future.plan = NULL)
[11:41:50.483]                   if (is.na(NA_character_)) 
[11:41:50.483]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:50.483]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:50.483]                   future::plan(list(function (..., workers = 2, 
[11:41:50.483]                     envir = parent.frame()) 
[11:41:50.483]                   strategy(..., workers = workers, envir = envir)), 
[11:41:50.483]                     .cleanup = FALSE, .init = FALSE)
[11:41:50.483]                 }
[11:41:50.483]             }
[11:41:50.483]         }
[11:41:50.483]     })
[11:41:50.483]     if (TRUE) {
[11:41:50.483]         base::sink(type = "output", split = FALSE)
[11:41:50.483]         if (TRUE) {
[11:41:50.483]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:50.483]         }
[11:41:50.483]         else {
[11:41:50.483]             ...future.result["stdout"] <- base::list(NULL)
[11:41:50.483]         }
[11:41:50.483]         base::close(...future.stdout)
[11:41:50.483]         ...future.stdout <- NULL
[11:41:50.483]     }
[11:41:50.483]     ...future.result$conditions <- ...future.conditions
[11:41:50.483]     ...future.result$finished <- base::Sys.time()
[11:41:50.483]     ...future.result
[11:41:50.483] }
[11:41:50.485] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:50.495] receiveMessageFromWorker() for ClusterFuture ...
[11:41:50.496] - Validating connection of MultisessionFuture
[11:41:50.496] - received message: FutureResult
[11:41:50.496] - Received FutureResult
[11:41:50.496] - Erased future from FutureRegistry
[11:41:50.496] result() for ClusterFuture ...
[11:41:50.496] - result already collected: FutureResult
[11:41:50.496] result() for ClusterFuture ... done
[11:41:50.497] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:50.497] result() for ClusterFuture ...
[11:41:50.497] - result already collected: FutureResult
[11:41:50.497] result() for ClusterFuture ... done
[11:41:50.497] result() for ClusterFuture ...
[11:41:50.497] - result already collected: FutureResult
[11:41:50.497] result() for ClusterFuture ... done
[11:41:50.498] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:50.498] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:50.542] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:50.549] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:50.598] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:50.598] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:50.641] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:50.641] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:50.642] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:50.642] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:50.642] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:50.643] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:50.643] MultisessionFuture started
[11:41:50.643] - Launch lazy future ... done
[11:41:50.643] run() for ‘MultisessionFuture’ ... done
[11:41:50.644] Created future:
[11:41:50.644] MultisessionFuture:
[11:41:50.644] Label: ‘future_mapply-26’
[11:41:50.644] Expression:
[11:41:50.644] {
[11:41:50.644]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:50.644]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:50.644]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:50.644]         on.exit(options(oopts), add = TRUE)
[11:41:50.644]     }
[11:41:50.644]     {
[11:41:50.644]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:50.644]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:50.644]                 inherits = FALSE)
[11:41:50.644]             ...future.FUN(...)
[11:41:50.644]         }
[11:41:50.644]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:50.644]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:50.644]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:50.644]         do.call(mapply, args = args)
[11:41:50.644]     }
[11:41:50.644] }
[11:41:50.644] Lazy evaluation: FALSE
[11:41:50.644] Asynchronous evaluation: TRUE
[11:41:50.644] Local evaluation: TRUE
[11:41:50.644] Environment: 0x560ef58e1768
[11:41:50.644] Capture standard output: TRUE
[11:41:50.644] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:50.644] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:50.644] Packages: 1 packages (‘mlr3’)
[11:41:50.644] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:50.644] Resolved: FALSE
[11:41:50.644] Value: <not collected>
[11:41:50.644] Conditions captured: <none>
[11:41:50.644] Early signaling: FALSE
[11:41:50.644] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:50.644] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:50.660] Chunk #26 of 90 ... DONE
[11:41:50.660] Chunk #27 of 90 ...
[11:41:50.660]  - seeds: [1] <seeds>
[11:41:50.660] getGlobalsAndPackages() ...
[11:41:50.660] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:50.660] Resolving globals: FALSE
[11:41:50.661] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:50.661] - packages: [1] ‘mlr3’
[11:41:50.661] getGlobalsAndPackages() ... DONE
[11:41:50.661] run() for ‘Future’ ...
[11:41:50.661] - state: ‘created’
[11:41:50.662] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:50.671] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:50.671] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:50.671]   - Field: ‘node’
[11:41:50.671]   - Field: ‘label’
[11:41:50.671]   - Field: ‘local’
[11:41:50.671]   - Field: ‘owner’
[11:41:50.671]   - Field: ‘envir’
[11:41:50.671]   - Field: ‘workers’
[11:41:50.672]   - Field: ‘packages’
[11:41:50.672]   - Field: ‘gc’
[11:41:50.672]   - Field: ‘conditions’
[11:41:50.672]   - Field: ‘persistent’
[11:41:50.672]   - Field: ‘expr’
[11:41:50.672]   - Field: ‘uuid’
[11:41:50.672]   - Field: ‘seed’
[11:41:50.672]   - Field: ‘version’
[11:41:50.672]   - Field: ‘result’
[11:41:50.672]   - Field: ‘asynchronous’
[11:41:50.672]   - Field: ‘calls’
[11:41:50.672]   - Field: ‘globals’
[11:41:50.672]   - Field: ‘stdout’
[11:41:50.672]   - Field: ‘earlySignal’
[11:41:50.672]   - Field: ‘lazy’
[11:41:50.672]   - Field: ‘state’
[11:41:50.672] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:50.672] - Launch lazy future ...
[11:41:50.673] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:50.673] Packages needed by future strategies (n = 0): <none>
[11:41:50.673] {
[11:41:50.673]     {
[11:41:50.673]         {
[11:41:50.673]             ...future.startTime <- base::Sys.time()
[11:41:50.673]             {
[11:41:50.673]                 {
[11:41:50.673]                   {
[11:41:50.673]                     {
[11:41:50.673]                       {
[11:41:50.673]                         base::local({
[11:41:50.673]                           has_future <- base::requireNamespace("future", 
[11:41:50.673]                             quietly = TRUE)
[11:41:50.673]                           if (has_future) {
[11:41:50.673]                             ns <- base::getNamespace("future")
[11:41:50.673]                             version <- ns[[".package"]][["version"]]
[11:41:50.673]                             if (is.null(version)) 
[11:41:50.673]                               version <- utils::packageVersion("future")
[11:41:50.673]                           }
[11:41:50.673]                           else {
[11:41:50.673]                             version <- NULL
[11:41:50.673]                           }
[11:41:50.673]                           if (!has_future || version < "1.8.0") {
[11:41:50.673]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:50.673]                               "", base::R.version$version.string), 
[11:41:50.673]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:50.673]                                 base::R.version$platform, 8 * 
[11:41:50.673]                                   base::.Machine$sizeof.pointer), 
[11:41:50.673]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:50.673]                                 "release", "version")], collapse = " "), 
[11:41:50.673]                               hostname = base::Sys.info()[["nodename"]])
[11:41:50.673]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:50.673]                               info)
[11:41:50.673]                             info <- base::paste(info, collapse = "; ")
[11:41:50.673]                             if (!has_future) {
[11:41:50.673]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:50.673]                                 info)
[11:41:50.673]                             }
[11:41:50.673]                             else {
[11:41:50.673]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:50.673]                                 info, version)
[11:41:50.673]                             }
[11:41:50.673]                             base::stop(msg)
[11:41:50.673]                           }
[11:41:50.673]                         })
[11:41:50.673]                       }
[11:41:50.673]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:50.673]                       base::options(mc.cores = 1L)
[11:41:50.673]                     }
[11:41:50.673]                     base::local({
[11:41:50.673]                       for (pkg in "mlr3") {
[11:41:50.673]                         base::loadNamespace(pkg)
[11:41:50.673]                         base::library(pkg, character.only = TRUE)
[11:41:50.673]                       }
[11:41:50.673]                     })
[11:41:50.673]                   }
[11:41:50.673]                   options(future.plan = NULL)
[11:41:50.673]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:50.673]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:50.673]                 }
[11:41:50.673]                 ...future.workdir <- getwd()
[11:41:50.673]             }
[11:41:50.673]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:50.673]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:50.673]         }
[11:41:50.673]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:50.673]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:50.673]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:50.673]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:50.673]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:50.673]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:50.673]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:50.673]             base::names(...future.oldOptions))
[11:41:50.673]     }
[11:41:50.673]     if (FALSE) {
[11:41:50.673]     }
[11:41:50.673]     else {
[11:41:50.673]         if (TRUE) {
[11:41:50.673]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:50.673]                 open = "w")
[11:41:50.673]         }
[11:41:50.673]         else {
[11:41:50.673]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:50.673]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:50.673]         }
[11:41:50.673]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:50.673]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:50.673]             base::sink(type = "output", split = FALSE)
[11:41:50.673]             base::close(...future.stdout)
[11:41:50.673]         }, add = TRUE)
[11:41:50.673]     }
[11:41:50.673]     ...future.frame <- base::sys.nframe()
[11:41:50.673]     ...future.conditions <- base::list()
[11:41:50.673]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:50.673]     if (FALSE) {
[11:41:50.673]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:50.673]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:50.673]     }
[11:41:50.673]     ...future.result <- base::tryCatch({
[11:41:50.673]         base::withCallingHandlers({
[11:41:50.673]             ...future.value <- base::withVisible(base::local({
[11:41:50.673]                 ...future.makeSendCondition <- local({
[11:41:50.673]                   sendCondition <- NULL
[11:41:50.673]                   function(frame = 1L) {
[11:41:50.673]                     if (is.function(sendCondition)) 
[11:41:50.673]                       return(sendCondition)
[11:41:50.673]                     ns <- getNamespace("parallel")
[11:41:50.673]                     if (exists("sendData", mode = "function", 
[11:41:50.673]                       envir = ns)) {
[11:41:50.673]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:50.673]                         envir = ns)
[11:41:50.673]                       envir <- sys.frame(frame)
[11:41:50.673]                       master <- NULL
[11:41:50.673]                       while (!identical(envir, .GlobalEnv) && 
[11:41:50.673]                         !identical(envir, emptyenv())) {
[11:41:50.673]                         if (exists("master", mode = "list", envir = envir, 
[11:41:50.673]                           inherits = FALSE)) {
[11:41:50.673]                           master <- get("master", mode = "list", 
[11:41:50.673]                             envir = envir, inherits = FALSE)
[11:41:50.673]                           if (inherits(master, c("SOCKnode", 
[11:41:50.673]                             "SOCK0node"))) {
[11:41:50.673]                             sendCondition <<- function(cond) {
[11:41:50.673]                               data <- list(type = "VALUE", value = cond, 
[11:41:50.673]                                 success = TRUE)
[11:41:50.673]                               parallel_sendData(master, data)
[11:41:50.673]                             }
[11:41:50.673]                             return(sendCondition)
[11:41:50.673]                           }
[11:41:50.673]                         }
[11:41:50.673]                         frame <- frame + 1L
[11:41:50.673]                         envir <- sys.frame(frame)
[11:41:50.673]                       }
[11:41:50.673]                     }
[11:41:50.673]                     sendCondition <<- function(cond) NULL
[11:41:50.673]                   }
[11:41:50.673]                 })
[11:41:50.673]                 withCallingHandlers({
[11:41:50.673]                   {
[11:41:50.673]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:50.673]                     if (!identical(...future.globals.maxSize.org, 
[11:41:50.673]                       ...future.globals.maxSize)) {
[11:41:50.673]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:50.673]                       on.exit(options(oopts), add = TRUE)
[11:41:50.673]                     }
[11:41:50.673]                     {
[11:41:50.673]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:50.673]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:50.673]                           envir = globalenv(), inherits = FALSE)
[11:41:50.673]                         ...future.FUN(...)
[11:41:50.673]                       }
[11:41:50.673]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:50.673]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:50.673]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:50.673]                         USE.NAMES = FALSE)
[11:41:50.673]                       do.call(mapply, args = args)
[11:41:50.673]                     }
[11:41:50.673]                   }
[11:41:50.673]                 }, immediateCondition = function(cond) {
[11:41:50.673]                   sendCondition <- ...future.makeSendCondition()
[11:41:50.673]                   sendCondition(cond)
[11:41:50.673]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:50.673]                   {
[11:41:50.673]                     inherits <- base::inherits
[11:41:50.673]                     invokeRestart <- base::invokeRestart
[11:41:50.673]                     is.null <- base::is.null
[11:41:50.673]                     muffled <- FALSE
[11:41:50.673]                     if (inherits(cond, "message")) {
[11:41:50.673]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:50.673]                       if (muffled) 
[11:41:50.673]                         invokeRestart("muffleMessage")
[11:41:50.673]                     }
[11:41:50.673]                     else if (inherits(cond, "warning")) {
[11:41:50.673]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:50.673]                       if (muffled) 
[11:41:50.673]                         invokeRestart("muffleWarning")
[11:41:50.673]                     }
[11:41:50.673]                     else if (inherits(cond, "condition")) {
[11:41:50.673]                       if (!is.null(pattern)) {
[11:41:50.673]                         computeRestarts <- base::computeRestarts
[11:41:50.673]                         grepl <- base::grepl
[11:41:50.673]                         restarts <- computeRestarts(cond)
[11:41:50.673]                         for (restart in restarts) {
[11:41:50.673]                           name <- restart$name
[11:41:50.673]                           if (is.null(name)) 
[11:41:50.673]                             next
[11:41:50.673]                           if (!grepl(pattern, name)) 
[11:41:50.673]                             next
[11:41:50.673]                           invokeRestart(restart)
[11:41:50.673]                           muffled <- TRUE
[11:41:50.673]                           break
[11:41:50.673]                         }
[11:41:50.673]                       }
[11:41:50.673]                     }
[11:41:50.673]                     invisible(muffled)
[11:41:50.673]                   }
[11:41:50.673]                   muffleCondition(cond)
[11:41:50.673]                 })
[11:41:50.673]             }))
[11:41:50.673]             future::FutureResult(value = ...future.value$value, 
[11:41:50.673]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:50.673]                   ...future.rng), globalenv = if (FALSE) 
[11:41:50.673]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:50.673]                     ...future.globalenv.names))
[11:41:50.673]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:50.673]         }, condition = base::local({
[11:41:50.673]             c <- base::c
[11:41:50.673]             inherits <- base::inherits
[11:41:50.673]             invokeRestart <- base::invokeRestart
[11:41:50.673]             length <- base::length
[11:41:50.673]             list <- base::list
[11:41:50.673]             seq.int <- base::seq.int
[11:41:50.673]             signalCondition <- base::signalCondition
[11:41:50.673]             sys.calls <- base::sys.calls
[11:41:50.673]             `[[` <- base::`[[`
[11:41:50.673]             `+` <- base::`+`
[11:41:50.673]             `<<-` <- base::`<<-`
[11:41:50.673]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:50.673]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:50.673]                   3L)]
[11:41:50.673]             }
[11:41:50.673]             function(cond) {
[11:41:50.673]                 is_error <- inherits(cond, "error")
[11:41:50.673]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:50.673]                   NULL)
[11:41:50.673]                 if (is_error) {
[11:41:50.673]                   sessionInformation <- function() {
[11:41:50.673]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:50.673]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:50.673]                       search = base::search(), system = base::Sys.info())
[11:41:50.673]                   }
[11:41:50.673]                   ...future.conditions[[length(...future.conditions) + 
[11:41:50.673]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:50.673]                     cond$call), session = sessionInformation(), 
[11:41:50.673]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:50.673]                   signalCondition(cond)
[11:41:50.673]                 }
[11:41:50.673]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:50.673]                 "immediateCondition"))) {
[11:41:50.673]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:50.673]                   ...future.conditions[[length(...future.conditions) + 
[11:41:50.673]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:50.673]                   if (TRUE && !signal) {
[11:41:50.673]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:50.673]                     {
[11:41:50.673]                       inherits <- base::inherits
[11:41:50.673]                       invokeRestart <- base::invokeRestart
[11:41:50.673]                       is.null <- base::is.null
[11:41:50.673]                       muffled <- FALSE
[11:41:50.673]                       if (inherits(cond, "message")) {
[11:41:50.673]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:50.673]                         if (muffled) 
[11:41:50.673]                           invokeRestart("muffleMessage")
[11:41:50.673]                       }
[11:41:50.673]                       else if (inherits(cond, "warning")) {
[11:41:50.673]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:50.673]                         if (muffled) 
[11:41:50.673]                           invokeRestart("muffleWarning")
[11:41:50.673]                       }
[11:41:50.673]                       else if (inherits(cond, "condition")) {
[11:41:50.673]                         if (!is.null(pattern)) {
[11:41:50.673]                           computeRestarts <- base::computeRestarts
[11:41:50.673]                           grepl <- base::grepl
[11:41:50.673]                           restarts <- computeRestarts(cond)
[11:41:50.673]                           for (restart in restarts) {
[11:41:50.673]                             name <- restart$name
[11:41:50.673]                             if (is.null(name)) 
[11:41:50.673]                               next
[11:41:50.673]                             if (!grepl(pattern, name)) 
[11:41:50.673]                               next
[11:41:50.673]                             invokeRestart(restart)
[11:41:50.673]                             muffled <- TRUE
[11:41:50.673]                             break
[11:41:50.673]                           }
[11:41:50.673]                         }
[11:41:50.673]                       }
[11:41:50.673]                       invisible(muffled)
[11:41:50.673]                     }
[11:41:50.673]                     muffleCondition(cond, pattern = "^muffle")
[11:41:50.673]                   }
[11:41:50.673]                 }
[11:41:50.673]                 else {
[11:41:50.673]                   if (TRUE) {
[11:41:50.673]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:50.673]                     {
[11:41:50.673]                       inherits <- base::inherits
[11:41:50.673]                       invokeRestart <- base::invokeRestart
[11:41:50.673]                       is.null <- base::is.null
[11:41:50.673]                       muffled <- FALSE
[11:41:50.673]                       if (inherits(cond, "message")) {
[11:41:50.673]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:50.673]                         if (muffled) 
[11:41:50.673]                           invokeRestart("muffleMessage")
[11:41:50.673]                       }
[11:41:50.673]                       else if (inherits(cond, "warning")) {
[11:41:50.673]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:50.673]                         if (muffled) 
[11:41:50.673]                           invokeRestart("muffleWarning")
[11:41:50.673]                       }
[11:41:50.673]                       else if (inherits(cond, "condition")) {
[11:41:50.673]                         if (!is.null(pattern)) {
[11:41:50.673]                           computeRestarts <- base::computeRestarts
[11:41:50.673]                           grepl <- base::grepl
[11:41:50.673]                           restarts <- computeRestarts(cond)
[11:41:50.673]                           for (restart in restarts) {
[11:41:50.673]                             name <- restart$name
[11:41:50.673]                             if (is.null(name)) 
[11:41:50.673]                               next
[11:41:50.673]                             if (!grepl(pattern, name)) 
[11:41:50.673]                               next
[11:41:50.673]                             invokeRestart(restart)
[11:41:50.673]                             muffled <- TRUE
[11:41:50.673]                             break
[11:41:50.673]                           }
[11:41:50.673]                         }
[11:41:50.673]                       }
[11:41:50.673]                       invisible(muffled)
[11:41:50.673]                     }
[11:41:50.673]                     muffleCondition(cond, pattern = "^muffle")
[11:41:50.673]                   }
[11:41:50.673]                 }
[11:41:50.673]             }
[11:41:50.673]         }))
[11:41:50.673]     }, error = function(ex) {
[11:41:50.673]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:50.673]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:50.673]                 ...future.rng), started = ...future.startTime, 
[11:41:50.673]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:50.673]             version = "1.8"), class = "FutureResult")
[11:41:50.673]     }, finally = {
[11:41:50.673]         if (!identical(...future.workdir, getwd())) 
[11:41:50.673]             setwd(...future.workdir)
[11:41:50.673]         {
[11:41:50.673]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:50.673]                 ...future.oldOptions$nwarnings <- NULL
[11:41:50.673]             }
[11:41:50.673]             base::options(...future.oldOptions)
[11:41:50.673]             if (.Platform$OS.type == "windows") {
[11:41:50.673]                 old_names <- names(...future.oldEnvVars)
[11:41:50.673]                 envs <- base::Sys.getenv()
[11:41:50.673]                 names <- names(envs)
[11:41:50.673]                 common <- intersect(names, old_names)
[11:41:50.673]                 added <- setdiff(names, old_names)
[11:41:50.673]                 removed <- setdiff(old_names, names)
[11:41:50.673]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:50.673]                   envs[common]]
[11:41:50.673]                 NAMES <- toupper(changed)
[11:41:50.673]                 args <- list()
[11:41:50.673]                 for (kk in seq_along(NAMES)) {
[11:41:50.673]                   name <- changed[[kk]]
[11:41:50.673]                   NAME <- NAMES[[kk]]
[11:41:50.673]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:50.673]                     next
[11:41:50.673]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:50.673]                 }
[11:41:50.673]                 NAMES <- toupper(added)
[11:41:50.673]                 for (kk in seq_along(NAMES)) {
[11:41:50.673]                   name <- added[[kk]]
[11:41:50.673]                   NAME <- NAMES[[kk]]
[11:41:50.673]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:50.673]                     next
[11:41:50.673]                   args[[name]] <- ""
[11:41:50.673]                 }
[11:41:50.673]                 NAMES <- toupper(removed)
[11:41:50.673]                 for (kk in seq_along(NAMES)) {
[11:41:50.673]                   name <- removed[[kk]]
[11:41:50.673]                   NAME <- NAMES[[kk]]
[11:41:50.673]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:50.673]                     next
[11:41:50.673]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:50.673]                 }
[11:41:50.673]                 if (length(args) > 0) 
[11:41:50.673]                   base::do.call(base::Sys.setenv, args = args)
[11:41:50.673]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:50.673]             }
[11:41:50.673]             else {
[11:41:50.673]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:50.673]             }
[11:41:50.673]             {
[11:41:50.673]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:50.673]                   0L) {
[11:41:50.673]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:50.673]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:50.673]                   base::options(opts)
[11:41:50.673]                 }
[11:41:50.673]                 {
[11:41:50.673]                   {
[11:41:50.673]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:50.673]                     NULL
[11:41:50.673]                   }
[11:41:50.673]                   options(future.plan = NULL)
[11:41:50.673]                   if (is.na(NA_character_)) 
[11:41:50.673]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:50.673]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:50.673]                   future::plan(list(function (..., workers = 2, 
[11:41:50.673]                     envir = parent.frame()) 
[11:41:50.673]                   strategy(..., workers = workers, envir = envir)), 
[11:41:50.673]                     .cleanup = FALSE, .init = FALSE)
[11:41:50.673]                 }
[11:41:50.673]             }
[11:41:50.673]         }
[11:41:50.673]     })
[11:41:50.673]     if (TRUE) {
[11:41:50.673]         base::sink(type = "output", split = FALSE)
[11:41:50.673]         if (TRUE) {
[11:41:50.673]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:50.673]         }
[11:41:50.673]         else {
[11:41:50.673]             ...future.result["stdout"] <- base::list(NULL)
[11:41:50.673]         }
[11:41:50.673]         base::close(...future.stdout)
[11:41:50.673]         ...future.stdout <- NULL
[11:41:50.673]     }
[11:41:50.673]     ...future.result$conditions <- ...future.conditions
[11:41:50.673]     ...future.result$finished <- base::Sys.time()
[11:41:50.673]     ...future.result
[11:41:50.673] }
[11:41:50.675] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:50.685] receiveMessageFromWorker() for ClusterFuture ...
[11:41:50.685] - Validating connection of MultisessionFuture
[11:41:50.686] - received message: FutureResult
[11:41:50.686] - Received FutureResult
[11:41:50.686] - Erased future from FutureRegistry
[11:41:50.686] result() for ClusterFuture ...
[11:41:50.686] - result already collected: FutureResult
[11:41:50.686] result() for ClusterFuture ... done
[11:41:50.686] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:50.686] result() for ClusterFuture ...
[11:41:50.686] - result already collected: FutureResult
[11:41:50.686] result() for ClusterFuture ... done
[11:41:50.686] result() for ClusterFuture ...
[11:41:50.686] - result already collected: FutureResult
[11:41:50.686] result() for ClusterFuture ... done
[11:41:50.687] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:50.687] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:50.730] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:50.734] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:50.778] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:50.778] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:50.822] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:50.823] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:50.825] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:50.825] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:50.827] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:50.827] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:50.828] MultisessionFuture started
[11:41:50.829] - Launch lazy future ... done
[11:41:50.829] run() for ‘MultisessionFuture’ ... done
[11:41:50.829] Created future:
[11:41:50.829] MultisessionFuture:
[11:41:50.829] Label: ‘future_mapply-27’
[11:41:50.829] Expression:
[11:41:50.829] {
[11:41:50.829]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:50.829]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:50.829]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:50.829]         on.exit(options(oopts), add = TRUE)
[11:41:50.829]     }
[11:41:50.829]     {
[11:41:50.829]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:50.829]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:50.829]                 inherits = FALSE)
[11:41:50.829]             ...future.FUN(...)
[11:41:50.829]         }
[11:41:50.829]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:50.829]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:50.829]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:50.829]         do.call(mapply, args = args)
[11:41:50.829]     }
[11:41:50.829] }
[11:41:50.829] Lazy evaluation: FALSE
[11:41:50.829] Asynchronous evaluation: TRUE
[11:41:50.829] Local evaluation: TRUE
[11:41:50.829] Environment: 0x560ef58e1768
[11:41:50.829] Capture standard output: TRUE
[11:41:50.829] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:50.829] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:50.829] Packages: 1 packages (‘mlr3’)
[11:41:50.829] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:50.829] Resolved: FALSE
[11:41:50.829] Value: <not collected>
[11:41:50.829] Conditions captured: <none>
[11:41:50.829] Early signaling: FALSE
[11:41:50.829] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:50.829] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:50.847] Chunk #27 of 90 ... DONE
[11:41:50.847] Chunk #28 of 90 ...
[11:41:50.847]  - seeds: [1] <seeds>
[11:41:50.848] getGlobalsAndPackages() ...
[11:41:50.848] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:50.848] Resolving globals: FALSE
[11:41:50.848] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:50.849] - packages: [1] ‘mlr3’
[11:41:50.849] getGlobalsAndPackages() ... DONE
[11:41:50.849] run() for ‘Future’ ...
[11:41:50.849] - state: ‘created’
[11:41:50.849] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:50.860] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:50.860] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:50.860]   - Field: ‘node’
[11:41:50.860]   - Field: ‘label’
[11:41:50.860]   - Field: ‘local’
[11:41:50.860]   - Field: ‘owner’
[11:41:50.860]   - Field: ‘envir’
[11:41:50.860]   - Field: ‘workers’
[11:41:50.860]   - Field: ‘packages’
[11:41:50.860]   - Field: ‘gc’
[11:41:50.860]   - Field: ‘conditions’
[11:41:50.860]   - Field: ‘persistent’
[11:41:50.860]   - Field: ‘expr’
[11:41:50.861]   - Field: ‘uuid’
[11:41:50.861]   - Field: ‘seed’
[11:41:50.861]   - Field: ‘version’
[11:41:50.861]   - Field: ‘result’
[11:41:50.861]   - Field: ‘asynchronous’
[11:41:50.861]   - Field: ‘calls’
[11:41:50.861]   - Field: ‘globals’
[11:41:50.861]   - Field: ‘stdout’
[11:41:50.861]   - Field: ‘earlySignal’
[11:41:50.861]   - Field: ‘lazy’
[11:41:50.861]   - Field: ‘state’
[11:41:50.861] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:50.861] - Launch lazy future ...
[11:41:50.861] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:50.861] Packages needed by future strategies (n = 0): <none>
[11:41:50.862] {
[11:41:50.862]     {
[11:41:50.862]         {
[11:41:50.862]             ...future.startTime <- base::Sys.time()
[11:41:50.862]             {
[11:41:50.862]                 {
[11:41:50.862]                   {
[11:41:50.862]                     {
[11:41:50.862]                       {
[11:41:50.862]                         base::local({
[11:41:50.862]                           has_future <- base::requireNamespace("future", 
[11:41:50.862]                             quietly = TRUE)
[11:41:50.862]                           if (has_future) {
[11:41:50.862]                             ns <- base::getNamespace("future")
[11:41:50.862]                             version <- ns[[".package"]][["version"]]
[11:41:50.862]                             if (is.null(version)) 
[11:41:50.862]                               version <- utils::packageVersion("future")
[11:41:50.862]                           }
[11:41:50.862]                           else {
[11:41:50.862]                             version <- NULL
[11:41:50.862]                           }
[11:41:50.862]                           if (!has_future || version < "1.8.0") {
[11:41:50.862]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:50.862]                               "", base::R.version$version.string), 
[11:41:50.862]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:50.862]                                 base::R.version$platform, 8 * 
[11:41:50.862]                                   base::.Machine$sizeof.pointer), 
[11:41:50.862]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:50.862]                                 "release", "version")], collapse = " "), 
[11:41:50.862]                               hostname = base::Sys.info()[["nodename"]])
[11:41:50.862]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:50.862]                               info)
[11:41:50.862]                             info <- base::paste(info, collapse = "; ")
[11:41:50.862]                             if (!has_future) {
[11:41:50.862]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:50.862]                                 info)
[11:41:50.862]                             }
[11:41:50.862]                             else {
[11:41:50.862]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:50.862]                                 info, version)
[11:41:50.862]                             }
[11:41:50.862]                             base::stop(msg)
[11:41:50.862]                           }
[11:41:50.862]                         })
[11:41:50.862]                       }
[11:41:50.862]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:50.862]                       base::options(mc.cores = 1L)
[11:41:50.862]                     }
[11:41:50.862]                     base::local({
[11:41:50.862]                       for (pkg in "mlr3") {
[11:41:50.862]                         base::loadNamespace(pkg)
[11:41:50.862]                         base::library(pkg, character.only = TRUE)
[11:41:50.862]                       }
[11:41:50.862]                     })
[11:41:50.862]                   }
[11:41:50.862]                   options(future.plan = NULL)
[11:41:50.862]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:50.862]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:50.862]                 }
[11:41:50.862]                 ...future.workdir <- getwd()
[11:41:50.862]             }
[11:41:50.862]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:50.862]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:50.862]         }
[11:41:50.862]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:50.862]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:50.862]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:50.862]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:50.862]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:50.862]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:50.862]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:50.862]             base::names(...future.oldOptions))
[11:41:50.862]     }
[11:41:50.862]     if (FALSE) {
[11:41:50.862]     }
[11:41:50.862]     else {
[11:41:50.862]         if (TRUE) {
[11:41:50.862]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:50.862]                 open = "w")
[11:41:50.862]         }
[11:41:50.862]         else {
[11:41:50.862]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:50.862]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:50.862]         }
[11:41:50.862]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:50.862]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:50.862]             base::sink(type = "output", split = FALSE)
[11:41:50.862]             base::close(...future.stdout)
[11:41:50.862]         }, add = TRUE)
[11:41:50.862]     }
[11:41:50.862]     ...future.frame <- base::sys.nframe()
[11:41:50.862]     ...future.conditions <- base::list()
[11:41:50.862]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:50.862]     if (FALSE) {
[11:41:50.862]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:50.862]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:50.862]     }
[11:41:50.862]     ...future.result <- base::tryCatch({
[11:41:50.862]         base::withCallingHandlers({
[11:41:50.862]             ...future.value <- base::withVisible(base::local({
[11:41:50.862]                 ...future.makeSendCondition <- local({
[11:41:50.862]                   sendCondition <- NULL
[11:41:50.862]                   function(frame = 1L) {
[11:41:50.862]                     if (is.function(sendCondition)) 
[11:41:50.862]                       return(sendCondition)
[11:41:50.862]                     ns <- getNamespace("parallel")
[11:41:50.862]                     if (exists("sendData", mode = "function", 
[11:41:50.862]                       envir = ns)) {
[11:41:50.862]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:50.862]                         envir = ns)
[11:41:50.862]                       envir <- sys.frame(frame)
[11:41:50.862]                       master <- NULL
[11:41:50.862]                       while (!identical(envir, .GlobalEnv) && 
[11:41:50.862]                         !identical(envir, emptyenv())) {
[11:41:50.862]                         if (exists("master", mode = "list", envir = envir, 
[11:41:50.862]                           inherits = FALSE)) {
[11:41:50.862]                           master <- get("master", mode = "list", 
[11:41:50.862]                             envir = envir, inherits = FALSE)
[11:41:50.862]                           if (inherits(master, c("SOCKnode", 
[11:41:50.862]                             "SOCK0node"))) {
[11:41:50.862]                             sendCondition <<- function(cond) {
[11:41:50.862]                               data <- list(type = "VALUE", value = cond, 
[11:41:50.862]                                 success = TRUE)
[11:41:50.862]                               parallel_sendData(master, data)
[11:41:50.862]                             }
[11:41:50.862]                             return(sendCondition)
[11:41:50.862]                           }
[11:41:50.862]                         }
[11:41:50.862]                         frame <- frame + 1L
[11:41:50.862]                         envir <- sys.frame(frame)
[11:41:50.862]                       }
[11:41:50.862]                     }
[11:41:50.862]                     sendCondition <<- function(cond) NULL
[11:41:50.862]                   }
[11:41:50.862]                 })
[11:41:50.862]                 withCallingHandlers({
[11:41:50.862]                   {
[11:41:50.862]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:50.862]                     if (!identical(...future.globals.maxSize.org, 
[11:41:50.862]                       ...future.globals.maxSize)) {
[11:41:50.862]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:50.862]                       on.exit(options(oopts), add = TRUE)
[11:41:50.862]                     }
[11:41:50.862]                     {
[11:41:50.862]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:50.862]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:50.862]                           envir = globalenv(), inherits = FALSE)
[11:41:50.862]                         ...future.FUN(...)
[11:41:50.862]                       }
[11:41:50.862]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:50.862]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:50.862]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:50.862]                         USE.NAMES = FALSE)
[11:41:50.862]                       do.call(mapply, args = args)
[11:41:50.862]                     }
[11:41:50.862]                   }
[11:41:50.862]                 }, immediateCondition = function(cond) {
[11:41:50.862]                   sendCondition <- ...future.makeSendCondition()
[11:41:50.862]                   sendCondition(cond)
[11:41:50.862]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:50.862]                   {
[11:41:50.862]                     inherits <- base::inherits
[11:41:50.862]                     invokeRestart <- base::invokeRestart
[11:41:50.862]                     is.null <- base::is.null
[11:41:50.862]                     muffled <- FALSE
[11:41:50.862]                     if (inherits(cond, "message")) {
[11:41:50.862]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:50.862]                       if (muffled) 
[11:41:50.862]                         invokeRestart("muffleMessage")
[11:41:50.862]                     }
[11:41:50.862]                     else if (inherits(cond, "warning")) {
[11:41:50.862]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:50.862]                       if (muffled) 
[11:41:50.862]                         invokeRestart("muffleWarning")
[11:41:50.862]                     }
[11:41:50.862]                     else if (inherits(cond, "condition")) {
[11:41:50.862]                       if (!is.null(pattern)) {
[11:41:50.862]                         computeRestarts <- base::computeRestarts
[11:41:50.862]                         grepl <- base::grepl
[11:41:50.862]                         restarts <- computeRestarts(cond)
[11:41:50.862]                         for (restart in restarts) {
[11:41:50.862]                           name <- restart$name
[11:41:50.862]                           if (is.null(name)) 
[11:41:50.862]                             next
[11:41:50.862]                           if (!grepl(pattern, name)) 
[11:41:50.862]                             next
[11:41:50.862]                           invokeRestart(restart)
[11:41:50.862]                           muffled <- TRUE
[11:41:50.862]                           break
[11:41:50.862]                         }
[11:41:50.862]                       }
[11:41:50.862]                     }
[11:41:50.862]                     invisible(muffled)
[11:41:50.862]                   }
[11:41:50.862]                   muffleCondition(cond)
[11:41:50.862]                 })
[11:41:50.862]             }))
[11:41:50.862]             future::FutureResult(value = ...future.value$value, 
[11:41:50.862]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:50.862]                   ...future.rng), globalenv = if (FALSE) 
[11:41:50.862]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:50.862]                     ...future.globalenv.names))
[11:41:50.862]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:50.862]         }, condition = base::local({
[11:41:50.862]             c <- base::c
[11:41:50.862]             inherits <- base::inherits
[11:41:50.862]             invokeRestart <- base::invokeRestart
[11:41:50.862]             length <- base::length
[11:41:50.862]             list <- base::list
[11:41:50.862]             seq.int <- base::seq.int
[11:41:50.862]             signalCondition <- base::signalCondition
[11:41:50.862]             sys.calls <- base::sys.calls
[11:41:50.862]             `[[` <- base::`[[`
[11:41:50.862]             `+` <- base::`+`
[11:41:50.862]             `<<-` <- base::`<<-`
[11:41:50.862]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:50.862]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:50.862]                   3L)]
[11:41:50.862]             }
[11:41:50.862]             function(cond) {
[11:41:50.862]                 is_error <- inherits(cond, "error")
[11:41:50.862]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:50.862]                   NULL)
[11:41:50.862]                 if (is_error) {
[11:41:50.862]                   sessionInformation <- function() {
[11:41:50.862]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:50.862]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:50.862]                       search = base::search(), system = base::Sys.info())
[11:41:50.862]                   }
[11:41:50.862]                   ...future.conditions[[length(...future.conditions) + 
[11:41:50.862]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:50.862]                     cond$call), session = sessionInformation(), 
[11:41:50.862]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:50.862]                   signalCondition(cond)
[11:41:50.862]                 }
[11:41:50.862]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:50.862]                 "immediateCondition"))) {
[11:41:50.862]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:50.862]                   ...future.conditions[[length(...future.conditions) + 
[11:41:50.862]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:50.862]                   if (TRUE && !signal) {
[11:41:50.862]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:50.862]                     {
[11:41:50.862]                       inherits <- base::inherits
[11:41:50.862]                       invokeRestart <- base::invokeRestart
[11:41:50.862]                       is.null <- base::is.null
[11:41:50.862]                       muffled <- FALSE
[11:41:50.862]                       if (inherits(cond, "message")) {
[11:41:50.862]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:50.862]                         if (muffled) 
[11:41:50.862]                           invokeRestart("muffleMessage")
[11:41:50.862]                       }
[11:41:50.862]                       else if (inherits(cond, "warning")) {
[11:41:50.862]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:50.862]                         if (muffled) 
[11:41:50.862]                           invokeRestart("muffleWarning")
[11:41:50.862]                       }
[11:41:50.862]                       else if (inherits(cond, "condition")) {
[11:41:50.862]                         if (!is.null(pattern)) {
[11:41:50.862]                           computeRestarts <- base::computeRestarts
[11:41:50.862]                           grepl <- base::grepl
[11:41:50.862]                           restarts <- computeRestarts(cond)
[11:41:50.862]                           for (restart in restarts) {
[11:41:50.862]                             name <- restart$name
[11:41:50.862]                             if (is.null(name)) 
[11:41:50.862]                               next
[11:41:50.862]                             if (!grepl(pattern, name)) 
[11:41:50.862]                               next
[11:41:50.862]                             invokeRestart(restart)
[11:41:50.862]                             muffled <- TRUE
[11:41:50.862]                             break
[11:41:50.862]                           }
[11:41:50.862]                         }
[11:41:50.862]                       }
[11:41:50.862]                       invisible(muffled)
[11:41:50.862]                     }
[11:41:50.862]                     muffleCondition(cond, pattern = "^muffle")
[11:41:50.862]                   }
[11:41:50.862]                 }
[11:41:50.862]                 else {
[11:41:50.862]                   if (TRUE) {
[11:41:50.862]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:50.862]                     {
[11:41:50.862]                       inherits <- base::inherits
[11:41:50.862]                       invokeRestart <- base::invokeRestart
[11:41:50.862]                       is.null <- base::is.null
[11:41:50.862]                       muffled <- FALSE
[11:41:50.862]                       if (inherits(cond, "message")) {
[11:41:50.862]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:50.862]                         if (muffled) 
[11:41:50.862]                           invokeRestart("muffleMessage")
[11:41:50.862]                       }
[11:41:50.862]                       else if (inherits(cond, "warning")) {
[11:41:50.862]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:50.862]                         if (muffled) 
[11:41:50.862]                           invokeRestart("muffleWarning")
[11:41:50.862]                       }
[11:41:50.862]                       else if (inherits(cond, "condition")) {
[11:41:50.862]                         if (!is.null(pattern)) {
[11:41:50.862]                           computeRestarts <- base::computeRestarts
[11:41:50.862]                           grepl <- base::grepl
[11:41:50.862]                           restarts <- computeRestarts(cond)
[11:41:50.862]                           for (restart in restarts) {
[11:41:50.862]                             name <- restart$name
[11:41:50.862]                             if (is.null(name)) 
[11:41:50.862]                               next
[11:41:50.862]                             if (!grepl(pattern, name)) 
[11:41:50.862]                               next
[11:41:50.862]                             invokeRestart(restart)
[11:41:50.862]                             muffled <- TRUE
[11:41:50.862]                             break
[11:41:50.862]                           }
[11:41:50.862]                         }
[11:41:50.862]                       }
[11:41:50.862]                       invisible(muffled)
[11:41:50.862]                     }
[11:41:50.862]                     muffleCondition(cond, pattern = "^muffle")
[11:41:50.862]                   }
[11:41:50.862]                 }
[11:41:50.862]             }
[11:41:50.862]         }))
[11:41:50.862]     }, error = function(ex) {
[11:41:50.862]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:50.862]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:50.862]                 ...future.rng), started = ...future.startTime, 
[11:41:50.862]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:50.862]             version = "1.8"), class = "FutureResult")
[11:41:50.862]     }, finally = {
[11:41:50.862]         if (!identical(...future.workdir, getwd())) 
[11:41:50.862]             setwd(...future.workdir)
[11:41:50.862]         {
[11:41:50.862]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:50.862]                 ...future.oldOptions$nwarnings <- NULL
[11:41:50.862]             }
[11:41:50.862]             base::options(...future.oldOptions)
[11:41:50.862]             if (.Platform$OS.type == "windows") {
[11:41:50.862]                 old_names <- names(...future.oldEnvVars)
[11:41:50.862]                 envs <- base::Sys.getenv()
[11:41:50.862]                 names <- names(envs)
[11:41:50.862]                 common <- intersect(names, old_names)
[11:41:50.862]                 added <- setdiff(names, old_names)
[11:41:50.862]                 removed <- setdiff(old_names, names)
[11:41:50.862]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:50.862]                   envs[common]]
[11:41:50.862]                 NAMES <- toupper(changed)
[11:41:50.862]                 args <- list()
[11:41:50.862]                 for (kk in seq_along(NAMES)) {
[11:41:50.862]                   name <- changed[[kk]]
[11:41:50.862]                   NAME <- NAMES[[kk]]
[11:41:50.862]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:50.862]                     next
[11:41:50.862]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:50.862]                 }
[11:41:50.862]                 NAMES <- toupper(added)
[11:41:50.862]                 for (kk in seq_along(NAMES)) {
[11:41:50.862]                   name <- added[[kk]]
[11:41:50.862]                   NAME <- NAMES[[kk]]
[11:41:50.862]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:50.862]                     next
[11:41:50.862]                   args[[name]] <- ""
[11:41:50.862]                 }
[11:41:50.862]                 NAMES <- toupper(removed)
[11:41:50.862]                 for (kk in seq_along(NAMES)) {
[11:41:50.862]                   name <- removed[[kk]]
[11:41:50.862]                   NAME <- NAMES[[kk]]
[11:41:50.862]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:50.862]                     next
[11:41:50.862]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:50.862]                 }
[11:41:50.862]                 if (length(args) > 0) 
[11:41:50.862]                   base::do.call(base::Sys.setenv, args = args)
[11:41:50.862]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:50.862]             }
[11:41:50.862]             else {
[11:41:50.862]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:50.862]             }
[11:41:50.862]             {
[11:41:50.862]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:50.862]                   0L) {
[11:41:50.862]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:50.862]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:50.862]                   base::options(opts)
[11:41:50.862]                 }
[11:41:50.862]                 {
[11:41:50.862]                   {
[11:41:50.862]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:50.862]                     NULL
[11:41:50.862]                   }
[11:41:50.862]                   options(future.plan = NULL)
[11:41:50.862]                   if (is.na(NA_character_)) 
[11:41:50.862]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:50.862]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:50.862]                   future::plan(list(function (..., workers = 2, 
[11:41:50.862]                     envir = parent.frame()) 
[11:41:50.862]                   strategy(..., workers = workers, envir = envir)), 
[11:41:50.862]                     .cleanup = FALSE, .init = FALSE)
[11:41:50.862]                 }
[11:41:50.862]             }
[11:41:50.862]         }
[11:41:50.862]     })
[11:41:50.862]     if (TRUE) {
[11:41:50.862]         base::sink(type = "output", split = FALSE)
[11:41:50.862]         if (TRUE) {
[11:41:50.862]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:50.862]         }
[11:41:50.862]         else {
[11:41:50.862]             ...future.result["stdout"] <- base::list(NULL)
[11:41:50.862]         }
[11:41:50.862]         base::close(...future.stdout)
[11:41:50.862]         ...future.stdout <- NULL
[11:41:50.862]     }
[11:41:50.862]     ...future.result$conditions <- ...future.conditions
[11:41:50.862]     ...future.result$finished <- base::Sys.time()
[11:41:50.862]     ...future.result
[11:41:50.862] }
[11:41:50.863] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:50.874] receiveMessageFromWorker() for ClusterFuture ...
[11:41:50.875] - Validating connection of MultisessionFuture
[11:41:50.875] - received message: FutureResult
[11:41:50.875] - Received FutureResult
[11:41:50.875] - Erased future from FutureRegistry
[11:41:50.875] result() for ClusterFuture ...
[11:41:50.875] - result already collected: FutureResult
[11:41:50.875] result() for ClusterFuture ... done
[11:41:50.875] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:50.875] result() for ClusterFuture ...
[11:41:50.875] - result already collected: FutureResult
[11:41:50.875] result() for ClusterFuture ... done
[11:41:50.876] result() for ClusterFuture ...
[11:41:50.876] - result already collected: FutureResult
[11:41:50.876] result() for ClusterFuture ... done
[11:41:50.876] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:50.876] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:50.918] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:50.924] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:50.970] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:50.971] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:51.019] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:51.020] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:51.021] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:51.022] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:51.024] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:51.024] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:51.026] MultisessionFuture started
[11:41:51.026] - Launch lazy future ... done
[11:41:51.026] run() for ‘MultisessionFuture’ ... done
[11:41:51.026] Created future:
[11:41:51.026] MultisessionFuture:
[11:41:51.026] Label: ‘future_mapply-28’
[11:41:51.026] Expression:
[11:41:51.026] {
[11:41:51.026]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:51.026]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:51.026]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:51.026]         on.exit(options(oopts), add = TRUE)
[11:41:51.026]     }
[11:41:51.026]     {
[11:41:51.026]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:51.026]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:51.026]                 inherits = FALSE)
[11:41:51.026]             ...future.FUN(...)
[11:41:51.026]         }
[11:41:51.026]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:51.026]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:51.026]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:51.026]         do.call(mapply, args = args)
[11:41:51.026]     }
[11:41:51.026] }
[11:41:51.026] Lazy evaluation: FALSE
[11:41:51.026] Asynchronous evaluation: TRUE
[11:41:51.026] Local evaluation: TRUE
[11:41:51.026] Environment: 0x560ef58e1768
[11:41:51.026] Capture standard output: TRUE
[11:41:51.026] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:51.026] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:51.026] Packages: 1 packages (‘mlr3’)
[11:41:51.026] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:51.026] Resolved: FALSE
[11:41:51.026] Value: <not collected>
[11:41:51.026] Conditions captured: <none>
[11:41:51.026] Early signaling: FALSE
[11:41:51.026] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:51.026] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:51.043] Chunk #28 of 90 ... DONE
[11:41:51.043] Chunk #29 of 90 ...
[11:41:51.043]  - seeds: [1] <seeds>
[11:41:51.043] getGlobalsAndPackages() ...
[11:41:51.044] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:51.044] Resolving globals: FALSE
[11:41:51.045] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:51.045] - packages: [1] ‘mlr3’
[11:41:51.045] getGlobalsAndPackages() ... DONE
[11:41:51.045] run() for ‘Future’ ...
[11:41:51.046] - state: ‘created’
[11:41:51.046] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:51.061] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:51.061] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:51.061]   - Field: ‘node’
[11:41:51.061]   - Field: ‘label’
[11:41:51.061]   - Field: ‘local’
[11:41:51.061]   - Field: ‘owner’
[11:41:51.061]   - Field: ‘envir’
[11:41:51.062]   - Field: ‘workers’
[11:41:51.062]   - Field: ‘packages’
[11:41:51.062]   - Field: ‘gc’
[11:41:51.062]   - Field: ‘conditions’
[11:41:51.062]   - Field: ‘persistent’
[11:41:51.062]   - Field: ‘expr’
[11:41:51.062]   - Field: ‘uuid’
[11:41:51.062]   - Field: ‘seed’
[11:41:51.062]   - Field: ‘version’
[11:41:51.062]   - Field: ‘result’
[11:41:51.063]   - Field: ‘asynchronous’
[11:41:51.063]   - Field: ‘calls’
[11:41:51.063]   - Field: ‘globals’
[11:41:51.063]   - Field: ‘stdout’
[11:41:51.063]   - Field: ‘earlySignal’
[11:41:51.063]   - Field: ‘lazy’
[11:41:51.063]   - Field: ‘state’
[11:41:51.063] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:51.063] - Launch lazy future ...
[11:41:51.064] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:51.064] Packages needed by future strategies (n = 0): <none>
[11:41:51.064] {
[11:41:51.064]     {
[11:41:51.064]         {
[11:41:51.064]             ...future.startTime <- base::Sys.time()
[11:41:51.064]             {
[11:41:51.064]                 {
[11:41:51.064]                   {
[11:41:51.064]                     {
[11:41:51.064]                       {
[11:41:51.064]                         base::local({
[11:41:51.064]                           has_future <- base::requireNamespace("future", 
[11:41:51.064]                             quietly = TRUE)
[11:41:51.064]                           if (has_future) {
[11:41:51.064]                             ns <- base::getNamespace("future")
[11:41:51.064]                             version <- ns[[".package"]][["version"]]
[11:41:51.064]                             if (is.null(version)) 
[11:41:51.064]                               version <- utils::packageVersion("future")
[11:41:51.064]                           }
[11:41:51.064]                           else {
[11:41:51.064]                             version <- NULL
[11:41:51.064]                           }
[11:41:51.064]                           if (!has_future || version < "1.8.0") {
[11:41:51.064]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:51.064]                               "", base::R.version$version.string), 
[11:41:51.064]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:51.064]                                 base::R.version$platform, 8 * 
[11:41:51.064]                                   base::.Machine$sizeof.pointer), 
[11:41:51.064]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:51.064]                                 "release", "version")], collapse = " "), 
[11:41:51.064]                               hostname = base::Sys.info()[["nodename"]])
[11:41:51.064]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:51.064]                               info)
[11:41:51.064]                             info <- base::paste(info, collapse = "; ")
[11:41:51.064]                             if (!has_future) {
[11:41:51.064]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:51.064]                                 info)
[11:41:51.064]                             }
[11:41:51.064]                             else {
[11:41:51.064]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:51.064]                                 info, version)
[11:41:51.064]                             }
[11:41:51.064]                             base::stop(msg)
[11:41:51.064]                           }
[11:41:51.064]                         })
[11:41:51.064]                       }
[11:41:51.064]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:51.064]                       base::options(mc.cores = 1L)
[11:41:51.064]                     }
[11:41:51.064]                     base::local({
[11:41:51.064]                       for (pkg in "mlr3") {
[11:41:51.064]                         base::loadNamespace(pkg)
[11:41:51.064]                         base::library(pkg, character.only = TRUE)
[11:41:51.064]                       }
[11:41:51.064]                     })
[11:41:51.064]                   }
[11:41:51.064]                   options(future.plan = NULL)
[11:41:51.064]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:51.064]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:51.064]                 }
[11:41:51.064]                 ...future.workdir <- getwd()
[11:41:51.064]             }
[11:41:51.064]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:51.064]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:51.064]         }
[11:41:51.064]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:51.064]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:51.064]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:51.064]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:51.064]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:51.064]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:51.064]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:51.064]             base::names(...future.oldOptions))
[11:41:51.064]     }
[11:41:51.064]     if (FALSE) {
[11:41:51.064]     }
[11:41:51.064]     else {
[11:41:51.064]         if (TRUE) {
[11:41:51.064]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:51.064]                 open = "w")
[11:41:51.064]         }
[11:41:51.064]         else {
[11:41:51.064]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:51.064]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:51.064]         }
[11:41:51.064]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:51.064]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:51.064]             base::sink(type = "output", split = FALSE)
[11:41:51.064]             base::close(...future.stdout)
[11:41:51.064]         }, add = TRUE)
[11:41:51.064]     }
[11:41:51.064]     ...future.frame <- base::sys.nframe()
[11:41:51.064]     ...future.conditions <- base::list()
[11:41:51.064]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:51.064]     if (FALSE) {
[11:41:51.064]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:51.064]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:51.064]     }
[11:41:51.064]     ...future.result <- base::tryCatch({
[11:41:51.064]         base::withCallingHandlers({
[11:41:51.064]             ...future.value <- base::withVisible(base::local({
[11:41:51.064]                 ...future.makeSendCondition <- local({
[11:41:51.064]                   sendCondition <- NULL
[11:41:51.064]                   function(frame = 1L) {
[11:41:51.064]                     if (is.function(sendCondition)) 
[11:41:51.064]                       return(sendCondition)
[11:41:51.064]                     ns <- getNamespace("parallel")
[11:41:51.064]                     if (exists("sendData", mode = "function", 
[11:41:51.064]                       envir = ns)) {
[11:41:51.064]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:51.064]                         envir = ns)
[11:41:51.064]                       envir <- sys.frame(frame)
[11:41:51.064]                       master <- NULL
[11:41:51.064]                       while (!identical(envir, .GlobalEnv) && 
[11:41:51.064]                         !identical(envir, emptyenv())) {
[11:41:51.064]                         if (exists("master", mode = "list", envir = envir, 
[11:41:51.064]                           inherits = FALSE)) {
[11:41:51.064]                           master <- get("master", mode = "list", 
[11:41:51.064]                             envir = envir, inherits = FALSE)
[11:41:51.064]                           if (inherits(master, c("SOCKnode", 
[11:41:51.064]                             "SOCK0node"))) {
[11:41:51.064]                             sendCondition <<- function(cond) {
[11:41:51.064]                               data <- list(type = "VALUE", value = cond, 
[11:41:51.064]                                 success = TRUE)
[11:41:51.064]                               parallel_sendData(master, data)
[11:41:51.064]                             }
[11:41:51.064]                             return(sendCondition)
[11:41:51.064]                           }
[11:41:51.064]                         }
[11:41:51.064]                         frame <- frame + 1L
[11:41:51.064]                         envir <- sys.frame(frame)
[11:41:51.064]                       }
[11:41:51.064]                     }
[11:41:51.064]                     sendCondition <<- function(cond) NULL
[11:41:51.064]                   }
[11:41:51.064]                 })
[11:41:51.064]                 withCallingHandlers({
[11:41:51.064]                   {
[11:41:51.064]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:51.064]                     if (!identical(...future.globals.maxSize.org, 
[11:41:51.064]                       ...future.globals.maxSize)) {
[11:41:51.064]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:51.064]                       on.exit(options(oopts), add = TRUE)
[11:41:51.064]                     }
[11:41:51.064]                     {
[11:41:51.064]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:51.064]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:51.064]                           envir = globalenv(), inherits = FALSE)
[11:41:51.064]                         ...future.FUN(...)
[11:41:51.064]                       }
[11:41:51.064]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:51.064]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:51.064]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:51.064]                         USE.NAMES = FALSE)
[11:41:51.064]                       do.call(mapply, args = args)
[11:41:51.064]                     }
[11:41:51.064]                   }
[11:41:51.064]                 }, immediateCondition = function(cond) {
[11:41:51.064]                   sendCondition <- ...future.makeSendCondition()
[11:41:51.064]                   sendCondition(cond)
[11:41:51.064]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:51.064]                   {
[11:41:51.064]                     inherits <- base::inherits
[11:41:51.064]                     invokeRestart <- base::invokeRestart
[11:41:51.064]                     is.null <- base::is.null
[11:41:51.064]                     muffled <- FALSE
[11:41:51.064]                     if (inherits(cond, "message")) {
[11:41:51.064]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:51.064]                       if (muffled) 
[11:41:51.064]                         invokeRestart("muffleMessage")
[11:41:51.064]                     }
[11:41:51.064]                     else if (inherits(cond, "warning")) {
[11:41:51.064]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:51.064]                       if (muffled) 
[11:41:51.064]                         invokeRestart("muffleWarning")
[11:41:51.064]                     }
[11:41:51.064]                     else if (inherits(cond, "condition")) {
[11:41:51.064]                       if (!is.null(pattern)) {
[11:41:51.064]                         computeRestarts <- base::computeRestarts
[11:41:51.064]                         grepl <- base::grepl
[11:41:51.064]                         restarts <- computeRestarts(cond)
[11:41:51.064]                         for (restart in restarts) {
[11:41:51.064]                           name <- restart$name
[11:41:51.064]                           if (is.null(name)) 
[11:41:51.064]                             next
[11:41:51.064]                           if (!grepl(pattern, name)) 
[11:41:51.064]                             next
[11:41:51.064]                           invokeRestart(restart)
[11:41:51.064]                           muffled <- TRUE
[11:41:51.064]                           break
[11:41:51.064]                         }
[11:41:51.064]                       }
[11:41:51.064]                     }
[11:41:51.064]                     invisible(muffled)
[11:41:51.064]                   }
[11:41:51.064]                   muffleCondition(cond)
[11:41:51.064]                 })
[11:41:51.064]             }))
[11:41:51.064]             future::FutureResult(value = ...future.value$value, 
[11:41:51.064]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:51.064]                   ...future.rng), globalenv = if (FALSE) 
[11:41:51.064]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:51.064]                     ...future.globalenv.names))
[11:41:51.064]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:51.064]         }, condition = base::local({
[11:41:51.064]             c <- base::c
[11:41:51.064]             inherits <- base::inherits
[11:41:51.064]             invokeRestart <- base::invokeRestart
[11:41:51.064]             length <- base::length
[11:41:51.064]             list <- base::list
[11:41:51.064]             seq.int <- base::seq.int
[11:41:51.064]             signalCondition <- base::signalCondition
[11:41:51.064]             sys.calls <- base::sys.calls
[11:41:51.064]             `[[` <- base::`[[`
[11:41:51.064]             `+` <- base::`+`
[11:41:51.064]             `<<-` <- base::`<<-`
[11:41:51.064]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:51.064]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:51.064]                   3L)]
[11:41:51.064]             }
[11:41:51.064]             function(cond) {
[11:41:51.064]                 is_error <- inherits(cond, "error")
[11:41:51.064]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:51.064]                   NULL)
[11:41:51.064]                 if (is_error) {
[11:41:51.064]                   sessionInformation <- function() {
[11:41:51.064]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:51.064]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:51.064]                       search = base::search(), system = base::Sys.info())
[11:41:51.064]                   }
[11:41:51.064]                   ...future.conditions[[length(...future.conditions) + 
[11:41:51.064]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:51.064]                     cond$call), session = sessionInformation(), 
[11:41:51.064]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:51.064]                   signalCondition(cond)
[11:41:51.064]                 }
[11:41:51.064]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:51.064]                 "immediateCondition"))) {
[11:41:51.064]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:51.064]                   ...future.conditions[[length(...future.conditions) + 
[11:41:51.064]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:51.064]                   if (TRUE && !signal) {
[11:41:51.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:51.064]                     {
[11:41:51.064]                       inherits <- base::inherits
[11:41:51.064]                       invokeRestart <- base::invokeRestart
[11:41:51.064]                       is.null <- base::is.null
[11:41:51.064]                       muffled <- FALSE
[11:41:51.064]                       if (inherits(cond, "message")) {
[11:41:51.064]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:51.064]                         if (muffled) 
[11:41:51.064]                           invokeRestart("muffleMessage")
[11:41:51.064]                       }
[11:41:51.064]                       else if (inherits(cond, "warning")) {
[11:41:51.064]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:51.064]                         if (muffled) 
[11:41:51.064]                           invokeRestart("muffleWarning")
[11:41:51.064]                       }
[11:41:51.064]                       else if (inherits(cond, "condition")) {
[11:41:51.064]                         if (!is.null(pattern)) {
[11:41:51.064]                           computeRestarts <- base::computeRestarts
[11:41:51.064]                           grepl <- base::grepl
[11:41:51.064]                           restarts <- computeRestarts(cond)
[11:41:51.064]                           for (restart in restarts) {
[11:41:51.064]                             name <- restart$name
[11:41:51.064]                             if (is.null(name)) 
[11:41:51.064]                               next
[11:41:51.064]                             if (!grepl(pattern, name)) 
[11:41:51.064]                               next
[11:41:51.064]                             invokeRestart(restart)
[11:41:51.064]                             muffled <- TRUE
[11:41:51.064]                             break
[11:41:51.064]                           }
[11:41:51.064]                         }
[11:41:51.064]                       }
[11:41:51.064]                       invisible(muffled)
[11:41:51.064]                     }
[11:41:51.064]                     muffleCondition(cond, pattern = "^muffle")
[11:41:51.064]                   }
[11:41:51.064]                 }
[11:41:51.064]                 else {
[11:41:51.064]                   if (TRUE) {
[11:41:51.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:51.064]                     {
[11:41:51.064]                       inherits <- base::inherits
[11:41:51.064]                       invokeRestart <- base::invokeRestart
[11:41:51.064]                       is.null <- base::is.null
[11:41:51.064]                       muffled <- FALSE
[11:41:51.064]                       if (inherits(cond, "message")) {
[11:41:51.064]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:51.064]                         if (muffled) 
[11:41:51.064]                           invokeRestart("muffleMessage")
[11:41:51.064]                       }
[11:41:51.064]                       else if (inherits(cond, "warning")) {
[11:41:51.064]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:51.064]                         if (muffled) 
[11:41:51.064]                           invokeRestart("muffleWarning")
[11:41:51.064]                       }
[11:41:51.064]                       else if (inherits(cond, "condition")) {
[11:41:51.064]                         if (!is.null(pattern)) {
[11:41:51.064]                           computeRestarts <- base::computeRestarts
[11:41:51.064]                           grepl <- base::grepl
[11:41:51.064]                           restarts <- computeRestarts(cond)
[11:41:51.064]                           for (restart in restarts) {
[11:41:51.064]                             name <- restart$name
[11:41:51.064]                             if (is.null(name)) 
[11:41:51.064]                               next
[11:41:51.064]                             if (!grepl(pattern, name)) 
[11:41:51.064]                               next
[11:41:51.064]                             invokeRestart(restart)
[11:41:51.064]                             muffled <- TRUE
[11:41:51.064]                             break
[11:41:51.064]                           }
[11:41:51.064]                         }
[11:41:51.064]                       }
[11:41:51.064]                       invisible(muffled)
[11:41:51.064]                     }
[11:41:51.064]                     muffleCondition(cond, pattern = "^muffle")
[11:41:51.064]                   }
[11:41:51.064]                 }
[11:41:51.064]             }
[11:41:51.064]         }))
[11:41:51.064]     }, error = function(ex) {
[11:41:51.064]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:51.064]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:51.064]                 ...future.rng), started = ...future.startTime, 
[11:41:51.064]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:51.064]             version = "1.8"), class = "FutureResult")
[11:41:51.064]     }, finally = {
[11:41:51.064]         if (!identical(...future.workdir, getwd())) 
[11:41:51.064]             setwd(...future.workdir)
[11:41:51.064]         {
[11:41:51.064]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:51.064]                 ...future.oldOptions$nwarnings <- NULL
[11:41:51.064]             }
[11:41:51.064]             base::options(...future.oldOptions)
[11:41:51.064]             if (.Platform$OS.type == "windows") {
[11:41:51.064]                 old_names <- names(...future.oldEnvVars)
[11:41:51.064]                 envs <- base::Sys.getenv()
[11:41:51.064]                 names <- names(envs)
[11:41:51.064]                 common <- intersect(names, old_names)
[11:41:51.064]                 added <- setdiff(names, old_names)
[11:41:51.064]                 removed <- setdiff(old_names, names)
[11:41:51.064]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:51.064]                   envs[common]]
[11:41:51.064]                 NAMES <- toupper(changed)
[11:41:51.064]                 args <- list()
[11:41:51.064]                 for (kk in seq_along(NAMES)) {
[11:41:51.064]                   name <- changed[[kk]]
[11:41:51.064]                   NAME <- NAMES[[kk]]
[11:41:51.064]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:51.064]                     next
[11:41:51.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:51.064]                 }
[11:41:51.064]                 NAMES <- toupper(added)
[11:41:51.064]                 for (kk in seq_along(NAMES)) {
[11:41:51.064]                   name <- added[[kk]]
[11:41:51.064]                   NAME <- NAMES[[kk]]
[11:41:51.064]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:51.064]                     next
[11:41:51.064]                   args[[name]] <- ""
[11:41:51.064]                 }
[11:41:51.064]                 NAMES <- toupper(removed)
[11:41:51.064]                 for (kk in seq_along(NAMES)) {
[11:41:51.064]                   name <- removed[[kk]]
[11:41:51.064]                   NAME <- NAMES[[kk]]
[11:41:51.064]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:51.064]                     next
[11:41:51.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:51.064]                 }
[11:41:51.064]                 if (length(args) > 0) 
[11:41:51.064]                   base::do.call(base::Sys.setenv, args = args)
[11:41:51.064]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:51.064]             }
[11:41:51.064]             else {
[11:41:51.064]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:51.064]             }
[11:41:51.064]             {
[11:41:51.064]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:51.064]                   0L) {
[11:41:51.064]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:51.064]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:51.064]                   base::options(opts)
[11:41:51.064]                 }
[11:41:51.064]                 {
[11:41:51.064]                   {
[11:41:51.064]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:51.064]                     NULL
[11:41:51.064]                   }
[11:41:51.064]                   options(future.plan = NULL)
[11:41:51.064]                   if (is.na(NA_character_)) 
[11:41:51.064]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:51.064]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:51.064]                   future::plan(list(function (..., workers = 2, 
[11:41:51.064]                     envir = parent.frame()) 
[11:41:51.064]                   strategy(..., workers = workers, envir = envir)), 
[11:41:51.064]                     .cleanup = FALSE, .init = FALSE)
[11:41:51.064]                 }
[11:41:51.064]             }
[11:41:51.064]         }
[11:41:51.064]     })
[11:41:51.064]     if (TRUE) {
[11:41:51.064]         base::sink(type = "output", split = FALSE)
[11:41:51.064]         if (TRUE) {
[11:41:51.064]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:51.064]         }
[11:41:51.064]         else {
[11:41:51.064]             ...future.result["stdout"] <- base::list(NULL)
[11:41:51.064]         }
[11:41:51.064]         base::close(...future.stdout)
[11:41:51.064]         ...future.stdout <- NULL
[11:41:51.064]     }
[11:41:51.064]     ...future.result$conditions <- ...future.conditions
[11:41:51.064]     ...future.result$finished <- base::Sys.time()
[11:41:51.064]     ...future.result
[11:41:51.064] }
[11:41:51.066] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:51.077] receiveMessageFromWorker() for ClusterFuture ...
[11:41:51.077] - Validating connection of MultisessionFuture
[11:41:51.077] - received message: FutureResult
[11:41:51.078] - Received FutureResult
[11:41:51.078] - Erased future from FutureRegistry
[11:41:51.082] result() for ClusterFuture ...
[11:41:51.082] - result already collected: FutureResult
[11:41:51.083] result() for ClusterFuture ... done
[11:41:51.083] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:51.083] result() for ClusterFuture ...
[11:41:51.083] - result already collected: FutureResult
[11:41:51.083] result() for ClusterFuture ... done
[11:41:51.083] result() for ClusterFuture ...
[11:41:51.083] - result already collected: FutureResult
[11:41:51.084] result() for ClusterFuture ... done
[11:41:51.084] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:51.085] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:51.129] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:51.133] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:51.178] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:51.179] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:51.226] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:51.227] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:51.228] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:51.229] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:51.230] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:51.231] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:51.232] MultisessionFuture started
[11:41:51.232] - Launch lazy future ... done
[11:41:51.233] run() for ‘MultisessionFuture’ ... done
[11:41:51.233] Created future:
[11:41:51.233] MultisessionFuture:
[11:41:51.233] Label: ‘future_mapply-29’
[11:41:51.233] Expression:
[11:41:51.233] {
[11:41:51.233]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:51.233]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:51.233]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:51.233]         on.exit(options(oopts), add = TRUE)
[11:41:51.233]     }
[11:41:51.233]     {
[11:41:51.233]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:51.233]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:51.233]                 inherits = FALSE)
[11:41:51.233]             ...future.FUN(...)
[11:41:51.233]         }
[11:41:51.233]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:51.233]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:51.233]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:51.233]         do.call(mapply, args = args)
[11:41:51.233]     }
[11:41:51.233] }
[11:41:51.233] Lazy evaluation: FALSE
[11:41:51.233] Asynchronous evaluation: TRUE
[11:41:51.233] Local evaluation: TRUE
[11:41:51.233] Environment: 0x560ef58e1768
[11:41:51.233] Capture standard output: TRUE
[11:41:51.233] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:51.233] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:51.233] Packages: 1 packages (‘mlr3’)
[11:41:51.233] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:51.233] Resolved: FALSE
[11:41:51.233] Value: <not collected>
[11:41:51.233] Conditions captured: <none>
[11:41:51.233] Early signaling: FALSE
[11:41:51.233] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:51.233] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:51.252] Chunk #29 of 90 ... DONE
[11:41:51.252] Chunk #30 of 90 ...
[11:41:51.253]  - seeds: [1] <seeds>
[11:41:51.253] getGlobalsAndPackages() ...
[11:41:51.253] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:51.254] Resolving globals: FALSE
[11:41:51.254] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:51.255] - packages: [1] ‘mlr3’
[11:41:51.255] getGlobalsAndPackages() ... DONE
[11:41:51.256] run() for ‘Future’ ...
[11:41:51.256] - state: ‘created’
[11:41:51.256] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:51.268] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:51.268] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:51.268]   - Field: ‘node’
[11:41:51.268]   - Field: ‘label’
[11:41:51.268]   - Field: ‘local’
[11:41:51.268]   - Field: ‘owner’
[11:41:51.268]   - Field: ‘envir’
[11:41:51.268]   - Field: ‘workers’
[11:41:51.268]   - Field: ‘packages’
[11:41:51.268]   - Field: ‘gc’
[11:41:51.268]   - Field: ‘conditions’
[11:41:51.268]   - Field: ‘persistent’
[11:41:51.268]   - Field: ‘expr’
[11:41:51.268]   - Field: ‘uuid’
[11:41:51.269]   - Field: ‘seed’
[11:41:51.269]   - Field: ‘version’
[11:41:51.269]   - Field: ‘result’
[11:41:51.269]   - Field: ‘asynchronous’
[11:41:51.269]   - Field: ‘calls’
[11:41:51.269]   - Field: ‘globals’
[11:41:51.269]   - Field: ‘stdout’
[11:41:51.269]   - Field: ‘earlySignal’
[11:41:51.269]   - Field: ‘lazy’
[11:41:51.269]   - Field: ‘state’
[11:41:51.269] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:51.269] - Launch lazy future ...
[11:41:51.269] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:51.269] Packages needed by future strategies (n = 0): <none>
[11:41:51.270] {
[11:41:51.270]     {
[11:41:51.270]         {
[11:41:51.270]             ...future.startTime <- base::Sys.time()
[11:41:51.270]             {
[11:41:51.270]                 {
[11:41:51.270]                   {
[11:41:51.270]                     {
[11:41:51.270]                       {
[11:41:51.270]                         base::local({
[11:41:51.270]                           has_future <- base::requireNamespace("future", 
[11:41:51.270]                             quietly = TRUE)
[11:41:51.270]                           if (has_future) {
[11:41:51.270]                             ns <- base::getNamespace("future")
[11:41:51.270]                             version <- ns[[".package"]][["version"]]
[11:41:51.270]                             if (is.null(version)) 
[11:41:51.270]                               version <- utils::packageVersion("future")
[11:41:51.270]                           }
[11:41:51.270]                           else {
[11:41:51.270]                             version <- NULL
[11:41:51.270]                           }
[11:41:51.270]                           if (!has_future || version < "1.8.0") {
[11:41:51.270]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:51.270]                               "", base::R.version$version.string), 
[11:41:51.270]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:51.270]                                 base::R.version$platform, 8 * 
[11:41:51.270]                                   base::.Machine$sizeof.pointer), 
[11:41:51.270]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:51.270]                                 "release", "version")], collapse = " "), 
[11:41:51.270]                               hostname = base::Sys.info()[["nodename"]])
[11:41:51.270]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:51.270]                               info)
[11:41:51.270]                             info <- base::paste(info, collapse = "; ")
[11:41:51.270]                             if (!has_future) {
[11:41:51.270]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:51.270]                                 info)
[11:41:51.270]                             }
[11:41:51.270]                             else {
[11:41:51.270]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:51.270]                                 info, version)
[11:41:51.270]                             }
[11:41:51.270]                             base::stop(msg)
[11:41:51.270]                           }
[11:41:51.270]                         })
[11:41:51.270]                       }
[11:41:51.270]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:51.270]                       base::options(mc.cores = 1L)
[11:41:51.270]                     }
[11:41:51.270]                     base::local({
[11:41:51.270]                       for (pkg in "mlr3") {
[11:41:51.270]                         base::loadNamespace(pkg)
[11:41:51.270]                         base::library(pkg, character.only = TRUE)
[11:41:51.270]                       }
[11:41:51.270]                     })
[11:41:51.270]                   }
[11:41:51.270]                   options(future.plan = NULL)
[11:41:51.270]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:51.270]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:51.270]                 }
[11:41:51.270]                 ...future.workdir <- getwd()
[11:41:51.270]             }
[11:41:51.270]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:51.270]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:51.270]         }
[11:41:51.270]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:51.270]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:51.270]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:51.270]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:51.270]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:51.270]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:51.270]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:51.270]             base::names(...future.oldOptions))
[11:41:51.270]     }
[11:41:51.270]     if (FALSE) {
[11:41:51.270]     }
[11:41:51.270]     else {
[11:41:51.270]         if (TRUE) {
[11:41:51.270]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:51.270]                 open = "w")
[11:41:51.270]         }
[11:41:51.270]         else {
[11:41:51.270]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:51.270]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:51.270]         }
[11:41:51.270]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:51.270]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:51.270]             base::sink(type = "output", split = FALSE)
[11:41:51.270]             base::close(...future.stdout)
[11:41:51.270]         }, add = TRUE)
[11:41:51.270]     }
[11:41:51.270]     ...future.frame <- base::sys.nframe()
[11:41:51.270]     ...future.conditions <- base::list()
[11:41:51.270]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:51.270]     if (FALSE) {
[11:41:51.270]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:51.270]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:51.270]     }
[11:41:51.270]     ...future.result <- base::tryCatch({
[11:41:51.270]         base::withCallingHandlers({
[11:41:51.270]             ...future.value <- base::withVisible(base::local({
[11:41:51.270]                 ...future.makeSendCondition <- local({
[11:41:51.270]                   sendCondition <- NULL
[11:41:51.270]                   function(frame = 1L) {
[11:41:51.270]                     if (is.function(sendCondition)) 
[11:41:51.270]                       return(sendCondition)
[11:41:51.270]                     ns <- getNamespace("parallel")
[11:41:51.270]                     if (exists("sendData", mode = "function", 
[11:41:51.270]                       envir = ns)) {
[11:41:51.270]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:51.270]                         envir = ns)
[11:41:51.270]                       envir <- sys.frame(frame)
[11:41:51.270]                       master <- NULL
[11:41:51.270]                       while (!identical(envir, .GlobalEnv) && 
[11:41:51.270]                         !identical(envir, emptyenv())) {
[11:41:51.270]                         if (exists("master", mode = "list", envir = envir, 
[11:41:51.270]                           inherits = FALSE)) {
[11:41:51.270]                           master <- get("master", mode = "list", 
[11:41:51.270]                             envir = envir, inherits = FALSE)
[11:41:51.270]                           if (inherits(master, c("SOCKnode", 
[11:41:51.270]                             "SOCK0node"))) {
[11:41:51.270]                             sendCondition <<- function(cond) {
[11:41:51.270]                               data <- list(type = "VALUE", value = cond, 
[11:41:51.270]                                 success = TRUE)
[11:41:51.270]                               parallel_sendData(master, data)
[11:41:51.270]                             }
[11:41:51.270]                             return(sendCondition)
[11:41:51.270]                           }
[11:41:51.270]                         }
[11:41:51.270]                         frame <- frame + 1L
[11:41:51.270]                         envir <- sys.frame(frame)
[11:41:51.270]                       }
[11:41:51.270]                     }
[11:41:51.270]                     sendCondition <<- function(cond) NULL
[11:41:51.270]                   }
[11:41:51.270]                 })
[11:41:51.270]                 withCallingHandlers({
[11:41:51.270]                   {
[11:41:51.270]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:51.270]                     if (!identical(...future.globals.maxSize.org, 
[11:41:51.270]                       ...future.globals.maxSize)) {
[11:41:51.270]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:51.270]                       on.exit(options(oopts), add = TRUE)
[11:41:51.270]                     }
[11:41:51.270]                     {
[11:41:51.270]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:51.270]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:51.270]                           envir = globalenv(), inherits = FALSE)
[11:41:51.270]                         ...future.FUN(...)
[11:41:51.270]                       }
[11:41:51.270]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:51.270]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:51.270]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:51.270]                         USE.NAMES = FALSE)
[11:41:51.270]                       do.call(mapply, args = args)
[11:41:51.270]                     }
[11:41:51.270]                   }
[11:41:51.270]                 }, immediateCondition = function(cond) {
[11:41:51.270]                   sendCondition <- ...future.makeSendCondition()
[11:41:51.270]                   sendCondition(cond)
[11:41:51.270]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:51.270]                   {
[11:41:51.270]                     inherits <- base::inherits
[11:41:51.270]                     invokeRestart <- base::invokeRestart
[11:41:51.270]                     is.null <- base::is.null
[11:41:51.270]                     muffled <- FALSE
[11:41:51.270]                     if (inherits(cond, "message")) {
[11:41:51.270]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:51.270]                       if (muffled) 
[11:41:51.270]                         invokeRestart("muffleMessage")
[11:41:51.270]                     }
[11:41:51.270]                     else if (inherits(cond, "warning")) {
[11:41:51.270]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:51.270]                       if (muffled) 
[11:41:51.270]                         invokeRestart("muffleWarning")
[11:41:51.270]                     }
[11:41:51.270]                     else if (inherits(cond, "condition")) {
[11:41:51.270]                       if (!is.null(pattern)) {
[11:41:51.270]                         computeRestarts <- base::computeRestarts
[11:41:51.270]                         grepl <- base::grepl
[11:41:51.270]                         restarts <- computeRestarts(cond)
[11:41:51.270]                         for (restart in restarts) {
[11:41:51.270]                           name <- restart$name
[11:41:51.270]                           if (is.null(name)) 
[11:41:51.270]                             next
[11:41:51.270]                           if (!grepl(pattern, name)) 
[11:41:51.270]                             next
[11:41:51.270]                           invokeRestart(restart)
[11:41:51.270]                           muffled <- TRUE
[11:41:51.270]                           break
[11:41:51.270]                         }
[11:41:51.270]                       }
[11:41:51.270]                     }
[11:41:51.270]                     invisible(muffled)
[11:41:51.270]                   }
[11:41:51.270]                   muffleCondition(cond)
[11:41:51.270]                 })
[11:41:51.270]             }))
[11:41:51.270]             future::FutureResult(value = ...future.value$value, 
[11:41:51.270]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:51.270]                   ...future.rng), globalenv = if (FALSE) 
[11:41:51.270]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:51.270]                     ...future.globalenv.names))
[11:41:51.270]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:51.270]         }, condition = base::local({
[11:41:51.270]             c <- base::c
[11:41:51.270]             inherits <- base::inherits
[11:41:51.270]             invokeRestart <- base::invokeRestart
[11:41:51.270]             length <- base::length
[11:41:51.270]             list <- base::list
[11:41:51.270]             seq.int <- base::seq.int
[11:41:51.270]             signalCondition <- base::signalCondition
[11:41:51.270]             sys.calls <- base::sys.calls
[11:41:51.270]             `[[` <- base::`[[`
[11:41:51.270]             `+` <- base::`+`
[11:41:51.270]             `<<-` <- base::`<<-`
[11:41:51.270]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:51.270]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:51.270]                   3L)]
[11:41:51.270]             }
[11:41:51.270]             function(cond) {
[11:41:51.270]                 is_error <- inherits(cond, "error")
[11:41:51.270]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:51.270]                   NULL)
[11:41:51.270]                 if (is_error) {
[11:41:51.270]                   sessionInformation <- function() {
[11:41:51.270]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:51.270]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:51.270]                       search = base::search(), system = base::Sys.info())
[11:41:51.270]                   }
[11:41:51.270]                   ...future.conditions[[length(...future.conditions) + 
[11:41:51.270]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:51.270]                     cond$call), session = sessionInformation(), 
[11:41:51.270]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:51.270]                   signalCondition(cond)
[11:41:51.270]                 }
[11:41:51.270]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:51.270]                 "immediateCondition"))) {
[11:41:51.270]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:51.270]                   ...future.conditions[[length(...future.conditions) + 
[11:41:51.270]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:51.270]                   if (TRUE && !signal) {
[11:41:51.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:51.270]                     {
[11:41:51.270]                       inherits <- base::inherits
[11:41:51.270]                       invokeRestart <- base::invokeRestart
[11:41:51.270]                       is.null <- base::is.null
[11:41:51.270]                       muffled <- FALSE
[11:41:51.270]                       if (inherits(cond, "message")) {
[11:41:51.270]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:51.270]                         if (muffled) 
[11:41:51.270]                           invokeRestart("muffleMessage")
[11:41:51.270]                       }
[11:41:51.270]                       else if (inherits(cond, "warning")) {
[11:41:51.270]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:51.270]                         if (muffled) 
[11:41:51.270]                           invokeRestart("muffleWarning")
[11:41:51.270]                       }
[11:41:51.270]                       else if (inherits(cond, "condition")) {
[11:41:51.270]                         if (!is.null(pattern)) {
[11:41:51.270]                           computeRestarts <- base::computeRestarts
[11:41:51.270]                           grepl <- base::grepl
[11:41:51.270]                           restarts <- computeRestarts(cond)
[11:41:51.270]                           for (restart in restarts) {
[11:41:51.270]                             name <- restart$name
[11:41:51.270]                             if (is.null(name)) 
[11:41:51.270]                               next
[11:41:51.270]                             if (!grepl(pattern, name)) 
[11:41:51.270]                               next
[11:41:51.270]                             invokeRestart(restart)
[11:41:51.270]                             muffled <- TRUE
[11:41:51.270]                             break
[11:41:51.270]                           }
[11:41:51.270]                         }
[11:41:51.270]                       }
[11:41:51.270]                       invisible(muffled)
[11:41:51.270]                     }
[11:41:51.270]                     muffleCondition(cond, pattern = "^muffle")
[11:41:51.270]                   }
[11:41:51.270]                 }
[11:41:51.270]                 else {
[11:41:51.270]                   if (TRUE) {
[11:41:51.270]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:51.270]                     {
[11:41:51.270]                       inherits <- base::inherits
[11:41:51.270]                       invokeRestart <- base::invokeRestart
[11:41:51.270]                       is.null <- base::is.null
[11:41:51.270]                       muffled <- FALSE
[11:41:51.270]                       if (inherits(cond, "message")) {
[11:41:51.270]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:51.270]                         if (muffled) 
[11:41:51.270]                           invokeRestart("muffleMessage")
[11:41:51.270]                       }
[11:41:51.270]                       else if (inherits(cond, "warning")) {
[11:41:51.270]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:51.270]                         if (muffled) 
[11:41:51.270]                           invokeRestart("muffleWarning")
[11:41:51.270]                       }
[11:41:51.270]                       else if (inherits(cond, "condition")) {
[11:41:51.270]                         if (!is.null(pattern)) {
[11:41:51.270]                           computeRestarts <- base::computeRestarts
[11:41:51.270]                           grepl <- base::grepl
[11:41:51.270]                           restarts <- computeRestarts(cond)
[11:41:51.270]                           for (restart in restarts) {
[11:41:51.270]                             name <- restart$name
[11:41:51.270]                             if (is.null(name)) 
[11:41:51.270]                               next
[11:41:51.270]                             if (!grepl(pattern, name)) 
[11:41:51.270]                               next
[11:41:51.270]                             invokeRestart(restart)
[11:41:51.270]                             muffled <- TRUE
[11:41:51.270]                             break
[11:41:51.270]                           }
[11:41:51.270]                         }
[11:41:51.270]                       }
[11:41:51.270]                       invisible(muffled)
[11:41:51.270]                     }
[11:41:51.270]                     muffleCondition(cond, pattern = "^muffle")
[11:41:51.270]                   }
[11:41:51.270]                 }
[11:41:51.270]             }
[11:41:51.270]         }))
[11:41:51.270]     }, error = function(ex) {
[11:41:51.270]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:51.270]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:51.270]                 ...future.rng), started = ...future.startTime, 
[11:41:51.270]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:51.270]             version = "1.8"), class = "FutureResult")
[11:41:51.270]     }, finally = {
[11:41:51.270]         if (!identical(...future.workdir, getwd())) 
[11:41:51.270]             setwd(...future.workdir)
[11:41:51.270]         {
[11:41:51.270]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:51.270]                 ...future.oldOptions$nwarnings <- NULL
[11:41:51.270]             }
[11:41:51.270]             base::options(...future.oldOptions)
[11:41:51.270]             if (.Platform$OS.type == "windows") {
[11:41:51.270]                 old_names <- names(...future.oldEnvVars)
[11:41:51.270]                 envs <- base::Sys.getenv()
[11:41:51.270]                 names <- names(envs)
[11:41:51.270]                 common <- intersect(names, old_names)
[11:41:51.270]                 added <- setdiff(names, old_names)
[11:41:51.270]                 removed <- setdiff(old_names, names)
[11:41:51.270]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:51.270]                   envs[common]]
[11:41:51.270]                 NAMES <- toupper(changed)
[11:41:51.270]                 args <- list()
[11:41:51.270]                 for (kk in seq_along(NAMES)) {
[11:41:51.270]                   name <- changed[[kk]]
[11:41:51.270]                   NAME <- NAMES[[kk]]
[11:41:51.270]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:51.270]                     next
[11:41:51.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:51.270]                 }
[11:41:51.270]                 NAMES <- toupper(added)
[11:41:51.270]                 for (kk in seq_along(NAMES)) {
[11:41:51.270]                   name <- added[[kk]]
[11:41:51.270]                   NAME <- NAMES[[kk]]
[11:41:51.270]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:51.270]                     next
[11:41:51.270]                   args[[name]] <- ""
[11:41:51.270]                 }
[11:41:51.270]                 NAMES <- toupper(removed)
[11:41:51.270]                 for (kk in seq_along(NAMES)) {
[11:41:51.270]                   name <- removed[[kk]]
[11:41:51.270]                   NAME <- NAMES[[kk]]
[11:41:51.270]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:51.270]                     next
[11:41:51.270]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:51.270]                 }
[11:41:51.270]                 if (length(args) > 0) 
[11:41:51.270]                   base::do.call(base::Sys.setenv, args = args)
[11:41:51.270]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:51.270]             }
[11:41:51.270]             else {
[11:41:51.270]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:51.270]             }
[11:41:51.270]             {
[11:41:51.270]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:51.270]                   0L) {
[11:41:51.270]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:51.270]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:51.270]                   base::options(opts)
[11:41:51.270]                 }
[11:41:51.270]                 {
[11:41:51.270]                   {
[11:41:51.270]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:51.270]                     NULL
[11:41:51.270]                   }
[11:41:51.270]                   options(future.plan = NULL)
[11:41:51.270]                   if (is.na(NA_character_)) 
[11:41:51.270]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:51.270]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:51.270]                   future::plan(list(function (..., workers = 2, 
[11:41:51.270]                     envir = parent.frame()) 
[11:41:51.270]                   strategy(..., workers = workers, envir = envir)), 
[11:41:51.270]                     .cleanup = FALSE, .init = FALSE)
[11:41:51.270]                 }
[11:41:51.270]             }
[11:41:51.270]         }
[11:41:51.270]     })
[11:41:51.270]     if (TRUE) {
[11:41:51.270]         base::sink(type = "output", split = FALSE)
[11:41:51.270]         if (TRUE) {
[11:41:51.270]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:51.270]         }
[11:41:51.270]         else {
[11:41:51.270]             ...future.result["stdout"] <- base::list(NULL)
[11:41:51.270]         }
[11:41:51.270]         base::close(...future.stdout)
[11:41:51.270]         ...future.stdout <- NULL
[11:41:51.270]     }
[11:41:51.270]     ...future.result$conditions <- ...future.conditions
[11:41:51.270]     ...future.result$finished <- base::Sys.time()
[11:41:51.270]     ...future.result
[11:41:51.270] }
[11:41:51.271] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:51.282] receiveMessageFromWorker() for ClusterFuture ...
[11:41:51.283] - Validating connection of MultisessionFuture
[11:41:51.283] - received message: FutureResult
[11:41:51.283] - Received FutureResult
[11:41:51.283] - Erased future from FutureRegistry
[11:41:51.283] result() for ClusterFuture ...
[11:41:51.283] - result already collected: FutureResult
[11:41:51.283] result() for ClusterFuture ... done
[11:41:51.284] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:51.284] result() for ClusterFuture ...
[11:41:51.284] - result already collected: FutureResult
[11:41:51.284] result() for ClusterFuture ... done
[11:41:51.284] result() for ClusterFuture ...
[11:41:51.284] - result already collected: FutureResult
[11:41:51.284] result() for ClusterFuture ... done
[11:41:51.285] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:51.285] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:51.333] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:51.337] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:51.339] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:51.339] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:51.382] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:51.383] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:51.385] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:51.386] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:51.387] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:51.387] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:51.389] MultisessionFuture started
[11:41:51.389] - Launch lazy future ... done
[11:41:51.389] run() for ‘MultisessionFuture’ ... done
[11:41:51.390] Created future:
[11:41:51.390] MultisessionFuture:
[11:41:51.390] Label: ‘future_mapply-30’
[11:41:51.390] Expression:
[11:41:51.390] {
[11:41:51.390]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:51.390]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:51.390]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:51.390]         on.exit(options(oopts), add = TRUE)
[11:41:51.390]     }
[11:41:51.390]     {
[11:41:51.390]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:51.390]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:51.390]                 inherits = FALSE)
[11:41:51.390]             ...future.FUN(...)
[11:41:51.390]         }
[11:41:51.390]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:51.390]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:51.390]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:51.390]         do.call(mapply, args = args)
[11:41:51.390]     }
[11:41:51.390] }
[11:41:51.390] Lazy evaluation: FALSE
[11:41:51.390] Asynchronous evaluation: TRUE
[11:41:51.390] Local evaluation: TRUE
[11:41:51.390] Environment: 0x560ef58e1768
[11:41:51.390] Capture standard output: TRUE
[11:41:51.390] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:51.390] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:51.390] Packages: 1 packages (‘mlr3’)
[11:41:51.390] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:51.390] Resolved: FALSE
[11:41:51.390] Value: <not collected>
[11:41:51.390] Conditions captured: <none>
[11:41:51.390] Early signaling: FALSE
[11:41:51.390] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:51.390] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:51.407] Chunk #30 of 90 ... DONE
[11:41:51.408] Chunk #31 of 90 ...
[11:41:51.408]  - seeds: [1] <seeds>
[11:41:51.408] getGlobalsAndPackages() ...
[11:41:51.408] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:51.408] Resolving globals: FALSE
[11:41:51.409] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:51.409] - packages: [1] ‘mlr3’
[11:41:51.409] getGlobalsAndPackages() ... DONE
[11:41:51.410] run() for ‘Future’ ...
[11:41:51.410] - state: ‘created’
[11:41:51.410] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:51.422] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:51.422] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:51.422]   - Field: ‘node’
[11:41:51.422]   - Field: ‘label’
[11:41:51.422]   - Field: ‘local’
[11:41:51.422]   - Field: ‘owner’
[11:41:51.422]   - Field: ‘envir’
[11:41:51.422]   - Field: ‘workers’
[11:41:51.422]   - Field: ‘packages’
[11:41:51.423]   - Field: ‘gc’
[11:41:51.423]   - Field: ‘conditions’
[11:41:51.423]   - Field: ‘persistent’
[11:41:51.423]   - Field: ‘expr’
[11:41:51.423]   - Field: ‘uuid’
[11:41:51.423]   - Field: ‘seed’
[11:41:51.423]   - Field: ‘version’
[11:41:51.423]   - Field: ‘result’
[11:41:51.423]   - Field: ‘asynchronous’
[11:41:51.423]   - Field: ‘calls’
[11:41:51.423]   - Field: ‘globals’
[11:41:51.423]   - Field: ‘stdout’
[11:41:51.423]   - Field: ‘earlySignal’
[11:41:51.423]   - Field: ‘lazy’
[11:41:51.423]   - Field: ‘state’
[11:41:51.423] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:51.423] - Launch lazy future ...
[11:41:51.424] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:51.424] Packages needed by future strategies (n = 0): <none>
[11:41:51.424] {
[11:41:51.424]     {
[11:41:51.424]         {
[11:41:51.424]             ...future.startTime <- base::Sys.time()
[11:41:51.424]             {
[11:41:51.424]                 {
[11:41:51.424]                   {
[11:41:51.424]                     {
[11:41:51.424]                       {
[11:41:51.424]                         base::local({
[11:41:51.424]                           has_future <- base::requireNamespace("future", 
[11:41:51.424]                             quietly = TRUE)
[11:41:51.424]                           if (has_future) {
[11:41:51.424]                             ns <- base::getNamespace("future")
[11:41:51.424]                             version <- ns[[".package"]][["version"]]
[11:41:51.424]                             if (is.null(version)) 
[11:41:51.424]                               version <- utils::packageVersion("future")
[11:41:51.424]                           }
[11:41:51.424]                           else {
[11:41:51.424]                             version <- NULL
[11:41:51.424]                           }
[11:41:51.424]                           if (!has_future || version < "1.8.0") {
[11:41:51.424]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:51.424]                               "", base::R.version$version.string), 
[11:41:51.424]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:51.424]                                 base::R.version$platform, 8 * 
[11:41:51.424]                                   base::.Machine$sizeof.pointer), 
[11:41:51.424]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:51.424]                                 "release", "version")], collapse = " "), 
[11:41:51.424]                               hostname = base::Sys.info()[["nodename"]])
[11:41:51.424]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:51.424]                               info)
[11:41:51.424]                             info <- base::paste(info, collapse = "; ")
[11:41:51.424]                             if (!has_future) {
[11:41:51.424]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:51.424]                                 info)
[11:41:51.424]                             }
[11:41:51.424]                             else {
[11:41:51.424]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:51.424]                                 info, version)
[11:41:51.424]                             }
[11:41:51.424]                             base::stop(msg)
[11:41:51.424]                           }
[11:41:51.424]                         })
[11:41:51.424]                       }
[11:41:51.424]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:51.424]                       base::options(mc.cores = 1L)
[11:41:51.424]                     }
[11:41:51.424]                     base::local({
[11:41:51.424]                       for (pkg in "mlr3") {
[11:41:51.424]                         base::loadNamespace(pkg)
[11:41:51.424]                         base::library(pkg, character.only = TRUE)
[11:41:51.424]                       }
[11:41:51.424]                     })
[11:41:51.424]                   }
[11:41:51.424]                   options(future.plan = NULL)
[11:41:51.424]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:51.424]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:51.424]                 }
[11:41:51.424]                 ...future.workdir <- getwd()
[11:41:51.424]             }
[11:41:51.424]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:51.424]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:51.424]         }
[11:41:51.424]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:51.424]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:51.424]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:51.424]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:51.424]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:51.424]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:51.424]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:51.424]             base::names(...future.oldOptions))
[11:41:51.424]     }
[11:41:51.424]     if (FALSE) {
[11:41:51.424]     }
[11:41:51.424]     else {
[11:41:51.424]         if (TRUE) {
[11:41:51.424]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:51.424]                 open = "w")
[11:41:51.424]         }
[11:41:51.424]         else {
[11:41:51.424]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:51.424]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:51.424]         }
[11:41:51.424]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:51.424]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:51.424]             base::sink(type = "output", split = FALSE)
[11:41:51.424]             base::close(...future.stdout)
[11:41:51.424]         }, add = TRUE)
[11:41:51.424]     }
[11:41:51.424]     ...future.frame <- base::sys.nframe()
[11:41:51.424]     ...future.conditions <- base::list()
[11:41:51.424]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:51.424]     if (FALSE) {
[11:41:51.424]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:51.424]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:51.424]     }
[11:41:51.424]     ...future.result <- base::tryCatch({
[11:41:51.424]         base::withCallingHandlers({
[11:41:51.424]             ...future.value <- base::withVisible(base::local({
[11:41:51.424]                 ...future.makeSendCondition <- local({
[11:41:51.424]                   sendCondition <- NULL
[11:41:51.424]                   function(frame = 1L) {
[11:41:51.424]                     if (is.function(sendCondition)) 
[11:41:51.424]                       return(sendCondition)
[11:41:51.424]                     ns <- getNamespace("parallel")
[11:41:51.424]                     if (exists("sendData", mode = "function", 
[11:41:51.424]                       envir = ns)) {
[11:41:51.424]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:51.424]                         envir = ns)
[11:41:51.424]                       envir <- sys.frame(frame)
[11:41:51.424]                       master <- NULL
[11:41:51.424]                       while (!identical(envir, .GlobalEnv) && 
[11:41:51.424]                         !identical(envir, emptyenv())) {
[11:41:51.424]                         if (exists("master", mode = "list", envir = envir, 
[11:41:51.424]                           inherits = FALSE)) {
[11:41:51.424]                           master <- get("master", mode = "list", 
[11:41:51.424]                             envir = envir, inherits = FALSE)
[11:41:51.424]                           if (inherits(master, c("SOCKnode", 
[11:41:51.424]                             "SOCK0node"))) {
[11:41:51.424]                             sendCondition <<- function(cond) {
[11:41:51.424]                               data <- list(type = "VALUE", value = cond, 
[11:41:51.424]                                 success = TRUE)
[11:41:51.424]                               parallel_sendData(master, data)
[11:41:51.424]                             }
[11:41:51.424]                             return(sendCondition)
[11:41:51.424]                           }
[11:41:51.424]                         }
[11:41:51.424]                         frame <- frame + 1L
[11:41:51.424]                         envir <- sys.frame(frame)
[11:41:51.424]                       }
[11:41:51.424]                     }
[11:41:51.424]                     sendCondition <<- function(cond) NULL
[11:41:51.424]                   }
[11:41:51.424]                 })
[11:41:51.424]                 withCallingHandlers({
[11:41:51.424]                   {
[11:41:51.424]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:51.424]                     if (!identical(...future.globals.maxSize.org, 
[11:41:51.424]                       ...future.globals.maxSize)) {
[11:41:51.424]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:51.424]                       on.exit(options(oopts), add = TRUE)
[11:41:51.424]                     }
[11:41:51.424]                     {
[11:41:51.424]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:51.424]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:51.424]                           envir = globalenv(), inherits = FALSE)
[11:41:51.424]                         ...future.FUN(...)
[11:41:51.424]                       }
[11:41:51.424]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:51.424]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:51.424]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:51.424]                         USE.NAMES = FALSE)
[11:41:51.424]                       do.call(mapply, args = args)
[11:41:51.424]                     }
[11:41:51.424]                   }
[11:41:51.424]                 }, immediateCondition = function(cond) {
[11:41:51.424]                   sendCondition <- ...future.makeSendCondition()
[11:41:51.424]                   sendCondition(cond)
[11:41:51.424]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:51.424]                   {
[11:41:51.424]                     inherits <- base::inherits
[11:41:51.424]                     invokeRestart <- base::invokeRestart
[11:41:51.424]                     is.null <- base::is.null
[11:41:51.424]                     muffled <- FALSE
[11:41:51.424]                     if (inherits(cond, "message")) {
[11:41:51.424]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:51.424]                       if (muffled) 
[11:41:51.424]                         invokeRestart("muffleMessage")
[11:41:51.424]                     }
[11:41:51.424]                     else if (inherits(cond, "warning")) {
[11:41:51.424]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:51.424]                       if (muffled) 
[11:41:51.424]                         invokeRestart("muffleWarning")
[11:41:51.424]                     }
[11:41:51.424]                     else if (inherits(cond, "condition")) {
[11:41:51.424]                       if (!is.null(pattern)) {
[11:41:51.424]                         computeRestarts <- base::computeRestarts
[11:41:51.424]                         grepl <- base::grepl
[11:41:51.424]                         restarts <- computeRestarts(cond)
[11:41:51.424]                         for (restart in restarts) {
[11:41:51.424]                           name <- restart$name
[11:41:51.424]                           if (is.null(name)) 
[11:41:51.424]                             next
[11:41:51.424]                           if (!grepl(pattern, name)) 
[11:41:51.424]                             next
[11:41:51.424]                           invokeRestart(restart)
[11:41:51.424]                           muffled <- TRUE
[11:41:51.424]                           break
[11:41:51.424]                         }
[11:41:51.424]                       }
[11:41:51.424]                     }
[11:41:51.424]                     invisible(muffled)
[11:41:51.424]                   }
[11:41:51.424]                   muffleCondition(cond)
[11:41:51.424]                 })
[11:41:51.424]             }))
[11:41:51.424]             future::FutureResult(value = ...future.value$value, 
[11:41:51.424]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:51.424]                   ...future.rng), globalenv = if (FALSE) 
[11:41:51.424]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:51.424]                     ...future.globalenv.names))
[11:41:51.424]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:51.424]         }, condition = base::local({
[11:41:51.424]             c <- base::c
[11:41:51.424]             inherits <- base::inherits
[11:41:51.424]             invokeRestart <- base::invokeRestart
[11:41:51.424]             length <- base::length
[11:41:51.424]             list <- base::list
[11:41:51.424]             seq.int <- base::seq.int
[11:41:51.424]             signalCondition <- base::signalCondition
[11:41:51.424]             sys.calls <- base::sys.calls
[11:41:51.424]             `[[` <- base::`[[`
[11:41:51.424]             `+` <- base::`+`
[11:41:51.424]             `<<-` <- base::`<<-`
[11:41:51.424]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:51.424]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:51.424]                   3L)]
[11:41:51.424]             }
[11:41:51.424]             function(cond) {
[11:41:51.424]                 is_error <- inherits(cond, "error")
[11:41:51.424]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:51.424]                   NULL)
[11:41:51.424]                 if (is_error) {
[11:41:51.424]                   sessionInformation <- function() {
[11:41:51.424]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:51.424]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:51.424]                       search = base::search(), system = base::Sys.info())
[11:41:51.424]                   }
[11:41:51.424]                   ...future.conditions[[length(...future.conditions) + 
[11:41:51.424]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:51.424]                     cond$call), session = sessionInformation(), 
[11:41:51.424]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:51.424]                   signalCondition(cond)
[11:41:51.424]                 }
[11:41:51.424]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:51.424]                 "immediateCondition"))) {
[11:41:51.424]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:51.424]                   ...future.conditions[[length(...future.conditions) + 
[11:41:51.424]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:51.424]                   if (TRUE && !signal) {
[11:41:51.424]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:51.424]                     {
[11:41:51.424]                       inherits <- base::inherits
[11:41:51.424]                       invokeRestart <- base::invokeRestart
[11:41:51.424]                       is.null <- base::is.null
[11:41:51.424]                       muffled <- FALSE
[11:41:51.424]                       if (inherits(cond, "message")) {
[11:41:51.424]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:51.424]                         if (muffled) 
[11:41:51.424]                           invokeRestart("muffleMessage")
[11:41:51.424]                       }
[11:41:51.424]                       else if (inherits(cond, "warning")) {
[11:41:51.424]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:51.424]                         if (muffled) 
[11:41:51.424]                           invokeRestart("muffleWarning")
[11:41:51.424]                       }
[11:41:51.424]                       else if (inherits(cond, "condition")) {
[11:41:51.424]                         if (!is.null(pattern)) {
[11:41:51.424]                           computeRestarts <- base::computeRestarts
[11:41:51.424]                           grepl <- base::grepl
[11:41:51.424]                           restarts <- computeRestarts(cond)
[11:41:51.424]                           for (restart in restarts) {
[11:41:51.424]                             name <- restart$name
[11:41:51.424]                             if (is.null(name)) 
[11:41:51.424]                               next
[11:41:51.424]                             if (!grepl(pattern, name)) 
[11:41:51.424]                               next
[11:41:51.424]                             invokeRestart(restart)
[11:41:51.424]                             muffled <- TRUE
[11:41:51.424]                             break
[11:41:51.424]                           }
[11:41:51.424]                         }
[11:41:51.424]                       }
[11:41:51.424]                       invisible(muffled)
[11:41:51.424]                     }
[11:41:51.424]                     muffleCondition(cond, pattern = "^muffle")
[11:41:51.424]                   }
[11:41:51.424]                 }
[11:41:51.424]                 else {
[11:41:51.424]                   if (TRUE) {
[11:41:51.424]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:51.424]                     {
[11:41:51.424]                       inherits <- base::inherits
[11:41:51.424]                       invokeRestart <- base::invokeRestart
[11:41:51.424]                       is.null <- base::is.null
[11:41:51.424]                       muffled <- FALSE
[11:41:51.424]                       if (inherits(cond, "message")) {
[11:41:51.424]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:51.424]                         if (muffled) 
[11:41:51.424]                           invokeRestart("muffleMessage")
[11:41:51.424]                       }
[11:41:51.424]                       else if (inherits(cond, "warning")) {
[11:41:51.424]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:51.424]                         if (muffled) 
[11:41:51.424]                           invokeRestart("muffleWarning")
[11:41:51.424]                       }
[11:41:51.424]                       else if (inherits(cond, "condition")) {
[11:41:51.424]                         if (!is.null(pattern)) {
[11:41:51.424]                           computeRestarts <- base::computeRestarts
[11:41:51.424]                           grepl <- base::grepl
[11:41:51.424]                           restarts <- computeRestarts(cond)
[11:41:51.424]                           for (restart in restarts) {
[11:41:51.424]                             name <- restart$name
[11:41:51.424]                             if (is.null(name)) 
[11:41:51.424]                               next
[11:41:51.424]                             if (!grepl(pattern, name)) 
[11:41:51.424]                               next
[11:41:51.424]                             invokeRestart(restart)
[11:41:51.424]                             muffled <- TRUE
[11:41:51.424]                             break
[11:41:51.424]                           }
[11:41:51.424]                         }
[11:41:51.424]                       }
[11:41:51.424]                       invisible(muffled)
[11:41:51.424]                     }
[11:41:51.424]                     muffleCondition(cond, pattern = "^muffle")
[11:41:51.424]                   }
[11:41:51.424]                 }
[11:41:51.424]             }
[11:41:51.424]         }))
[11:41:51.424]     }, error = function(ex) {
[11:41:51.424]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:51.424]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:51.424]                 ...future.rng), started = ...future.startTime, 
[11:41:51.424]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:51.424]             version = "1.8"), class = "FutureResult")
[11:41:51.424]     }, finally = {
[11:41:51.424]         if (!identical(...future.workdir, getwd())) 
[11:41:51.424]             setwd(...future.workdir)
[11:41:51.424]         {
[11:41:51.424]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:51.424]                 ...future.oldOptions$nwarnings <- NULL
[11:41:51.424]             }
[11:41:51.424]             base::options(...future.oldOptions)
[11:41:51.424]             if (.Platform$OS.type == "windows") {
[11:41:51.424]                 old_names <- names(...future.oldEnvVars)
[11:41:51.424]                 envs <- base::Sys.getenv()
[11:41:51.424]                 names <- names(envs)
[11:41:51.424]                 common <- intersect(names, old_names)
[11:41:51.424]                 added <- setdiff(names, old_names)
[11:41:51.424]                 removed <- setdiff(old_names, names)
[11:41:51.424]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:51.424]                   envs[common]]
[11:41:51.424]                 NAMES <- toupper(changed)
[11:41:51.424]                 args <- list()
[11:41:51.424]                 for (kk in seq_along(NAMES)) {
[11:41:51.424]                   name <- changed[[kk]]
[11:41:51.424]                   NAME <- NAMES[[kk]]
[11:41:51.424]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:51.424]                     next
[11:41:51.424]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:51.424]                 }
[11:41:51.424]                 NAMES <- toupper(added)
[11:41:51.424]                 for (kk in seq_along(NAMES)) {
[11:41:51.424]                   name <- added[[kk]]
[11:41:51.424]                   NAME <- NAMES[[kk]]
[11:41:51.424]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:51.424]                     next
[11:41:51.424]                   args[[name]] <- ""
[11:41:51.424]                 }
[11:41:51.424]                 NAMES <- toupper(removed)
[11:41:51.424]                 for (kk in seq_along(NAMES)) {
[11:41:51.424]                   name <- removed[[kk]]
[11:41:51.424]                   NAME <- NAMES[[kk]]
[11:41:51.424]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:51.424]                     next
[11:41:51.424]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:51.424]                 }
[11:41:51.424]                 if (length(args) > 0) 
[11:41:51.424]                   base::do.call(base::Sys.setenv, args = args)
[11:41:51.424]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:51.424]             }
[11:41:51.424]             else {
[11:41:51.424]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:51.424]             }
[11:41:51.424]             {
[11:41:51.424]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:51.424]                   0L) {
[11:41:51.424]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:51.424]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:51.424]                   base::options(opts)
[11:41:51.424]                 }
[11:41:51.424]                 {
[11:41:51.424]                   {
[11:41:51.424]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:51.424]                     NULL
[11:41:51.424]                   }
[11:41:51.424]                   options(future.plan = NULL)
[11:41:51.424]                   if (is.na(NA_character_)) 
[11:41:51.424]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:51.424]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:51.424]                   future::plan(list(function (..., workers = 2, 
[11:41:51.424]                     envir = parent.frame()) 
[11:41:51.424]                   strategy(..., workers = workers, envir = envir)), 
[11:41:51.424]                     .cleanup = FALSE, .init = FALSE)
[11:41:51.424]                 }
[11:41:51.424]             }
[11:41:51.424]         }
[11:41:51.424]     })
[11:41:51.424]     if (TRUE) {
[11:41:51.424]         base::sink(type = "output", split = FALSE)
[11:41:51.424]         if (TRUE) {
[11:41:51.424]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:51.424]         }
[11:41:51.424]         else {
[11:41:51.424]             ...future.result["stdout"] <- base::list(NULL)
[11:41:51.424]         }
[11:41:51.424]         base::close(...future.stdout)
[11:41:51.424]         ...future.stdout <- NULL
[11:41:51.424]     }
[11:41:51.424]     ...future.result$conditions <- ...future.conditions
[11:41:51.424]     ...future.result$finished <- base::Sys.time()
[11:41:51.424]     ...future.result
[11:41:51.424] }
[11:41:51.426] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:51.436] receiveMessageFromWorker() for ClusterFuture ...
[11:41:51.437] - Validating connection of MultisessionFuture
[11:41:51.437] - received message: FutureResult
[11:41:51.437] - Received FutureResult
[11:41:51.437] - Erased future from FutureRegistry
[11:41:51.437] result() for ClusterFuture ...
[11:41:51.437] - result already collected: FutureResult
[11:41:51.437] result() for ClusterFuture ... done
[11:41:51.437] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:51.437] result() for ClusterFuture ...
[11:41:51.437] - result already collected: FutureResult
[11:41:51.437] result() for ClusterFuture ... done
[11:41:51.437] result() for ClusterFuture ...
[11:41:51.437] - result already collected: FutureResult
[11:41:51.437] result() for ClusterFuture ... done
[11:41:51.438] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:51.438] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:51.482] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:51.489] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:51.534] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:51.535] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:51.582] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:51.583] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:51.584] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:51.584] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:51.585] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:51.585] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:51.585] MultisessionFuture started
[11:41:51.585] - Launch lazy future ... done
[11:41:51.585] run() for ‘MultisessionFuture’ ... done
[11:41:51.585] Created future:
[11:41:51.585] MultisessionFuture:
[11:41:51.585] Label: ‘future_mapply-31’
[11:41:51.585] Expression:
[11:41:51.585] {
[11:41:51.585]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:51.585]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:51.585]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:51.585]         on.exit(options(oopts), add = TRUE)
[11:41:51.585]     }
[11:41:51.585]     {
[11:41:51.585]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:51.585]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:51.585]                 inherits = FALSE)
[11:41:51.585]             ...future.FUN(...)
[11:41:51.585]         }
[11:41:51.585]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:51.585]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:51.585]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:51.585]         do.call(mapply, args = args)
[11:41:51.585]     }
[11:41:51.585] }
[11:41:51.585] Lazy evaluation: FALSE
[11:41:51.585] Asynchronous evaluation: TRUE
[11:41:51.585] Local evaluation: TRUE
[11:41:51.585] Environment: 0x560ef58e1768
[11:41:51.585] Capture standard output: TRUE
[11:41:51.585] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:51.585] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:51.585] Packages: 1 packages (‘mlr3’)
[11:41:51.585] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:51.585] Resolved: FALSE
[11:41:51.585] Value: <not collected>
[11:41:51.585] Conditions captured: <none>
[11:41:51.585] Early signaling: FALSE
[11:41:51.585] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:51.585] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:51.599] Chunk #31 of 90 ... DONE
[11:41:51.599] Chunk #32 of 90 ...
[11:41:51.600]  - seeds: [1] <seeds>
[11:41:51.600] getGlobalsAndPackages() ...
[11:41:51.600] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:51.600] Resolving globals: FALSE
[11:41:51.600] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:51.600] - packages: [1] ‘mlr3’
[11:41:51.600] getGlobalsAndPackages() ... DONE
[11:41:51.601] run() for ‘Future’ ...
[11:41:51.601] - state: ‘created’
[11:41:51.601] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:51.610] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:51.611] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:51.611]   - Field: ‘node’
[11:41:51.611]   - Field: ‘label’
[11:41:51.611]   - Field: ‘local’
[11:41:51.611]   - Field: ‘owner’
[11:41:51.611]   - Field: ‘envir’
[11:41:51.611]   - Field: ‘workers’
[11:41:51.611]   - Field: ‘packages’
[11:41:51.611]   - Field: ‘gc’
[11:41:51.611]   - Field: ‘conditions’
[11:41:51.611]   - Field: ‘persistent’
[11:41:51.611]   - Field: ‘expr’
[11:41:51.611]   - Field: ‘uuid’
[11:41:51.611]   - Field: ‘seed’
[11:41:51.611]   - Field: ‘version’
[11:41:51.612]   - Field: ‘result’
[11:41:51.612]   - Field: ‘asynchronous’
[11:41:51.612]   - Field: ‘calls’
[11:41:51.612]   - Field: ‘globals’
[11:41:51.612]   - Field: ‘stdout’
[11:41:51.612]   - Field: ‘earlySignal’
[11:41:51.612]   - Field: ‘lazy’
[11:41:51.612]   - Field: ‘state’
[11:41:51.612] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:51.612] - Launch lazy future ...
[11:41:51.612] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:51.612] Packages needed by future strategies (n = 0): <none>
[11:41:51.613] {
[11:41:51.613]     {
[11:41:51.613]         {
[11:41:51.613]             ...future.startTime <- base::Sys.time()
[11:41:51.613]             {
[11:41:51.613]                 {
[11:41:51.613]                   {
[11:41:51.613]                     {
[11:41:51.613]                       {
[11:41:51.613]                         base::local({
[11:41:51.613]                           has_future <- base::requireNamespace("future", 
[11:41:51.613]                             quietly = TRUE)
[11:41:51.613]                           if (has_future) {
[11:41:51.613]                             ns <- base::getNamespace("future")
[11:41:51.613]                             version <- ns[[".package"]][["version"]]
[11:41:51.613]                             if (is.null(version)) 
[11:41:51.613]                               version <- utils::packageVersion("future")
[11:41:51.613]                           }
[11:41:51.613]                           else {
[11:41:51.613]                             version <- NULL
[11:41:51.613]                           }
[11:41:51.613]                           if (!has_future || version < "1.8.0") {
[11:41:51.613]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:51.613]                               "", base::R.version$version.string), 
[11:41:51.613]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:51.613]                                 base::R.version$platform, 8 * 
[11:41:51.613]                                   base::.Machine$sizeof.pointer), 
[11:41:51.613]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:51.613]                                 "release", "version")], collapse = " "), 
[11:41:51.613]                               hostname = base::Sys.info()[["nodename"]])
[11:41:51.613]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:51.613]                               info)
[11:41:51.613]                             info <- base::paste(info, collapse = "; ")
[11:41:51.613]                             if (!has_future) {
[11:41:51.613]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:51.613]                                 info)
[11:41:51.613]                             }
[11:41:51.613]                             else {
[11:41:51.613]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:51.613]                                 info, version)
[11:41:51.613]                             }
[11:41:51.613]                             base::stop(msg)
[11:41:51.613]                           }
[11:41:51.613]                         })
[11:41:51.613]                       }
[11:41:51.613]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:51.613]                       base::options(mc.cores = 1L)
[11:41:51.613]                     }
[11:41:51.613]                     base::local({
[11:41:51.613]                       for (pkg in "mlr3") {
[11:41:51.613]                         base::loadNamespace(pkg)
[11:41:51.613]                         base::library(pkg, character.only = TRUE)
[11:41:51.613]                       }
[11:41:51.613]                     })
[11:41:51.613]                   }
[11:41:51.613]                   options(future.plan = NULL)
[11:41:51.613]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:51.613]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:51.613]                 }
[11:41:51.613]                 ...future.workdir <- getwd()
[11:41:51.613]             }
[11:41:51.613]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:51.613]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:51.613]         }
[11:41:51.613]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:51.613]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:51.613]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:51.613]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:51.613]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:51.613]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:51.613]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:51.613]             base::names(...future.oldOptions))
[11:41:51.613]     }
[11:41:51.613]     if (FALSE) {
[11:41:51.613]     }
[11:41:51.613]     else {
[11:41:51.613]         if (TRUE) {
[11:41:51.613]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:51.613]                 open = "w")
[11:41:51.613]         }
[11:41:51.613]         else {
[11:41:51.613]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:51.613]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:51.613]         }
[11:41:51.613]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:51.613]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:51.613]             base::sink(type = "output", split = FALSE)
[11:41:51.613]             base::close(...future.stdout)
[11:41:51.613]         }, add = TRUE)
[11:41:51.613]     }
[11:41:51.613]     ...future.frame <- base::sys.nframe()
[11:41:51.613]     ...future.conditions <- base::list()
[11:41:51.613]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:51.613]     if (FALSE) {
[11:41:51.613]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:51.613]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:51.613]     }
[11:41:51.613]     ...future.result <- base::tryCatch({
[11:41:51.613]         base::withCallingHandlers({
[11:41:51.613]             ...future.value <- base::withVisible(base::local({
[11:41:51.613]                 ...future.makeSendCondition <- local({
[11:41:51.613]                   sendCondition <- NULL
[11:41:51.613]                   function(frame = 1L) {
[11:41:51.613]                     if (is.function(sendCondition)) 
[11:41:51.613]                       return(sendCondition)
[11:41:51.613]                     ns <- getNamespace("parallel")
[11:41:51.613]                     if (exists("sendData", mode = "function", 
[11:41:51.613]                       envir = ns)) {
[11:41:51.613]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:51.613]                         envir = ns)
[11:41:51.613]                       envir <- sys.frame(frame)
[11:41:51.613]                       master <- NULL
[11:41:51.613]                       while (!identical(envir, .GlobalEnv) && 
[11:41:51.613]                         !identical(envir, emptyenv())) {
[11:41:51.613]                         if (exists("master", mode = "list", envir = envir, 
[11:41:51.613]                           inherits = FALSE)) {
[11:41:51.613]                           master <- get("master", mode = "list", 
[11:41:51.613]                             envir = envir, inherits = FALSE)
[11:41:51.613]                           if (inherits(master, c("SOCKnode", 
[11:41:51.613]                             "SOCK0node"))) {
[11:41:51.613]                             sendCondition <<- function(cond) {
[11:41:51.613]                               data <- list(type = "VALUE", value = cond, 
[11:41:51.613]                                 success = TRUE)
[11:41:51.613]                               parallel_sendData(master, data)
[11:41:51.613]                             }
[11:41:51.613]                             return(sendCondition)
[11:41:51.613]                           }
[11:41:51.613]                         }
[11:41:51.613]                         frame <- frame + 1L
[11:41:51.613]                         envir <- sys.frame(frame)
[11:41:51.613]                       }
[11:41:51.613]                     }
[11:41:51.613]                     sendCondition <<- function(cond) NULL
[11:41:51.613]                   }
[11:41:51.613]                 })
[11:41:51.613]                 withCallingHandlers({
[11:41:51.613]                   {
[11:41:51.613]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:51.613]                     if (!identical(...future.globals.maxSize.org, 
[11:41:51.613]                       ...future.globals.maxSize)) {
[11:41:51.613]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:51.613]                       on.exit(options(oopts), add = TRUE)
[11:41:51.613]                     }
[11:41:51.613]                     {
[11:41:51.613]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:51.613]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:51.613]                           envir = globalenv(), inherits = FALSE)
[11:41:51.613]                         ...future.FUN(...)
[11:41:51.613]                       }
[11:41:51.613]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:51.613]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:51.613]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:51.613]                         USE.NAMES = FALSE)
[11:41:51.613]                       do.call(mapply, args = args)
[11:41:51.613]                     }
[11:41:51.613]                   }
[11:41:51.613]                 }, immediateCondition = function(cond) {
[11:41:51.613]                   sendCondition <- ...future.makeSendCondition()
[11:41:51.613]                   sendCondition(cond)
[11:41:51.613]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:51.613]                   {
[11:41:51.613]                     inherits <- base::inherits
[11:41:51.613]                     invokeRestart <- base::invokeRestart
[11:41:51.613]                     is.null <- base::is.null
[11:41:51.613]                     muffled <- FALSE
[11:41:51.613]                     if (inherits(cond, "message")) {
[11:41:51.613]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:51.613]                       if (muffled) 
[11:41:51.613]                         invokeRestart("muffleMessage")
[11:41:51.613]                     }
[11:41:51.613]                     else if (inherits(cond, "warning")) {
[11:41:51.613]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:51.613]                       if (muffled) 
[11:41:51.613]                         invokeRestart("muffleWarning")
[11:41:51.613]                     }
[11:41:51.613]                     else if (inherits(cond, "condition")) {
[11:41:51.613]                       if (!is.null(pattern)) {
[11:41:51.613]                         computeRestarts <- base::computeRestarts
[11:41:51.613]                         grepl <- base::grepl
[11:41:51.613]                         restarts <- computeRestarts(cond)
[11:41:51.613]                         for (restart in restarts) {
[11:41:51.613]                           name <- restart$name
[11:41:51.613]                           if (is.null(name)) 
[11:41:51.613]                             next
[11:41:51.613]                           if (!grepl(pattern, name)) 
[11:41:51.613]                             next
[11:41:51.613]                           invokeRestart(restart)
[11:41:51.613]                           muffled <- TRUE
[11:41:51.613]                           break
[11:41:51.613]                         }
[11:41:51.613]                       }
[11:41:51.613]                     }
[11:41:51.613]                     invisible(muffled)
[11:41:51.613]                   }
[11:41:51.613]                   muffleCondition(cond)
[11:41:51.613]                 })
[11:41:51.613]             }))
[11:41:51.613]             future::FutureResult(value = ...future.value$value, 
[11:41:51.613]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:51.613]                   ...future.rng), globalenv = if (FALSE) 
[11:41:51.613]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:51.613]                     ...future.globalenv.names))
[11:41:51.613]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:51.613]         }, condition = base::local({
[11:41:51.613]             c <- base::c
[11:41:51.613]             inherits <- base::inherits
[11:41:51.613]             invokeRestart <- base::invokeRestart
[11:41:51.613]             length <- base::length
[11:41:51.613]             list <- base::list
[11:41:51.613]             seq.int <- base::seq.int
[11:41:51.613]             signalCondition <- base::signalCondition
[11:41:51.613]             sys.calls <- base::sys.calls
[11:41:51.613]             `[[` <- base::`[[`
[11:41:51.613]             `+` <- base::`+`
[11:41:51.613]             `<<-` <- base::`<<-`
[11:41:51.613]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:51.613]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:51.613]                   3L)]
[11:41:51.613]             }
[11:41:51.613]             function(cond) {
[11:41:51.613]                 is_error <- inherits(cond, "error")
[11:41:51.613]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:51.613]                   NULL)
[11:41:51.613]                 if (is_error) {
[11:41:51.613]                   sessionInformation <- function() {
[11:41:51.613]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:51.613]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:51.613]                       search = base::search(), system = base::Sys.info())
[11:41:51.613]                   }
[11:41:51.613]                   ...future.conditions[[length(...future.conditions) + 
[11:41:51.613]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:51.613]                     cond$call), session = sessionInformation(), 
[11:41:51.613]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:51.613]                   signalCondition(cond)
[11:41:51.613]                 }
[11:41:51.613]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:51.613]                 "immediateCondition"))) {
[11:41:51.613]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:51.613]                   ...future.conditions[[length(...future.conditions) + 
[11:41:51.613]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:51.613]                   if (TRUE && !signal) {
[11:41:51.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:51.613]                     {
[11:41:51.613]                       inherits <- base::inherits
[11:41:51.613]                       invokeRestart <- base::invokeRestart
[11:41:51.613]                       is.null <- base::is.null
[11:41:51.613]                       muffled <- FALSE
[11:41:51.613]                       if (inherits(cond, "message")) {
[11:41:51.613]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:51.613]                         if (muffled) 
[11:41:51.613]                           invokeRestart("muffleMessage")
[11:41:51.613]                       }
[11:41:51.613]                       else if (inherits(cond, "warning")) {
[11:41:51.613]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:51.613]                         if (muffled) 
[11:41:51.613]                           invokeRestart("muffleWarning")
[11:41:51.613]                       }
[11:41:51.613]                       else if (inherits(cond, "condition")) {
[11:41:51.613]                         if (!is.null(pattern)) {
[11:41:51.613]                           computeRestarts <- base::computeRestarts
[11:41:51.613]                           grepl <- base::grepl
[11:41:51.613]                           restarts <- computeRestarts(cond)
[11:41:51.613]                           for (restart in restarts) {
[11:41:51.613]                             name <- restart$name
[11:41:51.613]                             if (is.null(name)) 
[11:41:51.613]                               next
[11:41:51.613]                             if (!grepl(pattern, name)) 
[11:41:51.613]                               next
[11:41:51.613]                             invokeRestart(restart)
[11:41:51.613]                             muffled <- TRUE
[11:41:51.613]                             break
[11:41:51.613]                           }
[11:41:51.613]                         }
[11:41:51.613]                       }
[11:41:51.613]                       invisible(muffled)
[11:41:51.613]                     }
[11:41:51.613]                     muffleCondition(cond, pattern = "^muffle")
[11:41:51.613]                   }
[11:41:51.613]                 }
[11:41:51.613]                 else {
[11:41:51.613]                   if (TRUE) {
[11:41:51.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:51.613]                     {
[11:41:51.613]                       inherits <- base::inherits
[11:41:51.613]                       invokeRestart <- base::invokeRestart
[11:41:51.613]                       is.null <- base::is.null
[11:41:51.613]                       muffled <- FALSE
[11:41:51.613]                       if (inherits(cond, "message")) {
[11:41:51.613]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:51.613]                         if (muffled) 
[11:41:51.613]                           invokeRestart("muffleMessage")
[11:41:51.613]                       }
[11:41:51.613]                       else if (inherits(cond, "warning")) {
[11:41:51.613]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:51.613]                         if (muffled) 
[11:41:51.613]                           invokeRestart("muffleWarning")
[11:41:51.613]                       }
[11:41:51.613]                       else if (inherits(cond, "condition")) {
[11:41:51.613]                         if (!is.null(pattern)) {
[11:41:51.613]                           computeRestarts <- base::computeRestarts
[11:41:51.613]                           grepl <- base::grepl
[11:41:51.613]                           restarts <- computeRestarts(cond)
[11:41:51.613]                           for (restart in restarts) {
[11:41:51.613]                             name <- restart$name
[11:41:51.613]                             if (is.null(name)) 
[11:41:51.613]                               next
[11:41:51.613]                             if (!grepl(pattern, name)) 
[11:41:51.613]                               next
[11:41:51.613]                             invokeRestart(restart)
[11:41:51.613]                             muffled <- TRUE
[11:41:51.613]                             break
[11:41:51.613]                           }
[11:41:51.613]                         }
[11:41:51.613]                       }
[11:41:51.613]                       invisible(muffled)
[11:41:51.613]                     }
[11:41:51.613]                     muffleCondition(cond, pattern = "^muffle")
[11:41:51.613]                   }
[11:41:51.613]                 }
[11:41:51.613]             }
[11:41:51.613]         }))
[11:41:51.613]     }, error = function(ex) {
[11:41:51.613]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:51.613]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:51.613]                 ...future.rng), started = ...future.startTime, 
[11:41:51.613]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:51.613]             version = "1.8"), class = "FutureResult")
[11:41:51.613]     }, finally = {
[11:41:51.613]         if (!identical(...future.workdir, getwd())) 
[11:41:51.613]             setwd(...future.workdir)
[11:41:51.613]         {
[11:41:51.613]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:51.613]                 ...future.oldOptions$nwarnings <- NULL
[11:41:51.613]             }
[11:41:51.613]             base::options(...future.oldOptions)
[11:41:51.613]             if (.Platform$OS.type == "windows") {
[11:41:51.613]                 old_names <- names(...future.oldEnvVars)
[11:41:51.613]                 envs <- base::Sys.getenv()
[11:41:51.613]                 names <- names(envs)
[11:41:51.613]                 common <- intersect(names, old_names)
[11:41:51.613]                 added <- setdiff(names, old_names)
[11:41:51.613]                 removed <- setdiff(old_names, names)
[11:41:51.613]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:51.613]                   envs[common]]
[11:41:51.613]                 NAMES <- toupper(changed)
[11:41:51.613]                 args <- list()
[11:41:51.613]                 for (kk in seq_along(NAMES)) {
[11:41:51.613]                   name <- changed[[kk]]
[11:41:51.613]                   NAME <- NAMES[[kk]]
[11:41:51.613]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:51.613]                     next
[11:41:51.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:51.613]                 }
[11:41:51.613]                 NAMES <- toupper(added)
[11:41:51.613]                 for (kk in seq_along(NAMES)) {
[11:41:51.613]                   name <- added[[kk]]
[11:41:51.613]                   NAME <- NAMES[[kk]]
[11:41:51.613]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:51.613]                     next
[11:41:51.613]                   args[[name]] <- ""
[11:41:51.613]                 }
[11:41:51.613]                 NAMES <- toupper(removed)
[11:41:51.613]                 for (kk in seq_along(NAMES)) {
[11:41:51.613]                   name <- removed[[kk]]
[11:41:51.613]                   NAME <- NAMES[[kk]]
[11:41:51.613]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:51.613]                     next
[11:41:51.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:51.613]                 }
[11:41:51.613]                 if (length(args) > 0) 
[11:41:51.613]                   base::do.call(base::Sys.setenv, args = args)
[11:41:51.613]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:51.613]             }
[11:41:51.613]             else {
[11:41:51.613]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:51.613]             }
[11:41:51.613]             {
[11:41:51.613]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:51.613]                   0L) {
[11:41:51.613]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:51.613]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:51.613]                   base::options(opts)
[11:41:51.613]                 }
[11:41:51.613]                 {
[11:41:51.613]                   {
[11:41:51.613]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:51.613]                     NULL
[11:41:51.613]                   }
[11:41:51.613]                   options(future.plan = NULL)
[11:41:51.613]                   if (is.na(NA_character_)) 
[11:41:51.613]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:51.613]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:51.613]                   future::plan(list(function (..., workers = 2, 
[11:41:51.613]                     envir = parent.frame()) 
[11:41:51.613]                   strategy(..., workers = workers, envir = envir)), 
[11:41:51.613]                     .cleanup = FALSE, .init = FALSE)
[11:41:51.613]                 }
[11:41:51.613]             }
[11:41:51.613]         }
[11:41:51.613]     })
[11:41:51.613]     if (TRUE) {
[11:41:51.613]         base::sink(type = "output", split = FALSE)
[11:41:51.613]         if (TRUE) {
[11:41:51.613]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:51.613]         }
[11:41:51.613]         else {
[11:41:51.613]             ...future.result["stdout"] <- base::list(NULL)
[11:41:51.613]         }
[11:41:51.613]         base::close(...future.stdout)
[11:41:51.613]         ...future.stdout <- NULL
[11:41:51.613]     }
[11:41:51.613]     ...future.result$conditions <- ...future.conditions
[11:41:51.613]     ...future.result$finished <- base::Sys.time()
[11:41:51.613]     ...future.result
[11:41:51.613] }
[11:41:51.614] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:51.625] receiveMessageFromWorker() for ClusterFuture ...
[11:41:51.625] - Validating connection of MultisessionFuture
[11:41:51.626] - received message: FutureResult
[11:41:51.626] - Received FutureResult
[11:41:51.626] - Erased future from FutureRegistry
[11:41:51.626] result() for ClusterFuture ...
[11:41:51.626] - result already collected: FutureResult
[11:41:51.626] result() for ClusterFuture ... done
[11:41:51.626] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:51.626] result() for ClusterFuture ...
[11:41:51.626] - result already collected: FutureResult
[11:41:51.626] result() for ClusterFuture ... done
[11:41:51.626] result() for ClusterFuture ...
[11:41:51.626] - result already collected: FutureResult
[11:41:51.626] result() for ClusterFuture ... done
[11:41:51.627] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:51.627] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:51.670] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:51.674] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:51.677] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:51.677] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:51.722] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:51.723] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:51.725] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:51.726] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:51.727] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:51.728] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:51.729] MultisessionFuture started
[11:41:51.729] - Launch lazy future ... done
[11:41:51.729] run() for ‘MultisessionFuture’ ... done
[11:41:51.729] Created future:
[11:41:51.729] MultisessionFuture:
[11:41:51.729] Label: ‘future_mapply-32’
[11:41:51.729] Expression:
[11:41:51.729] {
[11:41:51.729]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:51.729]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:51.729]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:51.729]         on.exit(options(oopts), add = TRUE)
[11:41:51.729]     }
[11:41:51.729]     {
[11:41:51.729]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:51.729]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:51.729]                 inherits = FALSE)
[11:41:51.729]             ...future.FUN(...)
[11:41:51.729]         }
[11:41:51.729]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:51.729]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:51.729]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:51.729]         do.call(mapply, args = args)
[11:41:51.729]     }
[11:41:51.729] }
[11:41:51.729] Lazy evaluation: FALSE
[11:41:51.729] Asynchronous evaluation: TRUE
[11:41:51.729] Local evaluation: TRUE
[11:41:51.729] Environment: 0x560ef58e1768
[11:41:51.729] Capture standard output: TRUE
[11:41:51.729] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:51.729] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:51.729] Packages: 1 packages (‘mlr3’)
[11:41:51.729] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:51.729] Resolved: FALSE
[11:41:51.729] Value: <not collected>
[11:41:51.729] Conditions captured: <none>
[11:41:51.729] Early signaling: FALSE
[11:41:51.729] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:51.729] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:51.750] Chunk #32 of 90 ... DONE
[11:41:51.750] Chunk #33 of 90 ...
[11:41:51.750]  - seeds: [1] <seeds>
[11:41:51.750] getGlobalsAndPackages() ...
[11:41:51.750] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:51.750] Resolving globals: FALSE
[11:41:51.751] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:51.751] - packages: [1] ‘mlr3’
[11:41:51.751] getGlobalsAndPackages() ... DONE
[11:41:51.751] run() for ‘Future’ ...
[11:41:51.751] - state: ‘created’
[11:41:51.752] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:51.762] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:51.762] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:51.762]   - Field: ‘node’
[11:41:51.762]   - Field: ‘label’
[11:41:51.762]   - Field: ‘local’
[11:41:51.762]   - Field: ‘owner’
[11:41:51.762]   - Field: ‘envir’
[11:41:51.762]   - Field: ‘workers’
[11:41:51.762]   - Field: ‘packages’
[11:41:51.763]   - Field: ‘gc’
[11:41:51.763]   - Field: ‘conditions’
[11:41:51.763]   - Field: ‘persistent’
[11:41:51.763]   - Field: ‘expr’
[11:41:51.763]   - Field: ‘uuid’
[11:41:51.763]   - Field: ‘seed’
[11:41:51.763]   - Field: ‘version’
[11:41:51.763]   - Field: ‘result’
[11:41:51.763]   - Field: ‘asynchronous’
[11:41:51.763]   - Field: ‘calls’
[11:41:51.763]   - Field: ‘globals’
[11:41:51.763]   - Field: ‘stdout’
[11:41:51.763]   - Field: ‘earlySignal’
[11:41:51.763]   - Field: ‘lazy’
[11:41:51.763]   - Field: ‘state’
[11:41:51.763] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:51.763] - Launch lazy future ...
[11:41:51.764] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:51.764] Packages needed by future strategies (n = 0): <none>
[11:41:51.764] {
[11:41:51.764]     {
[11:41:51.764]         {
[11:41:51.764]             ...future.startTime <- base::Sys.time()
[11:41:51.764]             {
[11:41:51.764]                 {
[11:41:51.764]                   {
[11:41:51.764]                     {
[11:41:51.764]                       {
[11:41:51.764]                         base::local({
[11:41:51.764]                           has_future <- base::requireNamespace("future", 
[11:41:51.764]                             quietly = TRUE)
[11:41:51.764]                           if (has_future) {
[11:41:51.764]                             ns <- base::getNamespace("future")
[11:41:51.764]                             version <- ns[[".package"]][["version"]]
[11:41:51.764]                             if (is.null(version)) 
[11:41:51.764]                               version <- utils::packageVersion("future")
[11:41:51.764]                           }
[11:41:51.764]                           else {
[11:41:51.764]                             version <- NULL
[11:41:51.764]                           }
[11:41:51.764]                           if (!has_future || version < "1.8.0") {
[11:41:51.764]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:51.764]                               "", base::R.version$version.string), 
[11:41:51.764]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:51.764]                                 base::R.version$platform, 8 * 
[11:41:51.764]                                   base::.Machine$sizeof.pointer), 
[11:41:51.764]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:51.764]                                 "release", "version")], collapse = " "), 
[11:41:51.764]                               hostname = base::Sys.info()[["nodename"]])
[11:41:51.764]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:51.764]                               info)
[11:41:51.764]                             info <- base::paste(info, collapse = "; ")
[11:41:51.764]                             if (!has_future) {
[11:41:51.764]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:51.764]                                 info)
[11:41:51.764]                             }
[11:41:51.764]                             else {
[11:41:51.764]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:51.764]                                 info, version)
[11:41:51.764]                             }
[11:41:51.764]                             base::stop(msg)
[11:41:51.764]                           }
[11:41:51.764]                         })
[11:41:51.764]                       }
[11:41:51.764]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:51.764]                       base::options(mc.cores = 1L)
[11:41:51.764]                     }
[11:41:51.764]                     base::local({
[11:41:51.764]                       for (pkg in "mlr3") {
[11:41:51.764]                         base::loadNamespace(pkg)
[11:41:51.764]                         base::library(pkg, character.only = TRUE)
[11:41:51.764]                       }
[11:41:51.764]                     })
[11:41:51.764]                   }
[11:41:51.764]                   options(future.plan = NULL)
[11:41:51.764]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:51.764]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:51.764]                 }
[11:41:51.764]                 ...future.workdir <- getwd()
[11:41:51.764]             }
[11:41:51.764]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:51.764]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:51.764]         }
[11:41:51.764]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:51.764]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:51.764]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:51.764]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:51.764]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:51.764]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:51.764]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:51.764]             base::names(...future.oldOptions))
[11:41:51.764]     }
[11:41:51.764]     if (FALSE) {
[11:41:51.764]     }
[11:41:51.764]     else {
[11:41:51.764]         if (TRUE) {
[11:41:51.764]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:51.764]                 open = "w")
[11:41:51.764]         }
[11:41:51.764]         else {
[11:41:51.764]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:51.764]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:51.764]         }
[11:41:51.764]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:51.764]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:51.764]             base::sink(type = "output", split = FALSE)
[11:41:51.764]             base::close(...future.stdout)
[11:41:51.764]         }, add = TRUE)
[11:41:51.764]     }
[11:41:51.764]     ...future.frame <- base::sys.nframe()
[11:41:51.764]     ...future.conditions <- base::list()
[11:41:51.764]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:51.764]     if (FALSE) {
[11:41:51.764]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:51.764]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:51.764]     }
[11:41:51.764]     ...future.result <- base::tryCatch({
[11:41:51.764]         base::withCallingHandlers({
[11:41:51.764]             ...future.value <- base::withVisible(base::local({
[11:41:51.764]                 ...future.makeSendCondition <- local({
[11:41:51.764]                   sendCondition <- NULL
[11:41:51.764]                   function(frame = 1L) {
[11:41:51.764]                     if (is.function(sendCondition)) 
[11:41:51.764]                       return(sendCondition)
[11:41:51.764]                     ns <- getNamespace("parallel")
[11:41:51.764]                     if (exists("sendData", mode = "function", 
[11:41:51.764]                       envir = ns)) {
[11:41:51.764]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:51.764]                         envir = ns)
[11:41:51.764]                       envir <- sys.frame(frame)
[11:41:51.764]                       master <- NULL
[11:41:51.764]                       while (!identical(envir, .GlobalEnv) && 
[11:41:51.764]                         !identical(envir, emptyenv())) {
[11:41:51.764]                         if (exists("master", mode = "list", envir = envir, 
[11:41:51.764]                           inherits = FALSE)) {
[11:41:51.764]                           master <- get("master", mode = "list", 
[11:41:51.764]                             envir = envir, inherits = FALSE)
[11:41:51.764]                           if (inherits(master, c("SOCKnode", 
[11:41:51.764]                             "SOCK0node"))) {
[11:41:51.764]                             sendCondition <<- function(cond) {
[11:41:51.764]                               data <- list(type = "VALUE", value = cond, 
[11:41:51.764]                                 success = TRUE)
[11:41:51.764]                               parallel_sendData(master, data)
[11:41:51.764]                             }
[11:41:51.764]                             return(sendCondition)
[11:41:51.764]                           }
[11:41:51.764]                         }
[11:41:51.764]                         frame <- frame + 1L
[11:41:51.764]                         envir <- sys.frame(frame)
[11:41:51.764]                       }
[11:41:51.764]                     }
[11:41:51.764]                     sendCondition <<- function(cond) NULL
[11:41:51.764]                   }
[11:41:51.764]                 })
[11:41:51.764]                 withCallingHandlers({
[11:41:51.764]                   {
[11:41:51.764]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:51.764]                     if (!identical(...future.globals.maxSize.org, 
[11:41:51.764]                       ...future.globals.maxSize)) {
[11:41:51.764]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:51.764]                       on.exit(options(oopts), add = TRUE)
[11:41:51.764]                     }
[11:41:51.764]                     {
[11:41:51.764]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:51.764]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:51.764]                           envir = globalenv(), inherits = FALSE)
[11:41:51.764]                         ...future.FUN(...)
[11:41:51.764]                       }
[11:41:51.764]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:51.764]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:51.764]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:51.764]                         USE.NAMES = FALSE)
[11:41:51.764]                       do.call(mapply, args = args)
[11:41:51.764]                     }
[11:41:51.764]                   }
[11:41:51.764]                 }, immediateCondition = function(cond) {
[11:41:51.764]                   sendCondition <- ...future.makeSendCondition()
[11:41:51.764]                   sendCondition(cond)
[11:41:51.764]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:51.764]                   {
[11:41:51.764]                     inherits <- base::inherits
[11:41:51.764]                     invokeRestart <- base::invokeRestart
[11:41:51.764]                     is.null <- base::is.null
[11:41:51.764]                     muffled <- FALSE
[11:41:51.764]                     if (inherits(cond, "message")) {
[11:41:51.764]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:51.764]                       if (muffled) 
[11:41:51.764]                         invokeRestart("muffleMessage")
[11:41:51.764]                     }
[11:41:51.764]                     else if (inherits(cond, "warning")) {
[11:41:51.764]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:51.764]                       if (muffled) 
[11:41:51.764]                         invokeRestart("muffleWarning")
[11:41:51.764]                     }
[11:41:51.764]                     else if (inherits(cond, "condition")) {
[11:41:51.764]                       if (!is.null(pattern)) {
[11:41:51.764]                         computeRestarts <- base::computeRestarts
[11:41:51.764]                         grepl <- base::grepl
[11:41:51.764]                         restarts <- computeRestarts(cond)
[11:41:51.764]                         for (restart in restarts) {
[11:41:51.764]                           name <- restart$name
[11:41:51.764]                           if (is.null(name)) 
[11:41:51.764]                             next
[11:41:51.764]                           if (!grepl(pattern, name)) 
[11:41:51.764]                             next
[11:41:51.764]                           invokeRestart(restart)
[11:41:51.764]                           muffled <- TRUE
[11:41:51.764]                           break
[11:41:51.764]                         }
[11:41:51.764]                       }
[11:41:51.764]                     }
[11:41:51.764]                     invisible(muffled)
[11:41:51.764]                   }
[11:41:51.764]                   muffleCondition(cond)
[11:41:51.764]                 })
[11:41:51.764]             }))
[11:41:51.764]             future::FutureResult(value = ...future.value$value, 
[11:41:51.764]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:51.764]                   ...future.rng), globalenv = if (FALSE) 
[11:41:51.764]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:51.764]                     ...future.globalenv.names))
[11:41:51.764]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:51.764]         }, condition = base::local({
[11:41:51.764]             c <- base::c
[11:41:51.764]             inherits <- base::inherits
[11:41:51.764]             invokeRestart <- base::invokeRestart
[11:41:51.764]             length <- base::length
[11:41:51.764]             list <- base::list
[11:41:51.764]             seq.int <- base::seq.int
[11:41:51.764]             signalCondition <- base::signalCondition
[11:41:51.764]             sys.calls <- base::sys.calls
[11:41:51.764]             `[[` <- base::`[[`
[11:41:51.764]             `+` <- base::`+`
[11:41:51.764]             `<<-` <- base::`<<-`
[11:41:51.764]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:51.764]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:51.764]                   3L)]
[11:41:51.764]             }
[11:41:51.764]             function(cond) {
[11:41:51.764]                 is_error <- inherits(cond, "error")
[11:41:51.764]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:51.764]                   NULL)
[11:41:51.764]                 if (is_error) {
[11:41:51.764]                   sessionInformation <- function() {
[11:41:51.764]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:51.764]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:51.764]                       search = base::search(), system = base::Sys.info())
[11:41:51.764]                   }
[11:41:51.764]                   ...future.conditions[[length(...future.conditions) + 
[11:41:51.764]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:51.764]                     cond$call), session = sessionInformation(), 
[11:41:51.764]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:51.764]                   signalCondition(cond)
[11:41:51.764]                 }
[11:41:51.764]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:51.764]                 "immediateCondition"))) {
[11:41:51.764]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:51.764]                   ...future.conditions[[length(...future.conditions) + 
[11:41:51.764]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:51.764]                   if (TRUE && !signal) {
[11:41:51.764]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:51.764]                     {
[11:41:51.764]                       inherits <- base::inherits
[11:41:51.764]                       invokeRestart <- base::invokeRestart
[11:41:51.764]                       is.null <- base::is.null
[11:41:51.764]                       muffled <- FALSE
[11:41:51.764]                       if (inherits(cond, "message")) {
[11:41:51.764]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:51.764]                         if (muffled) 
[11:41:51.764]                           invokeRestart("muffleMessage")
[11:41:51.764]                       }
[11:41:51.764]                       else if (inherits(cond, "warning")) {
[11:41:51.764]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:51.764]                         if (muffled) 
[11:41:51.764]                           invokeRestart("muffleWarning")
[11:41:51.764]                       }
[11:41:51.764]                       else if (inherits(cond, "condition")) {
[11:41:51.764]                         if (!is.null(pattern)) {
[11:41:51.764]                           computeRestarts <- base::computeRestarts
[11:41:51.764]                           grepl <- base::grepl
[11:41:51.764]                           restarts <- computeRestarts(cond)
[11:41:51.764]                           for (restart in restarts) {
[11:41:51.764]                             name <- restart$name
[11:41:51.764]                             if (is.null(name)) 
[11:41:51.764]                               next
[11:41:51.764]                             if (!grepl(pattern, name)) 
[11:41:51.764]                               next
[11:41:51.764]                             invokeRestart(restart)
[11:41:51.764]                             muffled <- TRUE
[11:41:51.764]                             break
[11:41:51.764]                           }
[11:41:51.764]                         }
[11:41:51.764]                       }
[11:41:51.764]                       invisible(muffled)
[11:41:51.764]                     }
[11:41:51.764]                     muffleCondition(cond, pattern = "^muffle")
[11:41:51.764]                   }
[11:41:51.764]                 }
[11:41:51.764]                 else {
[11:41:51.764]                   if (TRUE) {
[11:41:51.764]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:51.764]                     {
[11:41:51.764]                       inherits <- base::inherits
[11:41:51.764]                       invokeRestart <- base::invokeRestart
[11:41:51.764]                       is.null <- base::is.null
[11:41:51.764]                       muffled <- FALSE
[11:41:51.764]                       if (inherits(cond, "message")) {
[11:41:51.764]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:51.764]                         if (muffled) 
[11:41:51.764]                           invokeRestart("muffleMessage")
[11:41:51.764]                       }
[11:41:51.764]                       else if (inherits(cond, "warning")) {
[11:41:51.764]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:51.764]                         if (muffled) 
[11:41:51.764]                           invokeRestart("muffleWarning")
[11:41:51.764]                       }
[11:41:51.764]                       else if (inherits(cond, "condition")) {
[11:41:51.764]                         if (!is.null(pattern)) {
[11:41:51.764]                           computeRestarts <- base::computeRestarts
[11:41:51.764]                           grepl <- base::grepl
[11:41:51.764]                           restarts <- computeRestarts(cond)
[11:41:51.764]                           for (restart in restarts) {
[11:41:51.764]                             name <- restart$name
[11:41:51.764]                             if (is.null(name)) 
[11:41:51.764]                               next
[11:41:51.764]                             if (!grepl(pattern, name)) 
[11:41:51.764]                               next
[11:41:51.764]                             invokeRestart(restart)
[11:41:51.764]                             muffled <- TRUE
[11:41:51.764]                             break
[11:41:51.764]                           }
[11:41:51.764]                         }
[11:41:51.764]                       }
[11:41:51.764]                       invisible(muffled)
[11:41:51.764]                     }
[11:41:51.764]                     muffleCondition(cond, pattern = "^muffle")
[11:41:51.764]                   }
[11:41:51.764]                 }
[11:41:51.764]             }
[11:41:51.764]         }))
[11:41:51.764]     }, error = function(ex) {
[11:41:51.764]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:51.764]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:51.764]                 ...future.rng), started = ...future.startTime, 
[11:41:51.764]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:51.764]             version = "1.8"), class = "FutureResult")
[11:41:51.764]     }, finally = {
[11:41:51.764]         if (!identical(...future.workdir, getwd())) 
[11:41:51.764]             setwd(...future.workdir)
[11:41:51.764]         {
[11:41:51.764]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:51.764]                 ...future.oldOptions$nwarnings <- NULL
[11:41:51.764]             }
[11:41:51.764]             base::options(...future.oldOptions)
[11:41:51.764]             if (.Platform$OS.type == "windows") {
[11:41:51.764]                 old_names <- names(...future.oldEnvVars)
[11:41:51.764]                 envs <- base::Sys.getenv()
[11:41:51.764]                 names <- names(envs)
[11:41:51.764]                 common <- intersect(names, old_names)
[11:41:51.764]                 added <- setdiff(names, old_names)
[11:41:51.764]                 removed <- setdiff(old_names, names)
[11:41:51.764]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:51.764]                   envs[common]]
[11:41:51.764]                 NAMES <- toupper(changed)
[11:41:51.764]                 args <- list()
[11:41:51.764]                 for (kk in seq_along(NAMES)) {
[11:41:51.764]                   name <- changed[[kk]]
[11:41:51.764]                   NAME <- NAMES[[kk]]
[11:41:51.764]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:51.764]                     next
[11:41:51.764]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:51.764]                 }
[11:41:51.764]                 NAMES <- toupper(added)
[11:41:51.764]                 for (kk in seq_along(NAMES)) {
[11:41:51.764]                   name <- added[[kk]]
[11:41:51.764]                   NAME <- NAMES[[kk]]
[11:41:51.764]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:51.764]                     next
[11:41:51.764]                   args[[name]] <- ""
[11:41:51.764]                 }
[11:41:51.764]                 NAMES <- toupper(removed)
[11:41:51.764]                 for (kk in seq_along(NAMES)) {
[11:41:51.764]                   name <- removed[[kk]]
[11:41:51.764]                   NAME <- NAMES[[kk]]
[11:41:51.764]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:51.764]                     next
[11:41:51.764]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:51.764]                 }
[11:41:51.764]                 if (length(args) > 0) 
[11:41:51.764]                   base::do.call(base::Sys.setenv, args = args)
[11:41:51.764]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:51.764]             }
[11:41:51.764]             else {
[11:41:51.764]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:51.764]             }
[11:41:51.764]             {
[11:41:51.764]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:51.764]                   0L) {
[11:41:51.764]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:51.764]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:51.764]                   base::options(opts)
[11:41:51.764]                 }
[11:41:51.764]                 {
[11:41:51.764]                   {
[11:41:51.764]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:51.764]                     NULL
[11:41:51.764]                   }
[11:41:51.764]                   options(future.plan = NULL)
[11:41:51.764]                   if (is.na(NA_character_)) 
[11:41:51.764]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:51.764]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:51.764]                   future::plan(list(function (..., workers = 2, 
[11:41:51.764]                     envir = parent.frame()) 
[11:41:51.764]                   strategy(..., workers = workers, envir = envir)), 
[11:41:51.764]                     .cleanup = FALSE, .init = FALSE)
[11:41:51.764]                 }
[11:41:51.764]             }
[11:41:51.764]         }
[11:41:51.764]     })
[11:41:51.764]     if (TRUE) {
[11:41:51.764]         base::sink(type = "output", split = FALSE)
[11:41:51.764]         if (TRUE) {
[11:41:51.764]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:51.764]         }
[11:41:51.764]         else {
[11:41:51.764]             ...future.result["stdout"] <- base::list(NULL)
[11:41:51.764]         }
[11:41:51.764]         base::close(...future.stdout)
[11:41:51.764]         ...future.stdout <- NULL
[11:41:51.764]     }
[11:41:51.764]     ...future.result$conditions <- ...future.conditions
[11:41:51.764]     ...future.result$finished <- base::Sys.time()
[11:41:51.764]     ...future.result
[11:41:51.764] }
[11:41:51.766] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:51.777] receiveMessageFromWorker() for ClusterFuture ...
[11:41:51.777] - Validating connection of MultisessionFuture
[11:41:51.778] - received message: FutureResult
[11:41:51.778] - Received FutureResult
[11:41:51.778] - Erased future from FutureRegistry
[11:41:51.778] result() for ClusterFuture ...
[11:41:51.778] - result already collected: FutureResult
[11:41:51.778] result() for ClusterFuture ... done
[11:41:51.778] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:51.778] result() for ClusterFuture ...
[11:41:51.778] - result already collected: FutureResult
[11:41:51.779] result() for ClusterFuture ... done
[11:41:51.779] result() for ClusterFuture ...
[11:41:51.779] - result already collected: FutureResult
[11:41:51.779] result() for ClusterFuture ... done
[11:41:51.780] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:51.780] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:51.825] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:51.833] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:51.835] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:51.836] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:51.881] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:51.882] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:51.882] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:51.883] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:51.883] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:51.883] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:51.884] MultisessionFuture started
[11:41:51.884] - Launch lazy future ... done
[11:41:51.884] run() for ‘MultisessionFuture’ ... done
[11:41:51.884] Created future:
[11:41:51.884] MultisessionFuture:
[11:41:51.884] Label: ‘future_mapply-33’
[11:41:51.884] Expression:
[11:41:51.884] {
[11:41:51.884]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:51.884]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:51.884]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:51.884]         on.exit(options(oopts), add = TRUE)
[11:41:51.884]     }
[11:41:51.884]     {
[11:41:51.884]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:51.884]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:51.884]                 inherits = FALSE)
[11:41:51.884]             ...future.FUN(...)
[11:41:51.884]         }
[11:41:51.884]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:51.884]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:51.884]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:51.884]         do.call(mapply, args = args)
[11:41:51.884]     }
[11:41:51.884] }
[11:41:51.884] Lazy evaluation: FALSE
[11:41:51.884] Asynchronous evaluation: TRUE
[11:41:51.884] Local evaluation: TRUE
[11:41:51.884] Environment: 0x560ef58e1768
[11:41:51.884] Capture standard output: TRUE
[11:41:51.884] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:51.884] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:51.884] Packages: 1 packages (‘mlr3’)
[11:41:51.884] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:51.884] Resolved: FALSE
[11:41:51.884] Value: <not collected>
[11:41:51.884] Conditions captured: <none>
[11:41:51.884] Early signaling: FALSE
[11:41:51.884] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:51.884] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:51.901] Chunk #33 of 90 ... DONE
[11:41:51.901] Chunk #34 of 90 ...
[11:41:51.901]  - seeds: [1] <seeds>
[11:41:51.901] getGlobalsAndPackages() ...
[11:41:51.901] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:51.901] Resolving globals: FALSE
[11:41:51.902] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:51.902] - packages: [1] ‘mlr3’
[11:41:51.902] getGlobalsAndPackages() ... DONE
[11:41:51.902] run() for ‘Future’ ...
[11:41:51.902] - state: ‘created’
[11:41:51.902] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:51.911] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:51.911] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:51.911]   - Field: ‘node’
[11:41:51.911]   - Field: ‘label’
[11:41:51.911]   - Field: ‘local’
[11:41:51.912]   - Field: ‘owner’
[11:41:51.912]   - Field: ‘envir’
[11:41:51.912]   - Field: ‘workers’
[11:41:51.912]   - Field: ‘packages’
[11:41:51.912]   - Field: ‘gc’
[11:41:51.912]   - Field: ‘conditions’
[11:41:51.912]   - Field: ‘persistent’
[11:41:51.912]   - Field: ‘expr’
[11:41:51.912]   - Field: ‘uuid’
[11:41:51.912]   - Field: ‘seed’
[11:41:51.912]   - Field: ‘version’
[11:41:51.912]   - Field: ‘result’
[11:41:51.912]   - Field: ‘asynchronous’
[11:41:51.912]   - Field: ‘calls’
[11:41:51.912]   - Field: ‘globals’
[11:41:51.912]   - Field: ‘stdout’
[11:41:51.912]   - Field: ‘earlySignal’
[11:41:51.912]   - Field: ‘lazy’
[11:41:51.912]   - Field: ‘state’
[11:41:51.912] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:51.913] - Launch lazy future ...
[11:41:51.913] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:51.913] Packages needed by future strategies (n = 0): <none>
[11:41:51.913] {
[11:41:51.913]     {
[11:41:51.913]         {
[11:41:51.913]             ...future.startTime <- base::Sys.time()
[11:41:51.913]             {
[11:41:51.913]                 {
[11:41:51.913]                   {
[11:41:51.913]                     {
[11:41:51.913]                       {
[11:41:51.913]                         base::local({
[11:41:51.913]                           has_future <- base::requireNamespace("future", 
[11:41:51.913]                             quietly = TRUE)
[11:41:51.913]                           if (has_future) {
[11:41:51.913]                             ns <- base::getNamespace("future")
[11:41:51.913]                             version <- ns[[".package"]][["version"]]
[11:41:51.913]                             if (is.null(version)) 
[11:41:51.913]                               version <- utils::packageVersion("future")
[11:41:51.913]                           }
[11:41:51.913]                           else {
[11:41:51.913]                             version <- NULL
[11:41:51.913]                           }
[11:41:51.913]                           if (!has_future || version < "1.8.0") {
[11:41:51.913]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:51.913]                               "", base::R.version$version.string), 
[11:41:51.913]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:51.913]                                 base::R.version$platform, 8 * 
[11:41:51.913]                                   base::.Machine$sizeof.pointer), 
[11:41:51.913]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:51.913]                                 "release", "version")], collapse = " "), 
[11:41:51.913]                               hostname = base::Sys.info()[["nodename"]])
[11:41:51.913]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:51.913]                               info)
[11:41:51.913]                             info <- base::paste(info, collapse = "; ")
[11:41:51.913]                             if (!has_future) {
[11:41:51.913]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:51.913]                                 info)
[11:41:51.913]                             }
[11:41:51.913]                             else {
[11:41:51.913]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:51.913]                                 info, version)
[11:41:51.913]                             }
[11:41:51.913]                             base::stop(msg)
[11:41:51.913]                           }
[11:41:51.913]                         })
[11:41:51.913]                       }
[11:41:51.913]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:51.913]                       base::options(mc.cores = 1L)
[11:41:51.913]                     }
[11:41:51.913]                     base::local({
[11:41:51.913]                       for (pkg in "mlr3") {
[11:41:51.913]                         base::loadNamespace(pkg)
[11:41:51.913]                         base::library(pkg, character.only = TRUE)
[11:41:51.913]                       }
[11:41:51.913]                     })
[11:41:51.913]                   }
[11:41:51.913]                   options(future.plan = NULL)
[11:41:51.913]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:51.913]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:51.913]                 }
[11:41:51.913]                 ...future.workdir <- getwd()
[11:41:51.913]             }
[11:41:51.913]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:51.913]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:51.913]         }
[11:41:51.913]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:51.913]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:51.913]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:51.913]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:51.913]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:51.913]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:51.913]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:51.913]             base::names(...future.oldOptions))
[11:41:51.913]     }
[11:41:51.913]     if (FALSE) {
[11:41:51.913]     }
[11:41:51.913]     else {
[11:41:51.913]         if (TRUE) {
[11:41:51.913]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:51.913]                 open = "w")
[11:41:51.913]         }
[11:41:51.913]         else {
[11:41:51.913]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:51.913]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:51.913]         }
[11:41:51.913]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:51.913]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:51.913]             base::sink(type = "output", split = FALSE)
[11:41:51.913]             base::close(...future.stdout)
[11:41:51.913]         }, add = TRUE)
[11:41:51.913]     }
[11:41:51.913]     ...future.frame <- base::sys.nframe()
[11:41:51.913]     ...future.conditions <- base::list()
[11:41:51.913]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:51.913]     if (FALSE) {
[11:41:51.913]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:51.913]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:51.913]     }
[11:41:51.913]     ...future.result <- base::tryCatch({
[11:41:51.913]         base::withCallingHandlers({
[11:41:51.913]             ...future.value <- base::withVisible(base::local({
[11:41:51.913]                 ...future.makeSendCondition <- local({
[11:41:51.913]                   sendCondition <- NULL
[11:41:51.913]                   function(frame = 1L) {
[11:41:51.913]                     if (is.function(sendCondition)) 
[11:41:51.913]                       return(sendCondition)
[11:41:51.913]                     ns <- getNamespace("parallel")
[11:41:51.913]                     if (exists("sendData", mode = "function", 
[11:41:51.913]                       envir = ns)) {
[11:41:51.913]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:51.913]                         envir = ns)
[11:41:51.913]                       envir <- sys.frame(frame)
[11:41:51.913]                       master <- NULL
[11:41:51.913]                       while (!identical(envir, .GlobalEnv) && 
[11:41:51.913]                         !identical(envir, emptyenv())) {
[11:41:51.913]                         if (exists("master", mode = "list", envir = envir, 
[11:41:51.913]                           inherits = FALSE)) {
[11:41:51.913]                           master <- get("master", mode = "list", 
[11:41:51.913]                             envir = envir, inherits = FALSE)
[11:41:51.913]                           if (inherits(master, c("SOCKnode", 
[11:41:51.913]                             "SOCK0node"))) {
[11:41:51.913]                             sendCondition <<- function(cond) {
[11:41:51.913]                               data <- list(type = "VALUE", value = cond, 
[11:41:51.913]                                 success = TRUE)
[11:41:51.913]                               parallel_sendData(master, data)
[11:41:51.913]                             }
[11:41:51.913]                             return(sendCondition)
[11:41:51.913]                           }
[11:41:51.913]                         }
[11:41:51.913]                         frame <- frame + 1L
[11:41:51.913]                         envir <- sys.frame(frame)
[11:41:51.913]                       }
[11:41:51.913]                     }
[11:41:51.913]                     sendCondition <<- function(cond) NULL
[11:41:51.913]                   }
[11:41:51.913]                 })
[11:41:51.913]                 withCallingHandlers({
[11:41:51.913]                   {
[11:41:51.913]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:51.913]                     if (!identical(...future.globals.maxSize.org, 
[11:41:51.913]                       ...future.globals.maxSize)) {
[11:41:51.913]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:51.913]                       on.exit(options(oopts), add = TRUE)
[11:41:51.913]                     }
[11:41:51.913]                     {
[11:41:51.913]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:51.913]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:51.913]                           envir = globalenv(), inherits = FALSE)
[11:41:51.913]                         ...future.FUN(...)
[11:41:51.913]                       }
[11:41:51.913]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:51.913]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:51.913]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:51.913]                         USE.NAMES = FALSE)
[11:41:51.913]                       do.call(mapply, args = args)
[11:41:51.913]                     }
[11:41:51.913]                   }
[11:41:51.913]                 }, immediateCondition = function(cond) {
[11:41:51.913]                   sendCondition <- ...future.makeSendCondition()
[11:41:51.913]                   sendCondition(cond)
[11:41:51.913]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:51.913]                   {
[11:41:51.913]                     inherits <- base::inherits
[11:41:51.913]                     invokeRestart <- base::invokeRestart
[11:41:51.913]                     is.null <- base::is.null
[11:41:51.913]                     muffled <- FALSE
[11:41:51.913]                     if (inherits(cond, "message")) {
[11:41:51.913]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:51.913]                       if (muffled) 
[11:41:51.913]                         invokeRestart("muffleMessage")
[11:41:51.913]                     }
[11:41:51.913]                     else if (inherits(cond, "warning")) {
[11:41:51.913]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:51.913]                       if (muffled) 
[11:41:51.913]                         invokeRestart("muffleWarning")
[11:41:51.913]                     }
[11:41:51.913]                     else if (inherits(cond, "condition")) {
[11:41:51.913]                       if (!is.null(pattern)) {
[11:41:51.913]                         computeRestarts <- base::computeRestarts
[11:41:51.913]                         grepl <- base::grepl
[11:41:51.913]                         restarts <- computeRestarts(cond)
[11:41:51.913]                         for (restart in restarts) {
[11:41:51.913]                           name <- restart$name
[11:41:51.913]                           if (is.null(name)) 
[11:41:51.913]                             next
[11:41:51.913]                           if (!grepl(pattern, name)) 
[11:41:51.913]                             next
[11:41:51.913]                           invokeRestart(restart)
[11:41:51.913]                           muffled <- TRUE
[11:41:51.913]                           break
[11:41:51.913]                         }
[11:41:51.913]                       }
[11:41:51.913]                     }
[11:41:51.913]                     invisible(muffled)
[11:41:51.913]                   }
[11:41:51.913]                   muffleCondition(cond)
[11:41:51.913]                 })
[11:41:51.913]             }))
[11:41:51.913]             future::FutureResult(value = ...future.value$value, 
[11:41:51.913]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:51.913]                   ...future.rng), globalenv = if (FALSE) 
[11:41:51.913]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:51.913]                     ...future.globalenv.names))
[11:41:51.913]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:51.913]         }, condition = base::local({
[11:41:51.913]             c <- base::c
[11:41:51.913]             inherits <- base::inherits
[11:41:51.913]             invokeRestart <- base::invokeRestart
[11:41:51.913]             length <- base::length
[11:41:51.913]             list <- base::list
[11:41:51.913]             seq.int <- base::seq.int
[11:41:51.913]             signalCondition <- base::signalCondition
[11:41:51.913]             sys.calls <- base::sys.calls
[11:41:51.913]             `[[` <- base::`[[`
[11:41:51.913]             `+` <- base::`+`
[11:41:51.913]             `<<-` <- base::`<<-`
[11:41:51.913]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:51.913]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:51.913]                   3L)]
[11:41:51.913]             }
[11:41:51.913]             function(cond) {
[11:41:51.913]                 is_error <- inherits(cond, "error")
[11:41:51.913]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:51.913]                   NULL)
[11:41:51.913]                 if (is_error) {
[11:41:51.913]                   sessionInformation <- function() {
[11:41:51.913]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:51.913]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:51.913]                       search = base::search(), system = base::Sys.info())
[11:41:51.913]                   }
[11:41:51.913]                   ...future.conditions[[length(...future.conditions) + 
[11:41:51.913]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:51.913]                     cond$call), session = sessionInformation(), 
[11:41:51.913]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:51.913]                   signalCondition(cond)
[11:41:51.913]                 }
[11:41:51.913]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:51.913]                 "immediateCondition"))) {
[11:41:51.913]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:51.913]                   ...future.conditions[[length(...future.conditions) + 
[11:41:51.913]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:51.913]                   if (TRUE && !signal) {
[11:41:51.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:51.913]                     {
[11:41:51.913]                       inherits <- base::inherits
[11:41:51.913]                       invokeRestart <- base::invokeRestart
[11:41:51.913]                       is.null <- base::is.null
[11:41:51.913]                       muffled <- FALSE
[11:41:51.913]                       if (inherits(cond, "message")) {
[11:41:51.913]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:51.913]                         if (muffled) 
[11:41:51.913]                           invokeRestart("muffleMessage")
[11:41:51.913]                       }
[11:41:51.913]                       else if (inherits(cond, "warning")) {
[11:41:51.913]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:51.913]                         if (muffled) 
[11:41:51.913]                           invokeRestart("muffleWarning")
[11:41:51.913]                       }
[11:41:51.913]                       else if (inherits(cond, "condition")) {
[11:41:51.913]                         if (!is.null(pattern)) {
[11:41:51.913]                           computeRestarts <- base::computeRestarts
[11:41:51.913]                           grepl <- base::grepl
[11:41:51.913]                           restarts <- computeRestarts(cond)
[11:41:51.913]                           for (restart in restarts) {
[11:41:51.913]                             name <- restart$name
[11:41:51.913]                             if (is.null(name)) 
[11:41:51.913]                               next
[11:41:51.913]                             if (!grepl(pattern, name)) 
[11:41:51.913]                               next
[11:41:51.913]                             invokeRestart(restart)
[11:41:51.913]                             muffled <- TRUE
[11:41:51.913]                             break
[11:41:51.913]                           }
[11:41:51.913]                         }
[11:41:51.913]                       }
[11:41:51.913]                       invisible(muffled)
[11:41:51.913]                     }
[11:41:51.913]                     muffleCondition(cond, pattern = "^muffle")
[11:41:51.913]                   }
[11:41:51.913]                 }
[11:41:51.913]                 else {
[11:41:51.913]                   if (TRUE) {
[11:41:51.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:51.913]                     {
[11:41:51.913]                       inherits <- base::inherits
[11:41:51.913]                       invokeRestart <- base::invokeRestart
[11:41:51.913]                       is.null <- base::is.null
[11:41:51.913]                       muffled <- FALSE
[11:41:51.913]                       if (inherits(cond, "message")) {
[11:41:51.913]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:51.913]                         if (muffled) 
[11:41:51.913]                           invokeRestart("muffleMessage")
[11:41:51.913]                       }
[11:41:51.913]                       else if (inherits(cond, "warning")) {
[11:41:51.913]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:51.913]                         if (muffled) 
[11:41:51.913]                           invokeRestart("muffleWarning")
[11:41:51.913]                       }
[11:41:51.913]                       else if (inherits(cond, "condition")) {
[11:41:51.913]                         if (!is.null(pattern)) {
[11:41:51.913]                           computeRestarts <- base::computeRestarts
[11:41:51.913]                           grepl <- base::grepl
[11:41:51.913]                           restarts <- computeRestarts(cond)
[11:41:51.913]                           for (restart in restarts) {
[11:41:51.913]                             name <- restart$name
[11:41:51.913]                             if (is.null(name)) 
[11:41:51.913]                               next
[11:41:51.913]                             if (!grepl(pattern, name)) 
[11:41:51.913]                               next
[11:41:51.913]                             invokeRestart(restart)
[11:41:51.913]                             muffled <- TRUE
[11:41:51.913]                             break
[11:41:51.913]                           }
[11:41:51.913]                         }
[11:41:51.913]                       }
[11:41:51.913]                       invisible(muffled)
[11:41:51.913]                     }
[11:41:51.913]                     muffleCondition(cond, pattern = "^muffle")
[11:41:51.913]                   }
[11:41:51.913]                 }
[11:41:51.913]             }
[11:41:51.913]         }))
[11:41:51.913]     }, error = function(ex) {
[11:41:51.913]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:51.913]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:51.913]                 ...future.rng), started = ...future.startTime, 
[11:41:51.913]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:51.913]             version = "1.8"), class = "FutureResult")
[11:41:51.913]     }, finally = {
[11:41:51.913]         if (!identical(...future.workdir, getwd())) 
[11:41:51.913]             setwd(...future.workdir)
[11:41:51.913]         {
[11:41:51.913]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:51.913]                 ...future.oldOptions$nwarnings <- NULL
[11:41:51.913]             }
[11:41:51.913]             base::options(...future.oldOptions)
[11:41:51.913]             if (.Platform$OS.type == "windows") {
[11:41:51.913]                 old_names <- names(...future.oldEnvVars)
[11:41:51.913]                 envs <- base::Sys.getenv()
[11:41:51.913]                 names <- names(envs)
[11:41:51.913]                 common <- intersect(names, old_names)
[11:41:51.913]                 added <- setdiff(names, old_names)
[11:41:51.913]                 removed <- setdiff(old_names, names)
[11:41:51.913]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:51.913]                   envs[common]]
[11:41:51.913]                 NAMES <- toupper(changed)
[11:41:51.913]                 args <- list()
[11:41:51.913]                 for (kk in seq_along(NAMES)) {
[11:41:51.913]                   name <- changed[[kk]]
[11:41:51.913]                   NAME <- NAMES[[kk]]
[11:41:51.913]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:51.913]                     next
[11:41:51.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:51.913]                 }
[11:41:51.913]                 NAMES <- toupper(added)
[11:41:51.913]                 for (kk in seq_along(NAMES)) {
[11:41:51.913]                   name <- added[[kk]]
[11:41:51.913]                   NAME <- NAMES[[kk]]
[11:41:51.913]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:51.913]                     next
[11:41:51.913]                   args[[name]] <- ""
[11:41:51.913]                 }
[11:41:51.913]                 NAMES <- toupper(removed)
[11:41:51.913]                 for (kk in seq_along(NAMES)) {
[11:41:51.913]                   name <- removed[[kk]]
[11:41:51.913]                   NAME <- NAMES[[kk]]
[11:41:51.913]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:51.913]                     next
[11:41:51.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:51.913]                 }
[11:41:51.913]                 if (length(args) > 0) 
[11:41:51.913]                   base::do.call(base::Sys.setenv, args = args)
[11:41:51.913]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:51.913]             }
[11:41:51.913]             else {
[11:41:51.913]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:51.913]             }
[11:41:51.913]             {
[11:41:51.913]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:51.913]                   0L) {
[11:41:51.913]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:51.913]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:51.913]                   base::options(opts)
[11:41:51.913]                 }
[11:41:51.913]                 {
[11:41:51.913]                   {
[11:41:51.913]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:51.913]                     NULL
[11:41:51.913]                   }
[11:41:51.913]                   options(future.plan = NULL)
[11:41:51.913]                   if (is.na(NA_character_)) 
[11:41:51.913]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:51.913]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:51.913]                   future::plan(list(function (..., workers = 2, 
[11:41:51.913]                     envir = parent.frame()) 
[11:41:51.913]                   strategy(..., workers = workers, envir = envir)), 
[11:41:51.913]                     .cleanup = FALSE, .init = FALSE)
[11:41:51.913]                 }
[11:41:51.913]             }
[11:41:51.913]         }
[11:41:51.913]     })
[11:41:51.913]     if (TRUE) {
[11:41:51.913]         base::sink(type = "output", split = FALSE)
[11:41:51.913]         if (TRUE) {
[11:41:51.913]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:51.913]         }
[11:41:51.913]         else {
[11:41:51.913]             ...future.result["stdout"] <- base::list(NULL)
[11:41:51.913]         }
[11:41:51.913]         base::close(...future.stdout)
[11:41:51.913]         ...future.stdout <- NULL
[11:41:51.913]     }
[11:41:51.913]     ...future.result$conditions <- ...future.conditions
[11:41:51.913]     ...future.result$finished <- base::Sys.time()
[11:41:51.913]     ...future.result
[11:41:51.913] }
[11:41:51.915] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:51.926] receiveMessageFromWorker() for ClusterFuture ...
[11:41:51.926] - Validating connection of MultisessionFuture
[11:41:51.926] - received message: FutureResult
[11:41:51.926] - Received FutureResult
[11:41:51.926] - Erased future from FutureRegistry
[11:41:51.927] result() for ClusterFuture ...
[11:41:51.927] - result already collected: FutureResult
[11:41:51.927] result() for ClusterFuture ... done
[11:41:51.927] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:51.927] result() for ClusterFuture ...
[11:41:51.927] - result already collected: FutureResult
[11:41:51.927] result() for ClusterFuture ... done
[11:41:51.927] result() for ClusterFuture ...
[11:41:51.927] - result already collected: FutureResult
[11:41:51.927] result() for ClusterFuture ... done
[11:41:51.928] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:51.928] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:51.969] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:51.973] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:52.017] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:52.017] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:52.062] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:52.062] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:52.063] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:52.063] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:52.064] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:52.064] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:52.065] MultisessionFuture started
[11:41:52.065] - Launch lazy future ... done
[11:41:52.065] run() for ‘MultisessionFuture’ ... done
[11:41:52.065] Created future:
[11:41:52.065] MultisessionFuture:
[11:41:52.065] Label: ‘future_mapply-34’
[11:41:52.065] Expression:
[11:41:52.065] {
[11:41:52.065]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:52.065]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:52.065]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:52.065]         on.exit(options(oopts), add = TRUE)
[11:41:52.065]     }
[11:41:52.065]     {
[11:41:52.065]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:52.065]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:52.065]                 inherits = FALSE)
[11:41:52.065]             ...future.FUN(...)
[11:41:52.065]         }
[11:41:52.065]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:52.065]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:52.065]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:52.065]         do.call(mapply, args = args)
[11:41:52.065]     }
[11:41:52.065] }
[11:41:52.065] Lazy evaluation: FALSE
[11:41:52.065] Asynchronous evaluation: TRUE
[11:41:52.065] Local evaluation: TRUE
[11:41:52.065] Environment: 0x560ef58e1768
[11:41:52.065] Capture standard output: TRUE
[11:41:52.065] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:52.065] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:52.065] Packages: 1 packages (‘mlr3’)
[11:41:52.065] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:52.065] Resolved: FALSE
[11:41:52.065] Value: <not collected>
[11:41:52.065] Conditions captured: <none>
[11:41:52.065] Early signaling: FALSE
[11:41:52.065] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:52.065] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:52.080] Chunk #34 of 90 ... DONE
[11:41:52.080] Chunk #35 of 90 ...
[11:41:52.080]  - seeds: [1] <seeds>
[11:41:52.080] getGlobalsAndPackages() ...
[11:41:52.080] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:52.080] Resolving globals: FALSE
[11:41:52.081] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:52.081] - packages: [1] ‘mlr3’
[11:41:52.081] getGlobalsAndPackages() ... DONE
[11:41:52.081] run() for ‘Future’ ...
[11:41:52.081] - state: ‘created’
[11:41:52.081] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:52.091] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:52.091] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:52.091]   - Field: ‘node’
[11:41:52.091]   - Field: ‘label’
[11:41:52.091]   - Field: ‘local’
[11:41:52.091]   - Field: ‘owner’
[11:41:52.091]   - Field: ‘envir’
[11:41:52.091]   - Field: ‘workers’
[11:41:52.091]   - Field: ‘packages’
[11:41:52.091]   - Field: ‘gc’
[11:41:52.091]   - Field: ‘conditions’
[11:41:52.091]   - Field: ‘persistent’
[11:41:52.092]   - Field: ‘expr’
[11:41:52.092]   - Field: ‘uuid’
[11:41:52.092]   - Field: ‘seed’
[11:41:52.092]   - Field: ‘version’
[11:41:52.092]   - Field: ‘result’
[11:41:52.092]   - Field: ‘asynchronous’
[11:41:52.092]   - Field: ‘calls’
[11:41:52.092]   - Field: ‘globals’
[11:41:52.092]   - Field: ‘stdout’
[11:41:52.092]   - Field: ‘earlySignal’
[11:41:52.092]   - Field: ‘lazy’
[11:41:52.092]   - Field: ‘state’
[11:41:52.092] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:52.092] - Launch lazy future ...
[11:41:52.092] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:52.092] Packages needed by future strategies (n = 0): <none>
[11:41:52.093] {
[11:41:52.093]     {
[11:41:52.093]         {
[11:41:52.093]             ...future.startTime <- base::Sys.time()
[11:41:52.093]             {
[11:41:52.093]                 {
[11:41:52.093]                   {
[11:41:52.093]                     {
[11:41:52.093]                       {
[11:41:52.093]                         base::local({
[11:41:52.093]                           has_future <- base::requireNamespace("future", 
[11:41:52.093]                             quietly = TRUE)
[11:41:52.093]                           if (has_future) {
[11:41:52.093]                             ns <- base::getNamespace("future")
[11:41:52.093]                             version <- ns[[".package"]][["version"]]
[11:41:52.093]                             if (is.null(version)) 
[11:41:52.093]                               version <- utils::packageVersion("future")
[11:41:52.093]                           }
[11:41:52.093]                           else {
[11:41:52.093]                             version <- NULL
[11:41:52.093]                           }
[11:41:52.093]                           if (!has_future || version < "1.8.0") {
[11:41:52.093]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:52.093]                               "", base::R.version$version.string), 
[11:41:52.093]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:52.093]                                 base::R.version$platform, 8 * 
[11:41:52.093]                                   base::.Machine$sizeof.pointer), 
[11:41:52.093]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:52.093]                                 "release", "version")], collapse = " "), 
[11:41:52.093]                               hostname = base::Sys.info()[["nodename"]])
[11:41:52.093]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:52.093]                               info)
[11:41:52.093]                             info <- base::paste(info, collapse = "; ")
[11:41:52.093]                             if (!has_future) {
[11:41:52.093]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:52.093]                                 info)
[11:41:52.093]                             }
[11:41:52.093]                             else {
[11:41:52.093]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:52.093]                                 info, version)
[11:41:52.093]                             }
[11:41:52.093]                             base::stop(msg)
[11:41:52.093]                           }
[11:41:52.093]                         })
[11:41:52.093]                       }
[11:41:52.093]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:52.093]                       base::options(mc.cores = 1L)
[11:41:52.093]                     }
[11:41:52.093]                     base::local({
[11:41:52.093]                       for (pkg in "mlr3") {
[11:41:52.093]                         base::loadNamespace(pkg)
[11:41:52.093]                         base::library(pkg, character.only = TRUE)
[11:41:52.093]                       }
[11:41:52.093]                     })
[11:41:52.093]                   }
[11:41:52.093]                   options(future.plan = NULL)
[11:41:52.093]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:52.093]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:52.093]                 }
[11:41:52.093]                 ...future.workdir <- getwd()
[11:41:52.093]             }
[11:41:52.093]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:52.093]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:52.093]         }
[11:41:52.093]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:52.093]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:52.093]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:52.093]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:52.093]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:52.093]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:52.093]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:52.093]             base::names(...future.oldOptions))
[11:41:52.093]     }
[11:41:52.093]     if (FALSE) {
[11:41:52.093]     }
[11:41:52.093]     else {
[11:41:52.093]         if (TRUE) {
[11:41:52.093]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:52.093]                 open = "w")
[11:41:52.093]         }
[11:41:52.093]         else {
[11:41:52.093]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:52.093]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:52.093]         }
[11:41:52.093]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:52.093]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:52.093]             base::sink(type = "output", split = FALSE)
[11:41:52.093]             base::close(...future.stdout)
[11:41:52.093]         }, add = TRUE)
[11:41:52.093]     }
[11:41:52.093]     ...future.frame <- base::sys.nframe()
[11:41:52.093]     ...future.conditions <- base::list()
[11:41:52.093]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:52.093]     if (FALSE) {
[11:41:52.093]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:52.093]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:52.093]     }
[11:41:52.093]     ...future.result <- base::tryCatch({
[11:41:52.093]         base::withCallingHandlers({
[11:41:52.093]             ...future.value <- base::withVisible(base::local({
[11:41:52.093]                 ...future.makeSendCondition <- local({
[11:41:52.093]                   sendCondition <- NULL
[11:41:52.093]                   function(frame = 1L) {
[11:41:52.093]                     if (is.function(sendCondition)) 
[11:41:52.093]                       return(sendCondition)
[11:41:52.093]                     ns <- getNamespace("parallel")
[11:41:52.093]                     if (exists("sendData", mode = "function", 
[11:41:52.093]                       envir = ns)) {
[11:41:52.093]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:52.093]                         envir = ns)
[11:41:52.093]                       envir <- sys.frame(frame)
[11:41:52.093]                       master <- NULL
[11:41:52.093]                       while (!identical(envir, .GlobalEnv) && 
[11:41:52.093]                         !identical(envir, emptyenv())) {
[11:41:52.093]                         if (exists("master", mode = "list", envir = envir, 
[11:41:52.093]                           inherits = FALSE)) {
[11:41:52.093]                           master <- get("master", mode = "list", 
[11:41:52.093]                             envir = envir, inherits = FALSE)
[11:41:52.093]                           if (inherits(master, c("SOCKnode", 
[11:41:52.093]                             "SOCK0node"))) {
[11:41:52.093]                             sendCondition <<- function(cond) {
[11:41:52.093]                               data <- list(type = "VALUE", value = cond, 
[11:41:52.093]                                 success = TRUE)
[11:41:52.093]                               parallel_sendData(master, data)
[11:41:52.093]                             }
[11:41:52.093]                             return(sendCondition)
[11:41:52.093]                           }
[11:41:52.093]                         }
[11:41:52.093]                         frame <- frame + 1L
[11:41:52.093]                         envir <- sys.frame(frame)
[11:41:52.093]                       }
[11:41:52.093]                     }
[11:41:52.093]                     sendCondition <<- function(cond) NULL
[11:41:52.093]                   }
[11:41:52.093]                 })
[11:41:52.093]                 withCallingHandlers({
[11:41:52.093]                   {
[11:41:52.093]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:52.093]                     if (!identical(...future.globals.maxSize.org, 
[11:41:52.093]                       ...future.globals.maxSize)) {
[11:41:52.093]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:52.093]                       on.exit(options(oopts), add = TRUE)
[11:41:52.093]                     }
[11:41:52.093]                     {
[11:41:52.093]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:52.093]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:52.093]                           envir = globalenv(), inherits = FALSE)
[11:41:52.093]                         ...future.FUN(...)
[11:41:52.093]                       }
[11:41:52.093]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:52.093]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:52.093]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:52.093]                         USE.NAMES = FALSE)
[11:41:52.093]                       do.call(mapply, args = args)
[11:41:52.093]                     }
[11:41:52.093]                   }
[11:41:52.093]                 }, immediateCondition = function(cond) {
[11:41:52.093]                   sendCondition <- ...future.makeSendCondition()
[11:41:52.093]                   sendCondition(cond)
[11:41:52.093]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:52.093]                   {
[11:41:52.093]                     inherits <- base::inherits
[11:41:52.093]                     invokeRestart <- base::invokeRestart
[11:41:52.093]                     is.null <- base::is.null
[11:41:52.093]                     muffled <- FALSE
[11:41:52.093]                     if (inherits(cond, "message")) {
[11:41:52.093]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:52.093]                       if (muffled) 
[11:41:52.093]                         invokeRestart("muffleMessage")
[11:41:52.093]                     }
[11:41:52.093]                     else if (inherits(cond, "warning")) {
[11:41:52.093]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:52.093]                       if (muffled) 
[11:41:52.093]                         invokeRestart("muffleWarning")
[11:41:52.093]                     }
[11:41:52.093]                     else if (inherits(cond, "condition")) {
[11:41:52.093]                       if (!is.null(pattern)) {
[11:41:52.093]                         computeRestarts <- base::computeRestarts
[11:41:52.093]                         grepl <- base::grepl
[11:41:52.093]                         restarts <- computeRestarts(cond)
[11:41:52.093]                         for (restart in restarts) {
[11:41:52.093]                           name <- restart$name
[11:41:52.093]                           if (is.null(name)) 
[11:41:52.093]                             next
[11:41:52.093]                           if (!grepl(pattern, name)) 
[11:41:52.093]                             next
[11:41:52.093]                           invokeRestart(restart)
[11:41:52.093]                           muffled <- TRUE
[11:41:52.093]                           break
[11:41:52.093]                         }
[11:41:52.093]                       }
[11:41:52.093]                     }
[11:41:52.093]                     invisible(muffled)
[11:41:52.093]                   }
[11:41:52.093]                   muffleCondition(cond)
[11:41:52.093]                 })
[11:41:52.093]             }))
[11:41:52.093]             future::FutureResult(value = ...future.value$value, 
[11:41:52.093]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:52.093]                   ...future.rng), globalenv = if (FALSE) 
[11:41:52.093]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:52.093]                     ...future.globalenv.names))
[11:41:52.093]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:52.093]         }, condition = base::local({
[11:41:52.093]             c <- base::c
[11:41:52.093]             inherits <- base::inherits
[11:41:52.093]             invokeRestart <- base::invokeRestart
[11:41:52.093]             length <- base::length
[11:41:52.093]             list <- base::list
[11:41:52.093]             seq.int <- base::seq.int
[11:41:52.093]             signalCondition <- base::signalCondition
[11:41:52.093]             sys.calls <- base::sys.calls
[11:41:52.093]             `[[` <- base::`[[`
[11:41:52.093]             `+` <- base::`+`
[11:41:52.093]             `<<-` <- base::`<<-`
[11:41:52.093]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:52.093]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:52.093]                   3L)]
[11:41:52.093]             }
[11:41:52.093]             function(cond) {
[11:41:52.093]                 is_error <- inherits(cond, "error")
[11:41:52.093]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:52.093]                   NULL)
[11:41:52.093]                 if (is_error) {
[11:41:52.093]                   sessionInformation <- function() {
[11:41:52.093]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:52.093]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:52.093]                       search = base::search(), system = base::Sys.info())
[11:41:52.093]                   }
[11:41:52.093]                   ...future.conditions[[length(...future.conditions) + 
[11:41:52.093]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:52.093]                     cond$call), session = sessionInformation(), 
[11:41:52.093]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:52.093]                   signalCondition(cond)
[11:41:52.093]                 }
[11:41:52.093]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:52.093]                 "immediateCondition"))) {
[11:41:52.093]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:52.093]                   ...future.conditions[[length(...future.conditions) + 
[11:41:52.093]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:52.093]                   if (TRUE && !signal) {
[11:41:52.093]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:52.093]                     {
[11:41:52.093]                       inherits <- base::inherits
[11:41:52.093]                       invokeRestart <- base::invokeRestart
[11:41:52.093]                       is.null <- base::is.null
[11:41:52.093]                       muffled <- FALSE
[11:41:52.093]                       if (inherits(cond, "message")) {
[11:41:52.093]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:52.093]                         if (muffled) 
[11:41:52.093]                           invokeRestart("muffleMessage")
[11:41:52.093]                       }
[11:41:52.093]                       else if (inherits(cond, "warning")) {
[11:41:52.093]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:52.093]                         if (muffled) 
[11:41:52.093]                           invokeRestart("muffleWarning")
[11:41:52.093]                       }
[11:41:52.093]                       else if (inherits(cond, "condition")) {
[11:41:52.093]                         if (!is.null(pattern)) {
[11:41:52.093]                           computeRestarts <- base::computeRestarts
[11:41:52.093]                           grepl <- base::grepl
[11:41:52.093]                           restarts <- computeRestarts(cond)
[11:41:52.093]                           for (restart in restarts) {
[11:41:52.093]                             name <- restart$name
[11:41:52.093]                             if (is.null(name)) 
[11:41:52.093]                               next
[11:41:52.093]                             if (!grepl(pattern, name)) 
[11:41:52.093]                               next
[11:41:52.093]                             invokeRestart(restart)
[11:41:52.093]                             muffled <- TRUE
[11:41:52.093]                             break
[11:41:52.093]                           }
[11:41:52.093]                         }
[11:41:52.093]                       }
[11:41:52.093]                       invisible(muffled)
[11:41:52.093]                     }
[11:41:52.093]                     muffleCondition(cond, pattern = "^muffle")
[11:41:52.093]                   }
[11:41:52.093]                 }
[11:41:52.093]                 else {
[11:41:52.093]                   if (TRUE) {
[11:41:52.093]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:52.093]                     {
[11:41:52.093]                       inherits <- base::inherits
[11:41:52.093]                       invokeRestart <- base::invokeRestart
[11:41:52.093]                       is.null <- base::is.null
[11:41:52.093]                       muffled <- FALSE
[11:41:52.093]                       if (inherits(cond, "message")) {
[11:41:52.093]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:52.093]                         if (muffled) 
[11:41:52.093]                           invokeRestart("muffleMessage")
[11:41:52.093]                       }
[11:41:52.093]                       else if (inherits(cond, "warning")) {
[11:41:52.093]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:52.093]                         if (muffled) 
[11:41:52.093]                           invokeRestart("muffleWarning")
[11:41:52.093]                       }
[11:41:52.093]                       else if (inherits(cond, "condition")) {
[11:41:52.093]                         if (!is.null(pattern)) {
[11:41:52.093]                           computeRestarts <- base::computeRestarts
[11:41:52.093]                           grepl <- base::grepl
[11:41:52.093]                           restarts <- computeRestarts(cond)
[11:41:52.093]                           for (restart in restarts) {
[11:41:52.093]                             name <- restart$name
[11:41:52.093]                             if (is.null(name)) 
[11:41:52.093]                               next
[11:41:52.093]                             if (!grepl(pattern, name)) 
[11:41:52.093]                               next
[11:41:52.093]                             invokeRestart(restart)
[11:41:52.093]                             muffled <- TRUE
[11:41:52.093]                             break
[11:41:52.093]                           }
[11:41:52.093]                         }
[11:41:52.093]                       }
[11:41:52.093]                       invisible(muffled)
[11:41:52.093]                     }
[11:41:52.093]                     muffleCondition(cond, pattern = "^muffle")
[11:41:52.093]                   }
[11:41:52.093]                 }
[11:41:52.093]             }
[11:41:52.093]         }))
[11:41:52.093]     }, error = function(ex) {
[11:41:52.093]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:52.093]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:52.093]                 ...future.rng), started = ...future.startTime, 
[11:41:52.093]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:52.093]             version = "1.8"), class = "FutureResult")
[11:41:52.093]     }, finally = {
[11:41:52.093]         if (!identical(...future.workdir, getwd())) 
[11:41:52.093]             setwd(...future.workdir)
[11:41:52.093]         {
[11:41:52.093]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:52.093]                 ...future.oldOptions$nwarnings <- NULL
[11:41:52.093]             }
[11:41:52.093]             base::options(...future.oldOptions)
[11:41:52.093]             if (.Platform$OS.type == "windows") {
[11:41:52.093]                 old_names <- names(...future.oldEnvVars)
[11:41:52.093]                 envs <- base::Sys.getenv()
[11:41:52.093]                 names <- names(envs)
[11:41:52.093]                 common <- intersect(names, old_names)
[11:41:52.093]                 added <- setdiff(names, old_names)
[11:41:52.093]                 removed <- setdiff(old_names, names)
[11:41:52.093]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:52.093]                   envs[common]]
[11:41:52.093]                 NAMES <- toupper(changed)
[11:41:52.093]                 args <- list()
[11:41:52.093]                 for (kk in seq_along(NAMES)) {
[11:41:52.093]                   name <- changed[[kk]]
[11:41:52.093]                   NAME <- NAMES[[kk]]
[11:41:52.093]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:52.093]                     next
[11:41:52.093]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:52.093]                 }
[11:41:52.093]                 NAMES <- toupper(added)
[11:41:52.093]                 for (kk in seq_along(NAMES)) {
[11:41:52.093]                   name <- added[[kk]]
[11:41:52.093]                   NAME <- NAMES[[kk]]
[11:41:52.093]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:52.093]                     next
[11:41:52.093]                   args[[name]] <- ""
[11:41:52.093]                 }
[11:41:52.093]                 NAMES <- toupper(removed)
[11:41:52.093]                 for (kk in seq_along(NAMES)) {
[11:41:52.093]                   name <- removed[[kk]]
[11:41:52.093]                   NAME <- NAMES[[kk]]
[11:41:52.093]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:52.093]                     next
[11:41:52.093]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:52.093]                 }
[11:41:52.093]                 if (length(args) > 0) 
[11:41:52.093]                   base::do.call(base::Sys.setenv, args = args)
[11:41:52.093]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:52.093]             }
[11:41:52.093]             else {
[11:41:52.093]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:52.093]             }
[11:41:52.093]             {
[11:41:52.093]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:52.093]                   0L) {
[11:41:52.093]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:52.093]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:52.093]                   base::options(opts)
[11:41:52.093]                 }
[11:41:52.093]                 {
[11:41:52.093]                   {
[11:41:52.093]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:52.093]                     NULL
[11:41:52.093]                   }
[11:41:52.093]                   options(future.plan = NULL)
[11:41:52.093]                   if (is.na(NA_character_)) 
[11:41:52.093]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:52.093]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:52.093]                   future::plan(list(function (..., workers = 2, 
[11:41:52.093]                     envir = parent.frame()) 
[11:41:52.093]                   strategy(..., workers = workers, envir = envir)), 
[11:41:52.093]                     .cleanup = FALSE, .init = FALSE)
[11:41:52.093]                 }
[11:41:52.093]             }
[11:41:52.093]         }
[11:41:52.093]     })
[11:41:52.093]     if (TRUE) {
[11:41:52.093]         base::sink(type = "output", split = FALSE)
[11:41:52.093]         if (TRUE) {
[11:41:52.093]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:52.093]         }
[11:41:52.093]         else {
[11:41:52.093]             ...future.result["stdout"] <- base::list(NULL)
[11:41:52.093]         }
[11:41:52.093]         base::close(...future.stdout)
[11:41:52.093]         ...future.stdout <- NULL
[11:41:52.093]     }
[11:41:52.093]     ...future.result$conditions <- ...future.conditions
[11:41:52.093]     ...future.result$finished <- base::Sys.time()
[11:41:52.093]     ...future.result
[11:41:52.093] }
[11:41:52.094] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:52.105] receiveMessageFromWorker() for ClusterFuture ...
[11:41:52.105] - Validating connection of MultisessionFuture
[11:41:52.106] - received message: FutureResult
[11:41:52.106] - Received FutureResult
[11:41:52.106] - Erased future from FutureRegistry
[11:41:52.106] result() for ClusterFuture ...
[11:41:52.106] - result already collected: FutureResult
[11:41:52.106] result() for ClusterFuture ... done
[11:41:52.106] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:52.106] result() for ClusterFuture ...
[11:41:52.106] - result already collected: FutureResult
[11:41:52.106] result() for ClusterFuture ... done
[11:41:52.106] result() for ClusterFuture ...
[11:41:52.106] - result already collected: FutureResult
[11:41:52.106] result() for ClusterFuture ... done
[11:41:52.107] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:52.107] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:52.150] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:52.155] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:52.202] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:52.202] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:52.246] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:52.247] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:52.248] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:52.249] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:52.250] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:52.250] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:52.251] MultisessionFuture started
[11:41:52.252] - Launch lazy future ... done
[11:41:52.252] run() for ‘MultisessionFuture’ ... done
[11:41:52.252] Created future:
[11:41:52.252] MultisessionFuture:
[11:41:52.252] Label: ‘future_mapply-35’
[11:41:52.252] Expression:
[11:41:52.252] {
[11:41:52.252]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:52.252]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:52.252]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:52.252]         on.exit(options(oopts), add = TRUE)
[11:41:52.252]     }
[11:41:52.252]     {
[11:41:52.252]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:52.252]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:52.252]                 inherits = FALSE)
[11:41:52.252]             ...future.FUN(...)
[11:41:52.252]         }
[11:41:52.252]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:52.252]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:52.252]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:52.252]         do.call(mapply, args = args)
[11:41:52.252]     }
[11:41:52.252] }
[11:41:52.252] Lazy evaluation: FALSE
[11:41:52.252] Asynchronous evaluation: TRUE
[11:41:52.252] Local evaluation: TRUE
[11:41:52.252] Environment: 0x560ef58e1768
[11:41:52.252] Capture standard output: TRUE
[11:41:52.252] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:52.252] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:52.252] Packages: 1 packages (‘mlr3’)
[11:41:52.252] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:52.252] Resolved: FALSE
[11:41:52.252] Value: <not collected>
[11:41:52.252] Conditions captured: <none>
[11:41:52.252] Early signaling: FALSE
[11:41:52.252] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:52.252] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:52.269] Chunk #35 of 90 ... DONE
[11:41:52.269] Chunk #36 of 90 ...
[11:41:52.269]  - seeds: [1] <seeds>
[11:41:52.269] getGlobalsAndPackages() ...
[11:41:52.269] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:52.270] Resolving globals: FALSE
[11:41:52.270] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:52.270] - packages: [1] ‘mlr3’
[11:41:52.270] getGlobalsAndPackages() ... DONE
[11:41:52.271] run() for ‘Future’ ...
[11:41:52.271] - state: ‘created’
[11:41:52.271] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:52.280] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:52.281] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:52.281]   - Field: ‘node’
[11:41:52.281]   - Field: ‘label’
[11:41:52.281]   - Field: ‘local’
[11:41:52.281]   - Field: ‘owner’
[11:41:52.281]   - Field: ‘envir’
[11:41:52.281]   - Field: ‘workers’
[11:41:52.281]   - Field: ‘packages’
[11:41:52.281]   - Field: ‘gc’
[11:41:52.281]   - Field: ‘conditions’
[11:41:52.281]   - Field: ‘persistent’
[11:41:52.281]   - Field: ‘expr’
[11:41:52.281]   - Field: ‘uuid’
[11:41:52.281]   - Field: ‘seed’
[11:41:52.281]   - Field: ‘version’
[11:41:52.281]   - Field: ‘result’
[11:41:52.281]   - Field: ‘asynchronous’
[11:41:52.281]   - Field: ‘calls’
[11:41:52.282]   - Field: ‘globals’
[11:41:52.282]   - Field: ‘stdout’
[11:41:52.282]   - Field: ‘earlySignal’
[11:41:52.282]   - Field: ‘lazy’
[11:41:52.282]   - Field: ‘state’
[11:41:52.282] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:52.282] - Launch lazy future ...
[11:41:52.282] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:52.282] Packages needed by future strategies (n = 0): <none>
[11:41:52.282] {
[11:41:52.282]     {
[11:41:52.282]         {
[11:41:52.282]             ...future.startTime <- base::Sys.time()
[11:41:52.282]             {
[11:41:52.282]                 {
[11:41:52.282]                   {
[11:41:52.282]                     {
[11:41:52.282]                       {
[11:41:52.282]                         base::local({
[11:41:52.282]                           has_future <- base::requireNamespace("future", 
[11:41:52.282]                             quietly = TRUE)
[11:41:52.282]                           if (has_future) {
[11:41:52.282]                             ns <- base::getNamespace("future")
[11:41:52.282]                             version <- ns[[".package"]][["version"]]
[11:41:52.282]                             if (is.null(version)) 
[11:41:52.282]                               version <- utils::packageVersion("future")
[11:41:52.282]                           }
[11:41:52.282]                           else {
[11:41:52.282]                             version <- NULL
[11:41:52.282]                           }
[11:41:52.282]                           if (!has_future || version < "1.8.0") {
[11:41:52.282]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:52.282]                               "", base::R.version$version.string), 
[11:41:52.282]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:52.282]                                 base::R.version$platform, 8 * 
[11:41:52.282]                                   base::.Machine$sizeof.pointer), 
[11:41:52.282]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:52.282]                                 "release", "version")], collapse = " "), 
[11:41:52.282]                               hostname = base::Sys.info()[["nodename"]])
[11:41:52.282]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:52.282]                               info)
[11:41:52.282]                             info <- base::paste(info, collapse = "; ")
[11:41:52.282]                             if (!has_future) {
[11:41:52.282]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:52.282]                                 info)
[11:41:52.282]                             }
[11:41:52.282]                             else {
[11:41:52.282]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:52.282]                                 info, version)
[11:41:52.282]                             }
[11:41:52.282]                             base::stop(msg)
[11:41:52.282]                           }
[11:41:52.282]                         })
[11:41:52.282]                       }
[11:41:52.282]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:52.282]                       base::options(mc.cores = 1L)
[11:41:52.282]                     }
[11:41:52.282]                     base::local({
[11:41:52.282]                       for (pkg in "mlr3") {
[11:41:52.282]                         base::loadNamespace(pkg)
[11:41:52.282]                         base::library(pkg, character.only = TRUE)
[11:41:52.282]                       }
[11:41:52.282]                     })
[11:41:52.282]                   }
[11:41:52.282]                   options(future.plan = NULL)
[11:41:52.282]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:52.282]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:52.282]                 }
[11:41:52.282]                 ...future.workdir <- getwd()
[11:41:52.282]             }
[11:41:52.282]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:52.282]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:52.282]         }
[11:41:52.282]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:52.282]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:52.282]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:52.282]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:52.282]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:52.282]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:52.282]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:52.282]             base::names(...future.oldOptions))
[11:41:52.282]     }
[11:41:52.282]     if (FALSE) {
[11:41:52.282]     }
[11:41:52.282]     else {
[11:41:52.282]         if (TRUE) {
[11:41:52.282]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:52.282]                 open = "w")
[11:41:52.282]         }
[11:41:52.282]         else {
[11:41:52.282]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:52.282]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:52.282]         }
[11:41:52.282]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:52.282]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:52.282]             base::sink(type = "output", split = FALSE)
[11:41:52.282]             base::close(...future.stdout)
[11:41:52.282]         }, add = TRUE)
[11:41:52.282]     }
[11:41:52.282]     ...future.frame <- base::sys.nframe()
[11:41:52.282]     ...future.conditions <- base::list()
[11:41:52.282]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:52.282]     if (FALSE) {
[11:41:52.282]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:52.282]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:52.282]     }
[11:41:52.282]     ...future.result <- base::tryCatch({
[11:41:52.282]         base::withCallingHandlers({
[11:41:52.282]             ...future.value <- base::withVisible(base::local({
[11:41:52.282]                 ...future.makeSendCondition <- local({
[11:41:52.282]                   sendCondition <- NULL
[11:41:52.282]                   function(frame = 1L) {
[11:41:52.282]                     if (is.function(sendCondition)) 
[11:41:52.282]                       return(sendCondition)
[11:41:52.282]                     ns <- getNamespace("parallel")
[11:41:52.282]                     if (exists("sendData", mode = "function", 
[11:41:52.282]                       envir = ns)) {
[11:41:52.282]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:52.282]                         envir = ns)
[11:41:52.282]                       envir <- sys.frame(frame)
[11:41:52.282]                       master <- NULL
[11:41:52.282]                       while (!identical(envir, .GlobalEnv) && 
[11:41:52.282]                         !identical(envir, emptyenv())) {
[11:41:52.282]                         if (exists("master", mode = "list", envir = envir, 
[11:41:52.282]                           inherits = FALSE)) {
[11:41:52.282]                           master <- get("master", mode = "list", 
[11:41:52.282]                             envir = envir, inherits = FALSE)
[11:41:52.282]                           if (inherits(master, c("SOCKnode", 
[11:41:52.282]                             "SOCK0node"))) {
[11:41:52.282]                             sendCondition <<- function(cond) {
[11:41:52.282]                               data <- list(type = "VALUE", value = cond, 
[11:41:52.282]                                 success = TRUE)
[11:41:52.282]                               parallel_sendData(master, data)
[11:41:52.282]                             }
[11:41:52.282]                             return(sendCondition)
[11:41:52.282]                           }
[11:41:52.282]                         }
[11:41:52.282]                         frame <- frame + 1L
[11:41:52.282]                         envir <- sys.frame(frame)
[11:41:52.282]                       }
[11:41:52.282]                     }
[11:41:52.282]                     sendCondition <<- function(cond) NULL
[11:41:52.282]                   }
[11:41:52.282]                 })
[11:41:52.282]                 withCallingHandlers({
[11:41:52.282]                   {
[11:41:52.282]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:52.282]                     if (!identical(...future.globals.maxSize.org, 
[11:41:52.282]                       ...future.globals.maxSize)) {
[11:41:52.282]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:52.282]                       on.exit(options(oopts), add = TRUE)
[11:41:52.282]                     }
[11:41:52.282]                     {
[11:41:52.282]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:52.282]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:52.282]                           envir = globalenv(), inherits = FALSE)
[11:41:52.282]                         ...future.FUN(...)
[11:41:52.282]                       }
[11:41:52.282]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:52.282]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:52.282]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:52.282]                         USE.NAMES = FALSE)
[11:41:52.282]                       do.call(mapply, args = args)
[11:41:52.282]                     }
[11:41:52.282]                   }
[11:41:52.282]                 }, immediateCondition = function(cond) {
[11:41:52.282]                   sendCondition <- ...future.makeSendCondition()
[11:41:52.282]                   sendCondition(cond)
[11:41:52.282]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:52.282]                   {
[11:41:52.282]                     inherits <- base::inherits
[11:41:52.282]                     invokeRestart <- base::invokeRestart
[11:41:52.282]                     is.null <- base::is.null
[11:41:52.282]                     muffled <- FALSE
[11:41:52.282]                     if (inherits(cond, "message")) {
[11:41:52.282]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:52.282]                       if (muffled) 
[11:41:52.282]                         invokeRestart("muffleMessage")
[11:41:52.282]                     }
[11:41:52.282]                     else if (inherits(cond, "warning")) {
[11:41:52.282]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:52.282]                       if (muffled) 
[11:41:52.282]                         invokeRestart("muffleWarning")
[11:41:52.282]                     }
[11:41:52.282]                     else if (inherits(cond, "condition")) {
[11:41:52.282]                       if (!is.null(pattern)) {
[11:41:52.282]                         computeRestarts <- base::computeRestarts
[11:41:52.282]                         grepl <- base::grepl
[11:41:52.282]                         restarts <- computeRestarts(cond)
[11:41:52.282]                         for (restart in restarts) {
[11:41:52.282]                           name <- restart$name
[11:41:52.282]                           if (is.null(name)) 
[11:41:52.282]                             next
[11:41:52.282]                           if (!grepl(pattern, name)) 
[11:41:52.282]                             next
[11:41:52.282]                           invokeRestart(restart)
[11:41:52.282]                           muffled <- TRUE
[11:41:52.282]                           break
[11:41:52.282]                         }
[11:41:52.282]                       }
[11:41:52.282]                     }
[11:41:52.282]                     invisible(muffled)
[11:41:52.282]                   }
[11:41:52.282]                   muffleCondition(cond)
[11:41:52.282]                 })
[11:41:52.282]             }))
[11:41:52.282]             future::FutureResult(value = ...future.value$value, 
[11:41:52.282]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:52.282]                   ...future.rng), globalenv = if (FALSE) 
[11:41:52.282]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:52.282]                     ...future.globalenv.names))
[11:41:52.282]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:52.282]         }, condition = base::local({
[11:41:52.282]             c <- base::c
[11:41:52.282]             inherits <- base::inherits
[11:41:52.282]             invokeRestart <- base::invokeRestart
[11:41:52.282]             length <- base::length
[11:41:52.282]             list <- base::list
[11:41:52.282]             seq.int <- base::seq.int
[11:41:52.282]             signalCondition <- base::signalCondition
[11:41:52.282]             sys.calls <- base::sys.calls
[11:41:52.282]             `[[` <- base::`[[`
[11:41:52.282]             `+` <- base::`+`
[11:41:52.282]             `<<-` <- base::`<<-`
[11:41:52.282]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:52.282]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:52.282]                   3L)]
[11:41:52.282]             }
[11:41:52.282]             function(cond) {
[11:41:52.282]                 is_error <- inherits(cond, "error")
[11:41:52.282]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:52.282]                   NULL)
[11:41:52.282]                 if (is_error) {
[11:41:52.282]                   sessionInformation <- function() {
[11:41:52.282]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:52.282]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:52.282]                       search = base::search(), system = base::Sys.info())
[11:41:52.282]                   }
[11:41:52.282]                   ...future.conditions[[length(...future.conditions) + 
[11:41:52.282]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:52.282]                     cond$call), session = sessionInformation(), 
[11:41:52.282]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:52.282]                   signalCondition(cond)
[11:41:52.282]                 }
[11:41:52.282]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:52.282]                 "immediateCondition"))) {
[11:41:52.282]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:52.282]                   ...future.conditions[[length(...future.conditions) + 
[11:41:52.282]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:52.282]                   if (TRUE && !signal) {
[11:41:52.282]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:52.282]                     {
[11:41:52.282]                       inherits <- base::inherits
[11:41:52.282]                       invokeRestart <- base::invokeRestart
[11:41:52.282]                       is.null <- base::is.null
[11:41:52.282]                       muffled <- FALSE
[11:41:52.282]                       if (inherits(cond, "message")) {
[11:41:52.282]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:52.282]                         if (muffled) 
[11:41:52.282]                           invokeRestart("muffleMessage")
[11:41:52.282]                       }
[11:41:52.282]                       else if (inherits(cond, "warning")) {
[11:41:52.282]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:52.282]                         if (muffled) 
[11:41:52.282]                           invokeRestart("muffleWarning")
[11:41:52.282]                       }
[11:41:52.282]                       else if (inherits(cond, "condition")) {
[11:41:52.282]                         if (!is.null(pattern)) {
[11:41:52.282]                           computeRestarts <- base::computeRestarts
[11:41:52.282]                           grepl <- base::grepl
[11:41:52.282]                           restarts <- computeRestarts(cond)
[11:41:52.282]                           for (restart in restarts) {
[11:41:52.282]                             name <- restart$name
[11:41:52.282]                             if (is.null(name)) 
[11:41:52.282]                               next
[11:41:52.282]                             if (!grepl(pattern, name)) 
[11:41:52.282]                               next
[11:41:52.282]                             invokeRestart(restart)
[11:41:52.282]                             muffled <- TRUE
[11:41:52.282]                             break
[11:41:52.282]                           }
[11:41:52.282]                         }
[11:41:52.282]                       }
[11:41:52.282]                       invisible(muffled)
[11:41:52.282]                     }
[11:41:52.282]                     muffleCondition(cond, pattern = "^muffle")
[11:41:52.282]                   }
[11:41:52.282]                 }
[11:41:52.282]                 else {
[11:41:52.282]                   if (TRUE) {
[11:41:52.282]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:52.282]                     {
[11:41:52.282]                       inherits <- base::inherits
[11:41:52.282]                       invokeRestart <- base::invokeRestart
[11:41:52.282]                       is.null <- base::is.null
[11:41:52.282]                       muffled <- FALSE
[11:41:52.282]                       if (inherits(cond, "message")) {
[11:41:52.282]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:52.282]                         if (muffled) 
[11:41:52.282]                           invokeRestart("muffleMessage")
[11:41:52.282]                       }
[11:41:52.282]                       else if (inherits(cond, "warning")) {
[11:41:52.282]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:52.282]                         if (muffled) 
[11:41:52.282]                           invokeRestart("muffleWarning")
[11:41:52.282]                       }
[11:41:52.282]                       else if (inherits(cond, "condition")) {
[11:41:52.282]                         if (!is.null(pattern)) {
[11:41:52.282]                           computeRestarts <- base::computeRestarts
[11:41:52.282]                           grepl <- base::grepl
[11:41:52.282]                           restarts <- computeRestarts(cond)
[11:41:52.282]                           for (restart in restarts) {
[11:41:52.282]                             name <- restart$name
[11:41:52.282]                             if (is.null(name)) 
[11:41:52.282]                               next
[11:41:52.282]                             if (!grepl(pattern, name)) 
[11:41:52.282]                               next
[11:41:52.282]                             invokeRestart(restart)
[11:41:52.282]                             muffled <- TRUE
[11:41:52.282]                             break
[11:41:52.282]                           }
[11:41:52.282]                         }
[11:41:52.282]                       }
[11:41:52.282]                       invisible(muffled)
[11:41:52.282]                     }
[11:41:52.282]                     muffleCondition(cond, pattern = "^muffle")
[11:41:52.282]                   }
[11:41:52.282]                 }
[11:41:52.282]             }
[11:41:52.282]         }))
[11:41:52.282]     }, error = function(ex) {
[11:41:52.282]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:52.282]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:52.282]                 ...future.rng), started = ...future.startTime, 
[11:41:52.282]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:52.282]             version = "1.8"), class = "FutureResult")
[11:41:52.282]     }, finally = {
[11:41:52.282]         if (!identical(...future.workdir, getwd())) 
[11:41:52.282]             setwd(...future.workdir)
[11:41:52.282]         {
[11:41:52.282]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:52.282]                 ...future.oldOptions$nwarnings <- NULL
[11:41:52.282]             }
[11:41:52.282]             base::options(...future.oldOptions)
[11:41:52.282]             if (.Platform$OS.type == "windows") {
[11:41:52.282]                 old_names <- names(...future.oldEnvVars)
[11:41:52.282]                 envs <- base::Sys.getenv()
[11:41:52.282]                 names <- names(envs)
[11:41:52.282]                 common <- intersect(names, old_names)
[11:41:52.282]                 added <- setdiff(names, old_names)
[11:41:52.282]                 removed <- setdiff(old_names, names)
[11:41:52.282]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:52.282]                   envs[common]]
[11:41:52.282]                 NAMES <- toupper(changed)
[11:41:52.282]                 args <- list()
[11:41:52.282]                 for (kk in seq_along(NAMES)) {
[11:41:52.282]                   name <- changed[[kk]]
[11:41:52.282]                   NAME <- NAMES[[kk]]
[11:41:52.282]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:52.282]                     next
[11:41:52.282]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:52.282]                 }
[11:41:52.282]                 NAMES <- toupper(added)
[11:41:52.282]                 for (kk in seq_along(NAMES)) {
[11:41:52.282]                   name <- added[[kk]]
[11:41:52.282]                   NAME <- NAMES[[kk]]
[11:41:52.282]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:52.282]                     next
[11:41:52.282]                   args[[name]] <- ""
[11:41:52.282]                 }
[11:41:52.282]                 NAMES <- toupper(removed)
[11:41:52.282]                 for (kk in seq_along(NAMES)) {
[11:41:52.282]                   name <- removed[[kk]]
[11:41:52.282]                   NAME <- NAMES[[kk]]
[11:41:52.282]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:52.282]                     next
[11:41:52.282]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:52.282]                 }
[11:41:52.282]                 if (length(args) > 0) 
[11:41:52.282]                   base::do.call(base::Sys.setenv, args = args)
[11:41:52.282]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:52.282]             }
[11:41:52.282]             else {
[11:41:52.282]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:52.282]             }
[11:41:52.282]             {
[11:41:52.282]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:52.282]                   0L) {
[11:41:52.282]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:52.282]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:52.282]                   base::options(opts)
[11:41:52.282]                 }
[11:41:52.282]                 {
[11:41:52.282]                   {
[11:41:52.282]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:52.282]                     NULL
[11:41:52.282]                   }
[11:41:52.282]                   options(future.plan = NULL)
[11:41:52.282]                   if (is.na(NA_character_)) 
[11:41:52.282]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:52.282]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:52.282]                   future::plan(list(function (..., workers = 2, 
[11:41:52.282]                     envir = parent.frame()) 
[11:41:52.282]                   strategy(..., workers = workers, envir = envir)), 
[11:41:52.282]                     .cleanup = FALSE, .init = FALSE)
[11:41:52.282]                 }
[11:41:52.282]             }
[11:41:52.282]         }
[11:41:52.282]     })
[11:41:52.282]     if (TRUE) {
[11:41:52.282]         base::sink(type = "output", split = FALSE)
[11:41:52.282]         if (TRUE) {
[11:41:52.282]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:52.282]         }
[11:41:52.282]         else {
[11:41:52.282]             ...future.result["stdout"] <- base::list(NULL)
[11:41:52.282]         }
[11:41:52.282]         base::close(...future.stdout)
[11:41:52.282]         ...future.stdout <- NULL
[11:41:52.282]     }
[11:41:52.282]     ...future.result$conditions <- ...future.conditions
[11:41:52.282]     ...future.result$finished <- base::Sys.time()
[11:41:52.282]     ...future.result
[11:41:52.282] }
[11:41:52.284] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:52.295] receiveMessageFromWorker() for ClusterFuture ...
[11:41:52.295] - Validating connection of MultisessionFuture
[11:41:52.298] - received message: FutureResult
[11:41:52.299] - Received FutureResult
[11:41:52.299] - Erased future from FutureRegistry
[11:41:52.299] result() for ClusterFuture ...
[11:41:52.299] - result already collected: FutureResult
[11:41:52.299] result() for ClusterFuture ... done
[11:41:52.299] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:52.299] result() for ClusterFuture ...
[11:41:52.299] - result already collected: FutureResult
[11:41:52.299] result() for ClusterFuture ... done
[11:41:52.299] result() for ClusterFuture ...
[11:41:52.299] - result already collected: FutureResult
[11:41:52.299] result() for ClusterFuture ... done
[11:41:52.300] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:52.300] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:52.341] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:52.347] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:52.390] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:52.391] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:52.439] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:52.440] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:52.441] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:52.442] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:52.444] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:52.444] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:52.446] MultisessionFuture started
[11:41:52.446] - Launch lazy future ... done
[11:41:52.446] run() for ‘MultisessionFuture’ ... done
[11:41:52.447] Created future:
[11:41:52.447] MultisessionFuture:
[11:41:52.447] Label: ‘future_mapply-36’
[11:41:52.447] Expression:
[11:41:52.447] {
[11:41:52.447]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:52.447]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:52.447]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:52.447]         on.exit(options(oopts), add = TRUE)
[11:41:52.447]     }
[11:41:52.447]     {
[11:41:52.447]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:52.447]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:52.447]                 inherits = FALSE)
[11:41:52.447]             ...future.FUN(...)
[11:41:52.447]         }
[11:41:52.447]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:52.447]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:52.447]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:52.447]         do.call(mapply, args = args)
[11:41:52.447]     }
[11:41:52.447] }
[11:41:52.447] Lazy evaluation: FALSE
[11:41:52.447] Asynchronous evaluation: TRUE
[11:41:52.447] Local evaluation: TRUE
[11:41:52.447] Environment: 0x560ef58e1768
[11:41:52.447] Capture standard output: TRUE
[11:41:52.447] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:52.447] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:52.447] Packages: 1 packages (‘mlr3’)
[11:41:52.447] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:52.447] Resolved: FALSE
[11:41:52.447] Value: <not collected>
[11:41:52.447] Conditions captured: <none>
[11:41:52.447] Early signaling: FALSE
[11:41:52.447] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:52.447] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:52.465] Chunk #36 of 90 ... DONE
[11:41:52.465] Chunk #37 of 90 ...
[11:41:52.465]  - seeds: [1] <seeds>
[11:41:52.466] getGlobalsAndPackages() ...
[11:41:52.466] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:52.466] Resolving globals: FALSE
[11:41:52.466] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:52.467] - packages: [1] ‘mlr3’
[11:41:52.467] getGlobalsAndPackages() ... DONE
[11:41:52.467] run() for ‘Future’ ...
[11:41:52.467] - state: ‘created’
[11:41:52.467] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:52.476] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:52.477] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:52.477]   - Field: ‘node’
[11:41:52.477]   - Field: ‘label’
[11:41:52.477]   - Field: ‘local’
[11:41:52.477]   - Field: ‘owner’
[11:41:52.477]   - Field: ‘envir’
[11:41:52.477]   - Field: ‘workers’
[11:41:52.477]   - Field: ‘packages’
[11:41:52.477]   - Field: ‘gc’
[11:41:52.477]   - Field: ‘conditions’
[11:41:52.477]   - Field: ‘persistent’
[11:41:52.477]   - Field: ‘expr’
[11:41:52.477]   - Field: ‘uuid’
[11:41:52.477]   - Field: ‘seed’
[11:41:52.477]   - Field: ‘version’
[11:41:52.477]   - Field: ‘result’
[11:41:52.477]   - Field: ‘asynchronous’
[11:41:52.478]   - Field: ‘calls’
[11:41:52.478]   - Field: ‘globals’
[11:41:52.478]   - Field: ‘stdout’
[11:41:52.478]   - Field: ‘earlySignal’
[11:41:52.478]   - Field: ‘lazy’
[11:41:52.478]   - Field: ‘state’
[11:41:52.478] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:52.478] - Launch lazy future ...
[11:41:52.478] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:52.478] Packages needed by future strategies (n = 0): <none>
[11:41:52.478] {
[11:41:52.478]     {
[11:41:52.478]         {
[11:41:52.478]             ...future.startTime <- base::Sys.time()
[11:41:52.478]             {
[11:41:52.478]                 {
[11:41:52.478]                   {
[11:41:52.478]                     {
[11:41:52.478]                       {
[11:41:52.478]                         base::local({
[11:41:52.478]                           has_future <- base::requireNamespace("future", 
[11:41:52.478]                             quietly = TRUE)
[11:41:52.478]                           if (has_future) {
[11:41:52.478]                             ns <- base::getNamespace("future")
[11:41:52.478]                             version <- ns[[".package"]][["version"]]
[11:41:52.478]                             if (is.null(version)) 
[11:41:52.478]                               version <- utils::packageVersion("future")
[11:41:52.478]                           }
[11:41:52.478]                           else {
[11:41:52.478]                             version <- NULL
[11:41:52.478]                           }
[11:41:52.478]                           if (!has_future || version < "1.8.0") {
[11:41:52.478]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:52.478]                               "", base::R.version$version.string), 
[11:41:52.478]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:52.478]                                 base::R.version$platform, 8 * 
[11:41:52.478]                                   base::.Machine$sizeof.pointer), 
[11:41:52.478]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:52.478]                                 "release", "version")], collapse = " "), 
[11:41:52.478]                               hostname = base::Sys.info()[["nodename"]])
[11:41:52.478]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:52.478]                               info)
[11:41:52.478]                             info <- base::paste(info, collapse = "; ")
[11:41:52.478]                             if (!has_future) {
[11:41:52.478]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:52.478]                                 info)
[11:41:52.478]                             }
[11:41:52.478]                             else {
[11:41:52.478]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:52.478]                                 info, version)
[11:41:52.478]                             }
[11:41:52.478]                             base::stop(msg)
[11:41:52.478]                           }
[11:41:52.478]                         })
[11:41:52.478]                       }
[11:41:52.478]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:52.478]                       base::options(mc.cores = 1L)
[11:41:52.478]                     }
[11:41:52.478]                     base::local({
[11:41:52.478]                       for (pkg in "mlr3") {
[11:41:52.478]                         base::loadNamespace(pkg)
[11:41:52.478]                         base::library(pkg, character.only = TRUE)
[11:41:52.478]                       }
[11:41:52.478]                     })
[11:41:52.478]                   }
[11:41:52.478]                   options(future.plan = NULL)
[11:41:52.478]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:52.478]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:52.478]                 }
[11:41:52.478]                 ...future.workdir <- getwd()
[11:41:52.478]             }
[11:41:52.478]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:52.478]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:52.478]         }
[11:41:52.478]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:52.478]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:52.478]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:52.478]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:52.478]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:52.478]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:52.478]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:52.478]             base::names(...future.oldOptions))
[11:41:52.478]     }
[11:41:52.478]     if (FALSE) {
[11:41:52.478]     }
[11:41:52.478]     else {
[11:41:52.478]         if (TRUE) {
[11:41:52.478]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:52.478]                 open = "w")
[11:41:52.478]         }
[11:41:52.478]         else {
[11:41:52.478]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:52.478]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:52.478]         }
[11:41:52.478]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:52.478]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:52.478]             base::sink(type = "output", split = FALSE)
[11:41:52.478]             base::close(...future.stdout)
[11:41:52.478]         }, add = TRUE)
[11:41:52.478]     }
[11:41:52.478]     ...future.frame <- base::sys.nframe()
[11:41:52.478]     ...future.conditions <- base::list()
[11:41:52.478]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:52.478]     if (FALSE) {
[11:41:52.478]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:52.478]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:52.478]     }
[11:41:52.478]     ...future.result <- base::tryCatch({
[11:41:52.478]         base::withCallingHandlers({
[11:41:52.478]             ...future.value <- base::withVisible(base::local({
[11:41:52.478]                 ...future.makeSendCondition <- local({
[11:41:52.478]                   sendCondition <- NULL
[11:41:52.478]                   function(frame = 1L) {
[11:41:52.478]                     if (is.function(sendCondition)) 
[11:41:52.478]                       return(sendCondition)
[11:41:52.478]                     ns <- getNamespace("parallel")
[11:41:52.478]                     if (exists("sendData", mode = "function", 
[11:41:52.478]                       envir = ns)) {
[11:41:52.478]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:52.478]                         envir = ns)
[11:41:52.478]                       envir <- sys.frame(frame)
[11:41:52.478]                       master <- NULL
[11:41:52.478]                       while (!identical(envir, .GlobalEnv) && 
[11:41:52.478]                         !identical(envir, emptyenv())) {
[11:41:52.478]                         if (exists("master", mode = "list", envir = envir, 
[11:41:52.478]                           inherits = FALSE)) {
[11:41:52.478]                           master <- get("master", mode = "list", 
[11:41:52.478]                             envir = envir, inherits = FALSE)
[11:41:52.478]                           if (inherits(master, c("SOCKnode", 
[11:41:52.478]                             "SOCK0node"))) {
[11:41:52.478]                             sendCondition <<- function(cond) {
[11:41:52.478]                               data <- list(type = "VALUE", value = cond, 
[11:41:52.478]                                 success = TRUE)
[11:41:52.478]                               parallel_sendData(master, data)
[11:41:52.478]                             }
[11:41:52.478]                             return(sendCondition)
[11:41:52.478]                           }
[11:41:52.478]                         }
[11:41:52.478]                         frame <- frame + 1L
[11:41:52.478]                         envir <- sys.frame(frame)
[11:41:52.478]                       }
[11:41:52.478]                     }
[11:41:52.478]                     sendCondition <<- function(cond) NULL
[11:41:52.478]                   }
[11:41:52.478]                 })
[11:41:52.478]                 withCallingHandlers({
[11:41:52.478]                   {
[11:41:52.478]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:52.478]                     if (!identical(...future.globals.maxSize.org, 
[11:41:52.478]                       ...future.globals.maxSize)) {
[11:41:52.478]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:52.478]                       on.exit(options(oopts), add = TRUE)
[11:41:52.478]                     }
[11:41:52.478]                     {
[11:41:52.478]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:52.478]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:52.478]                           envir = globalenv(), inherits = FALSE)
[11:41:52.478]                         ...future.FUN(...)
[11:41:52.478]                       }
[11:41:52.478]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:52.478]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:52.478]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:52.478]                         USE.NAMES = FALSE)
[11:41:52.478]                       do.call(mapply, args = args)
[11:41:52.478]                     }
[11:41:52.478]                   }
[11:41:52.478]                 }, immediateCondition = function(cond) {
[11:41:52.478]                   sendCondition <- ...future.makeSendCondition()
[11:41:52.478]                   sendCondition(cond)
[11:41:52.478]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:52.478]                   {
[11:41:52.478]                     inherits <- base::inherits
[11:41:52.478]                     invokeRestart <- base::invokeRestart
[11:41:52.478]                     is.null <- base::is.null
[11:41:52.478]                     muffled <- FALSE
[11:41:52.478]                     if (inherits(cond, "message")) {
[11:41:52.478]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:52.478]                       if (muffled) 
[11:41:52.478]                         invokeRestart("muffleMessage")
[11:41:52.478]                     }
[11:41:52.478]                     else if (inherits(cond, "warning")) {
[11:41:52.478]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:52.478]                       if (muffled) 
[11:41:52.478]                         invokeRestart("muffleWarning")
[11:41:52.478]                     }
[11:41:52.478]                     else if (inherits(cond, "condition")) {
[11:41:52.478]                       if (!is.null(pattern)) {
[11:41:52.478]                         computeRestarts <- base::computeRestarts
[11:41:52.478]                         grepl <- base::grepl
[11:41:52.478]                         restarts <- computeRestarts(cond)
[11:41:52.478]                         for (restart in restarts) {
[11:41:52.478]                           name <- restart$name
[11:41:52.478]                           if (is.null(name)) 
[11:41:52.478]                             next
[11:41:52.478]                           if (!grepl(pattern, name)) 
[11:41:52.478]                             next
[11:41:52.478]                           invokeRestart(restart)
[11:41:52.478]                           muffled <- TRUE
[11:41:52.478]                           break
[11:41:52.478]                         }
[11:41:52.478]                       }
[11:41:52.478]                     }
[11:41:52.478]                     invisible(muffled)
[11:41:52.478]                   }
[11:41:52.478]                   muffleCondition(cond)
[11:41:52.478]                 })
[11:41:52.478]             }))
[11:41:52.478]             future::FutureResult(value = ...future.value$value, 
[11:41:52.478]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:52.478]                   ...future.rng), globalenv = if (FALSE) 
[11:41:52.478]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:52.478]                     ...future.globalenv.names))
[11:41:52.478]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:52.478]         }, condition = base::local({
[11:41:52.478]             c <- base::c
[11:41:52.478]             inherits <- base::inherits
[11:41:52.478]             invokeRestart <- base::invokeRestart
[11:41:52.478]             length <- base::length
[11:41:52.478]             list <- base::list
[11:41:52.478]             seq.int <- base::seq.int
[11:41:52.478]             signalCondition <- base::signalCondition
[11:41:52.478]             sys.calls <- base::sys.calls
[11:41:52.478]             `[[` <- base::`[[`
[11:41:52.478]             `+` <- base::`+`
[11:41:52.478]             `<<-` <- base::`<<-`
[11:41:52.478]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:52.478]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:52.478]                   3L)]
[11:41:52.478]             }
[11:41:52.478]             function(cond) {
[11:41:52.478]                 is_error <- inherits(cond, "error")
[11:41:52.478]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:52.478]                   NULL)
[11:41:52.478]                 if (is_error) {
[11:41:52.478]                   sessionInformation <- function() {
[11:41:52.478]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:52.478]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:52.478]                       search = base::search(), system = base::Sys.info())
[11:41:52.478]                   }
[11:41:52.478]                   ...future.conditions[[length(...future.conditions) + 
[11:41:52.478]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:52.478]                     cond$call), session = sessionInformation(), 
[11:41:52.478]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:52.478]                   signalCondition(cond)
[11:41:52.478]                 }
[11:41:52.478]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:52.478]                 "immediateCondition"))) {
[11:41:52.478]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:52.478]                   ...future.conditions[[length(...future.conditions) + 
[11:41:52.478]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:52.478]                   if (TRUE && !signal) {
[11:41:52.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:52.478]                     {
[11:41:52.478]                       inherits <- base::inherits
[11:41:52.478]                       invokeRestart <- base::invokeRestart
[11:41:52.478]                       is.null <- base::is.null
[11:41:52.478]                       muffled <- FALSE
[11:41:52.478]                       if (inherits(cond, "message")) {
[11:41:52.478]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:52.478]                         if (muffled) 
[11:41:52.478]                           invokeRestart("muffleMessage")
[11:41:52.478]                       }
[11:41:52.478]                       else if (inherits(cond, "warning")) {
[11:41:52.478]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:52.478]                         if (muffled) 
[11:41:52.478]                           invokeRestart("muffleWarning")
[11:41:52.478]                       }
[11:41:52.478]                       else if (inherits(cond, "condition")) {
[11:41:52.478]                         if (!is.null(pattern)) {
[11:41:52.478]                           computeRestarts <- base::computeRestarts
[11:41:52.478]                           grepl <- base::grepl
[11:41:52.478]                           restarts <- computeRestarts(cond)
[11:41:52.478]                           for (restart in restarts) {
[11:41:52.478]                             name <- restart$name
[11:41:52.478]                             if (is.null(name)) 
[11:41:52.478]                               next
[11:41:52.478]                             if (!grepl(pattern, name)) 
[11:41:52.478]                               next
[11:41:52.478]                             invokeRestart(restart)
[11:41:52.478]                             muffled <- TRUE
[11:41:52.478]                             break
[11:41:52.478]                           }
[11:41:52.478]                         }
[11:41:52.478]                       }
[11:41:52.478]                       invisible(muffled)
[11:41:52.478]                     }
[11:41:52.478]                     muffleCondition(cond, pattern = "^muffle")
[11:41:52.478]                   }
[11:41:52.478]                 }
[11:41:52.478]                 else {
[11:41:52.478]                   if (TRUE) {
[11:41:52.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:52.478]                     {
[11:41:52.478]                       inherits <- base::inherits
[11:41:52.478]                       invokeRestart <- base::invokeRestart
[11:41:52.478]                       is.null <- base::is.null
[11:41:52.478]                       muffled <- FALSE
[11:41:52.478]                       if (inherits(cond, "message")) {
[11:41:52.478]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:52.478]                         if (muffled) 
[11:41:52.478]                           invokeRestart("muffleMessage")
[11:41:52.478]                       }
[11:41:52.478]                       else if (inherits(cond, "warning")) {
[11:41:52.478]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:52.478]                         if (muffled) 
[11:41:52.478]                           invokeRestart("muffleWarning")
[11:41:52.478]                       }
[11:41:52.478]                       else if (inherits(cond, "condition")) {
[11:41:52.478]                         if (!is.null(pattern)) {
[11:41:52.478]                           computeRestarts <- base::computeRestarts
[11:41:52.478]                           grepl <- base::grepl
[11:41:52.478]                           restarts <- computeRestarts(cond)
[11:41:52.478]                           for (restart in restarts) {
[11:41:52.478]                             name <- restart$name
[11:41:52.478]                             if (is.null(name)) 
[11:41:52.478]                               next
[11:41:52.478]                             if (!grepl(pattern, name)) 
[11:41:52.478]                               next
[11:41:52.478]                             invokeRestart(restart)
[11:41:52.478]                             muffled <- TRUE
[11:41:52.478]                             break
[11:41:52.478]                           }
[11:41:52.478]                         }
[11:41:52.478]                       }
[11:41:52.478]                       invisible(muffled)
[11:41:52.478]                     }
[11:41:52.478]                     muffleCondition(cond, pattern = "^muffle")
[11:41:52.478]                   }
[11:41:52.478]                 }
[11:41:52.478]             }
[11:41:52.478]         }))
[11:41:52.478]     }, error = function(ex) {
[11:41:52.478]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:52.478]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:52.478]                 ...future.rng), started = ...future.startTime, 
[11:41:52.478]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:52.478]             version = "1.8"), class = "FutureResult")
[11:41:52.478]     }, finally = {
[11:41:52.478]         if (!identical(...future.workdir, getwd())) 
[11:41:52.478]             setwd(...future.workdir)
[11:41:52.478]         {
[11:41:52.478]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:52.478]                 ...future.oldOptions$nwarnings <- NULL
[11:41:52.478]             }
[11:41:52.478]             base::options(...future.oldOptions)
[11:41:52.478]             if (.Platform$OS.type == "windows") {
[11:41:52.478]                 old_names <- names(...future.oldEnvVars)
[11:41:52.478]                 envs <- base::Sys.getenv()
[11:41:52.478]                 names <- names(envs)
[11:41:52.478]                 common <- intersect(names, old_names)
[11:41:52.478]                 added <- setdiff(names, old_names)
[11:41:52.478]                 removed <- setdiff(old_names, names)
[11:41:52.478]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:52.478]                   envs[common]]
[11:41:52.478]                 NAMES <- toupper(changed)
[11:41:52.478]                 args <- list()
[11:41:52.478]                 for (kk in seq_along(NAMES)) {
[11:41:52.478]                   name <- changed[[kk]]
[11:41:52.478]                   NAME <- NAMES[[kk]]
[11:41:52.478]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:52.478]                     next
[11:41:52.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:52.478]                 }
[11:41:52.478]                 NAMES <- toupper(added)
[11:41:52.478]                 for (kk in seq_along(NAMES)) {
[11:41:52.478]                   name <- added[[kk]]
[11:41:52.478]                   NAME <- NAMES[[kk]]
[11:41:52.478]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:52.478]                     next
[11:41:52.478]                   args[[name]] <- ""
[11:41:52.478]                 }
[11:41:52.478]                 NAMES <- toupper(removed)
[11:41:52.478]                 for (kk in seq_along(NAMES)) {
[11:41:52.478]                   name <- removed[[kk]]
[11:41:52.478]                   NAME <- NAMES[[kk]]
[11:41:52.478]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:52.478]                     next
[11:41:52.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:52.478]                 }
[11:41:52.478]                 if (length(args) > 0) 
[11:41:52.478]                   base::do.call(base::Sys.setenv, args = args)
[11:41:52.478]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:52.478]             }
[11:41:52.478]             else {
[11:41:52.478]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:52.478]             }
[11:41:52.478]             {
[11:41:52.478]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:52.478]                   0L) {
[11:41:52.478]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:52.478]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:52.478]                   base::options(opts)
[11:41:52.478]                 }
[11:41:52.478]                 {
[11:41:52.478]                   {
[11:41:52.478]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:52.478]                     NULL
[11:41:52.478]                   }
[11:41:52.478]                   options(future.plan = NULL)
[11:41:52.478]                   if (is.na(NA_character_)) 
[11:41:52.478]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:52.478]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:52.478]                   future::plan(list(function (..., workers = 2, 
[11:41:52.478]                     envir = parent.frame()) 
[11:41:52.478]                   strategy(..., workers = workers, envir = envir)), 
[11:41:52.478]                     .cleanup = FALSE, .init = FALSE)
[11:41:52.478]                 }
[11:41:52.478]             }
[11:41:52.478]         }
[11:41:52.478]     })
[11:41:52.478]     if (TRUE) {
[11:41:52.478]         base::sink(type = "output", split = FALSE)
[11:41:52.478]         if (TRUE) {
[11:41:52.478]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:52.478]         }
[11:41:52.478]         else {
[11:41:52.478]             ...future.result["stdout"] <- base::list(NULL)
[11:41:52.478]         }
[11:41:52.478]         base::close(...future.stdout)
[11:41:52.478]         ...future.stdout <- NULL
[11:41:52.478]     }
[11:41:52.478]     ...future.result$conditions <- ...future.conditions
[11:41:52.478]     ...future.result$finished <- base::Sys.time()
[11:41:52.478]     ...future.result
[11:41:52.478] }
[11:41:52.480] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:52.491] receiveMessageFromWorker() for ClusterFuture ...
[11:41:52.491] - Validating connection of MultisessionFuture
[11:41:52.491] - received message: FutureResult
[11:41:52.491] - Received FutureResult
[11:41:52.491] - Erased future from FutureRegistry
[11:41:52.491] result() for ClusterFuture ...
[11:41:52.491] - result already collected: FutureResult
[11:41:52.492] result() for ClusterFuture ... done
[11:41:52.492] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:52.492] result() for ClusterFuture ...
[11:41:52.492] - result already collected: FutureResult
[11:41:52.492] result() for ClusterFuture ... done
[11:41:52.492] result() for ClusterFuture ...
[11:41:52.492] - result already collected: FutureResult
[11:41:52.492] result() for ClusterFuture ... done
[11:41:52.493] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:52.494] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:52.538] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:52.545] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:52.548] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:52.548] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:52.550] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:52.550] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:52.551] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:52.551] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:52.552] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:52.552] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:52.552] MultisessionFuture started
[11:41:52.552] - Launch lazy future ... done
[11:41:52.552] run() for ‘MultisessionFuture’ ... done
[11:41:52.553] Created future:
[11:41:52.553] MultisessionFuture:
[11:41:52.553] Label: ‘future_mapply-37’
[11:41:52.553] Expression:
[11:41:52.553] {
[11:41:52.553]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:52.553]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:52.553]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:52.553]         on.exit(options(oopts), add = TRUE)
[11:41:52.553]     }
[11:41:52.553]     {
[11:41:52.553]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:52.553]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:52.553]                 inherits = FALSE)
[11:41:52.553]             ...future.FUN(...)
[11:41:52.553]         }
[11:41:52.553]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:52.553]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:52.553]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:52.553]         do.call(mapply, args = args)
[11:41:52.553]     }
[11:41:52.553] }
[11:41:52.553] Lazy evaluation: FALSE
[11:41:52.553] Asynchronous evaluation: TRUE
[11:41:52.553] Local evaluation: TRUE
[11:41:52.553] Environment: 0x560ef58e1768
[11:41:52.553] Capture standard output: TRUE
[11:41:52.553] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:52.553] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:52.553] Packages: 1 packages (‘mlr3’)
[11:41:52.553] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:52.553] Resolved: FALSE
[11:41:52.553] Value: <not collected>
[11:41:52.553] Conditions captured: <none>
[11:41:52.553] Early signaling: FALSE
[11:41:52.553] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:52.553] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:52.567] Chunk #37 of 90 ... DONE
[11:41:52.567] Chunk #38 of 90 ...
[11:41:52.567]  - seeds: [1] <seeds>
[11:41:52.567] getGlobalsAndPackages() ...
[11:41:52.567] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:52.567] Resolving globals: FALSE
[11:41:52.567] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:52.567] - packages: [1] ‘mlr3’
[11:41:52.568] getGlobalsAndPackages() ... DONE
[11:41:52.568] run() for ‘Future’ ...
[11:41:52.568] - state: ‘created’
[11:41:52.568] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:52.577] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:52.577] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:52.578]   - Field: ‘node’
[11:41:52.578]   - Field: ‘label’
[11:41:52.578]   - Field: ‘local’
[11:41:52.578]   - Field: ‘owner’
[11:41:52.578]   - Field: ‘envir’
[11:41:52.578]   - Field: ‘workers’
[11:41:52.578]   - Field: ‘packages’
[11:41:52.578]   - Field: ‘gc’
[11:41:52.578]   - Field: ‘conditions’
[11:41:52.578]   - Field: ‘persistent’
[11:41:52.578]   - Field: ‘expr’
[11:41:52.578]   - Field: ‘uuid’
[11:41:52.578]   - Field: ‘seed’
[11:41:52.578]   - Field: ‘version’
[11:41:52.578]   - Field: ‘result’
[11:41:52.578]   - Field: ‘asynchronous’
[11:41:52.578]   - Field: ‘calls’
[11:41:52.578]   - Field: ‘globals’
[11:41:52.578]   - Field: ‘stdout’
[11:41:52.579]   - Field: ‘earlySignal’
[11:41:52.579]   - Field: ‘lazy’
[11:41:52.579]   - Field: ‘state’
[11:41:52.579] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:52.579] - Launch lazy future ...
[11:41:52.579] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:52.579] Packages needed by future strategies (n = 0): <none>
[11:41:52.579] {
[11:41:52.579]     {
[11:41:52.579]         {
[11:41:52.579]             ...future.startTime <- base::Sys.time()
[11:41:52.579]             {
[11:41:52.579]                 {
[11:41:52.579]                   {
[11:41:52.579]                     {
[11:41:52.579]                       {
[11:41:52.579]                         base::local({
[11:41:52.579]                           has_future <- base::requireNamespace("future", 
[11:41:52.579]                             quietly = TRUE)
[11:41:52.579]                           if (has_future) {
[11:41:52.579]                             ns <- base::getNamespace("future")
[11:41:52.579]                             version <- ns[[".package"]][["version"]]
[11:41:52.579]                             if (is.null(version)) 
[11:41:52.579]                               version <- utils::packageVersion("future")
[11:41:52.579]                           }
[11:41:52.579]                           else {
[11:41:52.579]                             version <- NULL
[11:41:52.579]                           }
[11:41:52.579]                           if (!has_future || version < "1.8.0") {
[11:41:52.579]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:52.579]                               "", base::R.version$version.string), 
[11:41:52.579]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:52.579]                                 base::R.version$platform, 8 * 
[11:41:52.579]                                   base::.Machine$sizeof.pointer), 
[11:41:52.579]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:52.579]                                 "release", "version")], collapse = " "), 
[11:41:52.579]                               hostname = base::Sys.info()[["nodename"]])
[11:41:52.579]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:52.579]                               info)
[11:41:52.579]                             info <- base::paste(info, collapse = "; ")
[11:41:52.579]                             if (!has_future) {
[11:41:52.579]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:52.579]                                 info)
[11:41:52.579]                             }
[11:41:52.579]                             else {
[11:41:52.579]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:52.579]                                 info, version)
[11:41:52.579]                             }
[11:41:52.579]                             base::stop(msg)
[11:41:52.579]                           }
[11:41:52.579]                         })
[11:41:52.579]                       }
[11:41:52.579]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:52.579]                       base::options(mc.cores = 1L)
[11:41:52.579]                     }
[11:41:52.579]                     base::local({
[11:41:52.579]                       for (pkg in "mlr3") {
[11:41:52.579]                         base::loadNamespace(pkg)
[11:41:52.579]                         base::library(pkg, character.only = TRUE)
[11:41:52.579]                       }
[11:41:52.579]                     })
[11:41:52.579]                   }
[11:41:52.579]                   options(future.plan = NULL)
[11:41:52.579]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:52.579]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:52.579]                 }
[11:41:52.579]                 ...future.workdir <- getwd()
[11:41:52.579]             }
[11:41:52.579]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:52.579]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:52.579]         }
[11:41:52.579]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:52.579]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:52.579]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:52.579]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:52.579]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:52.579]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:52.579]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:52.579]             base::names(...future.oldOptions))
[11:41:52.579]     }
[11:41:52.579]     if (FALSE) {
[11:41:52.579]     }
[11:41:52.579]     else {
[11:41:52.579]         if (TRUE) {
[11:41:52.579]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:52.579]                 open = "w")
[11:41:52.579]         }
[11:41:52.579]         else {
[11:41:52.579]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:52.579]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:52.579]         }
[11:41:52.579]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:52.579]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:52.579]             base::sink(type = "output", split = FALSE)
[11:41:52.579]             base::close(...future.stdout)
[11:41:52.579]         }, add = TRUE)
[11:41:52.579]     }
[11:41:52.579]     ...future.frame <- base::sys.nframe()
[11:41:52.579]     ...future.conditions <- base::list()
[11:41:52.579]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:52.579]     if (FALSE) {
[11:41:52.579]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:52.579]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:52.579]     }
[11:41:52.579]     ...future.result <- base::tryCatch({
[11:41:52.579]         base::withCallingHandlers({
[11:41:52.579]             ...future.value <- base::withVisible(base::local({
[11:41:52.579]                 ...future.makeSendCondition <- local({
[11:41:52.579]                   sendCondition <- NULL
[11:41:52.579]                   function(frame = 1L) {
[11:41:52.579]                     if (is.function(sendCondition)) 
[11:41:52.579]                       return(sendCondition)
[11:41:52.579]                     ns <- getNamespace("parallel")
[11:41:52.579]                     if (exists("sendData", mode = "function", 
[11:41:52.579]                       envir = ns)) {
[11:41:52.579]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:52.579]                         envir = ns)
[11:41:52.579]                       envir <- sys.frame(frame)
[11:41:52.579]                       master <- NULL
[11:41:52.579]                       while (!identical(envir, .GlobalEnv) && 
[11:41:52.579]                         !identical(envir, emptyenv())) {
[11:41:52.579]                         if (exists("master", mode = "list", envir = envir, 
[11:41:52.579]                           inherits = FALSE)) {
[11:41:52.579]                           master <- get("master", mode = "list", 
[11:41:52.579]                             envir = envir, inherits = FALSE)
[11:41:52.579]                           if (inherits(master, c("SOCKnode", 
[11:41:52.579]                             "SOCK0node"))) {
[11:41:52.579]                             sendCondition <<- function(cond) {
[11:41:52.579]                               data <- list(type = "VALUE", value = cond, 
[11:41:52.579]                                 success = TRUE)
[11:41:52.579]                               parallel_sendData(master, data)
[11:41:52.579]                             }
[11:41:52.579]                             return(sendCondition)
[11:41:52.579]                           }
[11:41:52.579]                         }
[11:41:52.579]                         frame <- frame + 1L
[11:41:52.579]                         envir <- sys.frame(frame)
[11:41:52.579]                       }
[11:41:52.579]                     }
[11:41:52.579]                     sendCondition <<- function(cond) NULL
[11:41:52.579]                   }
[11:41:52.579]                 })
[11:41:52.579]                 withCallingHandlers({
[11:41:52.579]                   {
[11:41:52.579]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:52.579]                     if (!identical(...future.globals.maxSize.org, 
[11:41:52.579]                       ...future.globals.maxSize)) {
[11:41:52.579]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:52.579]                       on.exit(options(oopts), add = TRUE)
[11:41:52.579]                     }
[11:41:52.579]                     {
[11:41:52.579]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:52.579]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:52.579]                           envir = globalenv(), inherits = FALSE)
[11:41:52.579]                         ...future.FUN(...)
[11:41:52.579]                       }
[11:41:52.579]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:52.579]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:52.579]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:52.579]                         USE.NAMES = FALSE)
[11:41:52.579]                       do.call(mapply, args = args)
[11:41:52.579]                     }
[11:41:52.579]                   }
[11:41:52.579]                 }, immediateCondition = function(cond) {
[11:41:52.579]                   sendCondition <- ...future.makeSendCondition()
[11:41:52.579]                   sendCondition(cond)
[11:41:52.579]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:52.579]                   {
[11:41:52.579]                     inherits <- base::inherits
[11:41:52.579]                     invokeRestart <- base::invokeRestart
[11:41:52.579]                     is.null <- base::is.null
[11:41:52.579]                     muffled <- FALSE
[11:41:52.579]                     if (inherits(cond, "message")) {
[11:41:52.579]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:52.579]                       if (muffled) 
[11:41:52.579]                         invokeRestart("muffleMessage")
[11:41:52.579]                     }
[11:41:52.579]                     else if (inherits(cond, "warning")) {
[11:41:52.579]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:52.579]                       if (muffled) 
[11:41:52.579]                         invokeRestart("muffleWarning")
[11:41:52.579]                     }
[11:41:52.579]                     else if (inherits(cond, "condition")) {
[11:41:52.579]                       if (!is.null(pattern)) {
[11:41:52.579]                         computeRestarts <- base::computeRestarts
[11:41:52.579]                         grepl <- base::grepl
[11:41:52.579]                         restarts <- computeRestarts(cond)
[11:41:52.579]                         for (restart in restarts) {
[11:41:52.579]                           name <- restart$name
[11:41:52.579]                           if (is.null(name)) 
[11:41:52.579]                             next
[11:41:52.579]                           if (!grepl(pattern, name)) 
[11:41:52.579]                             next
[11:41:52.579]                           invokeRestart(restart)
[11:41:52.579]                           muffled <- TRUE
[11:41:52.579]                           break
[11:41:52.579]                         }
[11:41:52.579]                       }
[11:41:52.579]                     }
[11:41:52.579]                     invisible(muffled)
[11:41:52.579]                   }
[11:41:52.579]                   muffleCondition(cond)
[11:41:52.579]                 })
[11:41:52.579]             }))
[11:41:52.579]             future::FutureResult(value = ...future.value$value, 
[11:41:52.579]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:52.579]                   ...future.rng), globalenv = if (FALSE) 
[11:41:52.579]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:52.579]                     ...future.globalenv.names))
[11:41:52.579]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:52.579]         }, condition = base::local({
[11:41:52.579]             c <- base::c
[11:41:52.579]             inherits <- base::inherits
[11:41:52.579]             invokeRestart <- base::invokeRestart
[11:41:52.579]             length <- base::length
[11:41:52.579]             list <- base::list
[11:41:52.579]             seq.int <- base::seq.int
[11:41:52.579]             signalCondition <- base::signalCondition
[11:41:52.579]             sys.calls <- base::sys.calls
[11:41:52.579]             `[[` <- base::`[[`
[11:41:52.579]             `+` <- base::`+`
[11:41:52.579]             `<<-` <- base::`<<-`
[11:41:52.579]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:52.579]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:52.579]                   3L)]
[11:41:52.579]             }
[11:41:52.579]             function(cond) {
[11:41:52.579]                 is_error <- inherits(cond, "error")
[11:41:52.579]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:52.579]                   NULL)
[11:41:52.579]                 if (is_error) {
[11:41:52.579]                   sessionInformation <- function() {
[11:41:52.579]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:52.579]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:52.579]                       search = base::search(), system = base::Sys.info())
[11:41:52.579]                   }
[11:41:52.579]                   ...future.conditions[[length(...future.conditions) + 
[11:41:52.579]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:52.579]                     cond$call), session = sessionInformation(), 
[11:41:52.579]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:52.579]                   signalCondition(cond)
[11:41:52.579]                 }
[11:41:52.579]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:52.579]                 "immediateCondition"))) {
[11:41:52.579]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:52.579]                   ...future.conditions[[length(...future.conditions) + 
[11:41:52.579]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:52.579]                   if (TRUE && !signal) {
[11:41:52.579]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:52.579]                     {
[11:41:52.579]                       inherits <- base::inherits
[11:41:52.579]                       invokeRestart <- base::invokeRestart
[11:41:52.579]                       is.null <- base::is.null
[11:41:52.579]                       muffled <- FALSE
[11:41:52.579]                       if (inherits(cond, "message")) {
[11:41:52.579]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:52.579]                         if (muffled) 
[11:41:52.579]                           invokeRestart("muffleMessage")
[11:41:52.579]                       }
[11:41:52.579]                       else if (inherits(cond, "warning")) {
[11:41:52.579]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:52.579]                         if (muffled) 
[11:41:52.579]                           invokeRestart("muffleWarning")
[11:41:52.579]                       }
[11:41:52.579]                       else if (inherits(cond, "condition")) {
[11:41:52.579]                         if (!is.null(pattern)) {
[11:41:52.579]                           computeRestarts <- base::computeRestarts
[11:41:52.579]                           grepl <- base::grepl
[11:41:52.579]                           restarts <- computeRestarts(cond)
[11:41:52.579]                           for (restart in restarts) {
[11:41:52.579]                             name <- restart$name
[11:41:52.579]                             if (is.null(name)) 
[11:41:52.579]                               next
[11:41:52.579]                             if (!grepl(pattern, name)) 
[11:41:52.579]                               next
[11:41:52.579]                             invokeRestart(restart)
[11:41:52.579]                             muffled <- TRUE
[11:41:52.579]                             break
[11:41:52.579]                           }
[11:41:52.579]                         }
[11:41:52.579]                       }
[11:41:52.579]                       invisible(muffled)
[11:41:52.579]                     }
[11:41:52.579]                     muffleCondition(cond, pattern = "^muffle")
[11:41:52.579]                   }
[11:41:52.579]                 }
[11:41:52.579]                 else {
[11:41:52.579]                   if (TRUE) {
[11:41:52.579]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:52.579]                     {
[11:41:52.579]                       inherits <- base::inherits
[11:41:52.579]                       invokeRestart <- base::invokeRestart
[11:41:52.579]                       is.null <- base::is.null
[11:41:52.579]                       muffled <- FALSE
[11:41:52.579]                       if (inherits(cond, "message")) {
[11:41:52.579]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:52.579]                         if (muffled) 
[11:41:52.579]                           invokeRestart("muffleMessage")
[11:41:52.579]                       }
[11:41:52.579]                       else if (inherits(cond, "warning")) {
[11:41:52.579]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:52.579]                         if (muffled) 
[11:41:52.579]                           invokeRestart("muffleWarning")
[11:41:52.579]                       }
[11:41:52.579]                       else if (inherits(cond, "condition")) {
[11:41:52.579]                         if (!is.null(pattern)) {
[11:41:52.579]                           computeRestarts <- base::computeRestarts
[11:41:52.579]                           grepl <- base::grepl
[11:41:52.579]                           restarts <- computeRestarts(cond)
[11:41:52.579]                           for (restart in restarts) {
[11:41:52.579]                             name <- restart$name
[11:41:52.579]                             if (is.null(name)) 
[11:41:52.579]                               next
[11:41:52.579]                             if (!grepl(pattern, name)) 
[11:41:52.579]                               next
[11:41:52.579]                             invokeRestart(restart)
[11:41:52.579]                             muffled <- TRUE
[11:41:52.579]                             break
[11:41:52.579]                           }
[11:41:52.579]                         }
[11:41:52.579]                       }
[11:41:52.579]                       invisible(muffled)
[11:41:52.579]                     }
[11:41:52.579]                     muffleCondition(cond, pattern = "^muffle")
[11:41:52.579]                   }
[11:41:52.579]                 }
[11:41:52.579]             }
[11:41:52.579]         }))
[11:41:52.579]     }, error = function(ex) {
[11:41:52.579]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:52.579]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:52.579]                 ...future.rng), started = ...future.startTime, 
[11:41:52.579]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:52.579]             version = "1.8"), class = "FutureResult")
[11:41:52.579]     }, finally = {
[11:41:52.579]         if (!identical(...future.workdir, getwd())) 
[11:41:52.579]             setwd(...future.workdir)
[11:41:52.579]         {
[11:41:52.579]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:52.579]                 ...future.oldOptions$nwarnings <- NULL
[11:41:52.579]             }
[11:41:52.579]             base::options(...future.oldOptions)
[11:41:52.579]             if (.Platform$OS.type == "windows") {
[11:41:52.579]                 old_names <- names(...future.oldEnvVars)
[11:41:52.579]                 envs <- base::Sys.getenv()
[11:41:52.579]                 names <- names(envs)
[11:41:52.579]                 common <- intersect(names, old_names)
[11:41:52.579]                 added <- setdiff(names, old_names)
[11:41:52.579]                 removed <- setdiff(old_names, names)
[11:41:52.579]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:52.579]                   envs[common]]
[11:41:52.579]                 NAMES <- toupper(changed)
[11:41:52.579]                 args <- list()
[11:41:52.579]                 for (kk in seq_along(NAMES)) {
[11:41:52.579]                   name <- changed[[kk]]
[11:41:52.579]                   NAME <- NAMES[[kk]]
[11:41:52.579]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:52.579]                     next
[11:41:52.579]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:52.579]                 }
[11:41:52.579]                 NAMES <- toupper(added)
[11:41:52.579]                 for (kk in seq_along(NAMES)) {
[11:41:52.579]                   name <- added[[kk]]
[11:41:52.579]                   NAME <- NAMES[[kk]]
[11:41:52.579]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:52.579]                     next
[11:41:52.579]                   args[[name]] <- ""
[11:41:52.579]                 }
[11:41:52.579]                 NAMES <- toupper(removed)
[11:41:52.579]                 for (kk in seq_along(NAMES)) {
[11:41:52.579]                   name <- removed[[kk]]
[11:41:52.579]                   NAME <- NAMES[[kk]]
[11:41:52.579]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:52.579]                     next
[11:41:52.579]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:52.579]                 }
[11:41:52.579]                 if (length(args) > 0) 
[11:41:52.579]                   base::do.call(base::Sys.setenv, args = args)
[11:41:52.579]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:52.579]             }
[11:41:52.579]             else {
[11:41:52.579]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:52.579]             }
[11:41:52.579]             {
[11:41:52.579]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:52.579]                   0L) {
[11:41:52.579]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:52.579]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:52.579]                   base::options(opts)
[11:41:52.579]                 }
[11:41:52.579]                 {
[11:41:52.579]                   {
[11:41:52.579]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:52.579]                     NULL
[11:41:52.579]                   }
[11:41:52.579]                   options(future.plan = NULL)
[11:41:52.579]                   if (is.na(NA_character_)) 
[11:41:52.579]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:52.579]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:52.579]                   future::plan(list(function (..., workers = 2, 
[11:41:52.579]                     envir = parent.frame()) 
[11:41:52.579]                   strategy(..., workers = workers, envir = envir)), 
[11:41:52.579]                     .cleanup = FALSE, .init = FALSE)
[11:41:52.579]                 }
[11:41:52.579]             }
[11:41:52.579]         }
[11:41:52.579]     })
[11:41:52.579]     if (TRUE) {
[11:41:52.579]         base::sink(type = "output", split = FALSE)
[11:41:52.579]         if (TRUE) {
[11:41:52.579]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:52.579]         }
[11:41:52.579]         else {
[11:41:52.579]             ...future.result["stdout"] <- base::list(NULL)
[11:41:52.579]         }
[11:41:52.579]         base::close(...future.stdout)
[11:41:52.579]         ...future.stdout <- NULL
[11:41:52.579]     }
[11:41:52.579]     ...future.result$conditions <- ...future.conditions
[11:41:52.579]     ...future.result$finished <- base::Sys.time()
[11:41:52.579]     ...future.result
[11:41:52.579] }
[11:41:52.581] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:52.592] receiveMessageFromWorker() for ClusterFuture ...
[11:41:52.592] - Validating connection of MultisessionFuture
[11:41:52.592] - received message: FutureResult
[11:41:52.592] - Received FutureResult
[11:41:52.592] - Erased future from FutureRegistry
[11:41:52.592] result() for ClusterFuture ...
[11:41:52.592] - result already collected: FutureResult
[11:41:52.592] result() for ClusterFuture ... done
[11:41:52.592] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:52.593] result() for ClusterFuture ...
[11:41:52.593] - result already collected: FutureResult
[11:41:52.593] result() for ClusterFuture ... done
[11:41:52.593] result() for ClusterFuture ...
[11:41:52.593] - result already collected: FutureResult
[11:41:52.593] result() for ClusterFuture ... done
[11:41:52.593] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:52.593] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:52.641] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:52.645] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:52.646] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:52.647] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:52.690] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:52.691] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:52.692] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:52.693] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:52.694] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:52.695] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:52.696] MultisessionFuture started
[11:41:52.696] - Launch lazy future ... done
[11:41:52.696] run() for ‘MultisessionFuture’ ... done
[11:41:52.696] Created future:
[11:41:52.696] MultisessionFuture:
[11:41:52.696] Label: ‘future_mapply-38’
[11:41:52.696] Expression:
[11:41:52.696] {
[11:41:52.696]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:52.696]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:52.696]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:52.696]         on.exit(options(oopts), add = TRUE)
[11:41:52.696]     }
[11:41:52.696]     {
[11:41:52.696]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:52.696]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:52.696]                 inherits = FALSE)
[11:41:52.696]             ...future.FUN(...)
[11:41:52.696]         }
[11:41:52.696]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:52.696]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:52.696]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:52.696]         do.call(mapply, args = args)
[11:41:52.696]     }
[11:41:52.696] }
[11:41:52.696] Lazy evaluation: FALSE
[11:41:52.696] Asynchronous evaluation: TRUE
[11:41:52.696] Local evaluation: TRUE
[11:41:52.696] Environment: 0x560ef58e1768
[11:41:52.696] Capture standard output: TRUE
[11:41:52.696] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:52.696] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:52.696] Packages: 1 packages (‘mlr3’)
[11:41:52.696] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:52.696] Resolved: FALSE
[11:41:52.696] Value: <not collected>
[11:41:52.696] Conditions captured: <none>
[11:41:52.696] Early signaling: FALSE
[11:41:52.696] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:52.696] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:52.713] Chunk #38 of 90 ... DONE
[11:41:52.714] Chunk #39 of 90 ...
[11:41:52.714]  - seeds: [1] <seeds>
[11:41:52.714] getGlobalsAndPackages() ...
[11:41:52.714] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:52.714] Resolving globals: FALSE
[11:41:52.715] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:52.715] - packages: [1] ‘mlr3’
[11:41:52.715] getGlobalsAndPackages() ... DONE
[11:41:52.715] run() for ‘Future’ ...
[11:41:52.716] - state: ‘created’
[11:41:52.716] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:52.726] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:52.726] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:52.726]   - Field: ‘node’
[11:41:52.726]   - Field: ‘label’
[11:41:52.726]   - Field: ‘local’
[11:41:52.726]   - Field: ‘owner’
[11:41:52.726]   - Field: ‘envir’
[11:41:52.726]   - Field: ‘workers’
[11:41:52.726]   - Field: ‘packages’
[11:41:52.726]   - Field: ‘gc’
[11:41:52.726]   - Field: ‘conditions’
[11:41:52.727]   - Field: ‘persistent’
[11:41:52.727]   - Field: ‘expr’
[11:41:52.727]   - Field: ‘uuid’
[11:41:52.727]   - Field: ‘seed’
[11:41:52.727]   - Field: ‘version’
[11:41:52.727]   - Field: ‘result’
[11:41:52.727]   - Field: ‘asynchronous’
[11:41:52.727]   - Field: ‘calls’
[11:41:52.727]   - Field: ‘globals’
[11:41:52.727]   - Field: ‘stdout’
[11:41:52.727]   - Field: ‘earlySignal’
[11:41:52.727]   - Field: ‘lazy’
[11:41:52.727]   - Field: ‘state’
[11:41:52.727] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:52.727] - Launch lazy future ...
[11:41:52.727] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:52.728] Packages needed by future strategies (n = 0): <none>
[11:41:52.728] {
[11:41:52.728]     {
[11:41:52.728]         {
[11:41:52.728]             ...future.startTime <- base::Sys.time()
[11:41:52.728]             {
[11:41:52.728]                 {
[11:41:52.728]                   {
[11:41:52.728]                     {
[11:41:52.728]                       {
[11:41:52.728]                         base::local({
[11:41:52.728]                           has_future <- base::requireNamespace("future", 
[11:41:52.728]                             quietly = TRUE)
[11:41:52.728]                           if (has_future) {
[11:41:52.728]                             ns <- base::getNamespace("future")
[11:41:52.728]                             version <- ns[[".package"]][["version"]]
[11:41:52.728]                             if (is.null(version)) 
[11:41:52.728]                               version <- utils::packageVersion("future")
[11:41:52.728]                           }
[11:41:52.728]                           else {
[11:41:52.728]                             version <- NULL
[11:41:52.728]                           }
[11:41:52.728]                           if (!has_future || version < "1.8.0") {
[11:41:52.728]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:52.728]                               "", base::R.version$version.string), 
[11:41:52.728]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:52.728]                                 base::R.version$platform, 8 * 
[11:41:52.728]                                   base::.Machine$sizeof.pointer), 
[11:41:52.728]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:52.728]                                 "release", "version")], collapse = " "), 
[11:41:52.728]                               hostname = base::Sys.info()[["nodename"]])
[11:41:52.728]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:52.728]                               info)
[11:41:52.728]                             info <- base::paste(info, collapse = "; ")
[11:41:52.728]                             if (!has_future) {
[11:41:52.728]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:52.728]                                 info)
[11:41:52.728]                             }
[11:41:52.728]                             else {
[11:41:52.728]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:52.728]                                 info, version)
[11:41:52.728]                             }
[11:41:52.728]                             base::stop(msg)
[11:41:52.728]                           }
[11:41:52.728]                         })
[11:41:52.728]                       }
[11:41:52.728]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:52.728]                       base::options(mc.cores = 1L)
[11:41:52.728]                     }
[11:41:52.728]                     base::local({
[11:41:52.728]                       for (pkg in "mlr3") {
[11:41:52.728]                         base::loadNamespace(pkg)
[11:41:52.728]                         base::library(pkg, character.only = TRUE)
[11:41:52.728]                       }
[11:41:52.728]                     })
[11:41:52.728]                   }
[11:41:52.728]                   options(future.plan = NULL)
[11:41:52.728]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:52.728]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:52.728]                 }
[11:41:52.728]                 ...future.workdir <- getwd()
[11:41:52.728]             }
[11:41:52.728]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:52.728]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:52.728]         }
[11:41:52.728]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:52.728]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:52.728]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:52.728]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:52.728]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:52.728]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:52.728]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:52.728]             base::names(...future.oldOptions))
[11:41:52.728]     }
[11:41:52.728]     if (FALSE) {
[11:41:52.728]     }
[11:41:52.728]     else {
[11:41:52.728]         if (TRUE) {
[11:41:52.728]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:52.728]                 open = "w")
[11:41:52.728]         }
[11:41:52.728]         else {
[11:41:52.728]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:52.728]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:52.728]         }
[11:41:52.728]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:52.728]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:52.728]             base::sink(type = "output", split = FALSE)
[11:41:52.728]             base::close(...future.stdout)
[11:41:52.728]         }, add = TRUE)
[11:41:52.728]     }
[11:41:52.728]     ...future.frame <- base::sys.nframe()
[11:41:52.728]     ...future.conditions <- base::list()
[11:41:52.728]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:52.728]     if (FALSE) {
[11:41:52.728]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:52.728]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:52.728]     }
[11:41:52.728]     ...future.result <- base::tryCatch({
[11:41:52.728]         base::withCallingHandlers({
[11:41:52.728]             ...future.value <- base::withVisible(base::local({
[11:41:52.728]                 ...future.makeSendCondition <- local({
[11:41:52.728]                   sendCondition <- NULL
[11:41:52.728]                   function(frame = 1L) {
[11:41:52.728]                     if (is.function(sendCondition)) 
[11:41:52.728]                       return(sendCondition)
[11:41:52.728]                     ns <- getNamespace("parallel")
[11:41:52.728]                     if (exists("sendData", mode = "function", 
[11:41:52.728]                       envir = ns)) {
[11:41:52.728]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:52.728]                         envir = ns)
[11:41:52.728]                       envir <- sys.frame(frame)
[11:41:52.728]                       master <- NULL
[11:41:52.728]                       while (!identical(envir, .GlobalEnv) && 
[11:41:52.728]                         !identical(envir, emptyenv())) {
[11:41:52.728]                         if (exists("master", mode = "list", envir = envir, 
[11:41:52.728]                           inherits = FALSE)) {
[11:41:52.728]                           master <- get("master", mode = "list", 
[11:41:52.728]                             envir = envir, inherits = FALSE)
[11:41:52.728]                           if (inherits(master, c("SOCKnode", 
[11:41:52.728]                             "SOCK0node"))) {
[11:41:52.728]                             sendCondition <<- function(cond) {
[11:41:52.728]                               data <- list(type = "VALUE", value = cond, 
[11:41:52.728]                                 success = TRUE)
[11:41:52.728]                               parallel_sendData(master, data)
[11:41:52.728]                             }
[11:41:52.728]                             return(sendCondition)
[11:41:52.728]                           }
[11:41:52.728]                         }
[11:41:52.728]                         frame <- frame + 1L
[11:41:52.728]                         envir <- sys.frame(frame)
[11:41:52.728]                       }
[11:41:52.728]                     }
[11:41:52.728]                     sendCondition <<- function(cond) NULL
[11:41:52.728]                   }
[11:41:52.728]                 })
[11:41:52.728]                 withCallingHandlers({
[11:41:52.728]                   {
[11:41:52.728]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:52.728]                     if (!identical(...future.globals.maxSize.org, 
[11:41:52.728]                       ...future.globals.maxSize)) {
[11:41:52.728]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:52.728]                       on.exit(options(oopts), add = TRUE)
[11:41:52.728]                     }
[11:41:52.728]                     {
[11:41:52.728]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:52.728]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:52.728]                           envir = globalenv(), inherits = FALSE)
[11:41:52.728]                         ...future.FUN(...)
[11:41:52.728]                       }
[11:41:52.728]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:52.728]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:52.728]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:52.728]                         USE.NAMES = FALSE)
[11:41:52.728]                       do.call(mapply, args = args)
[11:41:52.728]                     }
[11:41:52.728]                   }
[11:41:52.728]                 }, immediateCondition = function(cond) {
[11:41:52.728]                   sendCondition <- ...future.makeSendCondition()
[11:41:52.728]                   sendCondition(cond)
[11:41:52.728]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:52.728]                   {
[11:41:52.728]                     inherits <- base::inherits
[11:41:52.728]                     invokeRestart <- base::invokeRestart
[11:41:52.728]                     is.null <- base::is.null
[11:41:52.728]                     muffled <- FALSE
[11:41:52.728]                     if (inherits(cond, "message")) {
[11:41:52.728]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:52.728]                       if (muffled) 
[11:41:52.728]                         invokeRestart("muffleMessage")
[11:41:52.728]                     }
[11:41:52.728]                     else if (inherits(cond, "warning")) {
[11:41:52.728]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:52.728]                       if (muffled) 
[11:41:52.728]                         invokeRestart("muffleWarning")
[11:41:52.728]                     }
[11:41:52.728]                     else if (inherits(cond, "condition")) {
[11:41:52.728]                       if (!is.null(pattern)) {
[11:41:52.728]                         computeRestarts <- base::computeRestarts
[11:41:52.728]                         grepl <- base::grepl
[11:41:52.728]                         restarts <- computeRestarts(cond)
[11:41:52.728]                         for (restart in restarts) {
[11:41:52.728]                           name <- restart$name
[11:41:52.728]                           if (is.null(name)) 
[11:41:52.728]                             next
[11:41:52.728]                           if (!grepl(pattern, name)) 
[11:41:52.728]                             next
[11:41:52.728]                           invokeRestart(restart)
[11:41:52.728]                           muffled <- TRUE
[11:41:52.728]                           break
[11:41:52.728]                         }
[11:41:52.728]                       }
[11:41:52.728]                     }
[11:41:52.728]                     invisible(muffled)
[11:41:52.728]                   }
[11:41:52.728]                   muffleCondition(cond)
[11:41:52.728]                 })
[11:41:52.728]             }))
[11:41:52.728]             future::FutureResult(value = ...future.value$value, 
[11:41:52.728]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:52.728]                   ...future.rng), globalenv = if (FALSE) 
[11:41:52.728]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:52.728]                     ...future.globalenv.names))
[11:41:52.728]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:52.728]         }, condition = base::local({
[11:41:52.728]             c <- base::c
[11:41:52.728]             inherits <- base::inherits
[11:41:52.728]             invokeRestart <- base::invokeRestart
[11:41:52.728]             length <- base::length
[11:41:52.728]             list <- base::list
[11:41:52.728]             seq.int <- base::seq.int
[11:41:52.728]             signalCondition <- base::signalCondition
[11:41:52.728]             sys.calls <- base::sys.calls
[11:41:52.728]             `[[` <- base::`[[`
[11:41:52.728]             `+` <- base::`+`
[11:41:52.728]             `<<-` <- base::`<<-`
[11:41:52.728]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:52.728]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:52.728]                   3L)]
[11:41:52.728]             }
[11:41:52.728]             function(cond) {
[11:41:52.728]                 is_error <- inherits(cond, "error")
[11:41:52.728]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:52.728]                   NULL)
[11:41:52.728]                 if (is_error) {
[11:41:52.728]                   sessionInformation <- function() {
[11:41:52.728]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:52.728]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:52.728]                       search = base::search(), system = base::Sys.info())
[11:41:52.728]                   }
[11:41:52.728]                   ...future.conditions[[length(...future.conditions) + 
[11:41:52.728]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:52.728]                     cond$call), session = sessionInformation(), 
[11:41:52.728]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:52.728]                   signalCondition(cond)
[11:41:52.728]                 }
[11:41:52.728]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:52.728]                 "immediateCondition"))) {
[11:41:52.728]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:52.728]                   ...future.conditions[[length(...future.conditions) + 
[11:41:52.728]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:52.728]                   if (TRUE && !signal) {
[11:41:52.728]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:52.728]                     {
[11:41:52.728]                       inherits <- base::inherits
[11:41:52.728]                       invokeRestart <- base::invokeRestart
[11:41:52.728]                       is.null <- base::is.null
[11:41:52.728]                       muffled <- FALSE
[11:41:52.728]                       if (inherits(cond, "message")) {
[11:41:52.728]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:52.728]                         if (muffled) 
[11:41:52.728]                           invokeRestart("muffleMessage")
[11:41:52.728]                       }
[11:41:52.728]                       else if (inherits(cond, "warning")) {
[11:41:52.728]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:52.728]                         if (muffled) 
[11:41:52.728]                           invokeRestart("muffleWarning")
[11:41:52.728]                       }
[11:41:52.728]                       else if (inherits(cond, "condition")) {
[11:41:52.728]                         if (!is.null(pattern)) {
[11:41:52.728]                           computeRestarts <- base::computeRestarts
[11:41:52.728]                           grepl <- base::grepl
[11:41:52.728]                           restarts <- computeRestarts(cond)
[11:41:52.728]                           for (restart in restarts) {
[11:41:52.728]                             name <- restart$name
[11:41:52.728]                             if (is.null(name)) 
[11:41:52.728]                               next
[11:41:52.728]                             if (!grepl(pattern, name)) 
[11:41:52.728]                               next
[11:41:52.728]                             invokeRestart(restart)
[11:41:52.728]                             muffled <- TRUE
[11:41:52.728]                             break
[11:41:52.728]                           }
[11:41:52.728]                         }
[11:41:52.728]                       }
[11:41:52.728]                       invisible(muffled)
[11:41:52.728]                     }
[11:41:52.728]                     muffleCondition(cond, pattern = "^muffle")
[11:41:52.728]                   }
[11:41:52.728]                 }
[11:41:52.728]                 else {
[11:41:52.728]                   if (TRUE) {
[11:41:52.728]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:52.728]                     {
[11:41:52.728]                       inherits <- base::inherits
[11:41:52.728]                       invokeRestart <- base::invokeRestart
[11:41:52.728]                       is.null <- base::is.null
[11:41:52.728]                       muffled <- FALSE
[11:41:52.728]                       if (inherits(cond, "message")) {
[11:41:52.728]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:52.728]                         if (muffled) 
[11:41:52.728]                           invokeRestart("muffleMessage")
[11:41:52.728]                       }
[11:41:52.728]                       else if (inherits(cond, "warning")) {
[11:41:52.728]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:52.728]                         if (muffled) 
[11:41:52.728]                           invokeRestart("muffleWarning")
[11:41:52.728]                       }
[11:41:52.728]                       else if (inherits(cond, "condition")) {
[11:41:52.728]                         if (!is.null(pattern)) {
[11:41:52.728]                           computeRestarts <- base::computeRestarts
[11:41:52.728]                           grepl <- base::grepl
[11:41:52.728]                           restarts <- computeRestarts(cond)
[11:41:52.728]                           for (restart in restarts) {
[11:41:52.728]                             name <- restart$name
[11:41:52.728]                             if (is.null(name)) 
[11:41:52.728]                               next
[11:41:52.728]                             if (!grepl(pattern, name)) 
[11:41:52.728]                               next
[11:41:52.728]                             invokeRestart(restart)
[11:41:52.728]                             muffled <- TRUE
[11:41:52.728]                             break
[11:41:52.728]                           }
[11:41:52.728]                         }
[11:41:52.728]                       }
[11:41:52.728]                       invisible(muffled)
[11:41:52.728]                     }
[11:41:52.728]                     muffleCondition(cond, pattern = "^muffle")
[11:41:52.728]                   }
[11:41:52.728]                 }
[11:41:52.728]             }
[11:41:52.728]         }))
[11:41:52.728]     }, error = function(ex) {
[11:41:52.728]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:52.728]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:52.728]                 ...future.rng), started = ...future.startTime, 
[11:41:52.728]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:52.728]             version = "1.8"), class = "FutureResult")
[11:41:52.728]     }, finally = {
[11:41:52.728]         if (!identical(...future.workdir, getwd())) 
[11:41:52.728]             setwd(...future.workdir)
[11:41:52.728]         {
[11:41:52.728]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:52.728]                 ...future.oldOptions$nwarnings <- NULL
[11:41:52.728]             }
[11:41:52.728]             base::options(...future.oldOptions)
[11:41:52.728]             if (.Platform$OS.type == "windows") {
[11:41:52.728]                 old_names <- names(...future.oldEnvVars)
[11:41:52.728]                 envs <- base::Sys.getenv()
[11:41:52.728]                 names <- names(envs)
[11:41:52.728]                 common <- intersect(names, old_names)
[11:41:52.728]                 added <- setdiff(names, old_names)
[11:41:52.728]                 removed <- setdiff(old_names, names)
[11:41:52.728]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:52.728]                   envs[common]]
[11:41:52.728]                 NAMES <- toupper(changed)
[11:41:52.728]                 args <- list()
[11:41:52.728]                 for (kk in seq_along(NAMES)) {
[11:41:52.728]                   name <- changed[[kk]]
[11:41:52.728]                   NAME <- NAMES[[kk]]
[11:41:52.728]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:52.728]                     next
[11:41:52.728]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:52.728]                 }
[11:41:52.728]                 NAMES <- toupper(added)
[11:41:52.728]                 for (kk in seq_along(NAMES)) {
[11:41:52.728]                   name <- added[[kk]]
[11:41:52.728]                   NAME <- NAMES[[kk]]
[11:41:52.728]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:52.728]                     next
[11:41:52.728]                   args[[name]] <- ""
[11:41:52.728]                 }
[11:41:52.728]                 NAMES <- toupper(removed)
[11:41:52.728]                 for (kk in seq_along(NAMES)) {
[11:41:52.728]                   name <- removed[[kk]]
[11:41:52.728]                   NAME <- NAMES[[kk]]
[11:41:52.728]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:52.728]                     next
[11:41:52.728]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:52.728]                 }
[11:41:52.728]                 if (length(args) > 0) 
[11:41:52.728]                   base::do.call(base::Sys.setenv, args = args)
[11:41:52.728]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:52.728]             }
[11:41:52.728]             else {
[11:41:52.728]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:52.728]             }
[11:41:52.728]             {
[11:41:52.728]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:52.728]                   0L) {
[11:41:52.728]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:52.728]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:52.728]                   base::options(opts)
[11:41:52.728]                 }
[11:41:52.728]                 {
[11:41:52.728]                   {
[11:41:52.728]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:52.728]                     NULL
[11:41:52.728]                   }
[11:41:52.728]                   options(future.plan = NULL)
[11:41:52.728]                   if (is.na(NA_character_)) 
[11:41:52.728]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:52.728]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:52.728]                   future::plan(list(function (..., workers = 2, 
[11:41:52.728]                     envir = parent.frame()) 
[11:41:52.728]                   strategy(..., workers = workers, envir = envir)), 
[11:41:52.728]                     .cleanup = FALSE, .init = FALSE)
[11:41:52.728]                 }
[11:41:52.728]             }
[11:41:52.728]         }
[11:41:52.728]     })
[11:41:52.728]     if (TRUE) {
[11:41:52.728]         base::sink(type = "output", split = FALSE)
[11:41:52.728]         if (TRUE) {
[11:41:52.728]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:52.728]         }
[11:41:52.728]         else {
[11:41:52.728]             ...future.result["stdout"] <- base::list(NULL)
[11:41:52.728]         }
[11:41:52.728]         base::close(...future.stdout)
[11:41:52.728]         ...future.stdout <- NULL
[11:41:52.728]     }
[11:41:52.728]     ...future.result$conditions <- ...future.conditions
[11:41:52.728]     ...future.result$finished <- base::Sys.time()
[11:41:52.728]     ...future.result
[11:41:52.728] }
[11:41:52.730] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:52.741] receiveMessageFromWorker() for ClusterFuture ...
[11:41:52.742] - Validating connection of MultisessionFuture
[11:41:52.742] - received message: FutureResult
[11:41:52.742] - Received FutureResult
[11:41:52.742] - Erased future from FutureRegistry
[11:41:52.742] result() for ClusterFuture ...
[11:41:52.742] - result already collected: FutureResult
[11:41:52.742] result() for ClusterFuture ... done
[11:41:52.742] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:52.742] result() for ClusterFuture ...
[11:41:52.742] - result already collected: FutureResult
[11:41:52.742] result() for ClusterFuture ... done
[11:41:52.743] result() for ClusterFuture ...
[11:41:52.743] - result already collected: FutureResult
[11:41:52.743] result() for ClusterFuture ... done
[11:41:52.743] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:52.743] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:52.785] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:52.788] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:52.790] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:52.790] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:52.833] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:52.834] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:52.834] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:52.835] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:52.835] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:52.835] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:52.836] MultisessionFuture started
[11:41:52.836] - Launch lazy future ... done
[11:41:52.836] run() for ‘MultisessionFuture’ ... done
[11:41:52.836] Created future:
[11:41:52.836] MultisessionFuture:
[11:41:52.836] Label: ‘future_mapply-39’
[11:41:52.836] Expression:
[11:41:52.836] {
[11:41:52.836]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:52.836]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:52.836]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:52.836]         on.exit(options(oopts), add = TRUE)
[11:41:52.836]     }
[11:41:52.836]     {
[11:41:52.836]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:52.836]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:52.836]                 inherits = FALSE)
[11:41:52.836]             ...future.FUN(...)
[11:41:52.836]         }
[11:41:52.836]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:52.836]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:52.836]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:52.836]         do.call(mapply, args = args)
[11:41:52.836]     }
[11:41:52.836] }
[11:41:52.836] Lazy evaluation: FALSE
[11:41:52.836] Asynchronous evaluation: TRUE
[11:41:52.836] Local evaluation: TRUE
[11:41:52.836] Environment: 0x560ef58e1768
[11:41:52.836] Capture standard output: TRUE
[11:41:52.836] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:52.836] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:52.836] Packages: 1 packages (‘mlr3’)
[11:41:52.836] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:52.836] Resolved: FALSE
[11:41:52.836] Value: <not collected>
[11:41:52.836] Conditions captured: <none>
[11:41:52.836] Early signaling: FALSE
[11:41:52.836] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:52.836] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:52.855] Chunk #39 of 90 ... DONE
[11:41:52.856] Chunk #40 of 90 ...
[11:41:52.856]  - seeds: [1] <seeds>
[11:41:52.856] getGlobalsAndPackages() ...
[11:41:52.856] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:52.856] Resolving globals: FALSE
[11:41:52.856] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:52.857] - packages: [1] ‘mlr3’
[11:41:52.857] getGlobalsAndPackages() ... DONE
[11:41:52.857] run() for ‘Future’ ...
[11:41:52.857] - state: ‘created’
[11:41:52.857] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:52.867] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:52.867] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:52.867]   - Field: ‘node’
[11:41:52.867]   - Field: ‘label’
[11:41:52.867]   - Field: ‘local’
[11:41:52.867]   - Field: ‘owner’
[11:41:52.867]   - Field: ‘envir’
[11:41:52.867]   - Field: ‘workers’
[11:41:52.867]   - Field: ‘packages’
[11:41:52.867]   - Field: ‘gc’
[11:41:52.867]   - Field: ‘conditions’
[11:41:52.867]   - Field: ‘persistent’
[11:41:52.867]   - Field: ‘expr’
[11:41:52.868]   - Field: ‘uuid’
[11:41:52.868]   - Field: ‘seed’
[11:41:52.868]   - Field: ‘version’
[11:41:52.868]   - Field: ‘result’
[11:41:52.868]   - Field: ‘asynchronous’
[11:41:52.868]   - Field: ‘calls’
[11:41:52.868]   - Field: ‘globals’
[11:41:52.868]   - Field: ‘stdout’
[11:41:52.868]   - Field: ‘earlySignal’
[11:41:52.868]   - Field: ‘lazy’
[11:41:52.868]   - Field: ‘state’
[11:41:52.868] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:52.868] - Launch lazy future ...
[11:41:52.868] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:52.868] Packages needed by future strategies (n = 0): <none>
[11:41:52.869] {
[11:41:52.869]     {
[11:41:52.869]         {
[11:41:52.869]             ...future.startTime <- base::Sys.time()
[11:41:52.869]             {
[11:41:52.869]                 {
[11:41:52.869]                   {
[11:41:52.869]                     {
[11:41:52.869]                       {
[11:41:52.869]                         base::local({
[11:41:52.869]                           has_future <- base::requireNamespace("future", 
[11:41:52.869]                             quietly = TRUE)
[11:41:52.869]                           if (has_future) {
[11:41:52.869]                             ns <- base::getNamespace("future")
[11:41:52.869]                             version <- ns[[".package"]][["version"]]
[11:41:52.869]                             if (is.null(version)) 
[11:41:52.869]                               version <- utils::packageVersion("future")
[11:41:52.869]                           }
[11:41:52.869]                           else {
[11:41:52.869]                             version <- NULL
[11:41:52.869]                           }
[11:41:52.869]                           if (!has_future || version < "1.8.0") {
[11:41:52.869]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:52.869]                               "", base::R.version$version.string), 
[11:41:52.869]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:52.869]                                 base::R.version$platform, 8 * 
[11:41:52.869]                                   base::.Machine$sizeof.pointer), 
[11:41:52.869]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:52.869]                                 "release", "version")], collapse = " "), 
[11:41:52.869]                               hostname = base::Sys.info()[["nodename"]])
[11:41:52.869]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:52.869]                               info)
[11:41:52.869]                             info <- base::paste(info, collapse = "; ")
[11:41:52.869]                             if (!has_future) {
[11:41:52.869]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:52.869]                                 info)
[11:41:52.869]                             }
[11:41:52.869]                             else {
[11:41:52.869]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:52.869]                                 info, version)
[11:41:52.869]                             }
[11:41:52.869]                             base::stop(msg)
[11:41:52.869]                           }
[11:41:52.869]                         })
[11:41:52.869]                       }
[11:41:52.869]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:52.869]                       base::options(mc.cores = 1L)
[11:41:52.869]                     }
[11:41:52.869]                     base::local({
[11:41:52.869]                       for (pkg in "mlr3") {
[11:41:52.869]                         base::loadNamespace(pkg)
[11:41:52.869]                         base::library(pkg, character.only = TRUE)
[11:41:52.869]                       }
[11:41:52.869]                     })
[11:41:52.869]                   }
[11:41:52.869]                   options(future.plan = NULL)
[11:41:52.869]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:52.869]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:52.869]                 }
[11:41:52.869]                 ...future.workdir <- getwd()
[11:41:52.869]             }
[11:41:52.869]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:52.869]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:52.869]         }
[11:41:52.869]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:52.869]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:52.869]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:52.869]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:52.869]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:52.869]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:52.869]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:52.869]             base::names(...future.oldOptions))
[11:41:52.869]     }
[11:41:52.869]     if (FALSE) {
[11:41:52.869]     }
[11:41:52.869]     else {
[11:41:52.869]         if (TRUE) {
[11:41:52.869]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:52.869]                 open = "w")
[11:41:52.869]         }
[11:41:52.869]         else {
[11:41:52.869]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:52.869]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:52.869]         }
[11:41:52.869]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:52.869]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:52.869]             base::sink(type = "output", split = FALSE)
[11:41:52.869]             base::close(...future.stdout)
[11:41:52.869]         }, add = TRUE)
[11:41:52.869]     }
[11:41:52.869]     ...future.frame <- base::sys.nframe()
[11:41:52.869]     ...future.conditions <- base::list()
[11:41:52.869]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:52.869]     if (FALSE) {
[11:41:52.869]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:52.869]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:52.869]     }
[11:41:52.869]     ...future.result <- base::tryCatch({
[11:41:52.869]         base::withCallingHandlers({
[11:41:52.869]             ...future.value <- base::withVisible(base::local({
[11:41:52.869]                 ...future.makeSendCondition <- local({
[11:41:52.869]                   sendCondition <- NULL
[11:41:52.869]                   function(frame = 1L) {
[11:41:52.869]                     if (is.function(sendCondition)) 
[11:41:52.869]                       return(sendCondition)
[11:41:52.869]                     ns <- getNamespace("parallel")
[11:41:52.869]                     if (exists("sendData", mode = "function", 
[11:41:52.869]                       envir = ns)) {
[11:41:52.869]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:52.869]                         envir = ns)
[11:41:52.869]                       envir <- sys.frame(frame)
[11:41:52.869]                       master <- NULL
[11:41:52.869]                       while (!identical(envir, .GlobalEnv) && 
[11:41:52.869]                         !identical(envir, emptyenv())) {
[11:41:52.869]                         if (exists("master", mode = "list", envir = envir, 
[11:41:52.869]                           inherits = FALSE)) {
[11:41:52.869]                           master <- get("master", mode = "list", 
[11:41:52.869]                             envir = envir, inherits = FALSE)
[11:41:52.869]                           if (inherits(master, c("SOCKnode", 
[11:41:52.869]                             "SOCK0node"))) {
[11:41:52.869]                             sendCondition <<- function(cond) {
[11:41:52.869]                               data <- list(type = "VALUE", value = cond, 
[11:41:52.869]                                 success = TRUE)
[11:41:52.869]                               parallel_sendData(master, data)
[11:41:52.869]                             }
[11:41:52.869]                             return(sendCondition)
[11:41:52.869]                           }
[11:41:52.869]                         }
[11:41:52.869]                         frame <- frame + 1L
[11:41:52.869]                         envir <- sys.frame(frame)
[11:41:52.869]                       }
[11:41:52.869]                     }
[11:41:52.869]                     sendCondition <<- function(cond) NULL
[11:41:52.869]                   }
[11:41:52.869]                 })
[11:41:52.869]                 withCallingHandlers({
[11:41:52.869]                   {
[11:41:52.869]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:52.869]                     if (!identical(...future.globals.maxSize.org, 
[11:41:52.869]                       ...future.globals.maxSize)) {
[11:41:52.869]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:52.869]                       on.exit(options(oopts), add = TRUE)
[11:41:52.869]                     }
[11:41:52.869]                     {
[11:41:52.869]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:52.869]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:52.869]                           envir = globalenv(), inherits = FALSE)
[11:41:52.869]                         ...future.FUN(...)
[11:41:52.869]                       }
[11:41:52.869]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:52.869]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:52.869]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:52.869]                         USE.NAMES = FALSE)
[11:41:52.869]                       do.call(mapply, args = args)
[11:41:52.869]                     }
[11:41:52.869]                   }
[11:41:52.869]                 }, immediateCondition = function(cond) {
[11:41:52.869]                   sendCondition <- ...future.makeSendCondition()
[11:41:52.869]                   sendCondition(cond)
[11:41:52.869]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:52.869]                   {
[11:41:52.869]                     inherits <- base::inherits
[11:41:52.869]                     invokeRestart <- base::invokeRestart
[11:41:52.869]                     is.null <- base::is.null
[11:41:52.869]                     muffled <- FALSE
[11:41:52.869]                     if (inherits(cond, "message")) {
[11:41:52.869]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:52.869]                       if (muffled) 
[11:41:52.869]                         invokeRestart("muffleMessage")
[11:41:52.869]                     }
[11:41:52.869]                     else if (inherits(cond, "warning")) {
[11:41:52.869]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:52.869]                       if (muffled) 
[11:41:52.869]                         invokeRestart("muffleWarning")
[11:41:52.869]                     }
[11:41:52.869]                     else if (inherits(cond, "condition")) {
[11:41:52.869]                       if (!is.null(pattern)) {
[11:41:52.869]                         computeRestarts <- base::computeRestarts
[11:41:52.869]                         grepl <- base::grepl
[11:41:52.869]                         restarts <- computeRestarts(cond)
[11:41:52.869]                         for (restart in restarts) {
[11:41:52.869]                           name <- restart$name
[11:41:52.869]                           if (is.null(name)) 
[11:41:52.869]                             next
[11:41:52.869]                           if (!grepl(pattern, name)) 
[11:41:52.869]                             next
[11:41:52.869]                           invokeRestart(restart)
[11:41:52.869]                           muffled <- TRUE
[11:41:52.869]                           break
[11:41:52.869]                         }
[11:41:52.869]                       }
[11:41:52.869]                     }
[11:41:52.869]                     invisible(muffled)
[11:41:52.869]                   }
[11:41:52.869]                   muffleCondition(cond)
[11:41:52.869]                 })
[11:41:52.869]             }))
[11:41:52.869]             future::FutureResult(value = ...future.value$value, 
[11:41:52.869]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:52.869]                   ...future.rng), globalenv = if (FALSE) 
[11:41:52.869]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:52.869]                     ...future.globalenv.names))
[11:41:52.869]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:52.869]         }, condition = base::local({
[11:41:52.869]             c <- base::c
[11:41:52.869]             inherits <- base::inherits
[11:41:52.869]             invokeRestart <- base::invokeRestart
[11:41:52.869]             length <- base::length
[11:41:52.869]             list <- base::list
[11:41:52.869]             seq.int <- base::seq.int
[11:41:52.869]             signalCondition <- base::signalCondition
[11:41:52.869]             sys.calls <- base::sys.calls
[11:41:52.869]             `[[` <- base::`[[`
[11:41:52.869]             `+` <- base::`+`
[11:41:52.869]             `<<-` <- base::`<<-`
[11:41:52.869]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:52.869]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:52.869]                   3L)]
[11:41:52.869]             }
[11:41:52.869]             function(cond) {
[11:41:52.869]                 is_error <- inherits(cond, "error")
[11:41:52.869]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:52.869]                   NULL)
[11:41:52.869]                 if (is_error) {
[11:41:52.869]                   sessionInformation <- function() {
[11:41:52.869]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:52.869]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:52.869]                       search = base::search(), system = base::Sys.info())
[11:41:52.869]                   }
[11:41:52.869]                   ...future.conditions[[length(...future.conditions) + 
[11:41:52.869]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:52.869]                     cond$call), session = sessionInformation(), 
[11:41:52.869]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:52.869]                   signalCondition(cond)
[11:41:52.869]                 }
[11:41:52.869]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:52.869]                 "immediateCondition"))) {
[11:41:52.869]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:52.869]                   ...future.conditions[[length(...future.conditions) + 
[11:41:52.869]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:52.869]                   if (TRUE && !signal) {
[11:41:52.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:52.869]                     {
[11:41:52.869]                       inherits <- base::inherits
[11:41:52.869]                       invokeRestart <- base::invokeRestart
[11:41:52.869]                       is.null <- base::is.null
[11:41:52.869]                       muffled <- FALSE
[11:41:52.869]                       if (inherits(cond, "message")) {
[11:41:52.869]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:52.869]                         if (muffled) 
[11:41:52.869]                           invokeRestart("muffleMessage")
[11:41:52.869]                       }
[11:41:52.869]                       else if (inherits(cond, "warning")) {
[11:41:52.869]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:52.869]                         if (muffled) 
[11:41:52.869]                           invokeRestart("muffleWarning")
[11:41:52.869]                       }
[11:41:52.869]                       else if (inherits(cond, "condition")) {
[11:41:52.869]                         if (!is.null(pattern)) {
[11:41:52.869]                           computeRestarts <- base::computeRestarts
[11:41:52.869]                           grepl <- base::grepl
[11:41:52.869]                           restarts <- computeRestarts(cond)
[11:41:52.869]                           for (restart in restarts) {
[11:41:52.869]                             name <- restart$name
[11:41:52.869]                             if (is.null(name)) 
[11:41:52.869]                               next
[11:41:52.869]                             if (!grepl(pattern, name)) 
[11:41:52.869]                               next
[11:41:52.869]                             invokeRestart(restart)
[11:41:52.869]                             muffled <- TRUE
[11:41:52.869]                             break
[11:41:52.869]                           }
[11:41:52.869]                         }
[11:41:52.869]                       }
[11:41:52.869]                       invisible(muffled)
[11:41:52.869]                     }
[11:41:52.869]                     muffleCondition(cond, pattern = "^muffle")
[11:41:52.869]                   }
[11:41:52.869]                 }
[11:41:52.869]                 else {
[11:41:52.869]                   if (TRUE) {
[11:41:52.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:52.869]                     {
[11:41:52.869]                       inherits <- base::inherits
[11:41:52.869]                       invokeRestart <- base::invokeRestart
[11:41:52.869]                       is.null <- base::is.null
[11:41:52.869]                       muffled <- FALSE
[11:41:52.869]                       if (inherits(cond, "message")) {
[11:41:52.869]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:52.869]                         if (muffled) 
[11:41:52.869]                           invokeRestart("muffleMessage")
[11:41:52.869]                       }
[11:41:52.869]                       else if (inherits(cond, "warning")) {
[11:41:52.869]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:52.869]                         if (muffled) 
[11:41:52.869]                           invokeRestart("muffleWarning")
[11:41:52.869]                       }
[11:41:52.869]                       else if (inherits(cond, "condition")) {
[11:41:52.869]                         if (!is.null(pattern)) {
[11:41:52.869]                           computeRestarts <- base::computeRestarts
[11:41:52.869]                           grepl <- base::grepl
[11:41:52.869]                           restarts <- computeRestarts(cond)
[11:41:52.869]                           for (restart in restarts) {
[11:41:52.869]                             name <- restart$name
[11:41:52.869]                             if (is.null(name)) 
[11:41:52.869]                               next
[11:41:52.869]                             if (!grepl(pattern, name)) 
[11:41:52.869]                               next
[11:41:52.869]                             invokeRestart(restart)
[11:41:52.869]                             muffled <- TRUE
[11:41:52.869]                             break
[11:41:52.869]                           }
[11:41:52.869]                         }
[11:41:52.869]                       }
[11:41:52.869]                       invisible(muffled)
[11:41:52.869]                     }
[11:41:52.869]                     muffleCondition(cond, pattern = "^muffle")
[11:41:52.869]                   }
[11:41:52.869]                 }
[11:41:52.869]             }
[11:41:52.869]         }))
[11:41:52.869]     }, error = function(ex) {
[11:41:52.869]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:52.869]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:52.869]                 ...future.rng), started = ...future.startTime, 
[11:41:52.869]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:52.869]             version = "1.8"), class = "FutureResult")
[11:41:52.869]     }, finally = {
[11:41:52.869]         if (!identical(...future.workdir, getwd())) 
[11:41:52.869]             setwd(...future.workdir)
[11:41:52.869]         {
[11:41:52.869]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:52.869]                 ...future.oldOptions$nwarnings <- NULL
[11:41:52.869]             }
[11:41:52.869]             base::options(...future.oldOptions)
[11:41:52.869]             if (.Platform$OS.type == "windows") {
[11:41:52.869]                 old_names <- names(...future.oldEnvVars)
[11:41:52.869]                 envs <- base::Sys.getenv()
[11:41:52.869]                 names <- names(envs)
[11:41:52.869]                 common <- intersect(names, old_names)
[11:41:52.869]                 added <- setdiff(names, old_names)
[11:41:52.869]                 removed <- setdiff(old_names, names)
[11:41:52.869]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:52.869]                   envs[common]]
[11:41:52.869]                 NAMES <- toupper(changed)
[11:41:52.869]                 args <- list()
[11:41:52.869]                 for (kk in seq_along(NAMES)) {
[11:41:52.869]                   name <- changed[[kk]]
[11:41:52.869]                   NAME <- NAMES[[kk]]
[11:41:52.869]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:52.869]                     next
[11:41:52.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:52.869]                 }
[11:41:52.869]                 NAMES <- toupper(added)
[11:41:52.869]                 for (kk in seq_along(NAMES)) {
[11:41:52.869]                   name <- added[[kk]]
[11:41:52.869]                   NAME <- NAMES[[kk]]
[11:41:52.869]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:52.869]                     next
[11:41:52.869]                   args[[name]] <- ""
[11:41:52.869]                 }
[11:41:52.869]                 NAMES <- toupper(removed)
[11:41:52.869]                 for (kk in seq_along(NAMES)) {
[11:41:52.869]                   name <- removed[[kk]]
[11:41:52.869]                   NAME <- NAMES[[kk]]
[11:41:52.869]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:52.869]                     next
[11:41:52.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:52.869]                 }
[11:41:52.869]                 if (length(args) > 0) 
[11:41:52.869]                   base::do.call(base::Sys.setenv, args = args)
[11:41:52.869]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:52.869]             }
[11:41:52.869]             else {
[11:41:52.869]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:52.869]             }
[11:41:52.869]             {
[11:41:52.869]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:52.869]                   0L) {
[11:41:52.869]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:52.869]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:52.869]                   base::options(opts)
[11:41:52.869]                 }
[11:41:52.869]                 {
[11:41:52.869]                   {
[11:41:52.869]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:52.869]                     NULL
[11:41:52.869]                   }
[11:41:52.869]                   options(future.plan = NULL)
[11:41:52.869]                   if (is.na(NA_character_)) 
[11:41:52.869]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:52.869]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:52.869]                   future::plan(list(function (..., workers = 2, 
[11:41:52.869]                     envir = parent.frame()) 
[11:41:52.869]                   strategy(..., workers = workers, envir = envir)), 
[11:41:52.869]                     .cleanup = FALSE, .init = FALSE)
[11:41:52.869]                 }
[11:41:52.869]             }
[11:41:52.869]         }
[11:41:52.869]     })
[11:41:52.869]     if (TRUE) {
[11:41:52.869]         base::sink(type = "output", split = FALSE)
[11:41:52.869]         if (TRUE) {
[11:41:52.869]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:52.869]         }
[11:41:52.869]         else {
[11:41:52.869]             ...future.result["stdout"] <- base::list(NULL)
[11:41:52.869]         }
[11:41:52.869]         base::close(...future.stdout)
[11:41:52.869]         ...future.stdout <- NULL
[11:41:52.869]     }
[11:41:52.869]     ...future.result$conditions <- ...future.conditions
[11:41:52.869]     ...future.result$finished <- base::Sys.time()
[11:41:52.869]     ...future.result
[11:41:52.869] }
[11:41:52.871] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:52.882] receiveMessageFromWorker() for ClusterFuture ...
[11:41:52.882] - Validating connection of MultisessionFuture
[11:41:52.882] - received message: FutureResult
[11:41:52.882] - Received FutureResult
[11:41:52.882] - Erased future from FutureRegistry
[11:41:52.882] result() for ClusterFuture ...
[11:41:52.883] - result already collected: FutureResult
[11:41:52.883] result() for ClusterFuture ... done
[11:41:52.883] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:52.883] result() for ClusterFuture ...
[11:41:52.883] - result already collected: FutureResult
[11:41:52.883] result() for ClusterFuture ... done
[11:41:52.883] result() for ClusterFuture ...
[11:41:52.883] - result already collected: FutureResult
[11:41:52.883] result() for ClusterFuture ... done
[11:41:52.884] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:52.884] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:52.933] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:52.938] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:52.981] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:52.982] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:53.025] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:53.026] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:53.026] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:53.026] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:53.027] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:53.027] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:53.028] MultisessionFuture started
[11:41:53.028] - Launch lazy future ... done
[11:41:53.028] run() for ‘MultisessionFuture’ ... done
[11:41:53.028] Created future:
[11:41:53.028] MultisessionFuture:
[11:41:53.028] Label: ‘future_mapply-40’
[11:41:53.028] Expression:
[11:41:53.028] {
[11:41:53.028]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:53.028]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:53.028]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:53.028]         on.exit(options(oopts), add = TRUE)
[11:41:53.028]     }
[11:41:53.028]     {
[11:41:53.028]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:53.028]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:53.028]                 inherits = FALSE)
[11:41:53.028]             ...future.FUN(...)
[11:41:53.028]         }
[11:41:53.028]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:53.028]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:53.028]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:53.028]         do.call(mapply, args = args)
[11:41:53.028]     }
[11:41:53.028] }
[11:41:53.028] Lazy evaluation: FALSE
[11:41:53.028] Asynchronous evaluation: TRUE
[11:41:53.028] Local evaluation: TRUE
[11:41:53.028] Environment: 0x560ef58e1768
[11:41:53.028] Capture standard output: TRUE
[11:41:53.028] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:53.028] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:53.028] Packages: 1 packages (‘mlr3’)
[11:41:53.028] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:53.028] Resolved: FALSE
[11:41:53.028] Value: <not collected>
[11:41:53.028] Conditions captured: <none>
[11:41:53.028] Early signaling: FALSE
[11:41:53.028] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:53.028] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:53.045] Chunk #40 of 90 ... DONE
[11:41:53.045] Chunk #41 of 90 ...
[11:41:53.045]  - seeds: [1] <seeds>
[11:41:53.045] getGlobalsAndPackages() ...
[11:41:53.046] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:53.046] Resolving globals: FALSE
[11:41:53.046] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:53.047] - packages: [1] ‘mlr3’
[11:41:53.047] getGlobalsAndPackages() ... DONE
[11:41:53.047] run() for ‘Future’ ...
[11:41:53.047] - state: ‘created’
[11:41:53.047] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:53.063] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:53.063] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:53.063]   - Field: ‘node’
[11:41:53.063]   - Field: ‘label’
[11:41:53.063]   - Field: ‘local’
[11:41:53.063]   - Field: ‘owner’
[11:41:53.063]   - Field: ‘envir’
[11:41:53.063]   - Field: ‘workers’
[11:41:53.064]   - Field: ‘packages’
[11:41:53.064]   - Field: ‘gc’
[11:41:53.064]   - Field: ‘conditions’
[11:41:53.064]   - Field: ‘persistent’
[11:41:53.064]   - Field: ‘expr’
[11:41:53.064]   - Field: ‘uuid’
[11:41:53.064]   - Field: ‘seed’
[11:41:53.064]   - Field: ‘version’
[11:41:53.064]   - Field: ‘result’
[11:41:53.064]   - Field: ‘asynchronous’
[11:41:53.064]   - Field: ‘calls’
[11:41:53.065]   - Field: ‘globals’
[11:41:53.065]   - Field: ‘stdout’
[11:41:53.065]   - Field: ‘earlySignal’
[11:41:53.065]   - Field: ‘lazy’
[11:41:53.065]   - Field: ‘state’
[11:41:53.065] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:53.065] - Launch lazy future ...
[11:41:53.065] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:53.066] Packages needed by future strategies (n = 0): <none>
[11:41:53.066] {
[11:41:53.066]     {
[11:41:53.066]         {
[11:41:53.066]             ...future.startTime <- base::Sys.time()
[11:41:53.066]             {
[11:41:53.066]                 {
[11:41:53.066]                   {
[11:41:53.066]                     {
[11:41:53.066]                       {
[11:41:53.066]                         base::local({
[11:41:53.066]                           has_future <- base::requireNamespace("future", 
[11:41:53.066]                             quietly = TRUE)
[11:41:53.066]                           if (has_future) {
[11:41:53.066]                             ns <- base::getNamespace("future")
[11:41:53.066]                             version <- ns[[".package"]][["version"]]
[11:41:53.066]                             if (is.null(version)) 
[11:41:53.066]                               version <- utils::packageVersion("future")
[11:41:53.066]                           }
[11:41:53.066]                           else {
[11:41:53.066]                             version <- NULL
[11:41:53.066]                           }
[11:41:53.066]                           if (!has_future || version < "1.8.0") {
[11:41:53.066]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:53.066]                               "", base::R.version$version.string), 
[11:41:53.066]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:53.066]                                 base::R.version$platform, 8 * 
[11:41:53.066]                                   base::.Machine$sizeof.pointer), 
[11:41:53.066]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:53.066]                                 "release", "version")], collapse = " "), 
[11:41:53.066]                               hostname = base::Sys.info()[["nodename"]])
[11:41:53.066]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:53.066]                               info)
[11:41:53.066]                             info <- base::paste(info, collapse = "; ")
[11:41:53.066]                             if (!has_future) {
[11:41:53.066]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:53.066]                                 info)
[11:41:53.066]                             }
[11:41:53.066]                             else {
[11:41:53.066]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:53.066]                                 info, version)
[11:41:53.066]                             }
[11:41:53.066]                             base::stop(msg)
[11:41:53.066]                           }
[11:41:53.066]                         })
[11:41:53.066]                       }
[11:41:53.066]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:53.066]                       base::options(mc.cores = 1L)
[11:41:53.066]                     }
[11:41:53.066]                     base::local({
[11:41:53.066]                       for (pkg in "mlr3") {
[11:41:53.066]                         base::loadNamespace(pkg)
[11:41:53.066]                         base::library(pkg, character.only = TRUE)
[11:41:53.066]                       }
[11:41:53.066]                     })
[11:41:53.066]                   }
[11:41:53.066]                   options(future.plan = NULL)
[11:41:53.066]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:53.066]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:53.066]                 }
[11:41:53.066]                 ...future.workdir <- getwd()
[11:41:53.066]             }
[11:41:53.066]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:53.066]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:53.066]         }
[11:41:53.066]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:53.066]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:53.066]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:53.066]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:53.066]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:53.066]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:53.066]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:53.066]             base::names(...future.oldOptions))
[11:41:53.066]     }
[11:41:53.066]     if (FALSE) {
[11:41:53.066]     }
[11:41:53.066]     else {
[11:41:53.066]         if (TRUE) {
[11:41:53.066]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:53.066]                 open = "w")
[11:41:53.066]         }
[11:41:53.066]         else {
[11:41:53.066]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:53.066]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:53.066]         }
[11:41:53.066]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:53.066]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:53.066]             base::sink(type = "output", split = FALSE)
[11:41:53.066]             base::close(...future.stdout)
[11:41:53.066]         }, add = TRUE)
[11:41:53.066]     }
[11:41:53.066]     ...future.frame <- base::sys.nframe()
[11:41:53.066]     ...future.conditions <- base::list()
[11:41:53.066]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:53.066]     if (FALSE) {
[11:41:53.066]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:53.066]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:53.066]     }
[11:41:53.066]     ...future.result <- base::tryCatch({
[11:41:53.066]         base::withCallingHandlers({
[11:41:53.066]             ...future.value <- base::withVisible(base::local({
[11:41:53.066]                 ...future.makeSendCondition <- local({
[11:41:53.066]                   sendCondition <- NULL
[11:41:53.066]                   function(frame = 1L) {
[11:41:53.066]                     if (is.function(sendCondition)) 
[11:41:53.066]                       return(sendCondition)
[11:41:53.066]                     ns <- getNamespace("parallel")
[11:41:53.066]                     if (exists("sendData", mode = "function", 
[11:41:53.066]                       envir = ns)) {
[11:41:53.066]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:53.066]                         envir = ns)
[11:41:53.066]                       envir <- sys.frame(frame)
[11:41:53.066]                       master <- NULL
[11:41:53.066]                       while (!identical(envir, .GlobalEnv) && 
[11:41:53.066]                         !identical(envir, emptyenv())) {
[11:41:53.066]                         if (exists("master", mode = "list", envir = envir, 
[11:41:53.066]                           inherits = FALSE)) {
[11:41:53.066]                           master <- get("master", mode = "list", 
[11:41:53.066]                             envir = envir, inherits = FALSE)
[11:41:53.066]                           if (inherits(master, c("SOCKnode", 
[11:41:53.066]                             "SOCK0node"))) {
[11:41:53.066]                             sendCondition <<- function(cond) {
[11:41:53.066]                               data <- list(type = "VALUE", value = cond, 
[11:41:53.066]                                 success = TRUE)
[11:41:53.066]                               parallel_sendData(master, data)
[11:41:53.066]                             }
[11:41:53.066]                             return(sendCondition)
[11:41:53.066]                           }
[11:41:53.066]                         }
[11:41:53.066]                         frame <- frame + 1L
[11:41:53.066]                         envir <- sys.frame(frame)
[11:41:53.066]                       }
[11:41:53.066]                     }
[11:41:53.066]                     sendCondition <<- function(cond) NULL
[11:41:53.066]                   }
[11:41:53.066]                 })
[11:41:53.066]                 withCallingHandlers({
[11:41:53.066]                   {
[11:41:53.066]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:53.066]                     if (!identical(...future.globals.maxSize.org, 
[11:41:53.066]                       ...future.globals.maxSize)) {
[11:41:53.066]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:53.066]                       on.exit(options(oopts), add = TRUE)
[11:41:53.066]                     }
[11:41:53.066]                     {
[11:41:53.066]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:53.066]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:53.066]                           envir = globalenv(), inherits = FALSE)
[11:41:53.066]                         ...future.FUN(...)
[11:41:53.066]                       }
[11:41:53.066]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:53.066]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:53.066]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:53.066]                         USE.NAMES = FALSE)
[11:41:53.066]                       do.call(mapply, args = args)
[11:41:53.066]                     }
[11:41:53.066]                   }
[11:41:53.066]                 }, immediateCondition = function(cond) {
[11:41:53.066]                   sendCondition <- ...future.makeSendCondition()
[11:41:53.066]                   sendCondition(cond)
[11:41:53.066]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:53.066]                   {
[11:41:53.066]                     inherits <- base::inherits
[11:41:53.066]                     invokeRestart <- base::invokeRestart
[11:41:53.066]                     is.null <- base::is.null
[11:41:53.066]                     muffled <- FALSE
[11:41:53.066]                     if (inherits(cond, "message")) {
[11:41:53.066]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:53.066]                       if (muffled) 
[11:41:53.066]                         invokeRestart("muffleMessage")
[11:41:53.066]                     }
[11:41:53.066]                     else if (inherits(cond, "warning")) {
[11:41:53.066]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:53.066]                       if (muffled) 
[11:41:53.066]                         invokeRestart("muffleWarning")
[11:41:53.066]                     }
[11:41:53.066]                     else if (inherits(cond, "condition")) {
[11:41:53.066]                       if (!is.null(pattern)) {
[11:41:53.066]                         computeRestarts <- base::computeRestarts
[11:41:53.066]                         grepl <- base::grepl
[11:41:53.066]                         restarts <- computeRestarts(cond)
[11:41:53.066]                         for (restart in restarts) {
[11:41:53.066]                           name <- restart$name
[11:41:53.066]                           if (is.null(name)) 
[11:41:53.066]                             next
[11:41:53.066]                           if (!grepl(pattern, name)) 
[11:41:53.066]                             next
[11:41:53.066]                           invokeRestart(restart)
[11:41:53.066]                           muffled <- TRUE
[11:41:53.066]                           break
[11:41:53.066]                         }
[11:41:53.066]                       }
[11:41:53.066]                     }
[11:41:53.066]                     invisible(muffled)
[11:41:53.066]                   }
[11:41:53.066]                   muffleCondition(cond)
[11:41:53.066]                 })
[11:41:53.066]             }))
[11:41:53.066]             future::FutureResult(value = ...future.value$value, 
[11:41:53.066]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:53.066]                   ...future.rng), globalenv = if (FALSE) 
[11:41:53.066]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:53.066]                     ...future.globalenv.names))
[11:41:53.066]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:53.066]         }, condition = base::local({
[11:41:53.066]             c <- base::c
[11:41:53.066]             inherits <- base::inherits
[11:41:53.066]             invokeRestart <- base::invokeRestart
[11:41:53.066]             length <- base::length
[11:41:53.066]             list <- base::list
[11:41:53.066]             seq.int <- base::seq.int
[11:41:53.066]             signalCondition <- base::signalCondition
[11:41:53.066]             sys.calls <- base::sys.calls
[11:41:53.066]             `[[` <- base::`[[`
[11:41:53.066]             `+` <- base::`+`
[11:41:53.066]             `<<-` <- base::`<<-`
[11:41:53.066]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:53.066]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:53.066]                   3L)]
[11:41:53.066]             }
[11:41:53.066]             function(cond) {
[11:41:53.066]                 is_error <- inherits(cond, "error")
[11:41:53.066]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:53.066]                   NULL)
[11:41:53.066]                 if (is_error) {
[11:41:53.066]                   sessionInformation <- function() {
[11:41:53.066]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:53.066]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:53.066]                       search = base::search(), system = base::Sys.info())
[11:41:53.066]                   }
[11:41:53.066]                   ...future.conditions[[length(...future.conditions) + 
[11:41:53.066]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:53.066]                     cond$call), session = sessionInformation(), 
[11:41:53.066]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:53.066]                   signalCondition(cond)
[11:41:53.066]                 }
[11:41:53.066]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:53.066]                 "immediateCondition"))) {
[11:41:53.066]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:53.066]                   ...future.conditions[[length(...future.conditions) + 
[11:41:53.066]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:53.066]                   if (TRUE && !signal) {
[11:41:53.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:53.066]                     {
[11:41:53.066]                       inherits <- base::inherits
[11:41:53.066]                       invokeRestart <- base::invokeRestart
[11:41:53.066]                       is.null <- base::is.null
[11:41:53.066]                       muffled <- FALSE
[11:41:53.066]                       if (inherits(cond, "message")) {
[11:41:53.066]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:53.066]                         if (muffled) 
[11:41:53.066]                           invokeRestart("muffleMessage")
[11:41:53.066]                       }
[11:41:53.066]                       else if (inherits(cond, "warning")) {
[11:41:53.066]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:53.066]                         if (muffled) 
[11:41:53.066]                           invokeRestart("muffleWarning")
[11:41:53.066]                       }
[11:41:53.066]                       else if (inherits(cond, "condition")) {
[11:41:53.066]                         if (!is.null(pattern)) {
[11:41:53.066]                           computeRestarts <- base::computeRestarts
[11:41:53.066]                           grepl <- base::grepl
[11:41:53.066]                           restarts <- computeRestarts(cond)
[11:41:53.066]                           for (restart in restarts) {
[11:41:53.066]                             name <- restart$name
[11:41:53.066]                             if (is.null(name)) 
[11:41:53.066]                               next
[11:41:53.066]                             if (!grepl(pattern, name)) 
[11:41:53.066]                               next
[11:41:53.066]                             invokeRestart(restart)
[11:41:53.066]                             muffled <- TRUE
[11:41:53.066]                             break
[11:41:53.066]                           }
[11:41:53.066]                         }
[11:41:53.066]                       }
[11:41:53.066]                       invisible(muffled)
[11:41:53.066]                     }
[11:41:53.066]                     muffleCondition(cond, pattern = "^muffle")
[11:41:53.066]                   }
[11:41:53.066]                 }
[11:41:53.066]                 else {
[11:41:53.066]                   if (TRUE) {
[11:41:53.066]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:53.066]                     {
[11:41:53.066]                       inherits <- base::inherits
[11:41:53.066]                       invokeRestart <- base::invokeRestart
[11:41:53.066]                       is.null <- base::is.null
[11:41:53.066]                       muffled <- FALSE
[11:41:53.066]                       if (inherits(cond, "message")) {
[11:41:53.066]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:53.066]                         if (muffled) 
[11:41:53.066]                           invokeRestart("muffleMessage")
[11:41:53.066]                       }
[11:41:53.066]                       else if (inherits(cond, "warning")) {
[11:41:53.066]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:53.066]                         if (muffled) 
[11:41:53.066]                           invokeRestart("muffleWarning")
[11:41:53.066]                       }
[11:41:53.066]                       else if (inherits(cond, "condition")) {
[11:41:53.066]                         if (!is.null(pattern)) {
[11:41:53.066]                           computeRestarts <- base::computeRestarts
[11:41:53.066]                           grepl <- base::grepl
[11:41:53.066]                           restarts <- computeRestarts(cond)
[11:41:53.066]                           for (restart in restarts) {
[11:41:53.066]                             name <- restart$name
[11:41:53.066]                             if (is.null(name)) 
[11:41:53.066]                               next
[11:41:53.066]                             if (!grepl(pattern, name)) 
[11:41:53.066]                               next
[11:41:53.066]                             invokeRestart(restart)
[11:41:53.066]                             muffled <- TRUE
[11:41:53.066]                             break
[11:41:53.066]                           }
[11:41:53.066]                         }
[11:41:53.066]                       }
[11:41:53.066]                       invisible(muffled)
[11:41:53.066]                     }
[11:41:53.066]                     muffleCondition(cond, pattern = "^muffle")
[11:41:53.066]                   }
[11:41:53.066]                 }
[11:41:53.066]             }
[11:41:53.066]         }))
[11:41:53.066]     }, error = function(ex) {
[11:41:53.066]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:53.066]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:53.066]                 ...future.rng), started = ...future.startTime, 
[11:41:53.066]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:53.066]             version = "1.8"), class = "FutureResult")
[11:41:53.066]     }, finally = {
[11:41:53.066]         if (!identical(...future.workdir, getwd())) 
[11:41:53.066]             setwd(...future.workdir)
[11:41:53.066]         {
[11:41:53.066]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:53.066]                 ...future.oldOptions$nwarnings <- NULL
[11:41:53.066]             }
[11:41:53.066]             base::options(...future.oldOptions)
[11:41:53.066]             if (.Platform$OS.type == "windows") {
[11:41:53.066]                 old_names <- names(...future.oldEnvVars)
[11:41:53.066]                 envs <- base::Sys.getenv()
[11:41:53.066]                 names <- names(envs)
[11:41:53.066]                 common <- intersect(names, old_names)
[11:41:53.066]                 added <- setdiff(names, old_names)
[11:41:53.066]                 removed <- setdiff(old_names, names)
[11:41:53.066]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:53.066]                   envs[common]]
[11:41:53.066]                 NAMES <- toupper(changed)
[11:41:53.066]                 args <- list()
[11:41:53.066]                 for (kk in seq_along(NAMES)) {
[11:41:53.066]                   name <- changed[[kk]]
[11:41:53.066]                   NAME <- NAMES[[kk]]
[11:41:53.066]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:53.066]                     next
[11:41:53.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:53.066]                 }
[11:41:53.066]                 NAMES <- toupper(added)
[11:41:53.066]                 for (kk in seq_along(NAMES)) {
[11:41:53.066]                   name <- added[[kk]]
[11:41:53.066]                   NAME <- NAMES[[kk]]
[11:41:53.066]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:53.066]                     next
[11:41:53.066]                   args[[name]] <- ""
[11:41:53.066]                 }
[11:41:53.066]                 NAMES <- toupper(removed)
[11:41:53.066]                 for (kk in seq_along(NAMES)) {
[11:41:53.066]                   name <- removed[[kk]]
[11:41:53.066]                   NAME <- NAMES[[kk]]
[11:41:53.066]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:53.066]                     next
[11:41:53.066]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:53.066]                 }
[11:41:53.066]                 if (length(args) > 0) 
[11:41:53.066]                   base::do.call(base::Sys.setenv, args = args)
[11:41:53.066]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:53.066]             }
[11:41:53.066]             else {
[11:41:53.066]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:53.066]             }
[11:41:53.066]             {
[11:41:53.066]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:53.066]                   0L) {
[11:41:53.066]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:53.066]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:53.066]                   base::options(opts)
[11:41:53.066]                 }
[11:41:53.066]                 {
[11:41:53.066]                   {
[11:41:53.066]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:53.066]                     NULL
[11:41:53.066]                   }
[11:41:53.066]                   options(future.plan = NULL)
[11:41:53.066]                   if (is.na(NA_character_)) 
[11:41:53.066]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:53.066]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:53.066]                   future::plan(list(function (..., workers = 2, 
[11:41:53.066]                     envir = parent.frame()) 
[11:41:53.066]                   strategy(..., workers = workers, envir = envir)), 
[11:41:53.066]                     .cleanup = FALSE, .init = FALSE)
[11:41:53.066]                 }
[11:41:53.066]             }
[11:41:53.066]         }
[11:41:53.066]     })
[11:41:53.066]     if (TRUE) {
[11:41:53.066]         base::sink(type = "output", split = FALSE)
[11:41:53.066]         if (TRUE) {
[11:41:53.066]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:53.066]         }
[11:41:53.066]         else {
[11:41:53.066]             ...future.result["stdout"] <- base::list(NULL)
[11:41:53.066]         }
[11:41:53.066]         base::close(...future.stdout)
[11:41:53.066]         ...future.stdout <- NULL
[11:41:53.066]     }
[11:41:53.066]     ...future.result$conditions <- ...future.conditions
[11:41:53.066]     ...future.result$finished <- base::Sys.time()
[11:41:53.066]     ...future.result
[11:41:53.066] }
[11:41:53.069] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:53.080] receiveMessageFromWorker() for ClusterFuture ...
[11:41:53.080] - Validating connection of MultisessionFuture
[11:41:53.080] - received message: FutureResult
[11:41:53.080] - Received FutureResult
[11:41:53.080] - Erased future from FutureRegistry
[11:41:53.080] result() for ClusterFuture ...
[11:41:53.080] - result already collected: FutureResult
[11:41:53.081] result() for ClusterFuture ... done
[11:41:53.081] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:53.081] result() for ClusterFuture ...
[11:41:53.081] - result already collected: FutureResult
[11:41:53.081] result() for ClusterFuture ... done
[11:41:53.081] result() for ClusterFuture ...
[11:41:53.081] - result already collected: FutureResult
[11:41:53.081] result() for ClusterFuture ... done
[11:41:53.082] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:53.082] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:53.129] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:53.136] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:53.139] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:53.140] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:53.186] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:53.187] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:53.188] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:53.189] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:53.190] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:53.190] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:53.192] MultisessionFuture started
[11:41:53.192] - Launch lazy future ... done
[11:41:53.192] run() for ‘MultisessionFuture’ ... done
[11:41:53.192] Created future:
[11:41:53.192] MultisessionFuture:
[11:41:53.192] Label: ‘future_mapply-41’
[11:41:53.192] Expression:
[11:41:53.192] {
[11:41:53.192]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:53.192]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:53.192]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:53.192]         on.exit(options(oopts), add = TRUE)
[11:41:53.192]     }
[11:41:53.192]     {
[11:41:53.192]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:53.192]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:53.192]                 inherits = FALSE)
[11:41:53.192]             ...future.FUN(...)
[11:41:53.192]         }
[11:41:53.192]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:53.192]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:53.192]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:53.192]         do.call(mapply, args = args)
[11:41:53.192]     }
[11:41:53.192] }
[11:41:53.192] Lazy evaluation: FALSE
[11:41:53.192] Asynchronous evaluation: TRUE
[11:41:53.192] Local evaluation: TRUE
[11:41:53.192] Environment: 0x560ef58e1768
[11:41:53.192] Capture standard output: TRUE
[11:41:53.192] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:53.192] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:53.192] Packages: 1 packages (‘mlr3’)
[11:41:53.192] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:53.192] Resolved: FALSE
[11:41:53.192] Value: <not collected>
[11:41:53.192] Conditions captured: <none>
[11:41:53.192] Early signaling: FALSE
[11:41:53.192] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:53.192] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:53.210] Chunk #41 of 90 ... DONE
[11:41:53.211] Chunk #42 of 90 ...
[11:41:53.211]  - seeds: [1] <seeds>
[11:41:53.211] getGlobalsAndPackages() ...
[11:41:53.211] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:53.211] Resolving globals: FALSE
[11:41:53.212] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:53.212] - packages: [1] ‘mlr3’
[11:41:53.212] getGlobalsAndPackages() ... DONE
[11:41:53.213] run() for ‘Future’ ...
[11:41:53.213] - state: ‘created’
[11:41:53.213] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:53.223] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:53.224] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:53.224]   - Field: ‘node’
[11:41:53.224]   - Field: ‘label’
[11:41:53.224]   - Field: ‘local’
[11:41:53.224]   - Field: ‘owner’
[11:41:53.224]   - Field: ‘envir’
[11:41:53.224]   - Field: ‘workers’
[11:41:53.224]   - Field: ‘packages’
[11:41:53.224]   - Field: ‘gc’
[11:41:53.224]   - Field: ‘conditions’
[11:41:53.224]   - Field: ‘persistent’
[11:41:53.224]   - Field: ‘expr’
[11:41:53.224]   - Field: ‘uuid’
[11:41:53.224]   - Field: ‘seed’
[11:41:53.224]   - Field: ‘version’
[11:41:53.224]   - Field: ‘result’
[11:41:53.224]   - Field: ‘asynchronous’
[11:41:53.224]   - Field: ‘calls’
[11:41:53.224]   - Field: ‘globals’
[11:41:53.224]   - Field: ‘stdout’
[11:41:53.224]   - Field: ‘earlySignal’
[11:41:53.224]   - Field: ‘lazy’
[11:41:53.225]   - Field: ‘state’
[11:41:53.225] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:53.225] - Launch lazy future ...
[11:41:53.225] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:53.225] Packages needed by future strategies (n = 0): <none>
[11:41:53.225] {
[11:41:53.225]     {
[11:41:53.225]         {
[11:41:53.225]             ...future.startTime <- base::Sys.time()
[11:41:53.225]             {
[11:41:53.225]                 {
[11:41:53.225]                   {
[11:41:53.225]                     {
[11:41:53.225]                       {
[11:41:53.225]                         base::local({
[11:41:53.225]                           has_future <- base::requireNamespace("future", 
[11:41:53.225]                             quietly = TRUE)
[11:41:53.225]                           if (has_future) {
[11:41:53.225]                             ns <- base::getNamespace("future")
[11:41:53.225]                             version <- ns[[".package"]][["version"]]
[11:41:53.225]                             if (is.null(version)) 
[11:41:53.225]                               version <- utils::packageVersion("future")
[11:41:53.225]                           }
[11:41:53.225]                           else {
[11:41:53.225]                             version <- NULL
[11:41:53.225]                           }
[11:41:53.225]                           if (!has_future || version < "1.8.0") {
[11:41:53.225]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:53.225]                               "", base::R.version$version.string), 
[11:41:53.225]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:53.225]                                 base::R.version$platform, 8 * 
[11:41:53.225]                                   base::.Machine$sizeof.pointer), 
[11:41:53.225]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:53.225]                                 "release", "version")], collapse = " "), 
[11:41:53.225]                               hostname = base::Sys.info()[["nodename"]])
[11:41:53.225]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:53.225]                               info)
[11:41:53.225]                             info <- base::paste(info, collapse = "; ")
[11:41:53.225]                             if (!has_future) {
[11:41:53.225]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:53.225]                                 info)
[11:41:53.225]                             }
[11:41:53.225]                             else {
[11:41:53.225]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:53.225]                                 info, version)
[11:41:53.225]                             }
[11:41:53.225]                             base::stop(msg)
[11:41:53.225]                           }
[11:41:53.225]                         })
[11:41:53.225]                       }
[11:41:53.225]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:53.225]                       base::options(mc.cores = 1L)
[11:41:53.225]                     }
[11:41:53.225]                     base::local({
[11:41:53.225]                       for (pkg in "mlr3") {
[11:41:53.225]                         base::loadNamespace(pkg)
[11:41:53.225]                         base::library(pkg, character.only = TRUE)
[11:41:53.225]                       }
[11:41:53.225]                     })
[11:41:53.225]                   }
[11:41:53.225]                   options(future.plan = NULL)
[11:41:53.225]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:53.225]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:53.225]                 }
[11:41:53.225]                 ...future.workdir <- getwd()
[11:41:53.225]             }
[11:41:53.225]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:53.225]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:53.225]         }
[11:41:53.225]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:53.225]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:53.225]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:53.225]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:53.225]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:53.225]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:53.225]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:53.225]             base::names(...future.oldOptions))
[11:41:53.225]     }
[11:41:53.225]     if (FALSE) {
[11:41:53.225]     }
[11:41:53.225]     else {
[11:41:53.225]         if (TRUE) {
[11:41:53.225]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:53.225]                 open = "w")
[11:41:53.225]         }
[11:41:53.225]         else {
[11:41:53.225]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:53.225]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:53.225]         }
[11:41:53.225]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:53.225]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:53.225]             base::sink(type = "output", split = FALSE)
[11:41:53.225]             base::close(...future.stdout)
[11:41:53.225]         }, add = TRUE)
[11:41:53.225]     }
[11:41:53.225]     ...future.frame <- base::sys.nframe()
[11:41:53.225]     ...future.conditions <- base::list()
[11:41:53.225]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:53.225]     if (FALSE) {
[11:41:53.225]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:53.225]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:53.225]     }
[11:41:53.225]     ...future.result <- base::tryCatch({
[11:41:53.225]         base::withCallingHandlers({
[11:41:53.225]             ...future.value <- base::withVisible(base::local({
[11:41:53.225]                 ...future.makeSendCondition <- local({
[11:41:53.225]                   sendCondition <- NULL
[11:41:53.225]                   function(frame = 1L) {
[11:41:53.225]                     if (is.function(sendCondition)) 
[11:41:53.225]                       return(sendCondition)
[11:41:53.225]                     ns <- getNamespace("parallel")
[11:41:53.225]                     if (exists("sendData", mode = "function", 
[11:41:53.225]                       envir = ns)) {
[11:41:53.225]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:53.225]                         envir = ns)
[11:41:53.225]                       envir <- sys.frame(frame)
[11:41:53.225]                       master <- NULL
[11:41:53.225]                       while (!identical(envir, .GlobalEnv) && 
[11:41:53.225]                         !identical(envir, emptyenv())) {
[11:41:53.225]                         if (exists("master", mode = "list", envir = envir, 
[11:41:53.225]                           inherits = FALSE)) {
[11:41:53.225]                           master <- get("master", mode = "list", 
[11:41:53.225]                             envir = envir, inherits = FALSE)
[11:41:53.225]                           if (inherits(master, c("SOCKnode", 
[11:41:53.225]                             "SOCK0node"))) {
[11:41:53.225]                             sendCondition <<- function(cond) {
[11:41:53.225]                               data <- list(type = "VALUE", value = cond, 
[11:41:53.225]                                 success = TRUE)
[11:41:53.225]                               parallel_sendData(master, data)
[11:41:53.225]                             }
[11:41:53.225]                             return(sendCondition)
[11:41:53.225]                           }
[11:41:53.225]                         }
[11:41:53.225]                         frame <- frame + 1L
[11:41:53.225]                         envir <- sys.frame(frame)
[11:41:53.225]                       }
[11:41:53.225]                     }
[11:41:53.225]                     sendCondition <<- function(cond) NULL
[11:41:53.225]                   }
[11:41:53.225]                 })
[11:41:53.225]                 withCallingHandlers({
[11:41:53.225]                   {
[11:41:53.225]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:53.225]                     if (!identical(...future.globals.maxSize.org, 
[11:41:53.225]                       ...future.globals.maxSize)) {
[11:41:53.225]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:53.225]                       on.exit(options(oopts), add = TRUE)
[11:41:53.225]                     }
[11:41:53.225]                     {
[11:41:53.225]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:53.225]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:53.225]                           envir = globalenv(), inherits = FALSE)
[11:41:53.225]                         ...future.FUN(...)
[11:41:53.225]                       }
[11:41:53.225]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:53.225]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:53.225]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:53.225]                         USE.NAMES = FALSE)
[11:41:53.225]                       do.call(mapply, args = args)
[11:41:53.225]                     }
[11:41:53.225]                   }
[11:41:53.225]                 }, immediateCondition = function(cond) {
[11:41:53.225]                   sendCondition <- ...future.makeSendCondition()
[11:41:53.225]                   sendCondition(cond)
[11:41:53.225]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:53.225]                   {
[11:41:53.225]                     inherits <- base::inherits
[11:41:53.225]                     invokeRestart <- base::invokeRestart
[11:41:53.225]                     is.null <- base::is.null
[11:41:53.225]                     muffled <- FALSE
[11:41:53.225]                     if (inherits(cond, "message")) {
[11:41:53.225]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:53.225]                       if (muffled) 
[11:41:53.225]                         invokeRestart("muffleMessage")
[11:41:53.225]                     }
[11:41:53.225]                     else if (inherits(cond, "warning")) {
[11:41:53.225]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:53.225]                       if (muffled) 
[11:41:53.225]                         invokeRestart("muffleWarning")
[11:41:53.225]                     }
[11:41:53.225]                     else if (inherits(cond, "condition")) {
[11:41:53.225]                       if (!is.null(pattern)) {
[11:41:53.225]                         computeRestarts <- base::computeRestarts
[11:41:53.225]                         grepl <- base::grepl
[11:41:53.225]                         restarts <- computeRestarts(cond)
[11:41:53.225]                         for (restart in restarts) {
[11:41:53.225]                           name <- restart$name
[11:41:53.225]                           if (is.null(name)) 
[11:41:53.225]                             next
[11:41:53.225]                           if (!grepl(pattern, name)) 
[11:41:53.225]                             next
[11:41:53.225]                           invokeRestart(restart)
[11:41:53.225]                           muffled <- TRUE
[11:41:53.225]                           break
[11:41:53.225]                         }
[11:41:53.225]                       }
[11:41:53.225]                     }
[11:41:53.225]                     invisible(muffled)
[11:41:53.225]                   }
[11:41:53.225]                   muffleCondition(cond)
[11:41:53.225]                 })
[11:41:53.225]             }))
[11:41:53.225]             future::FutureResult(value = ...future.value$value, 
[11:41:53.225]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:53.225]                   ...future.rng), globalenv = if (FALSE) 
[11:41:53.225]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:53.225]                     ...future.globalenv.names))
[11:41:53.225]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:53.225]         }, condition = base::local({
[11:41:53.225]             c <- base::c
[11:41:53.225]             inherits <- base::inherits
[11:41:53.225]             invokeRestart <- base::invokeRestart
[11:41:53.225]             length <- base::length
[11:41:53.225]             list <- base::list
[11:41:53.225]             seq.int <- base::seq.int
[11:41:53.225]             signalCondition <- base::signalCondition
[11:41:53.225]             sys.calls <- base::sys.calls
[11:41:53.225]             `[[` <- base::`[[`
[11:41:53.225]             `+` <- base::`+`
[11:41:53.225]             `<<-` <- base::`<<-`
[11:41:53.225]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:53.225]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:53.225]                   3L)]
[11:41:53.225]             }
[11:41:53.225]             function(cond) {
[11:41:53.225]                 is_error <- inherits(cond, "error")
[11:41:53.225]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:53.225]                   NULL)
[11:41:53.225]                 if (is_error) {
[11:41:53.225]                   sessionInformation <- function() {
[11:41:53.225]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:53.225]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:53.225]                       search = base::search(), system = base::Sys.info())
[11:41:53.225]                   }
[11:41:53.225]                   ...future.conditions[[length(...future.conditions) + 
[11:41:53.225]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:53.225]                     cond$call), session = sessionInformation(), 
[11:41:53.225]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:53.225]                   signalCondition(cond)
[11:41:53.225]                 }
[11:41:53.225]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:53.225]                 "immediateCondition"))) {
[11:41:53.225]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:53.225]                   ...future.conditions[[length(...future.conditions) + 
[11:41:53.225]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:53.225]                   if (TRUE && !signal) {
[11:41:53.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:53.225]                     {
[11:41:53.225]                       inherits <- base::inherits
[11:41:53.225]                       invokeRestart <- base::invokeRestart
[11:41:53.225]                       is.null <- base::is.null
[11:41:53.225]                       muffled <- FALSE
[11:41:53.225]                       if (inherits(cond, "message")) {
[11:41:53.225]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:53.225]                         if (muffled) 
[11:41:53.225]                           invokeRestart("muffleMessage")
[11:41:53.225]                       }
[11:41:53.225]                       else if (inherits(cond, "warning")) {
[11:41:53.225]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:53.225]                         if (muffled) 
[11:41:53.225]                           invokeRestart("muffleWarning")
[11:41:53.225]                       }
[11:41:53.225]                       else if (inherits(cond, "condition")) {
[11:41:53.225]                         if (!is.null(pattern)) {
[11:41:53.225]                           computeRestarts <- base::computeRestarts
[11:41:53.225]                           grepl <- base::grepl
[11:41:53.225]                           restarts <- computeRestarts(cond)
[11:41:53.225]                           for (restart in restarts) {
[11:41:53.225]                             name <- restart$name
[11:41:53.225]                             if (is.null(name)) 
[11:41:53.225]                               next
[11:41:53.225]                             if (!grepl(pattern, name)) 
[11:41:53.225]                               next
[11:41:53.225]                             invokeRestart(restart)
[11:41:53.225]                             muffled <- TRUE
[11:41:53.225]                             break
[11:41:53.225]                           }
[11:41:53.225]                         }
[11:41:53.225]                       }
[11:41:53.225]                       invisible(muffled)
[11:41:53.225]                     }
[11:41:53.225]                     muffleCondition(cond, pattern = "^muffle")
[11:41:53.225]                   }
[11:41:53.225]                 }
[11:41:53.225]                 else {
[11:41:53.225]                   if (TRUE) {
[11:41:53.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:53.225]                     {
[11:41:53.225]                       inherits <- base::inherits
[11:41:53.225]                       invokeRestart <- base::invokeRestart
[11:41:53.225]                       is.null <- base::is.null
[11:41:53.225]                       muffled <- FALSE
[11:41:53.225]                       if (inherits(cond, "message")) {
[11:41:53.225]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:53.225]                         if (muffled) 
[11:41:53.225]                           invokeRestart("muffleMessage")
[11:41:53.225]                       }
[11:41:53.225]                       else if (inherits(cond, "warning")) {
[11:41:53.225]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:53.225]                         if (muffled) 
[11:41:53.225]                           invokeRestart("muffleWarning")
[11:41:53.225]                       }
[11:41:53.225]                       else if (inherits(cond, "condition")) {
[11:41:53.225]                         if (!is.null(pattern)) {
[11:41:53.225]                           computeRestarts <- base::computeRestarts
[11:41:53.225]                           grepl <- base::grepl
[11:41:53.225]                           restarts <- computeRestarts(cond)
[11:41:53.225]                           for (restart in restarts) {
[11:41:53.225]                             name <- restart$name
[11:41:53.225]                             if (is.null(name)) 
[11:41:53.225]                               next
[11:41:53.225]                             if (!grepl(pattern, name)) 
[11:41:53.225]                               next
[11:41:53.225]                             invokeRestart(restart)
[11:41:53.225]                             muffled <- TRUE
[11:41:53.225]                             break
[11:41:53.225]                           }
[11:41:53.225]                         }
[11:41:53.225]                       }
[11:41:53.225]                       invisible(muffled)
[11:41:53.225]                     }
[11:41:53.225]                     muffleCondition(cond, pattern = "^muffle")
[11:41:53.225]                   }
[11:41:53.225]                 }
[11:41:53.225]             }
[11:41:53.225]         }))
[11:41:53.225]     }, error = function(ex) {
[11:41:53.225]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:53.225]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:53.225]                 ...future.rng), started = ...future.startTime, 
[11:41:53.225]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:53.225]             version = "1.8"), class = "FutureResult")
[11:41:53.225]     }, finally = {
[11:41:53.225]         if (!identical(...future.workdir, getwd())) 
[11:41:53.225]             setwd(...future.workdir)
[11:41:53.225]         {
[11:41:53.225]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:53.225]                 ...future.oldOptions$nwarnings <- NULL
[11:41:53.225]             }
[11:41:53.225]             base::options(...future.oldOptions)
[11:41:53.225]             if (.Platform$OS.type == "windows") {
[11:41:53.225]                 old_names <- names(...future.oldEnvVars)
[11:41:53.225]                 envs <- base::Sys.getenv()
[11:41:53.225]                 names <- names(envs)
[11:41:53.225]                 common <- intersect(names, old_names)
[11:41:53.225]                 added <- setdiff(names, old_names)
[11:41:53.225]                 removed <- setdiff(old_names, names)
[11:41:53.225]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:53.225]                   envs[common]]
[11:41:53.225]                 NAMES <- toupper(changed)
[11:41:53.225]                 args <- list()
[11:41:53.225]                 for (kk in seq_along(NAMES)) {
[11:41:53.225]                   name <- changed[[kk]]
[11:41:53.225]                   NAME <- NAMES[[kk]]
[11:41:53.225]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:53.225]                     next
[11:41:53.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:53.225]                 }
[11:41:53.225]                 NAMES <- toupper(added)
[11:41:53.225]                 for (kk in seq_along(NAMES)) {
[11:41:53.225]                   name <- added[[kk]]
[11:41:53.225]                   NAME <- NAMES[[kk]]
[11:41:53.225]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:53.225]                     next
[11:41:53.225]                   args[[name]] <- ""
[11:41:53.225]                 }
[11:41:53.225]                 NAMES <- toupper(removed)
[11:41:53.225]                 for (kk in seq_along(NAMES)) {
[11:41:53.225]                   name <- removed[[kk]]
[11:41:53.225]                   NAME <- NAMES[[kk]]
[11:41:53.225]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:53.225]                     next
[11:41:53.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:53.225]                 }
[11:41:53.225]                 if (length(args) > 0) 
[11:41:53.225]                   base::do.call(base::Sys.setenv, args = args)
[11:41:53.225]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:53.225]             }
[11:41:53.225]             else {
[11:41:53.225]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:53.225]             }
[11:41:53.225]             {
[11:41:53.225]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:53.225]                   0L) {
[11:41:53.225]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:53.225]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:53.225]                   base::options(opts)
[11:41:53.225]                 }
[11:41:53.225]                 {
[11:41:53.225]                   {
[11:41:53.225]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:53.225]                     NULL
[11:41:53.225]                   }
[11:41:53.225]                   options(future.plan = NULL)
[11:41:53.225]                   if (is.na(NA_character_)) 
[11:41:53.225]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:53.225]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:53.225]                   future::plan(list(function (..., workers = 2, 
[11:41:53.225]                     envir = parent.frame()) 
[11:41:53.225]                   strategy(..., workers = workers, envir = envir)), 
[11:41:53.225]                     .cleanup = FALSE, .init = FALSE)
[11:41:53.225]                 }
[11:41:53.225]             }
[11:41:53.225]         }
[11:41:53.225]     })
[11:41:53.225]     if (TRUE) {
[11:41:53.225]         base::sink(type = "output", split = FALSE)
[11:41:53.225]         if (TRUE) {
[11:41:53.225]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:53.225]         }
[11:41:53.225]         else {
[11:41:53.225]             ...future.result["stdout"] <- base::list(NULL)
[11:41:53.225]         }
[11:41:53.225]         base::close(...future.stdout)
[11:41:53.225]         ...future.stdout <- NULL
[11:41:53.225]     }
[11:41:53.225]     ...future.result$conditions <- ...future.conditions
[11:41:53.225]     ...future.result$finished <- base::Sys.time()
[11:41:53.225]     ...future.result
[11:41:53.225] }
[11:41:53.227] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:53.238] receiveMessageFromWorker() for ClusterFuture ...
[11:41:53.238] - Validating connection of MultisessionFuture
[11:41:53.238] - received message: FutureResult
[11:41:53.238] - Received FutureResult
[11:41:53.238] - Erased future from FutureRegistry
[11:41:53.238] result() for ClusterFuture ...
[11:41:53.239] - result already collected: FutureResult
[11:41:53.239] result() for ClusterFuture ... done
[11:41:53.239] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:53.239] result() for ClusterFuture ...
[11:41:53.239] - result already collected: FutureResult
[11:41:53.239] result() for ClusterFuture ... done
[11:41:53.239] result() for ClusterFuture ...
[11:41:53.239] - result already collected: FutureResult
[11:41:53.239] result() for ClusterFuture ... done
[11:41:53.240] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:53.240] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:53.282] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:53.288] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:53.334] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:53.335] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:53.382] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:53.383] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:53.384] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:53.385] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:53.386] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:53.387] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:53.388] MultisessionFuture started
[11:41:53.388] - Launch lazy future ... done
[11:41:53.388] run() for ‘MultisessionFuture’ ... done
[11:41:53.388] Created future:
[11:41:53.388] MultisessionFuture:
[11:41:53.388] Label: ‘future_mapply-42’
[11:41:53.388] Expression:
[11:41:53.388] {
[11:41:53.388]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:53.388]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:53.388]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:53.388]         on.exit(options(oopts), add = TRUE)
[11:41:53.388]     }
[11:41:53.388]     {
[11:41:53.388]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:53.388]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:53.388]                 inherits = FALSE)
[11:41:53.388]             ...future.FUN(...)
[11:41:53.388]         }
[11:41:53.388]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:53.388]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:53.388]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:53.388]         do.call(mapply, args = args)
[11:41:53.388]     }
[11:41:53.388] }
[11:41:53.388] Lazy evaluation: FALSE
[11:41:53.388] Asynchronous evaluation: TRUE
[11:41:53.388] Local evaluation: TRUE
[11:41:53.388] Environment: 0x560ef58e1768
[11:41:53.388] Capture standard output: TRUE
[11:41:53.388] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:53.388] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:53.388] Packages: 1 packages (‘mlr3’)
[11:41:53.388] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:53.388] Resolved: FALSE
[11:41:53.388] Value: <not collected>
[11:41:53.388] Conditions captured: <none>
[11:41:53.388] Early signaling: FALSE
[11:41:53.388] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:53.388] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:53.406] Chunk #42 of 90 ... DONE
[11:41:53.406] Chunk #43 of 90 ...
[11:41:53.406]  - seeds: [1] <seeds>
[11:41:53.406] getGlobalsAndPackages() ...
[11:41:53.406] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:53.406] Resolving globals: FALSE
[11:41:53.407] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:53.407] - packages: [1] ‘mlr3’
[11:41:53.407] getGlobalsAndPackages() ... DONE
[11:41:53.408] run() for ‘Future’ ...
[11:41:53.408] - state: ‘created’
[11:41:53.408] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:53.418] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:53.418] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:53.419]   - Field: ‘node’
[11:41:53.419]   - Field: ‘label’
[11:41:53.419]   - Field: ‘local’
[11:41:53.419]   - Field: ‘owner’
[11:41:53.419]   - Field: ‘envir’
[11:41:53.419]   - Field: ‘workers’
[11:41:53.419]   - Field: ‘packages’
[11:41:53.419]   - Field: ‘gc’
[11:41:53.419]   - Field: ‘conditions’
[11:41:53.419]   - Field: ‘persistent’
[11:41:53.419]   - Field: ‘expr’
[11:41:53.419]   - Field: ‘uuid’
[11:41:53.419]   - Field: ‘seed’
[11:41:53.419]   - Field: ‘version’
[11:41:53.419]   - Field: ‘result’
[11:41:53.419]   - Field: ‘asynchronous’
[11:41:53.419]   - Field: ‘calls’
[11:41:53.419]   - Field: ‘globals’
[11:41:53.423]   - Field: ‘stdout’
[11:41:53.423]   - Field: ‘earlySignal’
[11:41:53.423]   - Field: ‘lazy’
[11:41:53.423]   - Field: ‘state’
[11:41:53.423] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:53.424] - Launch lazy future ...
[11:41:53.424] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:53.424] Packages needed by future strategies (n = 0): <none>
[11:41:53.424] {
[11:41:53.424]     {
[11:41:53.424]         {
[11:41:53.424]             ...future.startTime <- base::Sys.time()
[11:41:53.424]             {
[11:41:53.424]                 {
[11:41:53.424]                   {
[11:41:53.424]                     {
[11:41:53.424]                       {
[11:41:53.424]                         base::local({
[11:41:53.424]                           has_future <- base::requireNamespace("future", 
[11:41:53.424]                             quietly = TRUE)
[11:41:53.424]                           if (has_future) {
[11:41:53.424]                             ns <- base::getNamespace("future")
[11:41:53.424]                             version <- ns[[".package"]][["version"]]
[11:41:53.424]                             if (is.null(version)) 
[11:41:53.424]                               version <- utils::packageVersion("future")
[11:41:53.424]                           }
[11:41:53.424]                           else {
[11:41:53.424]                             version <- NULL
[11:41:53.424]                           }
[11:41:53.424]                           if (!has_future || version < "1.8.0") {
[11:41:53.424]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:53.424]                               "", base::R.version$version.string), 
[11:41:53.424]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:53.424]                                 base::R.version$platform, 8 * 
[11:41:53.424]                                   base::.Machine$sizeof.pointer), 
[11:41:53.424]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:53.424]                                 "release", "version")], collapse = " "), 
[11:41:53.424]                               hostname = base::Sys.info()[["nodename"]])
[11:41:53.424]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:53.424]                               info)
[11:41:53.424]                             info <- base::paste(info, collapse = "; ")
[11:41:53.424]                             if (!has_future) {
[11:41:53.424]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:53.424]                                 info)
[11:41:53.424]                             }
[11:41:53.424]                             else {
[11:41:53.424]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:53.424]                                 info, version)
[11:41:53.424]                             }
[11:41:53.424]                             base::stop(msg)
[11:41:53.424]                           }
[11:41:53.424]                         })
[11:41:53.424]                       }
[11:41:53.424]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:53.424]                       base::options(mc.cores = 1L)
[11:41:53.424]                     }
[11:41:53.424]                     base::local({
[11:41:53.424]                       for (pkg in "mlr3") {
[11:41:53.424]                         base::loadNamespace(pkg)
[11:41:53.424]                         base::library(pkg, character.only = TRUE)
[11:41:53.424]                       }
[11:41:53.424]                     })
[11:41:53.424]                   }
[11:41:53.424]                   options(future.plan = NULL)
[11:41:53.424]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:53.424]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:53.424]                 }
[11:41:53.424]                 ...future.workdir <- getwd()
[11:41:53.424]             }
[11:41:53.424]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:53.424]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:53.424]         }
[11:41:53.424]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:53.424]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:53.424]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:53.424]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:53.424]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:53.424]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:53.424]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:53.424]             base::names(...future.oldOptions))
[11:41:53.424]     }
[11:41:53.424]     if (FALSE) {
[11:41:53.424]     }
[11:41:53.424]     else {
[11:41:53.424]         if (TRUE) {
[11:41:53.424]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:53.424]                 open = "w")
[11:41:53.424]         }
[11:41:53.424]         else {
[11:41:53.424]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:53.424]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:53.424]         }
[11:41:53.424]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:53.424]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:53.424]             base::sink(type = "output", split = FALSE)
[11:41:53.424]             base::close(...future.stdout)
[11:41:53.424]         }, add = TRUE)
[11:41:53.424]     }
[11:41:53.424]     ...future.frame <- base::sys.nframe()
[11:41:53.424]     ...future.conditions <- base::list()
[11:41:53.424]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:53.424]     if (FALSE) {
[11:41:53.424]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:53.424]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:53.424]     }
[11:41:53.424]     ...future.result <- base::tryCatch({
[11:41:53.424]         base::withCallingHandlers({
[11:41:53.424]             ...future.value <- base::withVisible(base::local({
[11:41:53.424]                 ...future.makeSendCondition <- local({
[11:41:53.424]                   sendCondition <- NULL
[11:41:53.424]                   function(frame = 1L) {
[11:41:53.424]                     if (is.function(sendCondition)) 
[11:41:53.424]                       return(sendCondition)
[11:41:53.424]                     ns <- getNamespace("parallel")
[11:41:53.424]                     if (exists("sendData", mode = "function", 
[11:41:53.424]                       envir = ns)) {
[11:41:53.424]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:53.424]                         envir = ns)
[11:41:53.424]                       envir <- sys.frame(frame)
[11:41:53.424]                       master <- NULL
[11:41:53.424]                       while (!identical(envir, .GlobalEnv) && 
[11:41:53.424]                         !identical(envir, emptyenv())) {
[11:41:53.424]                         if (exists("master", mode = "list", envir = envir, 
[11:41:53.424]                           inherits = FALSE)) {
[11:41:53.424]                           master <- get("master", mode = "list", 
[11:41:53.424]                             envir = envir, inherits = FALSE)
[11:41:53.424]                           if (inherits(master, c("SOCKnode", 
[11:41:53.424]                             "SOCK0node"))) {
[11:41:53.424]                             sendCondition <<- function(cond) {
[11:41:53.424]                               data <- list(type = "VALUE", value = cond, 
[11:41:53.424]                                 success = TRUE)
[11:41:53.424]                               parallel_sendData(master, data)
[11:41:53.424]                             }
[11:41:53.424]                             return(sendCondition)
[11:41:53.424]                           }
[11:41:53.424]                         }
[11:41:53.424]                         frame <- frame + 1L
[11:41:53.424]                         envir <- sys.frame(frame)
[11:41:53.424]                       }
[11:41:53.424]                     }
[11:41:53.424]                     sendCondition <<- function(cond) NULL
[11:41:53.424]                   }
[11:41:53.424]                 })
[11:41:53.424]                 withCallingHandlers({
[11:41:53.424]                   {
[11:41:53.424]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:53.424]                     if (!identical(...future.globals.maxSize.org, 
[11:41:53.424]                       ...future.globals.maxSize)) {
[11:41:53.424]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:53.424]                       on.exit(options(oopts), add = TRUE)
[11:41:53.424]                     }
[11:41:53.424]                     {
[11:41:53.424]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:53.424]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:53.424]                           envir = globalenv(), inherits = FALSE)
[11:41:53.424]                         ...future.FUN(...)
[11:41:53.424]                       }
[11:41:53.424]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:53.424]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:53.424]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:53.424]                         USE.NAMES = FALSE)
[11:41:53.424]                       do.call(mapply, args = args)
[11:41:53.424]                     }
[11:41:53.424]                   }
[11:41:53.424]                 }, immediateCondition = function(cond) {
[11:41:53.424]                   sendCondition <- ...future.makeSendCondition()
[11:41:53.424]                   sendCondition(cond)
[11:41:53.424]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:53.424]                   {
[11:41:53.424]                     inherits <- base::inherits
[11:41:53.424]                     invokeRestart <- base::invokeRestart
[11:41:53.424]                     is.null <- base::is.null
[11:41:53.424]                     muffled <- FALSE
[11:41:53.424]                     if (inherits(cond, "message")) {
[11:41:53.424]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:53.424]                       if (muffled) 
[11:41:53.424]                         invokeRestart("muffleMessage")
[11:41:53.424]                     }
[11:41:53.424]                     else if (inherits(cond, "warning")) {
[11:41:53.424]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:53.424]                       if (muffled) 
[11:41:53.424]                         invokeRestart("muffleWarning")
[11:41:53.424]                     }
[11:41:53.424]                     else if (inherits(cond, "condition")) {
[11:41:53.424]                       if (!is.null(pattern)) {
[11:41:53.424]                         computeRestarts <- base::computeRestarts
[11:41:53.424]                         grepl <- base::grepl
[11:41:53.424]                         restarts <- computeRestarts(cond)
[11:41:53.424]                         for (restart in restarts) {
[11:41:53.424]                           name <- restart$name
[11:41:53.424]                           if (is.null(name)) 
[11:41:53.424]                             next
[11:41:53.424]                           if (!grepl(pattern, name)) 
[11:41:53.424]                             next
[11:41:53.424]                           invokeRestart(restart)
[11:41:53.424]                           muffled <- TRUE
[11:41:53.424]                           break
[11:41:53.424]                         }
[11:41:53.424]                       }
[11:41:53.424]                     }
[11:41:53.424]                     invisible(muffled)
[11:41:53.424]                   }
[11:41:53.424]                   muffleCondition(cond)
[11:41:53.424]                 })
[11:41:53.424]             }))
[11:41:53.424]             future::FutureResult(value = ...future.value$value, 
[11:41:53.424]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:53.424]                   ...future.rng), globalenv = if (FALSE) 
[11:41:53.424]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:53.424]                     ...future.globalenv.names))
[11:41:53.424]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:53.424]         }, condition = base::local({
[11:41:53.424]             c <- base::c
[11:41:53.424]             inherits <- base::inherits
[11:41:53.424]             invokeRestart <- base::invokeRestart
[11:41:53.424]             length <- base::length
[11:41:53.424]             list <- base::list
[11:41:53.424]             seq.int <- base::seq.int
[11:41:53.424]             signalCondition <- base::signalCondition
[11:41:53.424]             sys.calls <- base::sys.calls
[11:41:53.424]             `[[` <- base::`[[`
[11:41:53.424]             `+` <- base::`+`
[11:41:53.424]             `<<-` <- base::`<<-`
[11:41:53.424]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:53.424]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:53.424]                   3L)]
[11:41:53.424]             }
[11:41:53.424]             function(cond) {
[11:41:53.424]                 is_error <- inherits(cond, "error")
[11:41:53.424]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:53.424]                   NULL)
[11:41:53.424]                 if (is_error) {
[11:41:53.424]                   sessionInformation <- function() {
[11:41:53.424]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:53.424]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:53.424]                       search = base::search(), system = base::Sys.info())
[11:41:53.424]                   }
[11:41:53.424]                   ...future.conditions[[length(...future.conditions) + 
[11:41:53.424]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:53.424]                     cond$call), session = sessionInformation(), 
[11:41:53.424]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:53.424]                   signalCondition(cond)
[11:41:53.424]                 }
[11:41:53.424]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:53.424]                 "immediateCondition"))) {
[11:41:53.424]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:53.424]                   ...future.conditions[[length(...future.conditions) + 
[11:41:53.424]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:53.424]                   if (TRUE && !signal) {
[11:41:53.424]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:53.424]                     {
[11:41:53.424]                       inherits <- base::inherits
[11:41:53.424]                       invokeRestart <- base::invokeRestart
[11:41:53.424]                       is.null <- base::is.null
[11:41:53.424]                       muffled <- FALSE
[11:41:53.424]                       if (inherits(cond, "message")) {
[11:41:53.424]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:53.424]                         if (muffled) 
[11:41:53.424]                           invokeRestart("muffleMessage")
[11:41:53.424]                       }
[11:41:53.424]                       else if (inherits(cond, "warning")) {
[11:41:53.424]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:53.424]                         if (muffled) 
[11:41:53.424]                           invokeRestart("muffleWarning")
[11:41:53.424]                       }
[11:41:53.424]                       else if (inherits(cond, "condition")) {
[11:41:53.424]                         if (!is.null(pattern)) {
[11:41:53.424]                           computeRestarts <- base::computeRestarts
[11:41:53.424]                           grepl <- base::grepl
[11:41:53.424]                           restarts <- computeRestarts(cond)
[11:41:53.424]                           for (restart in restarts) {
[11:41:53.424]                             name <- restart$name
[11:41:53.424]                             if (is.null(name)) 
[11:41:53.424]                               next
[11:41:53.424]                             if (!grepl(pattern, name)) 
[11:41:53.424]                               next
[11:41:53.424]                             invokeRestart(restart)
[11:41:53.424]                             muffled <- TRUE
[11:41:53.424]                             break
[11:41:53.424]                           }
[11:41:53.424]                         }
[11:41:53.424]                       }
[11:41:53.424]                       invisible(muffled)
[11:41:53.424]                     }
[11:41:53.424]                     muffleCondition(cond, pattern = "^muffle")
[11:41:53.424]                   }
[11:41:53.424]                 }
[11:41:53.424]                 else {
[11:41:53.424]                   if (TRUE) {
[11:41:53.424]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:53.424]                     {
[11:41:53.424]                       inherits <- base::inherits
[11:41:53.424]                       invokeRestart <- base::invokeRestart
[11:41:53.424]                       is.null <- base::is.null
[11:41:53.424]                       muffled <- FALSE
[11:41:53.424]                       if (inherits(cond, "message")) {
[11:41:53.424]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:53.424]                         if (muffled) 
[11:41:53.424]                           invokeRestart("muffleMessage")
[11:41:53.424]                       }
[11:41:53.424]                       else if (inherits(cond, "warning")) {
[11:41:53.424]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:53.424]                         if (muffled) 
[11:41:53.424]                           invokeRestart("muffleWarning")
[11:41:53.424]                       }
[11:41:53.424]                       else if (inherits(cond, "condition")) {
[11:41:53.424]                         if (!is.null(pattern)) {
[11:41:53.424]                           computeRestarts <- base::computeRestarts
[11:41:53.424]                           grepl <- base::grepl
[11:41:53.424]                           restarts <- computeRestarts(cond)
[11:41:53.424]                           for (restart in restarts) {
[11:41:53.424]                             name <- restart$name
[11:41:53.424]                             if (is.null(name)) 
[11:41:53.424]                               next
[11:41:53.424]                             if (!grepl(pattern, name)) 
[11:41:53.424]                               next
[11:41:53.424]                             invokeRestart(restart)
[11:41:53.424]                             muffled <- TRUE
[11:41:53.424]                             break
[11:41:53.424]                           }
[11:41:53.424]                         }
[11:41:53.424]                       }
[11:41:53.424]                       invisible(muffled)
[11:41:53.424]                     }
[11:41:53.424]                     muffleCondition(cond, pattern = "^muffle")
[11:41:53.424]                   }
[11:41:53.424]                 }
[11:41:53.424]             }
[11:41:53.424]         }))
[11:41:53.424]     }, error = function(ex) {
[11:41:53.424]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:53.424]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:53.424]                 ...future.rng), started = ...future.startTime, 
[11:41:53.424]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:53.424]             version = "1.8"), class = "FutureResult")
[11:41:53.424]     }, finally = {
[11:41:53.424]         if (!identical(...future.workdir, getwd())) 
[11:41:53.424]             setwd(...future.workdir)
[11:41:53.424]         {
[11:41:53.424]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:53.424]                 ...future.oldOptions$nwarnings <- NULL
[11:41:53.424]             }
[11:41:53.424]             base::options(...future.oldOptions)
[11:41:53.424]             if (.Platform$OS.type == "windows") {
[11:41:53.424]                 old_names <- names(...future.oldEnvVars)
[11:41:53.424]                 envs <- base::Sys.getenv()
[11:41:53.424]                 names <- names(envs)
[11:41:53.424]                 common <- intersect(names, old_names)
[11:41:53.424]                 added <- setdiff(names, old_names)
[11:41:53.424]                 removed <- setdiff(old_names, names)
[11:41:53.424]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:53.424]                   envs[common]]
[11:41:53.424]                 NAMES <- toupper(changed)
[11:41:53.424]                 args <- list()
[11:41:53.424]                 for (kk in seq_along(NAMES)) {
[11:41:53.424]                   name <- changed[[kk]]
[11:41:53.424]                   NAME <- NAMES[[kk]]
[11:41:53.424]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:53.424]                     next
[11:41:53.424]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:53.424]                 }
[11:41:53.424]                 NAMES <- toupper(added)
[11:41:53.424]                 for (kk in seq_along(NAMES)) {
[11:41:53.424]                   name <- added[[kk]]
[11:41:53.424]                   NAME <- NAMES[[kk]]
[11:41:53.424]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:53.424]                     next
[11:41:53.424]                   args[[name]] <- ""
[11:41:53.424]                 }
[11:41:53.424]                 NAMES <- toupper(removed)
[11:41:53.424]                 for (kk in seq_along(NAMES)) {
[11:41:53.424]                   name <- removed[[kk]]
[11:41:53.424]                   NAME <- NAMES[[kk]]
[11:41:53.424]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:53.424]                     next
[11:41:53.424]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:53.424]                 }
[11:41:53.424]                 if (length(args) > 0) 
[11:41:53.424]                   base::do.call(base::Sys.setenv, args = args)
[11:41:53.424]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:53.424]             }
[11:41:53.424]             else {
[11:41:53.424]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:53.424]             }
[11:41:53.424]             {
[11:41:53.424]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:53.424]                   0L) {
[11:41:53.424]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:53.424]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:53.424]                   base::options(opts)
[11:41:53.424]                 }
[11:41:53.424]                 {
[11:41:53.424]                   {
[11:41:53.424]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:53.424]                     NULL
[11:41:53.424]                   }
[11:41:53.424]                   options(future.plan = NULL)
[11:41:53.424]                   if (is.na(NA_character_)) 
[11:41:53.424]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:53.424]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:53.424]                   future::plan(list(function (..., workers = 2, 
[11:41:53.424]                     envir = parent.frame()) 
[11:41:53.424]                   strategy(..., workers = workers, envir = envir)), 
[11:41:53.424]                     .cleanup = FALSE, .init = FALSE)
[11:41:53.424]                 }
[11:41:53.424]             }
[11:41:53.424]         }
[11:41:53.424]     })
[11:41:53.424]     if (TRUE) {
[11:41:53.424]         base::sink(type = "output", split = FALSE)
[11:41:53.424]         if (TRUE) {
[11:41:53.424]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:53.424]         }
[11:41:53.424]         else {
[11:41:53.424]             ...future.result["stdout"] <- base::list(NULL)
[11:41:53.424]         }
[11:41:53.424]         base::close(...future.stdout)
[11:41:53.424]         ...future.stdout <- NULL
[11:41:53.424]     }
[11:41:53.424]     ...future.result$conditions <- ...future.conditions
[11:41:53.424]     ...future.result$finished <- base::Sys.time()
[11:41:53.424]     ...future.result
[11:41:53.424] }
[11:41:53.426] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:53.437] receiveMessageFromWorker() for ClusterFuture ...
[11:41:53.437] - Validating connection of MultisessionFuture
[11:41:53.438] - received message: FutureResult
[11:41:53.438] - Received FutureResult
[11:41:53.438] - Erased future from FutureRegistry
[11:41:53.438] result() for ClusterFuture ...
[11:41:53.438] - result already collected: FutureResult
[11:41:53.439] result() for ClusterFuture ... done
[11:41:53.439] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:53.439] result() for ClusterFuture ...
[11:41:53.439] - result already collected: FutureResult
[11:41:53.439] result() for ClusterFuture ... done
[11:41:53.439] result() for ClusterFuture ...
[11:41:53.439] - result already collected: FutureResult
[11:41:53.439] result() for ClusterFuture ... done
[11:41:53.440] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:53.441] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:53.486] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:53.495] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:53.498] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:53.498] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:53.542] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:53.542] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:53.543] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:53.544] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:53.545] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:53.545] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:53.546] MultisessionFuture started
[11:41:53.546] - Launch lazy future ... done
[11:41:53.547] run() for ‘MultisessionFuture’ ... done
[11:41:53.547] Created future:
[11:41:53.547] MultisessionFuture:
[11:41:53.547] Label: ‘future_mapply-43’
[11:41:53.547] Expression:
[11:41:53.547] {
[11:41:53.547]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:53.547]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:53.547]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:53.547]         on.exit(options(oopts), add = TRUE)
[11:41:53.547]     }
[11:41:53.547]     {
[11:41:53.547]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:53.547]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:53.547]                 inherits = FALSE)
[11:41:53.547]             ...future.FUN(...)
[11:41:53.547]         }
[11:41:53.547]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:53.547]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:53.547]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:53.547]         do.call(mapply, args = args)
[11:41:53.547]     }
[11:41:53.547] }
[11:41:53.547] Lazy evaluation: FALSE
[11:41:53.547] Asynchronous evaluation: TRUE
[11:41:53.547] Local evaluation: TRUE
[11:41:53.547] Environment: 0x560ef58e1768
[11:41:53.547] Capture standard output: TRUE
[11:41:53.547] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:53.547] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:53.547] Packages: 1 packages (‘mlr3’)
[11:41:53.547] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:53.547] Resolved: FALSE
[11:41:53.547] Value: <not collected>
[11:41:53.547] Conditions captured: <none>
[11:41:53.547] Early signaling: FALSE
[11:41:53.547] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:53.547] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:53.564] Chunk #43 of 90 ... DONE
[11:41:53.564] Chunk #44 of 90 ...
[11:41:53.565]  - seeds: [1] <seeds>
[11:41:53.565] getGlobalsAndPackages() ...
[11:41:53.565] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:53.565] Resolving globals: FALSE
[11:41:53.566] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:53.566] - packages: [1] ‘mlr3’
[11:41:53.566] getGlobalsAndPackages() ... DONE
[11:41:53.566] run() for ‘Future’ ...
[11:41:53.566] - state: ‘created’
[11:41:53.566] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:53.576] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:53.576] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:53.576]   - Field: ‘node’
[11:41:53.576]   - Field: ‘label’
[11:41:53.576]   - Field: ‘local’
[11:41:53.577]   - Field: ‘owner’
[11:41:53.577]   - Field: ‘envir’
[11:41:53.577]   - Field: ‘workers’
[11:41:53.577]   - Field: ‘packages’
[11:41:53.577]   - Field: ‘gc’
[11:41:53.577]   - Field: ‘conditions’
[11:41:53.577]   - Field: ‘persistent’
[11:41:53.577]   - Field: ‘expr’
[11:41:53.577]   - Field: ‘uuid’
[11:41:53.577]   - Field: ‘seed’
[11:41:53.577]   - Field: ‘version’
[11:41:53.577]   - Field: ‘result’
[11:41:53.577]   - Field: ‘asynchronous’
[11:41:53.577]   - Field: ‘calls’
[11:41:53.577]   - Field: ‘globals’
[11:41:53.577]   - Field: ‘stdout’
[11:41:53.577]   - Field: ‘earlySignal’
[11:41:53.577]   - Field: ‘lazy’
[11:41:53.577]   - Field: ‘state’
[11:41:53.577] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:53.577] - Launch lazy future ...
[11:41:53.578] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:53.578] Packages needed by future strategies (n = 0): <none>
[11:41:53.578] {
[11:41:53.578]     {
[11:41:53.578]         {
[11:41:53.578]             ...future.startTime <- base::Sys.time()
[11:41:53.578]             {
[11:41:53.578]                 {
[11:41:53.578]                   {
[11:41:53.578]                     {
[11:41:53.578]                       {
[11:41:53.578]                         base::local({
[11:41:53.578]                           has_future <- base::requireNamespace("future", 
[11:41:53.578]                             quietly = TRUE)
[11:41:53.578]                           if (has_future) {
[11:41:53.578]                             ns <- base::getNamespace("future")
[11:41:53.578]                             version <- ns[[".package"]][["version"]]
[11:41:53.578]                             if (is.null(version)) 
[11:41:53.578]                               version <- utils::packageVersion("future")
[11:41:53.578]                           }
[11:41:53.578]                           else {
[11:41:53.578]                             version <- NULL
[11:41:53.578]                           }
[11:41:53.578]                           if (!has_future || version < "1.8.0") {
[11:41:53.578]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:53.578]                               "", base::R.version$version.string), 
[11:41:53.578]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:53.578]                                 base::R.version$platform, 8 * 
[11:41:53.578]                                   base::.Machine$sizeof.pointer), 
[11:41:53.578]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:53.578]                                 "release", "version")], collapse = " "), 
[11:41:53.578]                               hostname = base::Sys.info()[["nodename"]])
[11:41:53.578]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:53.578]                               info)
[11:41:53.578]                             info <- base::paste(info, collapse = "; ")
[11:41:53.578]                             if (!has_future) {
[11:41:53.578]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:53.578]                                 info)
[11:41:53.578]                             }
[11:41:53.578]                             else {
[11:41:53.578]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:53.578]                                 info, version)
[11:41:53.578]                             }
[11:41:53.578]                             base::stop(msg)
[11:41:53.578]                           }
[11:41:53.578]                         })
[11:41:53.578]                       }
[11:41:53.578]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:53.578]                       base::options(mc.cores = 1L)
[11:41:53.578]                     }
[11:41:53.578]                     base::local({
[11:41:53.578]                       for (pkg in "mlr3") {
[11:41:53.578]                         base::loadNamespace(pkg)
[11:41:53.578]                         base::library(pkg, character.only = TRUE)
[11:41:53.578]                       }
[11:41:53.578]                     })
[11:41:53.578]                   }
[11:41:53.578]                   options(future.plan = NULL)
[11:41:53.578]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:53.578]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:53.578]                 }
[11:41:53.578]                 ...future.workdir <- getwd()
[11:41:53.578]             }
[11:41:53.578]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:53.578]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:53.578]         }
[11:41:53.578]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:53.578]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:53.578]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:53.578]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:53.578]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:53.578]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:53.578]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:53.578]             base::names(...future.oldOptions))
[11:41:53.578]     }
[11:41:53.578]     if (FALSE) {
[11:41:53.578]     }
[11:41:53.578]     else {
[11:41:53.578]         if (TRUE) {
[11:41:53.578]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:53.578]                 open = "w")
[11:41:53.578]         }
[11:41:53.578]         else {
[11:41:53.578]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:53.578]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:53.578]         }
[11:41:53.578]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:53.578]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:53.578]             base::sink(type = "output", split = FALSE)
[11:41:53.578]             base::close(...future.stdout)
[11:41:53.578]         }, add = TRUE)
[11:41:53.578]     }
[11:41:53.578]     ...future.frame <- base::sys.nframe()
[11:41:53.578]     ...future.conditions <- base::list()
[11:41:53.578]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:53.578]     if (FALSE) {
[11:41:53.578]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:53.578]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:53.578]     }
[11:41:53.578]     ...future.result <- base::tryCatch({
[11:41:53.578]         base::withCallingHandlers({
[11:41:53.578]             ...future.value <- base::withVisible(base::local({
[11:41:53.578]                 ...future.makeSendCondition <- local({
[11:41:53.578]                   sendCondition <- NULL
[11:41:53.578]                   function(frame = 1L) {
[11:41:53.578]                     if (is.function(sendCondition)) 
[11:41:53.578]                       return(sendCondition)
[11:41:53.578]                     ns <- getNamespace("parallel")
[11:41:53.578]                     if (exists("sendData", mode = "function", 
[11:41:53.578]                       envir = ns)) {
[11:41:53.578]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:53.578]                         envir = ns)
[11:41:53.578]                       envir <- sys.frame(frame)
[11:41:53.578]                       master <- NULL
[11:41:53.578]                       while (!identical(envir, .GlobalEnv) && 
[11:41:53.578]                         !identical(envir, emptyenv())) {
[11:41:53.578]                         if (exists("master", mode = "list", envir = envir, 
[11:41:53.578]                           inherits = FALSE)) {
[11:41:53.578]                           master <- get("master", mode = "list", 
[11:41:53.578]                             envir = envir, inherits = FALSE)
[11:41:53.578]                           if (inherits(master, c("SOCKnode", 
[11:41:53.578]                             "SOCK0node"))) {
[11:41:53.578]                             sendCondition <<- function(cond) {
[11:41:53.578]                               data <- list(type = "VALUE", value = cond, 
[11:41:53.578]                                 success = TRUE)
[11:41:53.578]                               parallel_sendData(master, data)
[11:41:53.578]                             }
[11:41:53.578]                             return(sendCondition)
[11:41:53.578]                           }
[11:41:53.578]                         }
[11:41:53.578]                         frame <- frame + 1L
[11:41:53.578]                         envir <- sys.frame(frame)
[11:41:53.578]                       }
[11:41:53.578]                     }
[11:41:53.578]                     sendCondition <<- function(cond) NULL
[11:41:53.578]                   }
[11:41:53.578]                 })
[11:41:53.578]                 withCallingHandlers({
[11:41:53.578]                   {
[11:41:53.578]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:53.578]                     if (!identical(...future.globals.maxSize.org, 
[11:41:53.578]                       ...future.globals.maxSize)) {
[11:41:53.578]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:53.578]                       on.exit(options(oopts), add = TRUE)
[11:41:53.578]                     }
[11:41:53.578]                     {
[11:41:53.578]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:53.578]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:53.578]                           envir = globalenv(), inherits = FALSE)
[11:41:53.578]                         ...future.FUN(...)
[11:41:53.578]                       }
[11:41:53.578]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:53.578]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:53.578]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:53.578]                         USE.NAMES = FALSE)
[11:41:53.578]                       do.call(mapply, args = args)
[11:41:53.578]                     }
[11:41:53.578]                   }
[11:41:53.578]                 }, immediateCondition = function(cond) {
[11:41:53.578]                   sendCondition <- ...future.makeSendCondition()
[11:41:53.578]                   sendCondition(cond)
[11:41:53.578]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:53.578]                   {
[11:41:53.578]                     inherits <- base::inherits
[11:41:53.578]                     invokeRestart <- base::invokeRestart
[11:41:53.578]                     is.null <- base::is.null
[11:41:53.578]                     muffled <- FALSE
[11:41:53.578]                     if (inherits(cond, "message")) {
[11:41:53.578]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:53.578]                       if (muffled) 
[11:41:53.578]                         invokeRestart("muffleMessage")
[11:41:53.578]                     }
[11:41:53.578]                     else if (inherits(cond, "warning")) {
[11:41:53.578]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:53.578]                       if (muffled) 
[11:41:53.578]                         invokeRestart("muffleWarning")
[11:41:53.578]                     }
[11:41:53.578]                     else if (inherits(cond, "condition")) {
[11:41:53.578]                       if (!is.null(pattern)) {
[11:41:53.578]                         computeRestarts <- base::computeRestarts
[11:41:53.578]                         grepl <- base::grepl
[11:41:53.578]                         restarts <- computeRestarts(cond)
[11:41:53.578]                         for (restart in restarts) {
[11:41:53.578]                           name <- restart$name
[11:41:53.578]                           if (is.null(name)) 
[11:41:53.578]                             next
[11:41:53.578]                           if (!grepl(pattern, name)) 
[11:41:53.578]                             next
[11:41:53.578]                           invokeRestart(restart)
[11:41:53.578]                           muffled <- TRUE
[11:41:53.578]                           break
[11:41:53.578]                         }
[11:41:53.578]                       }
[11:41:53.578]                     }
[11:41:53.578]                     invisible(muffled)
[11:41:53.578]                   }
[11:41:53.578]                   muffleCondition(cond)
[11:41:53.578]                 })
[11:41:53.578]             }))
[11:41:53.578]             future::FutureResult(value = ...future.value$value, 
[11:41:53.578]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:53.578]                   ...future.rng), globalenv = if (FALSE) 
[11:41:53.578]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:53.578]                     ...future.globalenv.names))
[11:41:53.578]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:53.578]         }, condition = base::local({
[11:41:53.578]             c <- base::c
[11:41:53.578]             inherits <- base::inherits
[11:41:53.578]             invokeRestart <- base::invokeRestart
[11:41:53.578]             length <- base::length
[11:41:53.578]             list <- base::list
[11:41:53.578]             seq.int <- base::seq.int
[11:41:53.578]             signalCondition <- base::signalCondition
[11:41:53.578]             sys.calls <- base::sys.calls
[11:41:53.578]             `[[` <- base::`[[`
[11:41:53.578]             `+` <- base::`+`
[11:41:53.578]             `<<-` <- base::`<<-`
[11:41:53.578]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:53.578]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:53.578]                   3L)]
[11:41:53.578]             }
[11:41:53.578]             function(cond) {
[11:41:53.578]                 is_error <- inherits(cond, "error")
[11:41:53.578]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:53.578]                   NULL)
[11:41:53.578]                 if (is_error) {
[11:41:53.578]                   sessionInformation <- function() {
[11:41:53.578]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:53.578]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:53.578]                       search = base::search(), system = base::Sys.info())
[11:41:53.578]                   }
[11:41:53.578]                   ...future.conditions[[length(...future.conditions) + 
[11:41:53.578]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:53.578]                     cond$call), session = sessionInformation(), 
[11:41:53.578]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:53.578]                   signalCondition(cond)
[11:41:53.578]                 }
[11:41:53.578]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:53.578]                 "immediateCondition"))) {
[11:41:53.578]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:53.578]                   ...future.conditions[[length(...future.conditions) + 
[11:41:53.578]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:53.578]                   if (TRUE && !signal) {
[11:41:53.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:53.578]                     {
[11:41:53.578]                       inherits <- base::inherits
[11:41:53.578]                       invokeRestart <- base::invokeRestart
[11:41:53.578]                       is.null <- base::is.null
[11:41:53.578]                       muffled <- FALSE
[11:41:53.578]                       if (inherits(cond, "message")) {
[11:41:53.578]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:53.578]                         if (muffled) 
[11:41:53.578]                           invokeRestart("muffleMessage")
[11:41:53.578]                       }
[11:41:53.578]                       else if (inherits(cond, "warning")) {
[11:41:53.578]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:53.578]                         if (muffled) 
[11:41:53.578]                           invokeRestart("muffleWarning")
[11:41:53.578]                       }
[11:41:53.578]                       else if (inherits(cond, "condition")) {
[11:41:53.578]                         if (!is.null(pattern)) {
[11:41:53.578]                           computeRestarts <- base::computeRestarts
[11:41:53.578]                           grepl <- base::grepl
[11:41:53.578]                           restarts <- computeRestarts(cond)
[11:41:53.578]                           for (restart in restarts) {
[11:41:53.578]                             name <- restart$name
[11:41:53.578]                             if (is.null(name)) 
[11:41:53.578]                               next
[11:41:53.578]                             if (!grepl(pattern, name)) 
[11:41:53.578]                               next
[11:41:53.578]                             invokeRestart(restart)
[11:41:53.578]                             muffled <- TRUE
[11:41:53.578]                             break
[11:41:53.578]                           }
[11:41:53.578]                         }
[11:41:53.578]                       }
[11:41:53.578]                       invisible(muffled)
[11:41:53.578]                     }
[11:41:53.578]                     muffleCondition(cond, pattern = "^muffle")
[11:41:53.578]                   }
[11:41:53.578]                 }
[11:41:53.578]                 else {
[11:41:53.578]                   if (TRUE) {
[11:41:53.578]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:53.578]                     {
[11:41:53.578]                       inherits <- base::inherits
[11:41:53.578]                       invokeRestart <- base::invokeRestart
[11:41:53.578]                       is.null <- base::is.null
[11:41:53.578]                       muffled <- FALSE
[11:41:53.578]                       if (inherits(cond, "message")) {
[11:41:53.578]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:53.578]                         if (muffled) 
[11:41:53.578]                           invokeRestart("muffleMessage")
[11:41:53.578]                       }
[11:41:53.578]                       else if (inherits(cond, "warning")) {
[11:41:53.578]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:53.578]                         if (muffled) 
[11:41:53.578]                           invokeRestart("muffleWarning")
[11:41:53.578]                       }
[11:41:53.578]                       else if (inherits(cond, "condition")) {
[11:41:53.578]                         if (!is.null(pattern)) {
[11:41:53.578]                           computeRestarts <- base::computeRestarts
[11:41:53.578]                           grepl <- base::grepl
[11:41:53.578]                           restarts <- computeRestarts(cond)
[11:41:53.578]                           for (restart in restarts) {
[11:41:53.578]                             name <- restart$name
[11:41:53.578]                             if (is.null(name)) 
[11:41:53.578]                               next
[11:41:53.578]                             if (!grepl(pattern, name)) 
[11:41:53.578]                               next
[11:41:53.578]                             invokeRestart(restart)
[11:41:53.578]                             muffled <- TRUE
[11:41:53.578]                             break
[11:41:53.578]                           }
[11:41:53.578]                         }
[11:41:53.578]                       }
[11:41:53.578]                       invisible(muffled)
[11:41:53.578]                     }
[11:41:53.578]                     muffleCondition(cond, pattern = "^muffle")
[11:41:53.578]                   }
[11:41:53.578]                 }
[11:41:53.578]             }
[11:41:53.578]         }))
[11:41:53.578]     }, error = function(ex) {
[11:41:53.578]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:53.578]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:53.578]                 ...future.rng), started = ...future.startTime, 
[11:41:53.578]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:53.578]             version = "1.8"), class = "FutureResult")
[11:41:53.578]     }, finally = {
[11:41:53.578]         if (!identical(...future.workdir, getwd())) 
[11:41:53.578]             setwd(...future.workdir)
[11:41:53.578]         {
[11:41:53.578]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:53.578]                 ...future.oldOptions$nwarnings <- NULL
[11:41:53.578]             }
[11:41:53.578]             base::options(...future.oldOptions)
[11:41:53.578]             if (.Platform$OS.type == "windows") {
[11:41:53.578]                 old_names <- names(...future.oldEnvVars)
[11:41:53.578]                 envs <- base::Sys.getenv()
[11:41:53.578]                 names <- names(envs)
[11:41:53.578]                 common <- intersect(names, old_names)
[11:41:53.578]                 added <- setdiff(names, old_names)
[11:41:53.578]                 removed <- setdiff(old_names, names)
[11:41:53.578]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:53.578]                   envs[common]]
[11:41:53.578]                 NAMES <- toupper(changed)
[11:41:53.578]                 args <- list()
[11:41:53.578]                 for (kk in seq_along(NAMES)) {
[11:41:53.578]                   name <- changed[[kk]]
[11:41:53.578]                   NAME <- NAMES[[kk]]
[11:41:53.578]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:53.578]                     next
[11:41:53.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:53.578]                 }
[11:41:53.578]                 NAMES <- toupper(added)
[11:41:53.578]                 for (kk in seq_along(NAMES)) {
[11:41:53.578]                   name <- added[[kk]]
[11:41:53.578]                   NAME <- NAMES[[kk]]
[11:41:53.578]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:53.578]                     next
[11:41:53.578]                   args[[name]] <- ""
[11:41:53.578]                 }
[11:41:53.578]                 NAMES <- toupper(removed)
[11:41:53.578]                 for (kk in seq_along(NAMES)) {
[11:41:53.578]                   name <- removed[[kk]]
[11:41:53.578]                   NAME <- NAMES[[kk]]
[11:41:53.578]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:53.578]                     next
[11:41:53.578]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:53.578]                 }
[11:41:53.578]                 if (length(args) > 0) 
[11:41:53.578]                   base::do.call(base::Sys.setenv, args = args)
[11:41:53.578]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:53.578]             }
[11:41:53.578]             else {
[11:41:53.578]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:53.578]             }
[11:41:53.578]             {
[11:41:53.578]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:53.578]                   0L) {
[11:41:53.578]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:53.578]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:53.578]                   base::options(opts)
[11:41:53.578]                 }
[11:41:53.578]                 {
[11:41:53.578]                   {
[11:41:53.578]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:53.578]                     NULL
[11:41:53.578]                   }
[11:41:53.578]                   options(future.plan = NULL)
[11:41:53.578]                   if (is.na(NA_character_)) 
[11:41:53.578]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:53.578]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:53.578]                   future::plan(list(function (..., workers = 2, 
[11:41:53.578]                     envir = parent.frame()) 
[11:41:53.578]                   strategy(..., workers = workers, envir = envir)), 
[11:41:53.578]                     .cleanup = FALSE, .init = FALSE)
[11:41:53.578]                 }
[11:41:53.578]             }
[11:41:53.578]         }
[11:41:53.578]     })
[11:41:53.578]     if (TRUE) {
[11:41:53.578]         base::sink(type = "output", split = FALSE)
[11:41:53.578]         if (TRUE) {
[11:41:53.578]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:53.578]         }
[11:41:53.578]         else {
[11:41:53.578]             ...future.result["stdout"] <- base::list(NULL)
[11:41:53.578]         }
[11:41:53.578]         base::close(...future.stdout)
[11:41:53.578]         ...future.stdout <- NULL
[11:41:53.578]     }
[11:41:53.578]     ...future.result$conditions <- ...future.conditions
[11:41:53.578]     ...future.result$finished <- base::Sys.time()
[11:41:53.578]     ...future.result
[11:41:53.578] }
[11:41:53.579] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:53.590] receiveMessageFromWorker() for ClusterFuture ...
[11:41:53.590] - Validating connection of MultisessionFuture
[11:41:53.590] - received message: FutureResult
[11:41:53.590] - Received FutureResult
[11:41:53.591] - Erased future from FutureRegistry
[11:41:53.591] result() for ClusterFuture ...
[11:41:53.591] - result already collected: FutureResult
[11:41:53.591] result() for ClusterFuture ... done
[11:41:53.591] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:53.591] result() for ClusterFuture ...
[11:41:53.591] - result already collected: FutureResult
[11:41:53.591] result() for ClusterFuture ... done
[11:41:53.591] result() for ClusterFuture ...
[11:41:53.591] - result already collected: FutureResult
[11:41:53.591] result() for ClusterFuture ... done
[11:41:53.592] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:53.592] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:53.634] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:53.640] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:53.643] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:53.643] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:53.686] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:53.686] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:53.688] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:53.688] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:53.689] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:53.689] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:53.691] MultisessionFuture started
[11:41:53.691] - Launch lazy future ... done
[11:41:53.691] run() for ‘MultisessionFuture’ ... done
[11:41:53.692] Created future:
[11:41:53.692] MultisessionFuture:
[11:41:53.692] Label: ‘future_mapply-44’
[11:41:53.692] Expression:
[11:41:53.692] {
[11:41:53.692]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:53.692]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:53.692]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:53.692]         on.exit(options(oopts), add = TRUE)
[11:41:53.692]     }
[11:41:53.692]     {
[11:41:53.692]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:53.692]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:53.692]                 inherits = FALSE)
[11:41:53.692]             ...future.FUN(...)
[11:41:53.692]         }
[11:41:53.692]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:53.692]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:53.692]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:53.692]         do.call(mapply, args = args)
[11:41:53.692]     }
[11:41:53.692] }
[11:41:53.692] Lazy evaluation: FALSE
[11:41:53.692] Asynchronous evaluation: TRUE
[11:41:53.692] Local evaluation: TRUE
[11:41:53.692] Environment: 0x560ef58e1768
[11:41:53.692] Capture standard output: TRUE
[11:41:53.692] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:53.692] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:53.692] Packages: 1 packages (‘mlr3’)
[11:41:53.692] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:53.692] Resolved: FALSE
[11:41:53.692] Value: <not collected>
[11:41:53.692] Conditions captured: <none>
[11:41:53.692] Early signaling: FALSE
[11:41:53.692] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:53.692] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:53.711] Chunk #44 of 90 ... DONE
[11:41:53.712] Chunk #45 of 90 ...
[11:41:53.712]  - seeds: [1] <seeds>
[11:41:53.712] getGlobalsAndPackages() ...
[11:41:53.712] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:53.713] Resolving globals: FALSE
[11:41:53.713] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:53.714] - packages: [1] ‘mlr3’
[11:41:53.714] getGlobalsAndPackages() ... DONE
[11:41:53.714] run() for ‘Future’ ...
[11:41:53.714] - state: ‘created’
[11:41:53.714] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:53.727] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:53.727] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:53.727]   - Field: ‘node’
[11:41:53.727]   - Field: ‘label’
[11:41:53.727]   - Field: ‘local’
[11:41:53.727]   - Field: ‘owner’
[11:41:53.727]   - Field: ‘envir’
[11:41:53.727]   - Field: ‘workers’
[11:41:53.727]   - Field: ‘packages’
[11:41:53.727]   - Field: ‘gc’
[11:41:53.727]   - Field: ‘conditions’
[11:41:53.727]   - Field: ‘persistent’
[11:41:53.727]   - Field: ‘expr’
[11:41:53.727]   - Field: ‘uuid’
[11:41:53.727]   - Field: ‘seed’
[11:41:53.728]   - Field: ‘version’
[11:41:53.728]   - Field: ‘result’
[11:41:53.728]   - Field: ‘asynchronous’
[11:41:53.728]   - Field: ‘calls’
[11:41:53.728]   - Field: ‘globals’
[11:41:53.728]   - Field: ‘stdout’
[11:41:53.728]   - Field: ‘earlySignal’
[11:41:53.728]   - Field: ‘lazy’
[11:41:53.728]   - Field: ‘state’
[11:41:53.728] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:53.728] - Launch lazy future ...
[11:41:53.728] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:53.728] Packages needed by future strategies (n = 0): <none>
[11:41:53.729] {
[11:41:53.729]     {
[11:41:53.729]         {
[11:41:53.729]             ...future.startTime <- base::Sys.time()
[11:41:53.729]             {
[11:41:53.729]                 {
[11:41:53.729]                   {
[11:41:53.729]                     {
[11:41:53.729]                       {
[11:41:53.729]                         base::local({
[11:41:53.729]                           has_future <- base::requireNamespace("future", 
[11:41:53.729]                             quietly = TRUE)
[11:41:53.729]                           if (has_future) {
[11:41:53.729]                             ns <- base::getNamespace("future")
[11:41:53.729]                             version <- ns[[".package"]][["version"]]
[11:41:53.729]                             if (is.null(version)) 
[11:41:53.729]                               version <- utils::packageVersion("future")
[11:41:53.729]                           }
[11:41:53.729]                           else {
[11:41:53.729]                             version <- NULL
[11:41:53.729]                           }
[11:41:53.729]                           if (!has_future || version < "1.8.0") {
[11:41:53.729]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:53.729]                               "", base::R.version$version.string), 
[11:41:53.729]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:53.729]                                 base::R.version$platform, 8 * 
[11:41:53.729]                                   base::.Machine$sizeof.pointer), 
[11:41:53.729]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:53.729]                                 "release", "version")], collapse = " "), 
[11:41:53.729]                               hostname = base::Sys.info()[["nodename"]])
[11:41:53.729]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:53.729]                               info)
[11:41:53.729]                             info <- base::paste(info, collapse = "; ")
[11:41:53.729]                             if (!has_future) {
[11:41:53.729]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:53.729]                                 info)
[11:41:53.729]                             }
[11:41:53.729]                             else {
[11:41:53.729]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:53.729]                                 info, version)
[11:41:53.729]                             }
[11:41:53.729]                             base::stop(msg)
[11:41:53.729]                           }
[11:41:53.729]                         })
[11:41:53.729]                       }
[11:41:53.729]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:53.729]                       base::options(mc.cores = 1L)
[11:41:53.729]                     }
[11:41:53.729]                     base::local({
[11:41:53.729]                       for (pkg in "mlr3") {
[11:41:53.729]                         base::loadNamespace(pkg)
[11:41:53.729]                         base::library(pkg, character.only = TRUE)
[11:41:53.729]                       }
[11:41:53.729]                     })
[11:41:53.729]                   }
[11:41:53.729]                   options(future.plan = NULL)
[11:41:53.729]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:53.729]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:53.729]                 }
[11:41:53.729]                 ...future.workdir <- getwd()
[11:41:53.729]             }
[11:41:53.729]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:53.729]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:53.729]         }
[11:41:53.729]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:53.729]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:53.729]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:53.729]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:53.729]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:53.729]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:53.729]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:53.729]             base::names(...future.oldOptions))
[11:41:53.729]     }
[11:41:53.729]     if (FALSE) {
[11:41:53.729]     }
[11:41:53.729]     else {
[11:41:53.729]         if (TRUE) {
[11:41:53.729]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:53.729]                 open = "w")
[11:41:53.729]         }
[11:41:53.729]         else {
[11:41:53.729]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:53.729]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:53.729]         }
[11:41:53.729]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:53.729]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:53.729]             base::sink(type = "output", split = FALSE)
[11:41:53.729]             base::close(...future.stdout)
[11:41:53.729]         }, add = TRUE)
[11:41:53.729]     }
[11:41:53.729]     ...future.frame <- base::sys.nframe()
[11:41:53.729]     ...future.conditions <- base::list()
[11:41:53.729]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:53.729]     if (FALSE) {
[11:41:53.729]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:53.729]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:53.729]     }
[11:41:53.729]     ...future.result <- base::tryCatch({
[11:41:53.729]         base::withCallingHandlers({
[11:41:53.729]             ...future.value <- base::withVisible(base::local({
[11:41:53.729]                 ...future.makeSendCondition <- local({
[11:41:53.729]                   sendCondition <- NULL
[11:41:53.729]                   function(frame = 1L) {
[11:41:53.729]                     if (is.function(sendCondition)) 
[11:41:53.729]                       return(sendCondition)
[11:41:53.729]                     ns <- getNamespace("parallel")
[11:41:53.729]                     if (exists("sendData", mode = "function", 
[11:41:53.729]                       envir = ns)) {
[11:41:53.729]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:53.729]                         envir = ns)
[11:41:53.729]                       envir <- sys.frame(frame)
[11:41:53.729]                       master <- NULL
[11:41:53.729]                       while (!identical(envir, .GlobalEnv) && 
[11:41:53.729]                         !identical(envir, emptyenv())) {
[11:41:53.729]                         if (exists("master", mode = "list", envir = envir, 
[11:41:53.729]                           inherits = FALSE)) {
[11:41:53.729]                           master <- get("master", mode = "list", 
[11:41:53.729]                             envir = envir, inherits = FALSE)
[11:41:53.729]                           if (inherits(master, c("SOCKnode", 
[11:41:53.729]                             "SOCK0node"))) {
[11:41:53.729]                             sendCondition <<- function(cond) {
[11:41:53.729]                               data <- list(type = "VALUE", value = cond, 
[11:41:53.729]                                 success = TRUE)
[11:41:53.729]                               parallel_sendData(master, data)
[11:41:53.729]                             }
[11:41:53.729]                             return(sendCondition)
[11:41:53.729]                           }
[11:41:53.729]                         }
[11:41:53.729]                         frame <- frame + 1L
[11:41:53.729]                         envir <- sys.frame(frame)
[11:41:53.729]                       }
[11:41:53.729]                     }
[11:41:53.729]                     sendCondition <<- function(cond) NULL
[11:41:53.729]                   }
[11:41:53.729]                 })
[11:41:53.729]                 withCallingHandlers({
[11:41:53.729]                   {
[11:41:53.729]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:53.729]                     if (!identical(...future.globals.maxSize.org, 
[11:41:53.729]                       ...future.globals.maxSize)) {
[11:41:53.729]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:53.729]                       on.exit(options(oopts), add = TRUE)
[11:41:53.729]                     }
[11:41:53.729]                     {
[11:41:53.729]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:53.729]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:53.729]                           envir = globalenv(), inherits = FALSE)
[11:41:53.729]                         ...future.FUN(...)
[11:41:53.729]                       }
[11:41:53.729]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:53.729]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:53.729]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:53.729]                         USE.NAMES = FALSE)
[11:41:53.729]                       do.call(mapply, args = args)
[11:41:53.729]                     }
[11:41:53.729]                   }
[11:41:53.729]                 }, immediateCondition = function(cond) {
[11:41:53.729]                   sendCondition <- ...future.makeSendCondition()
[11:41:53.729]                   sendCondition(cond)
[11:41:53.729]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:53.729]                   {
[11:41:53.729]                     inherits <- base::inherits
[11:41:53.729]                     invokeRestart <- base::invokeRestart
[11:41:53.729]                     is.null <- base::is.null
[11:41:53.729]                     muffled <- FALSE
[11:41:53.729]                     if (inherits(cond, "message")) {
[11:41:53.729]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:53.729]                       if (muffled) 
[11:41:53.729]                         invokeRestart("muffleMessage")
[11:41:53.729]                     }
[11:41:53.729]                     else if (inherits(cond, "warning")) {
[11:41:53.729]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:53.729]                       if (muffled) 
[11:41:53.729]                         invokeRestart("muffleWarning")
[11:41:53.729]                     }
[11:41:53.729]                     else if (inherits(cond, "condition")) {
[11:41:53.729]                       if (!is.null(pattern)) {
[11:41:53.729]                         computeRestarts <- base::computeRestarts
[11:41:53.729]                         grepl <- base::grepl
[11:41:53.729]                         restarts <- computeRestarts(cond)
[11:41:53.729]                         for (restart in restarts) {
[11:41:53.729]                           name <- restart$name
[11:41:53.729]                           if (is.null(name)) 
[11:41:53.729]                             next
[11:41:53.729]                           if (!grepl(pattern, name)) 
[11:41:53.729]                             next
[11:41:53.729]                           invokeRestart(restart)
[11:41:53.729]                           muffled <- TRUE
[11:41:53.729]                           break
[11:41:53.729]                         }
[11:41:53.729]                       }
[11:41:53.729]                     }
[11:41:53.729]                     invisible(muffled)
[11:41:53.729]                   }
[11:41:53.729]                   muffleCondition(cond)
[11:41:53.729]                 })
[11:41:53.729]             }))
[11:41:53.729]             future::FutureResult(value = ...future.value$value, 
[11:41:53.729]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:53.729]                   ...future.rng), globalenv = if (FALSE) 
[11:41:53.729]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:53.729]                     ...future.globalenv.names))
[11:41:53.729]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:53.729]         }, condition = base::local({
[11:41:53.729]             c <- base::c
[11:41:53.729]             inherits <- base::inherits
[11:41:53.729]             invokeRestart <- base::invokeRestart
[11:41:53.729]             length <- base::length
[11:41:53.729]             list <- base::list
[11:41:53.729]             seq.int <- base::seq.int
[11:41:53.729]             signalCondition <- base::signalCondition
[11:41:53.729]             sys.calls <- base::sys.calls
[11:41:53.729]             `[[` <- base::`[[`
[11:41:53.729]             `+` <- base::`+`
[11:41:53.729]             `<<-` <- base::`<<-`
[11:41:53.729]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:53.729]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:53.729]                   3L)]
[11:41:53.729]             }
[11:41:53.729]             function(cond) {
[11:41:53.729]                 is_error <- inherits(cond, "error")
[11:41:53.729]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:53.729]                   NULL)
[11:41:53.729]                 if (is_error) {
[11:41:53.729]                   sessionInformation <- function() {
[11:41:53.729]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:53.729]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:53.729]                       search = base::search(), system = base::Sys.info())
[11:41:53.729]                   }
[11:41:53.729]                   ...future.conditions[[length(...future.conditions) + 
[11:41:53.729]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:53.729]                     cond$call), session = sessionInformation(), 
[11:41:53.729]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:53.729]                   signalCondition(cond)
[11:41:53.729]                 }
[11:41:53.729]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:53.729]                 "immediateCondition"))) {
[11:41:53.729]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:53.729]                   ...future.conditions[[length(...future.conditions) + 
[11:41:53.729]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:53.729]                   if (TRUE && !signal) {
[11:41:53.729]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:53.729]                     {
[11:41:53.729]                       inherits <- base::inherits
[11:41:53.729]                       invokeRestart <- base::invokeRestart
[11:41:53.729]                       is.null <- base::is.null
[11:41:53.729]                       muffled <- FALSE
[11:41:53.729]                       if (inherits(cond, "message")) {
[11:41:53.729]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:53.729]                         if (muffled) 
[11:41:53.729]                           invokeRestart("muffleMessage")
[11:41:53.729]                       }
[11:41:53.729]                       else if (inherits(cond, "warning")) {
[11:41:53.729]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:53.729]                         if (muffled) 
[11:41:53.729]                           invokeRestart("muffleWarning")
[11:41:53.729]                       }
[11:41:53.729]                       else if (inherits(cond, "condition")) {
[11:41:53.729]                         if (!is.null(pattern)) {
[11:41:53.729]                           computeRestarts <- base::computeRestarts
[11:41:53.729]                           grepl <- base::grepl
[11:41:53.729]                           restarts <- computeRestarts(cond)
[11:41:53.729]                           for (restart in restarts) {
[11:41:53.729]                             name <- restart$name
[11:41:53.729]                             if (is.null(name)) 
[11:41:53.729]                               next
[11:41:53.729]                             if (!grepl(pattern, name)) 
[11:41:53.729]                               next
[11:41:53.729]                             invokeRestart(restart)
[11:41:53.729]                             muffled <- TRUE
[11:41:53.729]                             break
[11:41:53.729]                           }
[11:41:53.729]                         }
[11:41:53.729]                       }
[11:41:53.729]                       invisible(muffled)
[11:41:53.729]                     }
[11:41:53.729]                     muffleCondition(cond, pattern = "^muffle")
[11:41:53.729]                   }
[11:41:53.729]                 }
[11:41:53.729]                 else {
[11:41:53.729]                   if (TRUE) {
[11:41:53.729]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:53.729]                     {
[11:41:53.729]                       inherits <- base::inherits
[11:41:53.729]                       invokeRestart <- base::invokeRestart
[11:41:53.729]                       is.null <- base::is.null
[11:41:53.729]                       muffled <- FALSE
[11:41:53.729]                       if (inherits(cond, "message")) {
[11:41:53.729]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:53.729]                         if (muffled) 
[11:41:53.729]                           invokeRestart("muffleMessage")
[11:41:53.729]                       }
[11:41:53.729]                       else if (inherits(cond, "warning")) {
[11:41:53.729]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:53.729]                         if (muffled) 
[11:41:53.729]                           invokeRestart("muffleWarning")
[11:41:53.729]                       }
[11:41:53.729]                       else if (inherits(cond, "condition")) {
[11:41:53.729]                         if (!is.null(pattern)) {
[11:41:53.729]                           computeRestarts <- base::computeRestarts
[11:41:53.729]                           grepl <- base::grepl
[11:41:53.729]                           restarts <- computeRestarts(cond)
[11:41:53.729]                           for (restart in restarts) {
[11:41:53.729]                             name <- restart$name
[11:41:53.729]                             if (is.null(name)) 
[11:41:53.729]                               next
[11:41:53.729]                             if (!grepl(pattern, name)) 
[11:41:53.729]                               next
[11:41:53.729]                             invokeRestart(restart)
[11:41:53.729]                             muffled <- TRUE
[11:41:53.729]                             break
[11:41:53.729]                           }
[11:41:53.729]                         }
[11:41:53.729]                       }
[11:41:53.729]                       invisible(muffled)
[11:41:53.729]                     }
[11:41:53.729]                     muffleCondition(cond, pattern = "^muffle")
[11:41:53.729]                   }
[11:41:53.729]                 }
[11:41:53.729]             }
[11:41:53.729]         }))
[11:41:53.729]     }, error = function(ex) {
[11:41:53.729]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:53.729]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:53.729]                 ...future.rng), started = ...future.startTime, 
[11:41:53.729]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:53.729]             version = "1.8"), class = "FutureResult")
[11:41:53.729]     }, finally = {
[11:41:53.729]         if (!identical(...future.workdir, getwd())) 
[11:41:53.729]             setwd(...future.workdir)
[11:41:53.729]         {
[11:41:53.729]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:53.729]                 ...future.oldOptions$nwarnings <- NULL
[11:41:53.729]             }
[11:41:53.729]             base::options(...future.oldOptions)
[11:41:53.729]             if (.Platform$OS.type == "windows") {
[11:41:53.729]                 old_names <- names(...future.oldEnvVars)
[11:41:53.729]                 envs <- base::Sys.getenv()
[11:41:53.729]                 names <- names(envs)
[11:41:53.729]                 common <- intersect(names, old_names)
[11:41:53.729]                 added <- setdiff(names, old_names)
[11:41:53.729]                 removed <- setdiff(old_names, names)
[11:41:53.729]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:53.729]                   envs[common]]
[11:41:53.729]                 NAMES <- toupper(changed)
[11:41:53.729]                 args <- list()
[11:41:53.729]                 for (kk in seq_along(NAMES)) {
[11:41:53.729]                   name <- changed[[kk]]
[11:41:53.729]                   NAME <- NAMES[[kk]]
[11:41:53.729]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:53.729]                     next
[11:41:53.729]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:53.729]                 }
[11:41:53.729]                 NAMES <- toupper(added)
[11:41:53.729]                 for (kk in seq_along(NAMES)) {
[11:41:53.729]                   name <- added[[kk]]
[11:41:53.729]                   NAME <- NAMES[[kk]]
[11:41:53.729]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:53.729]                     next
[11:41:53.729]                   args[[name]] <- ""
[11:41:53.729]                 }
[11:41:53.729]                 NAMES <- toupper(removed)
[11:41:53.729]                 for (kk in seq_along(NAMES)) {
[11:41:53.729]                   name <- removed[[kk]]
[11:41:53.729]                   NAME <- NAMES[[kk]]
[11:41:53.729]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:53.729]                     next
[11:41:53.729]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:53.729]                 }
[11:41:53.729]                 if (length(args) > 0) 
[11:41:53.729]                   base::do.call(base::Sys.setenv, args = args)
[11:41:53.729]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:53.729]             }
[11:41:53.729]             else {
[11:41:53.729]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:53.729]             }
[11:41:53.729]             {
[11:41:53.729]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:53.729]                   0L) {
[11:41:53.729]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:53.729]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:53.729]                   base::options(opts)
[11:41:53.729]                 }
[11:41:53.729]                 {
[11:41:53.729]                   {
[11:41:53.729]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:53.729]                     NULL
[11:41:53.729]                   }
[11:41:53.729]                   options(future.plan = NULL)
[11:41:53.729]                   if (is.na(NA_character_)) 
[11:41:53.729]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:53.729]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:53.729]                   future::plan(list(function (..., workers = 2, 
[11:41:53.729]                     envir = parent.frame()) 
[11:41:53.729]                   strategy(..., workers = workers, envir = envir)), 
[11:41:53.729]                     .cleanup = FALSE, .init = FALSE)
[11:41:53.729]                 }
[11:41:53.729]             }
[11:41:53.729]         }
[11:41:53.729]     })
[11:41:53.729]     if (TRUE) {
[11:41:53.729]         base::sink(type = "output", split = FALSE)
[11:41:53.729]         if (TRUE) {
[11:41:53.729]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:53.729]         }
[11:41:53.729]         else {
[11:41:53.729]             ...future.result["stdout"] <- base::list(NULL)
[11:41:53.729]         }
[11:41:53.729]         base::close(...future.stdout)
[11:41:53.729]         ...future.stdout <- NULL
[11:41:53.729]     }
[11:41:53.729]     ...future.result$conditions <- ...future.conditions
[11:41:53.729]     ...future.result$finished <- base::Sys.time()
[11:41:53.729]     ...future.result
[11:41:53.729] }
[11:41:53.730] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:53.741] receiveMessageFromWorker() for ClusterFuture ...
[11:41:53.741] - Validating connection of MultisessionFuture
[11:41:53.742] - received message: FutureResult
[11:41:53.742] - Received FutureResult
[11:41:53.742] - Erased future from FutureRegistry
[11:41:53.742] result() for ClusterFuture ...
[11:41:53.742] - result already collected: FutureResult
[11:41:53.742] result() for ClusterFuture ... done
[11:41:53.742] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:53.743] result() for ClusterFuture ...
[11:41:53.743] - result already collected: FutureResult
[11:41:53.743] result() for ClusterFuture ... done
[11:41:53.743] result() for ClusterFuture ...
[11:41:53.743] - result already collected: FutureResult
[11:41:53.743] result() for ClusterFuture ... done
[11:41:53.744] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:53.744] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:53.786] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:53.795] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:53.842] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:53.843] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:53.891] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:53.892] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:53.893] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:53.894] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:53.895] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:53.896] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:53.897] MultisessionFuture started
[11:41:53.897] - Launch lazy future ... done
[11:41:53.897] run() for ‘MultisessionFuture’ ... done
[11:41:53.898] Created future:
[11:41:53.898] MultisessionFuture:
[11:41:53.898] Label: ‘future_mapply-45’
[11:41:53.898] Expression:
[11:41:53.898] {
[11:41:53.898]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:53.898]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:53.898]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:53.898]         on.exit(options(oopts), add = TRUE)
[11:41:53.898]     }
[11:41:53.898]     {
[11:41:53.898]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:53.898]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:53.898]                 inherits = FALSE)
[11:41:53.898]             ...future.FUN(...)
[11:41:53.898]         }
[11:41:53.898]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:53.898]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:53.898]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:53.898]         do.call(mapply, args = args)
[11:41:53.898]     }
[11:41:53.898] }
[11:41:53.898] Lazy evaluation: FALSE
[11:41:53.898] Asynchronous evaluation: TRUE
[11:41:53.898] Local evaluation: TRUE
[11:41:53.898] Environment: 0x560ef58e1768
[11:41:53.898] Capture standard output: TRUE
[11:41:53.898] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:53.898] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:53.898] Packages: 1 packages (‘mlr3’)
[11:41:53.898] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:53.898] Resolved: FALSE
[11:41:53.898] Value: <not collected>
[11:41:53.898] Conditions captured: <none>
[11:41:53.898] Early signaling: FALSE
[11:41:53.898] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:53.898] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:53.916] Chunk #45 of 90 ... DONE
[11:41:53.916] Chunk #46 of 90 ...
[11:41:53.917]  - seeds: [1] <seeds>
[11:41:53.917] getGlobalsAndPackages() ...
[11:41:53.917] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:53.917] Resolving globals: FALSE
[11:41:53.918] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:53.918] - packages: [1] ‘mlr3’
[11:41:53.918] getGlobalsAndPackages() ... DONE
[11:41:53.919] run() for ‘Future’ ...
[11:41:53.919] - state: ‘created’
[11:41:53.919] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:53.929] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:53.929] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:53.929]   - Field: ‘node’
[11:41:53.929]   - Field: ‘label’
[11:41:53.929]   - Field: ‘local’
[11:41:53.929]   - Field: ‘owner’
[11:41:53.929]   - Field: ‘envir’
[11:41:53.929]   - Field: ‘workers’
[11:41:53.929]   - Field: ‘packages’
[11:41:53.929]   - Field: ‘gc’
[11:41:53.929]   - Field: ‘conditions’
[11:41:53.929]   - Field: ‘persistent’
[11:41:53.929]   - Field: ‘expr’
[11:41:53.930]   - Field: ‘uuid’
[11:41:53.930]   - Field: ‘seed’
[11:41:53.930]   - Field: ‘version’
[11:41:53.930]   - Field: ‘result’
[11:41:53.930]   - Field: ‘asynchronous’
[11:41:53.930]   - Field: ‘calls’
[11:41:53.930]   - Field: ‘globals’
[11:41:53.930]   - Field: ‘stdout’
[11:41:53.930]   - Field: ‘earlySignal’
[11:41:53.930]   - Field: ‘lazy’
[11:41:53.930]   - Field: ‘state’
[11:41:53.930] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:53.930] - Launch lazy future ...
[11:41:53.930] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:53.930] Packages needed by future strategies (n = 0): <none>
[11:41:53.931] {
[11:41:53.931]     {
[11:41:53.931]         {
[11:41:53.931]             ...future.startTime <- base::Sys.time()
[11:41:53.931]             {
[11:41:53.931]                 {
[11:41:53.931]                   {
[11:41:53.931]                     {
[11:41:53.931]                       {
[11:41:53.931]                         base::local({
[11:41:53.931]                           has_future <- base::requireNamespace("future", 
[11:41:53.931]                             quietly = TRUE)
[11:41:53.931]                           if (has_future) {
[11:41:53.931]                             ns <- base::getNamespace("future")
[11:41:53.931]                             version <- ns[[".package"]][["version"]]
[11:41:53.931]                             if (is.null(version)) 
[11:41:53.931]                               version <- utils::packageVersion("future")
[11:41:53.931]                           }
[11:41:53.931]                           else {
[11:41:53.931]                             version <- NULL
[11:41:53.931]                           }
[11:41:53.931]                           if (!has_future || version < "1.8.0") {
[11:41:53.931]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:53.931]                               "", base::R.version$version.string), 
[11:41:53.931]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:53.931]                                 base::R.version$platform, 8 * 
[11:41:53.931]                                   base::.Machine$sizeof.pointer), 
[11:41:53.931]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:53.931]                                 "release", "version")], collapse = " "), 
[11:41:53.931]                               hostname = base::Sys.info()[["nodename"]])
[11:41:53.931]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:53.931]                               info)
[11:41:53.931]                             info <- base::paste(info, collapse = "; ")
[11:41:53.931]                             if (!has_future) {
[11:41:53.931]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:53.931]                                 info)
[11:41:53.931]                             }
[11:41:53.931]                             else {
[11:41:53.931]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:53.931]                                 info, version)
[11:41:53.931]                             }
[11:41:53.931]                             base::stop(msg)
[11:41:53.931]                           }
[11:41:53.931]                         })
[11:41:53.931]                       }
[11:41:53.931]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:53.931]                       base::options(mc.cores = 1L)
[11:41:53.931]                     }
[11:41:53.931]                     base::local({
[11:41:53.931]                       for (pkg in "mlr3") {
[11:41:53.931]                         base::loadNamespace(pkg)
[11:41:53.931]                         base::library(pkg, character.only = TRUE)
[11:41:53.931]                       }
[11:41:53.931]                     })
[11:41:53.931]                   }
[11:41:53.931]                   options(future.plan = NULL)
[11:41:53.931]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:53.931]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:53.931]                 }
[11:41:53.931]                 ...future.workdir <- getwd()
[11:41:53.931]             }
[11:41:53.931]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:53.931]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:53.931]         }
[11:41:53.931]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:53.931]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:53.931]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:53.931]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:53.931]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:53.931]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:53.931]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:53.931]             base::names(...future.oldOptions))
[11:41:53.931]     }
[11:41:53.931]     if (FALSE) {
[11:41:53.931]     }
[11:41:53.931]     else {
[11:41:53.931]         if (TRUE) {
[11:41:53.931]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:53.931]                 open = "w")
[11:41:53.931]         }
[11:41:53.931]         else {
[11:41:53.931]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:53.931]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:53.931]         }
[11:41:53.931]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:53.931]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:53.931]             base::sink(type = "output", split = FALSE)
[11:41:53.931]             base::close(...future.stdout)
[11:41:53.931]         }, add = TRUE)
[11:41:53.931]     }
[11:41:53.931]     ...future.frame <- base::sys.nframe()
[11:41:53.931]     ...future.conditions <- base::list()
[11:41:53.931]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:53.931]     if (FALSE) {
[11:41:53.931]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:53.931]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:53.931]     }
[11:41:53.931]     ...future.result <- base::tryCatch({
[11:41:53.931]         base::withCallingHandlers({
[11:41:53.931]             ...future.value <- base::withVisible(base::local({
[11:41:53.931]                 ...future.makeSendCondition <- local({
[11:41:53.931]                   sendCondition <- NULL
[11:41:53.931]                   function(frame = 1L) {
[11:41:53.931]                     if (is.function(sendCondition)) 
[11:41:53.931]                       return(sendCondition)
[11:41:53.931]                     ns <- getNamespace("parallel")
[11:41:53.931]                     if (exists("sendData", mode = "function", 
[11:41:53.931]                       envir = ns)) {
[11:41:53.931]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:53.931]                         envir = ns)
[11:41:53.931]                       envir <- sys.frame(frame)
[11:41:53.931]                       master <- NULL
[11:41:53.931]                       while (!identical(envir, .GlobalEnv) && 
[11:41:53.931]                         !identical(envir, emptyenv())) {
[11:41:53.931]                         if (exists("master", mode = "list", envir = envir, 
[11:41:53.931]                           inherits = FALSE)) {
[11:41:53.931]                           master <- get("master", mode = "list", 
[11:41:53.931]                             envir = envir, inherits = FALSE)
[11:41:53.931]                           if (inherits(master, c("SOCKnode", 
[11:41:53.931]                             "SOCK0node"))) {
[11:41:53.931]                             sendCondition <<- function(cond) {
[11:41:53.931]                               data <- list(type = "VALUE", value = cond, 
[11:41:53.931]                                 success = TRUE)
[11:41:53.931]                               parallel_sendData(master, data)
[11:41:53.931]                             }
[11:41:53.931]                             return(sendCondition)
[11:41:53.931]                           }
[11:41:53.931]                         }
[11:41:53.931]                         frame <- frame + 1L
[11:41:53.931]                         envir <- sys.frame(frame)
[11:41:53.931]                       }
[11:41:53.931]                     }
[11:41:53.931]                     sendCondition <<- function(cond) NULL
[11:41:53.931]                   }
[11:41:53.931]                 })
[11:41:53.931]                 withCallingHandlers({
[11:41:53.931]                   {
[11:41:53.931]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:53.931]                     if (!identical(...future.globals.maxSize.org, 
[11:41:53.931]                       ...future.globals.maxSize)) {
[11:41:53.931]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:53.931]                       on.exit(options(oopts), add = TRUE)
[11:41:53.931]                     }
[11:41:53.931]                     {
[11:41:53.931]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:53.931]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:53.931]                           envir = globalenv(), inherits = FALSE)
[11:41:53.931]                         ...future.FUN(...)
[11:41:53.931]                       }
[11:41:53.931]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:53.931]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:53.931]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:53.931]                         USE.NAMES = FALSE)
[11:41:53.931]                       do.call(mapply, args = args)
[11:41:53.931]                     }
[11:41:53.931]                   }
[11:41:53.931]                 }, immediateCondition = function(cond) {
[11:41:53.931]                   sendCondition <- ...future.makeSendCondition()
[11:41:53.931]                   sendCondition(cond)
[11:41:53.931]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:53.931]                   {
[11:41:53.931]                     inherits <- base::inherits
[11:41:53.931]                     invokeRestart <- base::invokeRestart
[11:41:53.931]                     is.null <- base::is.null
[11:41:53.931]                     muffled <- FALSE
[11:41:53.931]                     if (inherits(cond, "message")) {
[11:41:53.931]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:53.931]                       if (muffled) 
[11:41:53.931]                         invokeRestart("muffleMessage")
[11:41:53.931]                     }
[11:41:53.931]                     else if (inherits(cond, "warning")) {
[11:41:53.931]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:53.931]                       if (muffled) 
[11:41:53.931]                         invokeRestart("muffleWarning")
[11:41:53.931]                     }
[11:41:53.931]                     else if (inherits(cond, "condition")) {
[11:41:53.931]                       if (!is.null(pattern)) {
[11:41:53.931]                         computeRestarts <- base::computeRestarts
[11:41:53.931]                         grepl <- base::grepl
[11:41:53.931]                         restarts <- computeRestarts(cond)
[11:41:53.931]                         for (restart in restarts) {
[11:41:53.931]                           name <- restart$name
[11:41:53.931]                           if (is.null(name)) 
[11:41:53.931]                             next
[11:41:53.931]                           if (!grepl(pattern, name)) 
[11:41:53.931]                             next
[11:41:53.931]                           invokeRestart(restart)
[11:41:53.931]                           muffled <- TRUE
[11:41:53.931]                           break
[11:41:53.931]                         }
[11:41:53.931]                       }
[11:41:53.931]                     }
[11:41:53.931]                     invisible(muffled)
[11:41:53.931]                   }
[11:41:53.931]                   muffleCondition(cond)
[11:41:53.931]                 })
[11:41:53.931]             }))
[11:41:53.931]             future::FutureResult(value = ...future.value$value, 
[11:41:53.931]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:53.931]                   ...future.rng), globalenv = if (FALSE) 
[11:41:53.931]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:53.931]                     ...future.globalenv.names))
[11:41:53.931]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:53.931]         }, condition = base::local({
[11:41:53.931]             c <- base::c
[11:41:53.931]             inherits <- base::inherits
[11:41:53.931]             invokeRestart <- base::invokeRestart
[11:41:53.931]             length <- base::length
[11:41:53.931]             list <- base::list
[11:41:53.931]             seq.int <- base::seq.int
[11:41:53.931]             signalCondition <- base::signalCondition
[11:41:53.931]             sys.calls <- base::sys.calls
[11:41:53.931]             `[[` <- base::`[[`
[11:41:53.931]             `+` <- base::`+`
[11:41:53.931]             `<<-` <- base::`<<-`
[11:41:53.931]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:53.931]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:53.931]                   3L)]
[11:41:53.931]             }
[11:41:53.931]             function(cond) {
[11:41:53.931]                 is_error <- inherits(cond, "error")
[11:41:53.931]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:53.931]                   NULL)
[11:41:53.931]                 if (is_error) {
[11:41:53.931]                   sessionInformation <- function() {
[11:41:53.931]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:53.931]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:53.931]                       search = base::search(), system = base::Sys.info())
[11:41:53.931]                   }
[11:41:53.931]                   ...future.conditions[[length(...future.conditions) + 
[11:41:53.931]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:53.931]                     cond$call), session = sessionInformation(), 
[11:41:53.931]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:53.931]                   signalCondition(cond)
[11:41:53.931]                 }
[11:41:53.931]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:53.931]                 "immediateCondition"))) {
[11:41:53.931]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:53.931]                   ...future.conditions[[length(...future.conditions) + 
[11:41:53.931]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:53.931]                   if (TRUE && !signal) {
[11:41:53.931]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:53.931]                     {
[11:41:53.931]                       inherits <- base::inherits
[11:41:53.931]                       invokeRestart <- base::invokeRestart
[11:41:53.931]                       is.null <- base::is.null
[11:41:53.931]                       muffled <- FALSE
[11:41:53.931]                       if (inherits(cond, "message")) {
[11:41:53.931]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:53.931]                         if (muffled) 
[11:41:53.931]                           invokeRestart("muffleMessage")
[11:41:53.931]                       }
[11:41:53.931]                       else if (inherits(cond, "warning")) {
[11:41:53.931]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:53.931]                         if (muffled) 
[11:41:53.931]                           invokeRestart("muffleWarning")
[11:41:53.931]                       }
[11:41:53.931]                       else if (inherits(cond, "condition")) {
[11:41:53.931]                         if (!is.null(pattern)) {
[11:41:53.931]                           computeRestarts <- base::computeRestarts
[11:41:53.931]                           grepl <- base::grepl
[11:41:53.931]                           restarts <- computeRestarts(cond)
[11:41:53.931]                           for (restart in restarts) {
[11:41:53.931]                             name <- restart$name
[11:41:53.931]                             if (is.null(name)) 
[11:41:53.931]                               next
[11:41:53.931]                             if (!grepl(pattern, name)) 
[11:41:53.931]                               next
[11:41:53.931]                             invokeRestart(restart)
[11:41:53.931]                             muffled <- TRUE
[11:41:53.931]                             break
[11:41:53.931]                           }
[11:41:53.931]                         }
[11:41:53.931]                       }
[11:41:53.931]                       invisible(muffled)
[11:41:53.931]                     }
[11:41:53.931]                     muffleCondition(cond, pattern = "^muffle")
[11:41:53.931]                   }
[11:41:53.931]                 }
[11:41:53.931]                 else {
[11:41:53.931]                   if (TRUE) {
[11:41:53.931]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:53.931]                     {
[11:41:53.931]                       inherits <- base::inherits
[11:41:53.931]                       invokeRestart <- base::invokeRestart
[11:41:53.931]                       is.null <- base::is.null
[11:41:53.931]                       muffled <- FALSE
[11:41:53.931]                       if (inherits(cond, "message")) {
[11:41:53.931]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:53.931]                         if (muffled) 
[11:41:53.931]                           invokeRestart("muffleMessage")
[11:41:53.931]                       }
[11:41:53.931]                       else if (inherits(cond, "warning")) {
[11:41:53.931]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:53.931]                         if (muffled) 
[11:41:53.931]                           invokeRestart("muffleWarning")
[11:41:53.931]                       }
[11:41:53.931]                       else if (inherits(cond, "condition")) {
[11:41:53.931]                         if (!is.null(pattern)) {
[11:41:53.931]                           computeRestarts <- base::computeRestarts
[11:41:53.931]                           grepl <- base::grepl
[11:41:53.931]                           restarts <- computeRestarts(cond)
[11:41:53.931]                           for (restart in restarts) {
[11:41:53.931]                             name <- restart$name
[11:41:53.931]                             if (is.null(name)) 
[11:41:53.931]                               next
[11:41:53.931]                             if (!grepl(pattern, name)) 
[11:41:53.931]                               next
[11:41:53.931]                             invokeRestart(restart)
[11:41:53.931]                             muffled <- TRUE
[11:41:53.931]                             break
[11:41:53.931]                           }
[11:41:53.931]                         }
[11:41:53.931]                       }
[11:41:53.931]                       invisible(muffled)
[11:41:53.931]                     }
[11:41:53.931]                     muffleCondition(cond, pattern = "^muffle")
[11:41:53.931]                   }
[11:41:53.931]                 }
[11:41:53.931]             }
[11:41:53.931]         }))
[11:41:53.931]     }, error = function(ex) {
[11:41:53.931]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:53.931]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:53.931]                 ...future.rng), started = ...future.startTime, 
[11:41:53.931]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:53.931]             version = "1.8"), class = "FutureResult")
[11:41:53.931]     }, finally = {
[11:41:53.931]         if (!identical(...future.workdir, getwd())) 
[11:41:53.931]             setwd(...future.workdir)
[11:41:53.931]         {
[11:41:53.931]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:53.931]                 ...future.oldOptions$nwarnings <- NULL
[11:41:53.931]             }
[11:41:53.931]             base::options(...future.oldOptions)
[11:41:53.931]             if (.Platform$OS.type == "windows") {
[11:41:53.931]                 old_names <- names(...future.oldEnvVars)
[11:41:53.931]                 envs <- base::Sys.getenv()
[11:41:53.931]                 names <- names(envs)
[11:41:53.931]                 common <- intersect(names, old_names)
[11:41:53.931]                 added <- setdiff(names, old_names)
[11:41:53.931]                 removed <- setdiff(old_names, names)
[11:41:53.931]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:53.931]                   envs[common]]
[11:41:53.931]                 NAMES <- toupper(changed)
[11:41:53.931]                 args <- list()
[11:41:53.931]                 for (kk in seq_along(NAMES)) {
[11:41:53.931]                   name <- changed[[kk]]
[11:41:53.931]                   NAME <- NAMES[[kk]]
[11:41:53.931]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:53.931]                     next
[11:41:53.931]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:53.931]                 }
[11:41:53.931]                 NAMES <- toupper(added)
[11:41:53.931]                 for (kk in seq_along(NAMES)) {
[11:41:53.931]                   name <- added[[kk]]
[11:41:53.931]                   NAME <- NAMES[[kk]]
[11:41:53.931]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:53.931]                     next
[11:41:53.931]                   args[[name]] <- ""
[11:41:53.931]                 }
[11:41:53.931]                 NAMES <- toupper(removed)
[11:41:53.931]                 for (kk in seq_along(NAMES)) {
[11:41:53.931]                   name <- removed[[kk]]
[11:41:53.931]                   NAME <- NAMES[[kk]]
[11:41:53.931]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:53.931]                     next
[11:41:53.931]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:53.931]                 }
[11:41:53.931]                 if (length(args) > 0) 
[11:41:53.931]                   base::do.call(base::Sys.setenv, args = args)
[11:41:53.931]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:53.931]             }
[11:41:53.931]             else {
[11:41:53.931]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:53.931]             }
[11:41:53.931]             {
[11:41:53.931]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:53.931]                   0L) {
[11:41:53.931]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:53.931]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:53.931]                   base::options(opts)
[11:41:53.931]                 }
[11:41:53.931]                 {
[11:41:53.931]                   {
[11:41:53.931]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:53.931]                     NULL
[11:41:53.931]                   }
[11:41:53.931]                   options(future.plan = NULL)
[11:41:53.931]                   if (is.na(NA_character_)) 
[11:41:53.931]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:53.931]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:53.931]                   future::plan(list(function (..., workers = 2, 
[11:41:53.931]                     envir = parent.frame()) 
[11:41:53.931]                   strategy(..., workers = workers, envir = envir)), 
[11:41:53.931]                     .cleanup = FALSE, .init = FALSE)
[11:41:53.931]                 }
[11:41:53.931]             }
[11:41:53.931]         }
[11:41:53.931]     })
[11:41:53.931]     if (TRUE) {
[11:41:53.931]         base::sink(type = "output", split = FALSE)
[11:41:53.931]         if (TRUE) {
[11:41:53.931]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:53.931]         }
[11:41:53.931]         else {
[11:41:53.931]             ...future.result["stdout"] <- base::list(NULL)
[11:41:53.931]         }
[11:41:53.931]         base::close(...future.stdout)
[11:41:53.931]         ...future.stdout <- NULL
[11:41:53.931]     }
[11:41:53.931]     ...future.result$conditions <- ...future.conditions
[11:41:53.931]     ...future.result$finished <- base::Sys.time()
[11:41:53.931]     ...future.result
[11:41:53.931] }
[11:41:53.932] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:53.943] receiveMessageFromWorker() for ClusterFuture ...
[11:41:53.944] - Validating connection of MultisessionFuture
[11:41:53.944] - received message: FutureResult
[11:41:53.944] - Received FutureResult
[11:41:53.944] - Erased future from FutureRegistry
[11:41:53.944] result() for ClusterFuture ...
[11:41:53.944] - result already collected: FutureResult
[11:41:53.945] result() for ClusterFuture ... done
[11:41:53.945] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:53.945] result() for ClusterFuture ...
[11:41:53.945] - result already collected: FutureResult
[11:41:53.945] result() for ClusterFuture ... done
[11:41:53.945] result() for ClusterFuture ...
[11:41:53.945] - result already collected: FutureResult
[11:41:53.945] result() for ClusterFuture ... done
[11:41:53.946] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:53.946] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:53.990] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:53.999] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:54.006] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:54.006] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:54.050] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:54.051] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:54.052] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:54.053] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:54.054] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:54.054] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:54.056] MultisessionFuture started
[11:41:54.056] - Launch lazy future ... done
[11:41:54.056] run() for ‘MultisessionFuture’ ... done
[11:41:54.056] Created future:
[11:41:54.056] MultisessionFuture:
[11:41:54.056] Label: ‘future_mapply-46’
[11:41:54.056] Expression:
[11:41:54.056] {
[11:41:54.056]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:54.056]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:54.056]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:54.056]         on.exit(options(oopts), add = TRUE)
[11:41:54.056]     }
[11:41:54.056]     {
[11:41:54.056]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:54.056]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:54.056]                 inherits = FALSE)
[11:41:54.056]             ...future.FUN(...)
[11:41:54.056]         }
[11:41:54.056]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:54.056]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:54.056]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:54.056]         do.call(mapply, args = args)
[11:41:54.056]     }
[11:41:54.056] }
[11:41:54.056] Lazy evaluation: FALSE
[11:41:54.056] Asynchronous evaluation: TRUE
[11:41:54.056] Local evaluation: TRUE
[11:41:54.056] Environment: 0x560ef58e1768
[11:41:54.056] Capture standard output: TRUE
[11:41:54.056] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:54.056] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:54.056] Packages: 1 packages (‘mlr3’)
[11:41:54.056] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:54.056] Resolved: FALSE
[11:41:54.056] Value: <not collected>
[11:41:54.056] Conditions captured: <none>
[11:41:54.056] Early signaling: FALSE
[11:41:54.056] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:54.056] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:54.074] Chunk #46 of 90 ... DONE
[11:41:54.074] Chunk #47 of 90 ...
[11:41:54.075]  - seeds: [1] <seeds>
[11:41:54.075] getGlobalsAndPackages() ...
[11:41:54.075] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:54.075] Resolving globals: FALSE
[11:41:54.076] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:54.076] - packages: [1] ‘mlr3’
[11:41:54.076] getGlobalsAndPackages() ... DONE
[11:41:54.076] run() for ‘Future’ ...
[11:41:54.076] - state: ‘created’
[11:41:54.077] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:54.087] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:54.087] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:54.087]   - Field: ‘node’
[11:41:54.087]   - Field: ‘label’
[11:41:54.087]   - Field: ‘local’
[11:41:54.087]   - Field: ‘owner’
[11:41:54.087]   - Field: ‘envir’
[11:41:54.087]   - Field: ‘workers’
[11:41:54.087]   - Field: ‘packages’
[11:41:54.087]   - Field: ‘gc’
[11:41:54.087]   - Field: ‘conditions’
[11:41:54.087]   - Field: ‘persistent’
[11:41:54.087]   - Field: ‘expr’
[11:41:54.087]   - Field: ‘uuid’
[11:41:54.087]   - Field: ‘seed’
[11:41:54.088]   - Field: ‘version’
[11:41:54.088]   - Field: ‘result’
[11:41:54.088]   - Field: ‘asynchronous’
[11:41:54.088]   - Field: ‘calls’
[11:41:54.088]   - Field: ‘globals’
[11:41:54.088]   - Field: ‘stdout’
[11:41:54.088]   - Field: ‘earlySignal’
[11:41:54.088]   - Field: ‘lazy’
[11:41:54.088]   - Field: ‘state’
[11:41:54.088] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:54.088] - Launch lazy future ...
[11:41:54.088] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:54.088] Packages needed by future strategies (n = 0): <none>
[11:41:54.089] {
[11:41:54.089]     {
[11:41:54.089]         {
[11:41:54.089]             ...future.startTime <- base::Sys.time()
[11:41:54.089]             {
[11:41:54.089]                 {
[11:41:54.089]                   {
[11:41:54.089]                     {
[11:41:54.089]                       {
[11:41:54.089]                         base::local({
[11:41:54.089]                           has_future <- base::requireNamespace("future", 
[11:41:54.089]                             quietly = TRUE)
[11:41:54.089]                           if (has_future) {
[11:41:54.089]                             ns <- base::getNamespace("future")
[11:41:54.089]                             version <- ns[[".package"]][["version"]]
[11:41:54.089]                             if (is.null(version)) 
[11:41:54.089]                               version <- utils::packageVersion("future")
[11:41:54.089]                           }
[11:41:54.089]                           else {
[11:41:54.089]                             version <- NULL
[11:41:54.089]                           }
[11:41:54.089]                           if (!has_future || version < "1.8.0") {
[11:41:54.089]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:54.089]                               "", base::R.version$version.string), 
[11:41:54.089]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:54.089]                                 base::R.version$platform, 8 * 
[11:41:54.089]                                   base::.Machine$sizeof.pointer), 
[11:41:54.089]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:54.089]                                 "release", "version")], collapse = " "), 
[11:41:54.089]                               hostname = base::Sys.info()[["nodename"]])
[11:41:54.089]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:54.089]                               info)
[11:41:54.089]                             info <- base::paste(info, collapse = "; ")
[11:41:54.089]                             if (!has_future) {
[11:41:54.089]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:54.089]                                 info)
[11:41:54.089]                             }
[11:41:54.089]                             else {
[11:41:54.089]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:54.089]                                 info, version)
[11:41:54.089]                             }
[11:41:54.089]                             base::stop(msg)
[11:41:54.089]                           }
[11:41:54.089]                         })
[11:41:54.089]                       }
[11:41:54.089]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:54.089]                       base::options(mc.cores = 1L)
[11:41:54.089]                     }
[11:41:54.089]                     base::local({
[11:41:54.089]                       for (pkg in "mlr3") {
[11:41:54.089]                         base::loadNamespace(pkg)
[11:41:54.089]                         base::library(pkg, character.only = TRUE)
[11:41:54.089]                       }
[11:41:54.089]                     })
[11:41:54.089]                   }
[11:41:54.089]                   options(future.plan = NULL)
[11:41:54.089]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:54.089]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:54.089]                 }
[11:41:54.089]                 ...future.workdir <- getwd()
[11:41:54.089]             }
[11:41:54.089]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:54.089]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:54.089]         }
[11:41:54.089]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:54.089]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:54.089]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:54.089]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:54.089]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:54.089]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:54.089]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:54.089]             base::names(...future.oldOptions))
[11:41:54.089]     }
[11:41:54.089]     if (FALSE) {
[11:41:54.089]     }
[11:41:54.089]     else {
[11:41:54.089]         if (TRUE) {
[11:41:54.089]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:54.089]                 open = "w")
[11:41:54.089]         }
[11:41:54.089]         else {
[11:41:54.089]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:54.089]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:54.089]         }
[11:41:54.089]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:54.089]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:54.089]             base::sink(type = "output", split = FALSE)
[11:41:54.089]             base::close(...future.stdout)
[11:41:54.089]         }, add = TRUE)
[11:41:54.089]     }
[11:41:54.089]     ...future.frame <- base::sys.nframe()
[11:41:54.089]     ...future.conditions <- base::list()
[11:41:54.089]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:54.089]     if (FALSE) {
[11:41:54.089]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:54.089]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:54.089]     }
[11:41:54.089]     ...future.result <- base::tryCatch({
[11:41:54.089]         base::withCallingHandlers({
[11:41:54.089]             ...future.value <- base::withVisible(base::local({
[11:41:54.089]                 ...future.makeSendCondition <- local({
[11:41:54.089]                   sendCondition <- NULL
[11:41:54.089]                   function(frame = 1L) {
[11:41:54.089]                     if (is.function(sendCondition)) 
[11:41:54.089]                       return(sendCondition)
[11:41:54.089]                     ns <- getNamespace("parallel")
[11:41:54.089]                     if (exists("sendData", mode = "function", 
[11:41:54.089]                       envir = ns)) {
[11:41:54.089]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:54.089]                         envir = ns)
[11:41:54.089]                       envir <- sys.frame(frame)
[11:41:54.089]                       master <- NULL
[11:41:54.089]                       while (!identical(envir, .GlobalEnv) && 
[11:41:54.089]                         !identical(envir, emptyenv())) {
[11:41:54.089]                         if (exists("master", mode = "list", envir = envir, 
[11:41:54.089]                           inherits = FALSE)) {
[11:41:54.089]                           master <- get("master", mode = "list", 
[11:41:54.089]                             envir = envir, inherits = FALSE)
[11:41:54.089]                           if (inherits(master, c("SOCKnode", 
[11:41:54.089]                             "SOCK0node"))) {
[11:41:54.089]                             sendCondition <<- function(cond) {
[11:41:54.089]                               data <- list(type = "VALUE", value = cond, 
[11:41:54.089]                                 success = TRUE)
[11:41:54.089]                               parallel_sendData(master, data)
[11:41:54.089]                             }
[11:41:54.089]                             return(sendCondition)
[11:41:54.089]                           }
[11:41:54.089]                         }
[11:41:54.089]                         frame <- frame + 1L
[11:41:54.089]                         envir <- sys.frame(frame)
[11:41:54.089]                       }
[11:41:54.089]                     }
[11:41:54.089]                     sendCondition <<- function(cond) NULL
[11:41:54.089]                   }
[11:41:54.089]                 })
[11:41:54.089]                 withCallingHandlers({
[11:41:54.089]                   {
[11:41:54.089]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:54.089]                     if (!identical(...future.globals.maxSize.org, 
[11:41:54.089]                       ...future.globals.maxSize)) {
[11:41:54.089]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:54.089]                       on.exit(options(oopts), add = TRUE)
[11:41:54.089]                     }
[11:41:54.089]                     {
[11:41:54.089]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:54.089]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:54.089]                           envir = globalenv(), inherits = FALSE)
[11:41:54.089]                         ...future.FUN(...)
[11:41:54.089]                       }
[11:41:54.089]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:54.089]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:54.089]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:54.089]                         USE.NAMES = FALSE)
[11:41:54.089]                       do.call(mapply, args = args)
[11:41:54.089]                     }
[11:41:54.089]                   }
[11:41:54.089]                 }, immediateCondition = function(cond) {
[11:41:54.089]                   sendCondition <- ...future.makeSendCondition()
[11:41:54.089]                   sendCondition(cond)
[11:41:54.089]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:54.089]                   {
[11:41:54.089]                     inherits <- base::inherits
[11:41:54.089]                     invokeRestart <- base::invokeRestart
[11:41:54.089]                     is.null <- base::is.null
[11:41:54.089]                     muffled <- FALSE
[11:41:54.089]                     if (inherits(cond, "message")) {
[11:41:54.089]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:54.089]                       if (muffled) 
[11:41:54.089]                         invokeRestart("muffleMessage")
[11:41:54.089]                     }
[11:41:54.089]                     else if (inherits(cond, "warning")) {
[11:41:54.089]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:54.089]                       if (muffled) 
[11:41:54.089]                         invokeRestart("muffleWarning")
[11:41:54.089]                     }
[11:41:54.089]                     else if (inherits(cond, "condition")) {
[11:41:54.089]                       if (!is.null(pattern)) {
[11:41:54.089]                         computeRestarts <- base::computeRestarts
[11:41:54.089]                         grepl <- base::grepl
[11:41:54.089]                         restarts <- computeRestarts(cond)
[11:41:54.089]                         for (restart in restarts) {
[11:41:54.089]                           name <- restart$name
[11:41:54.089]                           if (is.null(name)) 
[11:41:54.089]                             next
[11:41:54.089]                           if (!grepl(pattern, name)) 
[11:41:54.089]                             next
[11:41:54.089]                           invokeRestart(restart)
[11:41:54.089]                           muffled <- TRUE
[11:41:54.089]                           break
[11:41:54.089]                         }
[11:41:54.089]                       }
[11:41:54.089]                     }
[11:41:54.089]                     invisible(muffled)
[11:41:54.089]                   }
[11:41:54.089]                   muffleCondition(cond)
[11:41:54.089]                 })
[11:41:54.089]             }))
[11:41:54.089]             future::FutureResult(value = ...future.value$value, 
[11:41:54.089]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:54.089]                   ...future.rng), globalenv = if (FALSE) 
[11:41:54.089]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:54.089]                     ...future.globalenv.names))
[11:41:54.089]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:54.089]         }, condition = base::local({
[11:41:54.089]             c <- base::c
[11:41:54.089]             inherits <- base::inherits
[11:41:54.089]             invokeRestart <- base::invokeRestart
[11:41:54.089]             length <- base::length
[11:41:54.089]             list <- base::list
[11:41:54.089]             seq.int <- base::seq.int
[11:41:54.089]             signalCondition <- base::signalCondition
[11:41:54.089]             sys.calls <- base::sys.calls
[11:41:54.089]             `[[` <- base::`[[`
[11:41:54.089]             `+` <- base::`+`
[11:41:54.089]             `<<-` <- base::`<<-`
[11:41:54.089]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:54.089]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:54.089]                   3L)]
[11:41:54.089]             }
[11:41:54.089]             function(cond) {
[11:41:54.089]                 is_error <- inherits(cond, "error")
[11:41:54.089]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:54.089]                   NULL)
[11:41:54.089]                 if (is_error) {
[11:41:54.089]                   sessionInformation <- function() {
[11:41:54.089]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:54.089]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:54.089]                       search = base::search(), system = base::Sys.info())
[11:41:54.089]                   }
[11:41:54.089]                   ...future.conditions[[length(...future.conditions) + 
[11:41:54.089]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:54.089]                     cond$call), session = sessionInformation(), 
[11:41:54.089]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:54.089]                   signalCondition(cond)
[11:41:54.089]                 }
[11:41:54.089]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:54.089]                 "immediateCondition"))) {
[11:41:54.089]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:54.089]                   ...future.conditions[[length(...future.conditions) + 
[11:41:54.089]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:54.089]                   if (TRUE && !signal) {
[11:41:54.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:54.089]                     {
[11:41:54.089]                       inherits <- base::inherits
[11:41:54.089]                       invokeRestart <- base::invokeRestart
[11:41:54.089]                       is.null <- base::is.null
[11:41:54.089]                       muffled <- FALSE
[11:41:54.089]                       if (inherits(cond, "message")) {
[11:41:54.089]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:54.089]                         if (muffled) 
[11:41:54.089]                           invokeRestart("muffleMessage")
[11:41:54.089]                       }
[11:41:54.089]                       else if (inherits(cond, "warning")) {
[11:41:54.089]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:54.089]                         if (muffled) 
[11:41:54.089]                           invokeRestart("muffleWarning")
[11:41:54.089]                       }
[11:41:54.089]                       else if (inherits(cond, "condition")) {
[11:41:54.089]                         if (!is.null(pattern)) {
[11:41:54.089]                           computeRestarts <- base::computeRestarts
[11:41:54.089]                           grepl <- base::grepl
[11:41:54.089]                           restarts <- computeRestarts(cond)
[11:41:54.089]                           for (restart in restarts) {
[11:41:54.089]                             name <- restart$name
[11:41:54.089]                             if (is.null(name)) 
[11:41:54.089]                               next
[11:41:54.089]                             if (!grepl(pattern, name)) 
[11:41:54.089]                               next
[11:41:54.089]                             invokeRestart(restart)
[11:41:54.089]                             muffled <- TRUE
[11:41:54.089]                             break
[11:41:54.089]                           }
[11:41:54.089]                         }
[11:41:54.089]                       }
[11:41:54.089]                       invisible(muffled)
[11:41:54.089]                     }
[11:41:54.089]                     muffleCondition(cond, pattern = "^muffle")
[11:41:54.089]                   }
[11:41:54.089]                 }
[11:41:54.089]                 else {
[11:41:54.089]                   if (TRUE) {
[11:41:54.089]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:54.089]                     {
[11:41:54.089]                       inherits <- base::inherits
[11:41:54.089]                       invokeRestart <- base::invokeRestart
[11:41:54.089]                       is.null <- base::is.null
[11:41:54.089]                       muffled <- FALSE
[11:41:54.089]                       if (inherits(cond, "message")) {
[11:41:54.089]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:54.089]                         if (muffled) 
[11:41:54.089]                           invokeRestart("muffleMessage")
[11:41:54.089]                       }
[11:41:54.089]                       else if (inherits(cond, "warning")) {
[11:41:54.089]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:54.089]                         if (muffled) 
[11:41:54.089]                           invokeRestart("muffleWarning")
[11:41:54.089]                       }
[11:41:54.089]                       else if (inherits(cond, "condition")) {
[11:41:54.089]                         if (!is.null(pattern)) {
[11:41:54.089]                           computeRestarts <- base::computeRestarts
[11:41:54.089]                           grepl <- base::grepl
[11:41:54.089]                           restarts <- computeRestarts(cond)
[11:41:54.089]                           for (restart in restarts) {
[11:41:54.089]                             name <- restart$name
[11:41:54.089]                             if (is.null(name)) 
[11:41:54.089]                               next
[11:41:54.089]                             if (!grepl(pattern, name)) 
[11:41:54.089]                               next
[11:41:54.089]                             invokeRestart(restart)
[11:41:54.089]                             muffled <- TRUE
[11:41:54.089]                             break
[11:41:54.089]                           }
[11:41:54.089]                         }
[11:41:54.089]                       }
[11:41:54.089]                       invisible(muffled)
[11:41:54.089]                     }
[11:41:54.089]                     muffleCondition(cond, pattern = "^muffle")
[11:41:54.089]                   }
[11:41:54.089]                 }
[11:41:54.089]             }
[11:41:54.089]         }))
[11:41:54.089]     }, error = function(ex) {
[11:41:54.089]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:54.089]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:54.089]                 ...future.rng), started = ...future.startTime, 
[11:41:54.089]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:54.089]             version = "1.8"), class = "FutureResult")
[11:41:54.089]     }, finally = {
[11:41:54.089]         if (!identical(...future.workdir, getwd())) 
[11:41:54.089]             setwd(...future.workdir)
[11:41:54.089]         {
[11:41:54.089]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:54.089]                 ...future.oldOptions$nwarnings <- NULL
[11:41:54.089]             }
[11:41:54.089]             base::options(...future.oldOptions)
[11:41:54.089]             if (.Platform$OS.type == "windows") {
[11:41:54.089]                 old_names <- names(...future.oldEnvVars)
[11:41:54.089]                 envs <- base::Sys.getenv()
[11:41:54.089]                 names <- names(envs)
[11:41:54.089]                 common <- intersect(names, old_names)
[11:41:54.089]                 added <- setdiff(names, old_names)
[11:41:54.089]                 removed <- setdiff(old_names, names)
[11:41:54.089]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:54.089]                   envs[common]]
[11:41:54.089]                 NAMES <- toupper(changed)
[11:41:54.089]                 args <- list()
[11:41:54.089]                 for (kk in seq_along(NAMES)) {
[11:41:54.089]                   name <- changed[[kk]]
[11:41:54.089]                   NAME <- NAMES[[kk]]
[11:41:54.089]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:54.089]                     next
[11:41:54.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:54.089]                 }
[11:41:54.089]                 NAMES <- toupper(added)
[11:41:54.089]                 for (kk in seq_along(NAMES)) {
[11:41:54.089]                   name <- added[[kk]]
[11:41:54.089]                   NAME <- NAMES[[kk]]
[11:41:54.089]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:54.089]                     next
[11:41:54.089]                   args[[name]] <- ""
[11:41:54.089]                 }
[11:41:54.089]                 NAMES <- toupper(removed)
[11:41:54.089]                 for (kk in seq_along(NAMES)) {
[11:41:54.089]                   name <- removed[[kk]]
[11:41:54.089]                   NAME <- NAMES[[kk]]
[11:41:54.089]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:54.089]                     next
[11:41:54.089]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:54.089]                 }
[11:41:54.089]                 if (length(args) > 0) 
[11:41:54.089]                   base::do.call(base::Sys.setenv, args = args)
[11:41:54.089]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:54.089]             }
[11:41:54.089]             else {
[11:41:54.089]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:54.089]             }
[11:41:54.089]             {
[11:41:54.089]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:54.089]                   0L) {
[11:41:54.089]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:54.089]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:54.089]                   base::options(opts)
[11:41:54.089]                 }
[11:41:54.089]                 {
[11:41:54.089]                   {
[11:41:54.089]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:54.089]                     NULL
[11:41:54.089]                   }
[11:41:54.089]                   options(future.plan = NULL)
[11:41:54.089]                   if (is.na(NA_character_)) 
[11:41:54.089]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:54.089]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:54.089]                   future::plan(list(function (..., workers = 2, 
[11:41:54.089]                     envir = parent.frame()) 
[11:41:54.089]                   strategy(..., workers = workers, envir = envir)), 
[11:41:54.089]                     .cleanup = FALSE, .init = FALSE)
[11:41:54.089]                 }
[11:41:54.089]             }
[11:41:54.089]         }
[11:41:54.089]     })
[11:41:54.089]     if (TRUE) {
[11:41:54.089]         base::sink(type = "output", split = FALSE)
[11:41:54.089]         if (TRUE) {
[11:41:54.089]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:54.089]         }
[11:41:54.089]         else {
[11:41:54.089]             ...future.result["stdout"] <- base::list(NULL)
[11:41:54.089]         }
[11:41:54.089]         base::close(...future.stdout)
[11:41:54.089]         ...future.stdout <- NULL
[11:41:54.089]     }
[11:41:54.089]     ...future.result$conditions <- ...future.conditions
[11:41:54.089]     ...future.result$finished <- base::Sys.time()
[11:41:54.089]     ...future.result
[11:41:54.089] }
[11:41:54.090] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:54.102] receiveMessageFromWorker() for ClusterFuture ...
[11:41:54.102] - Validating connection of MultisessionFuture
[11:41:54.103] - received message: FutureResult
[11:41:54.103] - Received FutureResult
[11:41:54.103] - Erased future from FutureRegistry
[11:41:54.103] result() for ClusterFuture ...
[11:41:54.103] - result already collected: FutureResult
[11:41:54.103] result() for ClusterFuture ... done
[11:41:54.103] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:54.103] result() for ClusterFuture ...
[11:41:54.103] - result already collected: FutureResult
[11:41:54.103] result() for ClusterFuture ... done
[11:41:54.104] result() for ClusterFuture ...
[11:41:54.104] - result already collected: FutureResult
[11:41:54.104] result() for ClusterFuture ... done
[11:41:54.105] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:54.105] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:54.154] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:54.161] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:54.206] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:54.207] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:54.254] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:54.255] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:54.256] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:54.257] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:54.258] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:54.259] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:54.260] MultisessionFuture started
[11:41:54.260] - Launch lazy future ... done
[11:41:54.261] run() for ‘MultisessionFuture’ ... done
[11:41:54.261] Created future:
[11:41:54.261] MultisessionFuture:
[11:41:54.261] Label: ‘future_mapply-47’
[11:41:54.261] Expression:
[11:41:54.261] {
[11:41:54.261]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:54.261]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:54.261]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:54.261]         on.exit(options(oopts), add = TRUE)
[11:41:54.261]     }
[11:41:54.261]     {
[11:41:54.261]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:54.261]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:54.261]                 inherits = FALSE)
[11:41:54.261]             ...future.FUN(...)
[11:41:54.261]         }
[11:41:54.261]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:54.261]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:54.261]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:54.261]         do.call(mapply, args = args)
[11:41:54.261]     }
[11:41:54.261] }
[11:41:54.261] Lazy evaluation: FALSE
[11:41:54.261] Asynchronous evaluation: TRUE
[11:41:54.261] Local evaluation: TRUE
[11:41:54.261] Environment: 0x560ef58e1768
[11:41:54.261] Capture standard output: TRUE
[11:41:54.261] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:54.261] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:54.261] Packages: 1 packages (‘mlr3’)
[11:41:54.261] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:54.261] Resolved: FALSE
[11:41:54.261] Value: <not collected>
[11:41:54.261] Conditions captured: <none>
[11:41:54.261] Early signaling: FALSE
[11:41:54.261] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:54.261] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:54.279] Chunk #47 of 90 ... DONE
[11:41:54.280] Chunk #48 of 90 ...
[11:41:54.280]  - seeds: [1] <seeds>
[11:41:54.280] getGlobalsAndPackages() ...
[11:41:54.280] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:54.281] Resolving globals: FALSE
[11:41:54.282] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:54.282] - packages: [1] ‘mlr3’
[11:41:54.282] getGlobalsAndPackages() ... DONE
[11:41:54.283] run() for ‘Future’ ...
[11:41:54.283] - state: ‘created’
[11:41:54.283] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:54.294] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:54.294] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:54.294]   - Field: ‘node’
[11:41:54.294]   - Field: ‘label’
[11:41:54.295]   - Field: ‘local’
[11:41:54.295]   - Field: ‘owner’
[11:41:54.295]   - Field: ‘envir’
[11:41:54.295]   - Field: ‘workers’
[11:41:54.295]   - Field: ‘packages’
[11:41:54.295]   - Field: ‘gc’
[11:41:54.295]   - Field: ‘conditions’
[11:41:54.295]   - Field: ‘persistent’
[11:41:54.295]   - Field: ‘expr’
[11:41:54.295]   - Field: ‘uuid’
[11:41:54.295]   - Field: ‘seed’
[11:41:54.295]   - Field: ‘version’
[11:41:54.295]   - Field: ‘result’
[11:41:54.295]   - Field: ‘asynchronous’
[11:41:54.295]   - Field: ‘calls’
[11:41:54.295]   - Field: ‘globals’
[11:41:54.295]   - Field: ‘stdout’
[11:41:54.295]   - Field: ‘earlySignal’
[11:41:54.295]   - Field: ‘lazy’
[11:41:54.295]   - Field: ‘state’
[11:41:54.295] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:54.295] - Launch lazy future ...
[11:41:54.296] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:54.296] Packages needed by future strategies (n = 0): <none>
[11:41:54.296] {
[11:41:54.296]     {
[11:41:54.296]         {
[11:41:54.296]             ...future.startTime <- base::Sys.time()
[11:41:54.296]             {
[11:41:54.296]                 {
[11:41:54.296]                   {
[11:41:54.296]                     {
[11:41:54.296]                       {
[11:41:54.296]                         base::local({
[11:41:54.296]                           has_future <- base::requireNamespace("future", 
[11:41:54.296]                             quietly = TRUE)
[11:41:54.296]                           if (has_future) {
[11:41:54.296]                             ns <- base::getNamespace("future")
[11:41:54.296]                             version <- ns[[".package"]][["version"]]
[11:41:54.296]                             if (is.null(version)) 
[11:41:54.296]                               version <- utils::packageVersion("future")
[11:41:54.296]                           }
[11:41:54.296]                           else {
[11:41:54.296]                             version <- NULL
[11:41:54.296]                           }
[11:41:54.296]                           if (!has_future || version < "1.8.0") {
[11:41:54.296]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:54.296]                               "", base::R.version$version.string), 
[11:41:54.296]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:54.296]                                 base::R.version$platform, 8 * 
[11:41:54.296]                                   base::.Machine$sizeof.pointer), 
[11:41:54.296]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:54.296]                                 "release", "version")], collapse = " "), 
[11:41:54.296]                               hostname = base::Sys.info()[["nodename"]])
[11:41:54.296]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:54.296]                               info)
[11:41:54.296]                             info <- base::paste(info, collapse = "; ")
[11:41:54.296]                             if (!has_future) {
[11:41:54.296]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:54.296]                                 info)
[11:41:54.296]                             }
[11:41:54.296]                             else {
[11:41:54.296]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:54.296]                                 info, version)
[11:41:54.296]                             }
[11:41:54.296]                             base::stop(msg)
[11:41:54.296]                           }
[11:41:54.296]                         })
[11:41:54.296]                       }
[11:41:54.296]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:54.296]                       base::options(mc.cores = 1L)
[11:41:54.296]                     }
[11:41:54.296]                     base::local({
[11:41:54.296]                       for (pkg in "mlr3") {
[11:41:54.296]                         base::loadNamespace(pkg)
[11:41:54.296]                         base::library(pkg, character.only = TRUE)
[11:41:54.296]                       }
[11:41:54.296]                     })
[11:41:54.296]                   }
[11:41:54.296]                   options(future.plan = NULL)
[11:41:54.296]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:54.296]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:54.296]                 }
[11:41:54.296]                 ...future.workdir <- getwd()
[11:41:54.296]             }
[11:41:54.296]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:54.296]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:54.296]         }
[11:41:54.296]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:54.296]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:54.296]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:54.296]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:54.296]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:54.296]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:54.296]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:54.296]             base::names(...future.oldOptions))
[11:41:54.296]     }
[11:41:54.296]     if (FALSE) {
[11:41:54.296]     }
[11:41:54.296]     else {
[11:41:54.296]         if (TRUE) {
[11:41:54.296]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:54.296]                 open = "w")
[11:41:54.296]         }
[11:41:54.296]         else {
[11:41:54.296]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:54.296]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:54.296]         }
[11:41:54.296]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:54.296]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:54.296]             base::sink(type = "output", split = FALSE)
[11:41:54.296]             base::close(...future.stdout)
[11:41:54.296]         }, add = TRUE)
[11:41:54.296]     }
[11:41:54.296]     ...future.frame <- base::sys.nframe()
[11:41:54.296]     ...future.conditions <- base::list()
[11:41:54.296]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:54.296]     if (FALSE) {
[11:41:54.296]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:54.296]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:54.296]     }
[11:41:54.296]     ...future.result <- base::tryCatch({
[11:41:54.296]         base::withCallingHandlers({
[11:41:54.296]             ...future.value <- base::withVisible(base::local({
[11:41:54.296]                 ...future.makeSendCondition <- local({
[11:41:54.296]                   sendCondition <- NULL
[11:41:54.296]                   function(frame = 1L) {
[11:41:54.296]                     if (is.function(sendCondition)) 
[11:41:54.296]                       return(sendCondition)
[11:41:54.296]                     ns <- getNamespace("parallel")
[11:41:54.296]                     if (exists("sendData", mode = "function", 
[11:41:54.296]                       envir = ns)) {
[11:41:54.296]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:54.296]                         envir = ns)
[11:41:54.296]                       envir <- sys.frame(frame)
[11:41:54.296]                       master <- NULL
[11:41:54.296]                       while (!identical(envir, .GlobalEnv) && 
[11:41:54.296]                         !identical(envir, emptyenv())) {
[11:41:54.296]                         if (exists("master", mode = "list", envir = envir, 
[11:41:54.296]                           inherits = FALSE)) {
[11:41:54.296]                           master <- get("master", mode = "list", 
[11:41:54.296]                             envir = envir, inherits = FALSE)
[11:41:54.296]                           if (inherits(master, c("SOCKnode", 
[11:41:54.296]                             "SOCK0node"))) {
[11:41:54.296]                             sendCondition <<- function(cond) {
[11:41:54.296]                               data <- list(type = "VALUE", value = cond, 
[11:41:54.296]                                 success = TRUE)
[11:41:54.296]                               parallel_sendData(master, data)
[11:41:54.296]                             }
[11:41:54.296]                             return(sendCondition)
[11:41:54.296]                           }
[11:41:54.296]                         }
[11:41:54.296]                         frame <- frame + 1L
[11:41:54.296]                         envir <- sys.frame(frame)
[11:41:54.296]                       }
[11:41:54.296]                     }
[11:41:54.296]                     sendCondition <<- function(cond) NULL
[11:41:54.296]                   }
[11:41:54.296]                 })
[11:41:54.296]                 withCallingHandlers({
[11:41:54.296]                   {
[11:41:54.296]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:54.296]                     if (!identical(...future.globals.maxSize.org, 
[11:41:54.296]                       ...future.globals.maxSize)) {
[11:41:54.296]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:54.296]                       on.exit(options(oopts), add = TRUE)
[11:41:54.296]                     }
[11:41:54.296]                     {
[11:41:54.296]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:54.296]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:54.296]                           envir = globalenv(), inherits = FALSE)
[11:41:54.296]                         ...future.FUN(...)
[11:41:54.296]                       }
[11:41:54.296]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:54.296]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:54.296]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:54.296]                         USE.NAMES = FALSE)
[11:41:54.296]                       do.call(mapply, args = args)
[11:41:54.296]                     }
[11:41:54.296]                   }
[11:41:54.296]                 }, immediateCondition = function(cond) {
[11:41:54.296]                   sendCondition <- ...future.makeSendCondition()
[11:41:54.296]                   sendCondition(cond)
[11:41:54.296]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:54.296]                   {
[11:41:54.296]                     inherits <- base::inherits
[11:41:54.296]                     invokeRestart <- base::invokeRestart
[11:41:54.296]                     is.null <- base::is.null
[11:41:54.296]                     muffled <- FALSE
[11:41:54.296]                     if (inherits(cond, "message")) {
[11:41:54.296]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:54.296]                       if (muffled) 
[11:41:54.296]                         invokeRestart("muffleMessage")
[11:41:54.296]                     }
[11:41:54.296]                     else if (inherits(cond, "warning")) {
[11:41:54.296]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:54.296]                       if (muffled) 
[11:41:54.296]                         invokeRestart("muffleWarning")
[11:41:54.296]                     }
[11:41:54.296]                     else if (inherits(cond, "condition")) {
[11:41:54.296]                       if (!is.null(pattern)) {
[11:41:54.296]                         computeRestarts <- base::computeRestarts
[11:41:54.296]                         grepl <- base::grepl
[11:41:54.296]                         restarts <- computeRestarts(cond)
[11:41:54.296]                         for (restart in restarts) {
[11:41:54.296]                           name <- restart$name
[11:41:54.296]                           if (is.null(name)) 
[11:41:54.296]                             next
[11:41:54.296]                           if (!grepl(pattern, name)) 
[11:41:54.296]                             next
[11:41:54.296]                           invokeRestart(restart)
[11:41:54.296]                           muffled <- TRUE
[11:41:54.296]                           break
[11:41:54.296]                         }
[11:41:54.296]                       }
[11:41:54.296]                     }
[11:41:54.296]                     invisible(muffled)
[11:41:54.296]                   }
[11:41:54.296]                   muffleCondition(cond)
[11:41:54.296]                 })
[11:41:54.296]             }))
[11:41:54.296]             future::FutureResult(value = ...future.value$value, 
[11:41:54.296]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:54.296]                   ...future.rng), globalenv = if (FALSE) 
[11:41:54.296]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:54.296]                     ...future.globalenv.names))
[11:41:54.296]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:54.296]         }, condition = base::local({
[11:41:54.296]             c <- base::c
[11:41:54.296]             inherits <- base::inherits
[11:41:54.296]             invokeRestart <- base::invokeRestart
[11:41:54.296]             length <- base::length
[11:41:54.296]             list <- base::list
[11:41:54.296]             seq.int <- base::seq.int
[11:41:54.296]             signalCondition <- base::signalCondition
[11:41:54.296]             sys.calls <- base::sys.calls
[11:41:54.296]             `[[` <- base::`[[`
[11:41:54.296]             `+` <- base::`+`
[11:41:54.296]             `<<-` <- base::`<<-`
[11:41:54.296]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:54.296]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:54.296]                   3L)]
[11:41:54.296]             }
[11:41:54.296]             function(cond) {
[11:41:54.296]                 is_error <- inherits(cond, "error")
[11:41:54.296]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:54.296]                   NULL)
[11:41:54.296]                 if (is_error) {
[11:41:54.296]                   sessionInformation <- function() {
[11:41:54.296]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:54.296]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:54.296]                       search = base::search(), system = base::Sys.info())
[11:41:54.296]                   }
[11:41:54.296]                   ...future.conditions[[length(...future.conditions) + 
[11:41:54.296]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:54.296]                     cond$call), session = sessionInformation(), 
[11:41:54.296]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:54.296]                   signalCondition(cond)
[11:41:54.296]                 }
[11:41:54.296]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:54.296]                 "immediateCondition"))) {
[11:41:54.296]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:54.296]                   ...future.conditions[[length(...future.conditions) + 
[11:41:54.296]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:54.296]                   if (TRUE && !signal) {
[11:41:54.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:54.296]                     {
[11:41:54.296]                       inherits <- base::inherits
[11:41:54.296]                       invokeRestart <- base::invokeRestart
[11:41:54.296]                       is.null <- base::is.null
[11:41:54.296]                       muffled <- FALSE
[11:41:54.296]                       if (inherits(cond, "message")) {
[11:41:54.296]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:54.296]                         if (muffled) 
[11:41:54.296]                           invokeRestart("muffleMessage")
[11:41:54.296]                       }
[11:41:54.296]                       else if (inherits(cond, "warning")) {
[11:41:54.296]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:54.296]                         if (muffled) 
[11:41:54.296]                           invokeRestart("muffleWarning")
[11:41:54.296]                       }
[11:41:54.296]                       else if (inherits(cond, "condition")) {
[11:41:54.296]                         if (!is.null(pattern)) {
[11:41:54.296]                           computeRestarts <- base::computeRestarts
[11:41:54.296]                           grepl <- base::grepl
[11:41:54.296]                           restarts <- computeRestarts(cond)
[11:41:54.296]                           for (restart in restarts) {
[11:41:54.296]                             name <- restart$name
[11:41:54.296]                             if (is.null(name)) 
[11:41:54.296]                               next
[11:41:54.296]                             if (!grepl(pattern, name)) 
[11:41:54.296]                               next
[11:41:54.296]                             invokeRestart(restart)
[11:41:54.296]                             muffled <- TRUE
[11:41:54.296]                             break
[11:41:54.296]                           }
[11:41:54.296]                         }
[11:41:54.296]                       }
[11:41:54.296]                       invisible(muffled)
[11:41:54.296]                     }
[11:41:54.296]                     muffleCondition(cond, pattern = "^muffle")
[11:41:54.296]                   }
[11:41:54.296]                 }
[11:41:54.296]                 else {
[11:41:54.296]                   if (TRUE) {
[11:41:54.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:54.296]                     {
[11:41:54.296]                       inherits <- base::inherits
[11:41:54.296]                       invokeRestart <- base::invokeRestart
[11:41:54.296]                       is.null <- base::is.null
[11:41:54.296]                       muffled <- FALSE
[11:41:54.296]                       if (inherits(cond, "message")) {
[11:41:54.296]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:54.296]                         if (muffled) 
[11:41:54.296]                           invokeRestart("muffleMessage")
[11:41:54.296]                       }
[11:41:54.296]                       else if (inherits(cond, "warning")) {
[11:41:54.296]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:54.296]                         if (muffled) 
[11:41:54.296]                           invokeRestart("muffleWarning")
[11:41:54.296]                       }
[11:41:54.296]                       else if (inherits(cond, "condition")) {
[11:41:54.296]                         if (!is.null(pattern)) {
[11:41:54.296]                           computeRestarts <- base::computeRestarts
[11:41:54.296]                           grepl <- base::grepl
[11:41:54.296]                           restarts <- computeRestarts(cond)
[11:41:54.296]                           for (restart in restarts) {
[11:41:54.296]                             name <- restart$name
[11:41:54.296]                             if (is.null(name)) 
[11:41:54.296]                               next
[11:41:54.296]                             if (!grepl(pattern, name)) 
[11:41:54.296]                               next
[11:41:54.296]                             invokeRestart(restart)
[11:41:54.296]                             muffled <- TRUE
[11:41:54.296]                             break
[11:41:54.296]                           }
[11:41:54.296]                         }
[11:41:54.296]                       }
[11:41:54.296]                       invisible(muffled)
[11:41:54.296]                     }
[11:41:54.296]                     muffleCondition(cond, pattern = "^muffle")
[11:41:54.296]                   }
[11:41:54.296]                 }
[11:41:54.296]             }
[11:41:54.296]         }))
[11:41:54.296]     }, error = function(ex) {
[11:41:54.296]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:54.296]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:54.296]                 ...future.rng), started = ...future.startTime, 
[11:41:54.296]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:54.296]             version = "1.8"), class = "FutureResult")
[11:41:54.296]     }, finally = {
[11:41:54.296]         if (!identical(...future.workdir, getwd())) 
[11:41:54.296]             setwd(...future.workdir)
[11:41:54.296]         {
[11:41:54.296]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:54.296]                 ...future.oldOptions$nwarnings <- NULL
[11:41:54.296]             }
[11:41:54.296]             base::options(...future.oldOptions)
[11:41:54.296]             if (.Platform$OS.type == "windows") {
[11:41:54.296]                 old_names <- names(...future.oldEnvVars)
[11:41:54.296]                 envs <- base::Sys.getenv()
[11:41:54.296]                 names <- names(envs)
[11:41:54.296]                 common <- intersect(names, old_names)
[11:41:54.296]                 added <- setdiff(names, old_names)
[11:41:54.296]                 removed <- setdiff(old_names, names)
[11:41:54.296]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:54.296]                   envs[common]]
[11:41:54.296]                 NAMES <- toupper(changed)
[11:41:54.296]                 args <- list()
[11:41:54.296]                 for (kk in seq_along(NAMES)) {
[11:41:54.296]                   name <- changed[[kk]]
[11:41:54.296]                   NAME <- NAMES[[kk]]
[11:41:54.296]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:54.296]                     next
[11:41:54.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:54.296]                 }
[11:41:54.296]                 NAMES <- toupper(added)
[11:41:54.296]                 for (kk in seq_along(NAMES)) {
[11:41:54.296]                   name <- added[[kk]]
[11:41:54.296]                   NAME <- NAMES[[kk]]
[11:41:54.296]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:54.296]                     next
[11:41:54.296]                   args[[name]] <- ""
[11:41:54.296]                 }
[11:41:54.296]                 NAMES <- toupper(removed)
[11:41:54.296]                 for (kk in seq_along(NAMES)) {
[11:41:54.296]                   name <- removed[[kk]]
[11:41:54.296]                   NAME <- NAMES[[kk]]
[11:41:54.296]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:54.296]                     next
[11:41:54.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:54.296]                 }
[11:41:54.296]                 if (length(args) > 0) 
[11:41:54.296]                   base::do.call(base::Sys.setenv, args = args)
[11:41:54.296]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:54.296]             }
[11:41:54.296]             else {
[11:41:54.296]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:54.296]             }
[11:41:54.296]             {
[11:41:54.296]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:54.296]                   0L) {
[11:41:54.296]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:54.296]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:54.296]                   base::options(opts)
[11:41:54.296]                 }
[11:41:54.296]                 {
[11:41:54.296]                   {
[11:41:54.296]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:54.296]                     NULL
[11:41:54.296]                   }
[11:41:54.296]                   options(future.plan = NULL)
[11:41:54.296]                   if (is.na(NA_character_)) 
[11:41:54.296]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:54.296]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:54.296]                   future::plan(list(function (..., workers = 2, 
[11:41:54.296]                     envir = parent.frame()) 
[11:41:54.296]                   strategy(..., workers = workers, envir = envir)), 
[11:41:54.296]                     .cleanup = FALSE, .init = FALSE)
[11:41:54.296]                 }
[11:41:54.296]             }
[11:41:54.296]         }
[11:41:54.296]     })
[11:41:54.296]     if (TRUE) {
[11:41:54.296]         base::sink(type = "output", split = FALSE)
[11:41:54.296]         if (TRUE) {
[11:41:54.296]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:54.296]         }
[11:41:54.296]         else {
[11:41:54.296]             ...future.result["stdout"] <- base::list(NULL)
[11:41:54.296]         }
[11:41:54.296]         base::close(...future.stdout)
[11:41:54.296]         ...future.stdout <- NULL
[11:41:54.296]     }
[11:41:54.296]     ...future.result$conditions <- ...future.conditions
[11:41:54.296]     ...future.result$finished <- base::Sys.time()
[11:41:54.296]     ...future.result
[11:41:54.296] }
[11:41:54.297] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:54.308] receiveMessageFromWorker() for ClusterFuture ...
[11:41:54.308] - Validating connection of MultisessionFuture
[11:41:54.309] - received message: FutureResult
[11:41:54.309] - Received FutureResult
[11:41:54.309] - Erased future from FutureRegistry
[11:41:54.309] result() for ClusterFuture ...
[11:41:54.309] - result already collected: FutureResult
[11:41:54.309] result() for ClusterFuture ... done
[11:41:54.309] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:54.310] result() for ClusterFuture ...
[11:41:54.310] - result already collected: FutureResult
[11:41:54.310] result() for ClusterFuture ... done
[11:41:54.310] result() for ClusterFuture ...
[11:41:54.310] - result already collected: FutureResult
[11:41:54.310] result() for ClusterFuture ... done
[11:41:54.311] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:54.311] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:54.354] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:54.361] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:54.406] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:54.407] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:54.454] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:54.455] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:54.456] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:54.457] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:54.458] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:54.458] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:54.460] MultisessionFuture started
[11:41:54.460] - Launch lazy future ... done
[11:41:54.460] run() for ‘MultisessionFuture’ ... done
[11:41:54.460] Created future:
[11:41:54.460] MultisessionFuture:
[11:41:54.460] Label: ‘future_mapply-48’
[11:41:54.460] Expression:
[11:41:54.460] {
[11:41:54.460]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:54.460]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:54.460]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:54.460]         on.exit(options(oopts), add = TRUE)
[11:41:54.460]     }
[11:41:54.460]     {
[11:41:54.460]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:54.460]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:54.460]                 inherits = FALSE)
[11:41:54.460]             ...future.FUN(...)
[11:41:54.460]         }
[11:41:54.460]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:54.460]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:54.460]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:54.460]         do.call(mapply, args = args)
[11:41:54.460]     }
[11:41:54.460] }
[11:41:54.460] Lazy evaluation: FALSE
[11:41:54.460] Asynchronous evaluation: TRUE
[11:41:54.460] Local evaluation: TRUE
[11:41:54.460] Environment: 0x560ef58e1768
[11:41:54.460] Capture standard output: TRUE
[11:41:54.460] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:54.460] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:54.460] Packages: 1 packages (‘mlr3’)
[11:41:54.460] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:54.460] Resolved: FALSE
[11:41:54.460] Value: <not collected>
[11:41:54.460] Conditions captured: <none>
[11:41:54.460] Early signaling: FALSE
[11:41:54.460] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:54.460] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:54.478] Chunk #48 of 90 ... DONE
[11:41:54.478] Chunk #49 of 90 ...
[11:41:54.478]  - seeds: [1] <seeds>
[11:41:54.479] getGlobalsAndPackages() ...
[11:41:54.479] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:54.479] Resolving globals: FALSE
[11:41:54.479] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:54.480] - packages: [1] ‘mlr3’
[11:41:54.480] getGlobalsAndPackages() ... DONE
[11:41:54.480] run() for ‘Future’ ...
[11:41:54.480] - state: ‘created’
[11:41:54.480] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:54.490] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:54.490] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:54.491]   - Field: ‘node’
[11:41:54.491]   - Field: ‘label’
[11:41:54.491]   - Field: ‘local’
[11:41:54.491]   - Field: ‘owner’
[11:41:54.491]   - Field: ‘envir’
[11:41:54.491]   - Field: ‘workers’
[11:41:54.491]   - Field: ‘packages’
[11:41:54.491]   - Field: ‘gc’
[11:41:54.491]   - Field: ‘conditions’
[11:41:54.491]   - Field: ‘persistent’
[11:41:54.491]   - Field: ‘expr’
[11:41:54.491]   - Field: ‘uuid’
[11:41:54.491]   - Field: ‘seed’
[11:41:54.491]   - Field: ‘version’
[11:41:54.491]   - Field: ‘result’
[11:41:54.491]   - Field: ‘asynchronous’
[11:41:54.491]   - Field: ‘calls’
[11:41:54.491]   - Field: ‘globals’
[11:41:54.491]   - Field: ‘stdout’
[11:41:54.491]   - Field: ‘earlySignal’
[11:41:54.491]   - Field: ‘lazy’
[11:41:54.492]   - Field: ‘state’
[11:41:54.492] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:54.492] - Launch lazy future ...
[11:41:54.492] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:54.492] Packages needed by future strategies (n = 0): <none>
[11:41:54.492] {
[11:41:54.492]     {
[11:41:54.492]         {
[11:41:54.492]             ...future.startTime <- base::Sys.time()
[11:41:54.492]             {
[11:41:54.492]                 {
[11:41:54.492]                   {
[11:41:54.492]                     {
[11:41:54.492]                       {
[11:41:54.492]                         base::local({
[11:41:54.492]                           has_future <- base::requireNamespace("future", 
[11:41:54.492]                             quietly = TRUE)
[11:41:54.492]                           if (has_future) {
[11:41:54.492]                             ns <- base::getNamespace("future")
[11:41:54.492]                             version <- ns[[".package"]][["version"]]
[11:41:54.492]                             if (is.null(version)) 
[11:41:54.492]                               version <- utils::packageVersion("future")
[11:41:54.492]                           }
[11:41:54.492]                           else {
[11:41:54.492]                             version <- NULL
[11:41:54.492]                           }
[11:41:54.492]                           if (!has_future || version < "1.8.0") {
[11:41:54.492]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:54.492]                               "", base::R.version$version.string), 
[11:41:54.492]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:54.492]                                 base::R.version$platform, 8 * 
[11:41:54.492]                                   base::.Machine$sizeof.pointer), 
[11:41:54.492]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:54.492]                                 "release", "version")], collapse = " "), 
[11:41:54.492]                               hostname = base::Sys.info()[["nodename"]])
[11:41:54.492]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:54.492]                               info)
[11:41:54.492]                             info <- base::paste(info, collapse = "; ")
[11:41:54.492]                             if (!has_future) {
[11:41:54.492]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:54.492]                                 info)
[11:41:54.492]                             }
[11:41:54.492]                             else {
[11:41:54.492]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:54.492]                                 info, version)
[11:41:54.492]                             }
[11:41:54.492]                             base::stop(msg)
[11:41:54.492]                           }
[11:41:54.492]                         })
[11:41:54.492]                       }
[11:41:54.492]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:54.492]                       base::options(mc.cores = 1L)
[11:41:54.492]                     }
[11:41:54.492]                     base::local({
[11:41:54.492]                       for (pkg in "mlr3") {
[11:41:54.492]                         base::loadNamespace(pkg)
[11:41:54.492]                         base::library(pkg, character.only = TRUE)
[11:41:54.492]                       }
[11:41:54.492]                     })
[11:41:54.492]                   }
[11:41:54.492]                   options(future.plan = NULL)
[11:41:54.492]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:54.492]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:54.492]                 }
[11:41:54.492]                 ...future.workdir <- getwd()
[11:41:54.492]             }
[11:41:54.492]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:54.492]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:54.492]         }
[11:41:54.492]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:54.492]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:54.492]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:54.492]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:54.492]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:54.492]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:54.492]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:54.492]             base::names(...future.oldOptions))
[11:41:54.492]     }
[11:41:54.492]     if (FALSE) {
[11:41:54.492]     }
[11:41:54.492]     else {
[11:41:54.492]         if (TRUE) {
[11:41:54.492]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:54.492]                 open = "w")
[11:41:54.492]         }
[11:41:54.492]         else {
[11:41:54.492]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:54.492]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:54.492]         }
[11:41:54.492]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:54.492]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:54.492]             base::sink(type = "output", split = FALSE)
[11:41:54.492]             base::close(...future.stdout)
[11:41:54.492]         }, add = TRUE)
[11:41:54.492]     }
[11:41:54.492]     ...future.frame <- base::sys.nframe()
[11:41:54.492]     ...future.conditions <- base::list()
[11:41:54.492]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:54.492]     if (FALSE) {
[11:41:54.492]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:54.492]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:54.492]     }
[11:41:54.492]     ...future.result <- base::tryCatch({
[11:41:54.492]         base::withCallingHandlers({
[11:41:54.492]             ...future.value <- base::withVisible(base::local({
[11:41:54.492]                 ...future.makeSendCondition <- local({
[11:41:54.492]                   sendCondition <- NULL
[11:41:54.492]                   function(frame = 1L) {
[11:41:54.492]                     if (is.function(sendCondition)) 
[11:41:54.492]                       return(sendCondition)
[11:41:54.492]                     ns <- getNamespace("parallel")
[11:41:54.492]                     if (exists("sendData", mode = "function", 
[11:41:54.492]                       envir = ns)) {
[11:41:54.492]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:54.492]                         envir = ns)
[11:41:54.492]                       envir <- sys.frame(frame)
[11:41:54.492]                       master <- NULL
[11:41:54.492]                       while (!identical(envir, .GlobalEnv) && 
[11:41:54.492]                         !identical(envir, emptyenv())) {
[11:41:54.492]                         if (exists("master", mode = "list", envir = envir, 
[11:41:54.492]                           inherits = FALSE)) {
[11:41:54.492]                           master <- get("master", mode = "list", 
[11:41:54.492]                             envir = envir, inherits = FALSE)
[11:41:54.492]                           if (inherits(master, c("SOCKnode", 
[11:41:54.492]                             "SOCK0node"))) {
[11:41:54.492]                             sendCondition <<- function(cond) {
[11:41:54.492]                               data <- list(type = "VALUE", value = cond, 
[11:41:54.492]                                 success = TRUE)
[11:41:54.492]                               parallel_sendData(master, data)
[11:41:54.492]                             }
[11:41:54.492]                             return(sendCondition)
[11:41:54.492]                           }
[11:41:54.492]                         }
[11:41:54.492]                         frame <- frame + 1L
[11:41:54.492]                         envir <- sys.frame(frame)
[11:41:54.492]                       }
[11:41:54.492]                     }
[11:41:54.492]                     sendCondition <<- function(cond) NULL
[11:41:54.492]                   }
[11:41:54.492]                 })
[11:41:54.492]                 withCallingHandlers({
[11:41:54.492]                   {
[11:41:54.492]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:54.492]                     if (!identical(...future.globals.maxSize.org, 
[11:41:54.492]                       ...future.globals.maxSize)) {
[11:41:54.492]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:54.492]                       on.exit(options(oopts), add = TRUE)
[11:41:54.492]                     }
[11:41:54.492]                     {
[11:41:54.492]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:54.492]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:54.492]                           envir = globalenv(), inherits = FALSE)
[11:41:54.492]                         ...future.FUN(...)
[11:41:54.492]                       }
[11:41:54.492]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:54.492]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:54.492]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:54.492]                         USE.NAMES = FALSE)
[11:41:54.492]                       do.call(mapply, args = args)
[11:41:54.492]                     }
[11:41:54.492]                   }
[11:41:54.492]                 }, immediateCondition = function(cond) {
[11:41:54.492]                   sendCondition <- ...future.makeSendCondition()
[11:41:54.492]                   sendCondition(cond)
[11:41:54.492]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:54.492]                   {
[11:41:54.492]                     inherits <- base::inherits
[11:41:54.492]                     invokeRestart <- base::invokeRestart
[11:41:54.492]                     is.null <- base::is.null
[11:41:54.492]                     muffled <- FALSE
[11:41:54.492]                     if (inherits(cond, "message")) {
[11:41:54.492]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:54.492]                       if (muffled) 
[11:41:54.492]                         invokeRestart("muffleMessage")
[11:41:54.492]                     }
[11:41:54.492]                     else if (inherits(cond, "warning")) {
[11:41:54.492]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:54.492]                       if (muffled) 
[11:41:54.492]                         invokeRestart("muffleWarning")
[11:41:54.492]                     }
[11:41:54.492]                     else if (inherits(cond, "condition")) {
[11:41:54.492]                       if (!is.null(pattern)) {
[11:41:54.492]                         computeRestarts <- base::computeRestarts
[11:41:54.492]                         grepl <- base::grepl
[11:41:54.492]                         restarts <- computeRestarts(cond)
[11:41:54.492]                         for (restart in restarts) {
[11:41:54.492]                           name <- restart$name
[11:41:54.492]                           if (is.null(name)) 
[11:41:54.492]                             next
[11:41:54.492]                           if (!grepl(pattern, name)) 
[11:41:54.492]                             next
[11:41:54.492]                           invokeRestart(restart)
[11:41:54.492]                           muffled <- TRUE
[11:41:54.492]                           break
[11:41:54.492]                         }
[11:41:54.492]                       }
[11:41:54.492]                     }
[11:41:54.492]                     invisible(muffled)
[11:41:54.492]                   }
[11:41:54.492]                   muffleCondition(cond)
[11:41:54.492]                 })
[11:41:54.492]             }))
[11:41:54.492]             future::FutureResult(value = ...future.value$value, 
[11:41:54.492]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:54.492]                   ...future.rng), globalenv = if (FALSE) 
[11:41:54.492]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:54.492]                     ...future.globalenv.names))
[11:41:54.492]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:54.492]         }, condition = base::local({
[11:41:54.492]             c <- base::c
[11:41:54.492]             inherits <- base::inherits
[11:41:54.492]             invokeRestart <- base::invokeRestart
[11:41:54.492]             length <- base::length
[11:41:54.492]             list <- base::list
[11:41:54.492]             seq.int <- base::seq.int
[11:41:54.492]             signalCondition <- base::signalCondition
[11:41:54.492]             sys.calls <- base::sys.calls
[11:41:54.492]             `[[` <- base::`[[`
[11:41:54.492]             `+` <- base::`+`
[11:41:54.492]             `<<-` <- base::`<<-`
[11:41:54.492]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:54.492]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:54.492]                   3L)]
[11:41:54.492]             }
[11:41:54.492]             function(cond) {
[11:41:54.492]                 is_error <- inherits(cond, "error")
[11:41:54.492]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:54.492]                   NULL)
[11:41:54.492]                 if (is_error) {
[11:41:54.492]                   sessionInformation <- function() {
[11:41:54.492]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:54.492]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:54.492]                       search = base::search(), system = base::Sys.info())
[11:41:54.492]                   }
[11:41:54.492]                   ...future.conditions[[length(...future.conditions) + 
[11:41:54.492]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:54.492]                     cond$call), session = sessionInformation(), 
[11:41:54.492]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:54.492]                   signalCondition(cond)
[11:41:54.492]                 }
[11:41:54.492]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:54.492]                 "immediateCondition"))) {
[11:41:54.492]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:54.492]                   ...future.conditions[[length(...future.conditions) + 
[11:41:54.492]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:54.492]                   if (TRUE && !signal) {
[11:41:54.492]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:54.492]                     {
[11:41:54.492]                       inherits <- base::inherits
[11:41:54.492]                       invokeRestart <- base::invokeRestart
[11:41:54.492]                       is.null <- base::is.null
[11:41:54.492]                       muffled <- FALSE
[11:41:54.492]                       if (inherits(cond, "message")) {
[11:41:54.492]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:54.492]                         if (muffled) 
[11:41:54.492]                           invokeRestart("muffleMessage")
[11:41:54.492]                       }
[11:41:54.492]                       else if (inherits(cond, "warning")) {
[11:41:54.492]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:54.492]                         if (muffled) 
[11:41:54.492]                           invokeRestart("muffleWarning")
[11:41:54.492]                       }
[11:41:54.492]                       else if (inherits(cond, "condition")) {
[11:41:54.492]                         if (!is.null(pattern)) {
[11:41:54.492]                           computeRestarts <- base::computeRestarts
[11:41:54.492]                           grepl <- base::grepl
[11:41:54.492]                           restarts <- computeRestarts(cond)
[11:41:54.492]                           for (restart in restarts) {
[11:41:54.492]                             name <- restart$name
[11:41:54.492]                             if (is.null(name)) 
[11:41:54.492]                               next
[11:41:54.492]                             if (!grepl(pattern, name)) 
[11:41:54.492]                               next
[11:41:54.492]                             invokeRestart(restart)
[11:41:54.492]                             muffled <- TRUE
[11:41:54.492]                             break
[11:41:54.492]                           }
[11:41:54.492]                         }
[11:41:54.492]                       }
[11:41:54.492]                       invisible(muffled)
[11:41:54.492]                     }
[11:41:54.492]                     muffleCondition(cond, pattern = "^muffle")
[11:41:54.492]                   }
[11:41:54.492]                 }
[11:41:54.492]                 else {
[11:41:54.492]                   if (TRUE) {
[11:41:54.492]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:54.492]                     {
[11:41:54.492]                       inherits <- base::inherits
[11:41:54.492]                       invokeRestart <- base::invokeRestart
[11:41:54.492]                       is.null <- base::is.null
[11:41:54.492]                       muffled <- FALSE
[11:41:54.492]                       if (inherits(cond, "message")) {
[11:41:54.492]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:54.492]                         if (muffled) 
[11:41:54.492]                           invokeRestart("muffleMessage")
[11:41:54.492]                       }
[11:41:54.492]                       else if (inherits(cond, "warning")) {
[11:41:54.492]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:54.492]                         if (muffled) 
[11:41:54.492]                           invokeRestart("muffleWarning")
[11:41:54.492]                       }
[11:41:54.492]                       else if (inherits(cond, "condition")) {
[11:41:54.492]                         if (!is.null(pattern)) {
[11:41:54.492]                           computeRestarts <- base::computeRestarts
[11:41:54.492]                           grepl <- base::grepl
[11:41:54.492]                           restarts <- computeRestarts(cond)
[11:41:54.492]                           for (restart in restarts) {
[11:41:54.492]                             name <- restart$name
[11:41:54.492]                             if (is.null(name)) 
[11:41:54.492]                               next
[11:41:54.492]                             if (!grepl(pattern, name)) 
[11:41:54.492]                               next
[11:41:54.492]                             invokeRestart(restart)
[11:41:54.492]                             muffled <- TRUE
[11:41:54.492]                             break
[11:41:54.492]                           }
[11:41:54.492]                         }
[11:41:54.492]                       }
[11:41:54.492]                       invisible(muffled)
[11:41:54.492]                     }
[11:41:54.492]                     muffleCondition(cond, pattern = "^muffle")
[11:41:54.492]                   }
[11:41:54.492]                 }
[11:41:54.492]             }
[11:41:54.492]         }))
[11:41:54.492]     }, error = function(ex) {
[11:41:54.492]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:54.492]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:54.492]                 ...future.rng), started = ...future.startTime, 
[11:41:54.492]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:54.492]             version = "1.8"), class = "FutureResult")
[11:41:54.492]     }, finally = {
[11:41:54.492]         if (!identical(...future.workdir, getwd())) 
[11:41:54.492]             setwd(...future.workdir)
[11:41:54.492]         {
[11:41:54.492]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:54.492]                 ...future.oldOptions$nwarnings <- NULL
[11:41:54.492]             }
[11:41:54.492]             base::options(...future.oldOptions)
[11:41:54.492]             if (.Platform$OS.type == "windows") {
[11:41:54.492]                 old_names <- names(...future.oldEnvVars)
[11:41:54.492]                 envs <- base::Sys.getenv()
[11:41:54.492]                 names <- names(envs)
[11:41:54.492]                 common <- intersect(names, old_names)
[11:41:54.492]                 added <- setdiff(names, old_names)
[11:41:54.492]                 removed <- setdiff(old_names, names)
[11:41:54.492]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:54.492]                   envs[common]]
[11:41:54.492]                 NAMES <- toupper(changed)
[11:41:54.492]                 args <- list()
[11:41:54.492]                 for (kk in seq_along(NAMES)) {
[11:41:54.492]                   name <- changed[[kk]]
[11:41:54.492]                   NAME <- NAMES[[kk]]
[11:41:54.492]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:54.492]                     next
[11:41:54.492]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:54.492]                 }
[11:41:54.492]                 NAMES <- toupper(added)
[11:41:54.492]                 for (kk in seq_along(NAMES)) {
[11:41:54.492]                   name <- added[[kk]]
[11:41:54.492]                   NAME <- NAMES[[kk]]
[11:41:54.492]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:54.492]                     next
[11:41:54.492]                   args[[name]] <- ""
[11:41:54.492]                 }
[11:41:54.492]                 NAMES <- toupper(removed)
[11:41:54.492]                 for (kk in seq_along(NAMES)) {
[11:41:54.492]                   name <- removed[[kk]]
[11:41:54.492]                   NAME <- NAMES[[kk]]
[11:41:54.492]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:54.492]                     next
[11:41:54.492]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:54.492]                 }
[11:41:54.492]                 if (length(args) > 0) 
[11:41:54.492]                   base::do.call(base::Sys.setenv, args = args)
[11:41:54.492]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:54.492]             }
[11:41:54.492]             else {
[11:41:54.492]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:54.492]             }
[11:41:54.492]             {
[11:41:54.492]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:54.492]                   0L) {
[11:41:54.492]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:54.492]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:54.492]                   base::options(opts)
[11:41:54.492]                 }
[11:41:54.492]                 {
[11:41:54.492]                   {
[11:41:54.492]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:54.492]                     NULL
[11:41:54.492]                   }
[11:41:54.492]                   options(future.plan = NULL)
[11:41:54.492]                   if (is.na(NA_character_)) 
[11:41:54.492]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:54.492]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:54.492]                   future::plan(list(function (..., workers = 2, 
[11:41:54.492]                     envir = parent.frame()) 
[11:41:54.492]                   strategy(..., workers = workers, envir = envir)), 
[11:41:54.492]                     .cleanup = FALSE, .init = FALSE)
[11:41:54.492]                 }
[11:41:54.492]             }
[11:41:54.492]         }
[11:41:54.492]     })
[11:41:54.492]     if (TRUE) {
[11:41:54.492]         base::sink(type = "output", split = FALSE)
[11:41:54.492]         if (TRUE) {
[11:41:54.492]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:54.492]         }
[11:41:54.492]         else {
[11:41:54.492]             ...future.result["stdout"] <- base::list(NULL)
[11:41:54.492]         }
[11:41:54.492]         base::close(...future.stdout)
[11:41:54.492]         ...future.stdout <- NULL
[11:41:54.492]     }
[11:41:54.492]     ...future.result$conditions <- ...future.conditions
[11:41:54.492]     ...future.result$finished <- base::Sys.time()
[11:41:54.492]     ...future.result
[11:41:54.492] }
[11:41:54.494] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:54.506] receiveMessageFromWorker() for ClusterFuture ...
[11:41:54.506] - Validating connection of MultisessionFuture
[11:41:54.506] - received message: FutureResult
[11:41:54.506] - Received FutureResult
[11:41:54.507] - Erased future from FutureRegistry
[11:41:54.507] result() for ClusterFuture ...
[11:41:54.507] - result already collected: FutureResult
[11:41:54.507] result() for ClusterFuture ... done
[11:41:54.507] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:54.507] result() for ClusterFuture ...
[11:41:54.507] - result already collected: FutureResult
[11:41:54.507] result() for ClusterFuture ... done
[11:41:54.507] result() for ClusterFuture ...
[11:41:54.508] - result already collected: FutureResult
[11:41:54.508] result() for ClusterFuture ... done
[11:41:54.509] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:54.509] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:54.554] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:54.560] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:54.606] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:54.607] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:54.653] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:54.653] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:54.654] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:54.654] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:54.655] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:54.655] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:54.655] MultisessionFuture started
[11:41:54.655] - Launch lazy future ... done
[11:41:54.655] run() for ‘MultisessionFuture’ ... done
[11:41:54.655] Created future:
[11:41:54.655] MultisessionFuture:
[11:41:54.655] Label: ‘future_mapply-49’
[11:41:54.655] Expression:
[11:41:54.655] {
[11:41:54.655]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:54.655]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:54.655]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:54.655]         on.exit(options(oopts), add = TRUE)
[11:41:54.655]     }
[11:41:54.655]     {
[11:41:54.655]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:54.655]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:54.655]                 inherits = FALSE)
[11:41:54.655]             ...future.FUN(...)
[11:41:54.655]         }
[11:41:54.655]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:54.655]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:54.655]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:54.655]         do.call(mapply, args = args)
[11:41:54.655]     }
[11:41:54.655] }
[11:41:54.655] Lazy evaluation: FALSE
[11:41:54.655] Asynchronous evaluation: TRUE
[11:41:54.655] Local evaluation: TRUE
[11:41:54.655] Environment: 0x560ef58e1768
[11:41:54.655] Capture standard output: TRUE
[11:41:54.655] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:54.655] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:54.655] Packages: 1 packages (‘mlr3’)
[11:41:54.655] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:54.655] Resolved: FALSE
[11:41:54.655] Value: <not collected>
[11:41:54.655] Conditions captured: <none>
[11:41:54.655] Early signaling: FALSE
[11:41:54.655] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:54.655] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:54.670] Chunk #49 of 90 ... DONE
[11:41:54.670] Chunk #50 of 90 ...
[11:41:54.670]  - seeds: [1] <seeds>
[11:41:54.670] getGlobalsAndPackages() ...
[11:41:54.670] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:54.670] Resolving globals: FALSE
[11:41:54.671] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:54.671] - packages: [1] ‘mlr3’
[11:41:54.675] getGlobalsAndPackages() ... DONE
[11:41:54.675] run() for ‘Future’ ...
[11:41:54.675] - state: ‘created’
[11:41:54.676] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:54.687] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:54.688] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:54.688]   - Field: ‘node’
[11:41:54.688]   - Field: ‘label’
[11:41:54.688]   - Field: ‘local’
[11:41:54.688]   - Field: ‘owner’
[11:41:54.688]   - Field: ‘envir’
[11:41:54.688]   - Field: ‘workers’
[11:41:54.688]   - Field: ‘packages’
[11:41:54.688]   - Field: ‘gc’
[11:41:54.688]   - Field: ‘conditions’
[11:41:54.689]   - Field: ‘persistent’
[11:41:54.689]   - Field: ‘expr’
[11:41:54.689]   - Field: ‘uuid’
[11:41:54.689]   - Field: ‘seed’
[11:41:54.689]   - Field: ‘version’
[11:41:54.689]   - Field: ‘result’
[11:41:54.689]   - Field: ‘asynchronous’
[11:41:54.689]   - Field: ‘calls’
[11:41:54.689]   - Field: ‘globals’
[11:41:54.689]   - Field: ‘stdout’
[11:41:54.689]   - Field: ‘earlySignal’
[11:41:54.689]   - Field: ‘lazy’
[11:41:54.689]   - Field: ‘state’
[11:41:54.689] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:54.689] - Launch lazy future ...
[11:41:54.689] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:54.690] Packages needed by future strategies (n = 0): <none>
[11:41:54.690] {
[11:41:54.690]     {
[11:41:54.690]         {
[11:41:54.690]             ...future.startTime <- base::Sys.time()
[11:41:54.690]             {
[11:41:54.690]                 {
[11:41:54.690]                   {
[11:41:54.690]                     {
[11:41:54.690]                       {
[11:41:54.690]                         base::local({
[11:41:54.690]                           has_future <- base::requireNamespace("future", 
[11:41:54.690]                             quietly = TRUE)
[11:41:54.690]                           if (has_future) {
[11:41:54.690]                             ns <- base::getNamespace("future")
[11:41:54.690]                             version <- ns[[".package"]][["version"]]
[11:41:54.690]                             if (is.null(version)) 
[11:41:54.690]                               version <- utils::packageVersion("future")
[11:41:54.690]                           }
[11:41:54.690]                           else {
[11:41:54.690]                             version <- NULL
[11:41:54.690]                           }
[11:41:54.690]                           if (!has_future || version < "1.8.0") {
[11:41:54.690]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:54.690]                               "", base::R.version$version.string), 
[11:41:54.690]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:54.690]                                 base::R.version$platform, 8 * 
[11:41:54.690]                                   base::.Machine$sizeof.pointer), 
[11:41:54.690]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:54.690]                                 "release", "version")], collapse = " "), 
[11:41:54.690]                               hostname = base::Sys.info()[["nodename"]])
[11:41:54.690]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:54.690]                               info)
[11:41:54.690]                             info <- base::paste(info, collapse = "; ")
[11:41:54.690]                             if (!has_future) {
[11:41:54.690]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:54.690]                                 info)
[11:41:54.690]                             }
[11:41:54.690]                             else {
[11:41:54.690]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:54.690]                                 info, version)
[11:41:54.690]                             }
[11:41:54.690]                             base::stop(msg)
[11:41:54.690]                           }
[11:41:54.690]                         })
[11:41:54.690]                       }
[11:41:54.690]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:54.690]                       base::options(mc.cores = 1L)
[11:41:54.690]                     }
[11:41:54.690]                     base::local({
[11:41:54.690]                       for (pkg in "mlr3") {
[11:41:54.690]                         base::loadNamespace(pkg)
[11:41:54.690]                         base::library(pkg, character.only = TRUE)
[11:41:54.690]                       }
[11:41:54.690]                     })
[11:41:54.690]                   }
[11:41:54.690]                   options(future.plan = NULL)
[11:41:54.690]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:54.690]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:54.690]                 }
[11:41:54.690]                 ...future.workdir <- getwd()
[11:41:54.690]             }
[11:41:54.690]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:54.690]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:54.690]         }
[11:41:54.690]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:54.690]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:54.690]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:54.690]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:54.690]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:54.690]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:54.690]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:54.690]             base::names(...future.oldOptions))
[11:41:54.690]     }
[11:41:54.690]     if (FALSE) {
[11:41:54.690]     }
[11:41:54.690]     else {
[11:41:54.690]         if (TRUE) {
[11:41:54.690]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:54.690]                 open = "w")
[11:41:54.690]         }
[11:41:54.690]         else {
[11:41:54.690]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:54.690]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:54.690]         }
[11:41:54.690]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:54.690]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:54.690]             base::sink(type = "output", split = FALSE)
[11:41:54.690]             base::close(...future.stdout)
[11:41:54.690]         }, add = TRUE)
[11:41:54.690]     }
[11:41:54.690]     ...future.frame <- base::sys.nframe()
[11:41:54.690]     ...future.conditions <- base::list()
[11:41:54.690]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:54.690]     if (FALSE) {
[11:41:54.690]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:54.690]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:54.690]     }
[11:41:54.690]     ...future.result <- base::tryCatch({
[11:41:54.690]         base::withCallingHandlers({
[11:41:54.690]             ...future.value <- base::withVisible(base::local({
[11:41:54.690]                 ...future.makeSendCondition <- local({
[11:41:54.690]                   sendCondition <- NULL
[11:41:54.690]                   function(frame = 1L) {
[11:41:54.690]                     if (is.function(sendCondition)) 
[11:41:54.690]                       return(sendCondition)
[11:41:54.690]                     ns <- getNamespace("parallel")
[11:41:54.690]                     if (exists("sendData", mode = "function", 
[11:41:54.690]                       envir = ns)) {
[11:41:54.690]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:54.690]                         envir = ns)
[11:41:54.690]                       envir <- sys.frame(frame)
[11:41:54.690]                       master <- NULL
[11:41:54.690]                       while (!identical(envir, .GlobalEnv) && 
[11:41:54.690]                         !identical(envir, emptyenv())) {
[11:41:54.690]                         if (exists("master", mode = "list", envir = envir, 
[11:41:54.690]                           inherits = FALSE)) {
[11:41:54.690]                           master <- get("master", mode = "list", 
[11:41:54.690]                             envir = envir, inherits = FALSE)
[11:41:54.690]                           if (inherits(master, c("SOCKnode", 
[11:41:54.690]                             "SOCK0node"))) {
[11:41:54.690]                             sendCondition <<- function(cond) {
[11:41:54.690]                               data <- list(type = "VALUE", value = cond, 
[11:41:54.690]                                 success = TRUE)
[11:41:54.690]                               parallel_sendData(master, data)
[11:41:54.690]                             }
[11:41:54.690]                             return(sendCondition)
[11:41:54.690]                           }
[11:41:54.690]                         }
[11:41:54.690]                         frame <- frame + 1L
[11:41:54.690]                         envir <- sys.frame(frame)
[11:41:54.690]                       }
[11:41:54.690]                     }
[11:41:54.690]                     sendCondition <<- function(cond) NULL
[11:41:54.690]                   }
[11:41:54.690]                 })
[11:41:54.690]                 withCallingHandlers({
[11:41:54.690]                   {
[11:41:54.690]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:54.690]                     if (!identical(...future.globals.maxSize.org, 
[11:41:54.690]                       ...future.globals.maxSize)) {
[11:41:54.690]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:54.690]                       on.exit(options(oopts), add = TRUE)
[11:41:54.690]                     }
[11:41:54.690]                     {
[11:41:54.690]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:54.690]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:54.690]                           envir = globalenv(), inherits = FALSE)
[11:41:54.690]                         ...future.FUN(...)
[11:41:54.690]                       }
[11:41:54.690]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:54.690]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:54.690]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:54.690]                         USE.NAMES = FALSE)
[11:41:54.690]                       do.call(mapply, args = args)
[11:41:54.690]                     }
[11:41:54.690]                   }
[11:41:54.690]                 }, immediateCondition = function(cond) {
[11:41:54.690]                   sendCondition <- ...future.makeSendCondition()
[11:41:54.690]                   sendCondition(cond)
[11:41:54.690]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:54.690]                   {
[11:41:54.690]                     inherits <- base::inherits
[11:41:54.690]                     invokeRestart <- base::invokeRestart
[11:41:54.690]                     is.null <- base::is.null
[11:41:54.690]                     muffled <- FALSE
[11:41:54.690]                     if (inherits(cond, "message")) {
[11:41:54.690]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:54.690]                       if (muffled) 
[11:41:54.690]                         invokeRestart("muffleMessage")
[11:41:54.690]                     }
[11:41:54.690]                     else if (inherits(cond, "warning")) {
[11:41:54.690]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:54.690]                       if (muffled) 
[11:41:54.690]                         invokeRestart("muffleWarning")
[11:41:54.690]                     }
[11:41:54.690]                     else if (inherits(cond, "condition")) {
[11:41:54.690]                       if (!is.null(pattern)) {
[11:41:54.690]                         computeRestarts <- base::computeRestarts
[11:41:54.690]                         grepl <- base::grepl
[11:41:54.690]                         restarts <- computeRestarts(cond)
[11:41:54.690]                         for (restart in restarts) {
[11:41:54.690]                           name <- restart$name
[11:41:54.690]                           if (is.null(name)) 
[11:41:54.690]                             next
[11:41:54.690]                           if (!grepl(pattern, name)) 
[11:41:54.690]                             next
[11:41:54.690]                           invokeRestart(restart)
[11:41:54.690]                           muffled <- TRUE
[11:41:54.690]                           break
[11:41:54.690]                         }
[11:41:54.690]                       }
[11:41:54.690]                     }
[11:41:54.690]                     invisible(muffled)
[11:41:54.690]                   }
[11:41:54.690]                   muffleCondition(cond)
[11:41:54.690]                 })
[11:41:54.690]             }))
[11:41:54.690]             future::FutureResult(value = ...future.value$value, 
[11:41:54.690]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:54.690]                   ...future.rng), globalenv = if (FALSE) 
[11:41:54.690]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:54.690]                     ...future.globalenv.names))
[11:41:54.690]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:54.690]         }, condition = base::local({
[11:41:54.690]             c <- base::c
[11:41:54.690]             inherits <- base::inherits
[11:41:54.690]             invokeRestart <- base::invokeRestart
[11:41:54.690]             length <- base::length
[11:41:54.690]             list <- base::list
[11:41:54.690]             seq.int <- base::seq.int
[11:41:54.690]             signalCondition <- base::signalCondition
[11:41:54.690]             sys.calls <- base::sys.calls
[11:41:54.690]             `[[` <- base::`[[`
[11:41:54.690]             `+` <- base::`+`
[11:41:54.690]             `<<-` <- base::`<<-`
[11:41:54.690]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:54.690]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:54.690]                   3L)]
[11:41:54.690]             }
[11:41:54.690]             function(cond) {
[11:41:54.690]                 is_error <- inherits(cond, "error")
[11:41:54.690]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:54.690]                   NULL)
[11:41:54.690]                 if (is_error) {
[11:41:54.690]                   sessionInformation <- function() {
[11:41:54.690]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:54.690]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:54.690]                       search = base::search(), system = base::Sys.info())
[11:41:54.690]                   }
[11:41:54.690]                   ...future.conditions[[length(...future.conditions) + 
[11:41:54.690]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:54.690]                     cond$call), session = sessionInformation(), 
[11:41:54.690]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:54.690]                   signalCondition(cond)
[11:41:54.690]                 }
[11:41:54.690]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:54.690]                 "immediateCondition"))) {
[11:41:54.690]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:54.690]                   ...future.conditions[[length(...future.conditions) + 
[11:41:54.690]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:54.690]                   if (TRUE && !signal) {
[11:41:54.690]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:54.690]                     {
[11:41:54.690]                       inherits <- base::inherits
[11:41:54.690]                       invokeRestart <- base::invokeRestart
[11:41:54.690]                       is.null <- base::is.null
[11:41:54.690]                       muffled <- FALSE
[11:41:54.690]                       if (inherits(cond, "message")) {
[11:41:54.690]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:54.690]                         if (muffled) 
[11:41:54.690]                           invokeRestart("muffleMessage")
[11:41:54.690]                       }
[11:41:54.690]                       else if (inherits(cond, "warning")) {
[11:41:54.690]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:54.690]                         if (muffled) 
[11:41:54.690]                           invokeRestart("muffleWarning")
[11:41:54.690]                       }
[11:41:54.690]                       else if (inherits(cond, "condition")) {
[11:41:54.690]                         if (!is.null(pattern)) {
[11:41:54.690]                           computeRestarts <- base::computeRestarts
[11:41:54.690]                           grepl <- base::grepl
[11:41:54.690]                           restarts <- computeRestarts(cond)
[11:41:54.690]                           for (restart in restarts) {
[11:41:54.690]                             name <- restart$name
[11:41:54.690]                             if (is.null(name)) 
[11:41:54.690]                               next
[11:41:54.690]                             if (!grepl(pattern, name)) 
[11:41:54.690]                               next
[11:41:54.690]                             invokeRestart(restart)
[11:41:54.690]                             muffled <- TRUE
[11:41:54.690]                             break
[11:41:54.690]                           }
[11:41:54.690]                         }
[11:41:54.690]                       }
[11:41:54.690]                       invisible(muffled)
[11:41:54.690]                     }
[11:41:54.690]                     muffleCondition(cond, pattern = "^muffle")
[11:41:54.690]                   }
[11:41:54.690]                 }
[11:41:54.690]                 else {
[11:41:54.690]                   if (TRUE) {
[11:41:54.690]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:54.690]                     {
[11:41:54.690]                       inherits <- base::inherits
[11:41:54.690]                       invokeRestart <- base::invokeRestart
[11:41:54.690]                       is.null <- base::is.null
[11:41:54.690]                       muffled <- FALSE
[11:41:54.690]                       if (inherits(cond, "message")) {
[11:41:54.690]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:54.690]                         if (muffled) 
[11:41:54.690]                           invokeRestart("muffleMessage")
[11:41:54.690]                       }
[11:41:54.690]                       else if (inherits(cond, "warning")) {
[11:41:54.690]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:54.690]                         if (muffled) 
[11:41:54.690]                           invokeRestart("muffleWarning")
[11:41:54.690]                       }
[11:41:54.690]                       else if (inherits(cond, "condition")) {
[11:41:54.690]                         if (!is.null(pattern)) {
[11:41:54.690]                           computeRestarts <- base::computeRestarts
[11:41:54.690]                           grepl <- base::grepl
[11:41:54.690]                           restarts <- computeRestarts(cond)
[11:41:54.690]                           for (restart in restarts) {
[11:41:54.690]                             name <- restart$name
[11:41:54.690]                             if (is.null(name)) 
[11:41:54.690]                               next
[11:41:54.690]                             if (!grepl(pattern, name)) 
[11:41:54.690]                               next
[11:41:54.690]                             invokeRestart(restart)
[11:41:54.690]                             muffled <- TRUE
[11:41:54.690]                             break
[11:41:54.690]                           }
[11:41:54.690]                         }
[11:41:54.690]                       }
[11:41:54.690]                       invisible(muffled)
[11:41:54.690]                     }
[11:41:54.690]                     muffleCondition(cond, pattern = "^muffle")
[11:41:54.690]                   }
[11:41:54.690]                 }
[11:41:54.690]             }
[11:41:54.690]         }))
[11:41:54.690]     }, error = function(ex) {
[11:41:54.690]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:54.690]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:54.690]                 ...future.rng), started = ...future.startTime, 
[11:41:54.690]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:54.690]             version = "1.8"), class = "FutureResult")
[11:41:54.690]     }, finally = {
[11:41:54.690]         if (!identical(...future.workdir, getwd())) 
[11:41:54.690]             setwd(...future.workdir)
[11:41:54.690]         {
[11:41:54.690]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:54.690]                 ...future.oldOptions$nwarnings <- NULL
[11:41:54.690]             }
[11:41:54.690]             base::options(...future.oldOptions)
[11:41:54.690]             if (.Platform$OS.type == "windows") {
[11:41:54.690]                 old_names <- names(...future.oldEnvVars)
[11:41:54.690]                 envs <- base::Sys.getenv()
[11:41:54.690]                 names <- names(envs)
[11:41:54.690]                 common <- intersect(names, old_names)
[11:41:54.690]                 added <- setdiff(names, old_names)
[11:41:54.690]                 removed <- setdiff(old_names, names)
[11:41:54.690]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:54.690]                   envs[common]]
[11:41:54.690]                 NAMES <- toupper(changed)
[11:41:54.690]                 args <- list()
[11:41:54.690]                 for (kk in seq_along(NAMES)) {
[11:41:54.690]                   name <- changed[[kk]]
[11:41:54.690]                   NAME <- NAMES[[kk]]
[11:41:54.690]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:54.690]                     next
[11:41:54.690]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:54.690]                 }
[11:41:54.690]                 NAMES <- toupper(added)
[11:41:54.690]                 for (kk in seq_along(NAMES)) {
[11:41:54.690]                   name <- added[[kk]]
[11:41:54.690]                   NAME <- NAMES[[kk]]
[11:41:54.690]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:54.690]                     next
[11:41:54.690]                   args[[name]] <- ""
[11:41:54.690]                 }
[11:41:54.690]                 NAMES <- toupper(removed)
[11:41:54.690]                 for (kk in seq_along(NAMES)) {
[11:41:54.690]                   name <- removed[[kk]]
[11:41:54.690]                   NAME <- NAMES[[kk]]
[11:41:54.690]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:54.690]                     next
[11:41:54.690]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:54.690]                 }
[11:41:54.690]                 if (length(args) > 0) 
[11:41:54.690]                   base::do.call(base::Sys.setenv, args = args)
[11:41:54.690]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:54.690]             }
[11:41:54.690]             else {
[11:41:54.690]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:54.690]             }
[11:41:54.690]             {
[11:41:54.690]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:54.690]                   0L) {
[11:41:54.690]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:54.690]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:54.690]                   base::options(opts)
[11:41:54.690]                 }
[11:41:54.690]                 {
[11:41:54.690]                   {
[11:41:54.690]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:54.690]                     NULL
[11:41:54.690]                   }
[11:41:54.690]                   options(future.plan = NULL)
[11:41:54.690]                   if (is.na(NA_character_)) 
[11:41:54.690]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:54.690]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:54.690]                   future::plan(list(function (..., workers = 2, 
[11:41:54.690]                     envir = parent.frame()) 
[11:41:54.690]                   strategy(..., workers = workers, envir = envir)), 
[11:41:54.690]                     .cleanup = FALSE, .init = FALSE)
[11:41:54.690]                 }
[11:41:54.690]             }
[11:41:54.690]         }
[11:41:54.690]     })
[11:41:54.690]     if (TRUE) {
[11:41:54.690]         base::sink(type = "output", split = FALSE)
[11:41:54.690]         if (TRUE) {
[11:41:54.690]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:54.690]         }
[11:41:54.690]         else {
[11:41:54.690]             ...future.result["stdout"] <- base::list(NULL)
[11:41:54.690]         }
[11:41:54.690]         base::close(...future.stdout)
[11:41:54.690]         ...future.stdout <- NULL
[11:41:54.690]     }
[11:41:54.690]     ...future.result$conditions <- ...future.conditions
[11:41:54.690]     ...future.result$finished <- base::Sys.time()
[11:41:54.690]     ...future.result
[11:41:54.690] }
[11:41:54.692] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:54.703] receiveMessageFromWorker() for ClusterFuture ...
[11:41:54.703] - Validating connection of MultisessionFuture
[11:41:54.703] - received message: FutureResult
[11:41:54.703] - Received FutureResult
[11:41:54.704] - Erased future from FutureRegistry
[11:41:54.704] result() for ClusterFuture ...
[11:41:54.704] - result already collected: FutureResult
[11:41:54.704] result() for ClusterFuture ... done
[11:41:54.704] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:54.704] result() for ClusterFuture ...
[11:41:54.704] - result already collected: FutureResult
[11:41:54.704] result() for ClusterFuture ... done
[11:41:54.704] result() for ClusterFuture ...
[11:41:54.705] - result already collected: FutureResult
[11:41:54.705] result() for ClusterFuture ... done
[11:41:54.705] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:54.706] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:54.749] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:54.755] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:54.798] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:54.798] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:54.846] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:54.847] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:54.848] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:54.848] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:54.849] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:54.850] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:54.851] MultisessionFuture started
[11:41:54.851] - Launch lazy future ... done
[11:41:54.851] run() for ‘MultisessionFuture’ ... done
[11:41:54.851] Created future:
[11:41:54.852] MultisessionFuture:
[11:41:54.852] Label: ‘future_mapply-50’
[11:41:54.852] Expression:
[11:41:54.852] {
[11:41:54.852]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:54.852]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:54.852]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:54.852]         on.exit(options(oopts), add = TRUE)
[11:41:54.852]     }
[11:41:54.852]     {
[11:41:54.852]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:54.852]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:54.852]                 inherits = FALSE)
[11:41:54.852]             ...future.FUN(...)
[11:41:54.852]         }
[11:41:54.852]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:54.852]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:54.852]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:54.852]         do.call(mapply, args = args)
[11:41:54.852]     }
[11:41:54.852] }
[11:41:54.852] Lazy evaluation: FALSE
[11:41:54.852] Asynchronous evaluation: TRUE
[11:41:54.852] Local evaluation: TRUE
[11:41:54.852] Environment: 0x560ef58e1768
[11:41:54.852] Capture standard output: TRUE
[11:41:54.852] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:54.852] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:54.852] Packages: 1 packages (‘mlr3’)
[11:41:54.852] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:54.852] Resolved: FALSE
[11:41:54.852] Value: <not collected>
[11:41:54.852] Conditions captured: <none>
[11:41:54.852] Early signaling: FALSE
[11:41:54.852] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:54.852] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:54.867] Chunk #50 of 90 ... DONE
[11:41:54.867] Chunk #51 of 90 ...
[11:41:54.868]  - seeds: [1] <seeds>
[11:41:54.868] getGlobalsAndPackages() ...
[11:41:54.868] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:54.868] Resolving globals: FALSE
[11:41:54.869] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:54.869] - packages: [1] ‘mlr3’
[11:41:54.869] getGlobalsAndPackages() ... DONE
[11:41:54.869] run() for ‘Future’ ...
[11:41:54.869] - state: ‘created’
[11:41:54.869] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:54.879] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:54.879] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:54.879]   - Field: ‘node’
[11:41:54.879]   - Field: ‘label’
[11:41:54.879]   - Field: ‘local’
[11:41:54.879]   - Field: ‘owner’
[11:41:54.879]   - Field: ‘envir’
[11:41:54.879]   - Field: ‘workers’
[11:41:54.879]   - Field: ‘packages’
[11:41:54.879]   - Field: ‘gc’
[11:41:54.879]   - Field: ‘conditions’
[11:41:54.879]   - Field: ‘persistent’
[11:41:54.879]   - Field: ‘expr’
[11:41:54.879]   - Field: ‘uuid’
[11:41:54.879]   - Field: ‘seed’
[11:41:54.880]   - Field: ‘version’
[11:41:54.880]   - Field: ‘result’
[11:41:54.880]   - Field: ‘asynchronous’
[11:41:54.880]   - Field: ‘calls’
[11:41:54.880]   - Field: ‘globals’
[11:41:54.880]   - Field: ‘stdout’
[11:41:54.880]   - Field: ‘earlySignal’
[11:41:54.880]   - Field: ‘lazy’
[11:41:54.880]   - Field: ‘state’
[11:41:54.880] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:54.880] - Launch lazy future ...
[11:41:54.880] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:54.880] Packages needed by future strategies (n = 0): <none>
[11:41:54.881] {
[11:41:54.881]     {
[11:41:54.881]         {
[11:41:54.881]             ...future.startTime <- base::Sys.time()
[11:41:54.881]             {
[11:41:54.881]                 {
[11:41:54.881]                   {
[11:41:54.881]                     {
[11:41:54.881]                       {
[11:41:54.881]                         base::local({
[11:41:54.881]                           has_future <- base::requireNamespace("future", 
[11:41:54.881]                             quietly = TRUE)
[11:41:54.881]                           if (has_future) {
[11:41:54.881]                             ns <- base::getNamespace("future")
[11:41:54.881]                             version <- ns[[".package"]][["version"]]
[11:41:54.881]                             if (is.null(version)) 
[11:41:54.881]                               version <- utils::packageVersion("future")
[11:41:54.881]                           }
[11:41:54.881]                           else {
[11:41:54.881]                             version <- NULL
[11:41:54.881]                           }
[11:41:54.881]                           if (!has_future || version < "1.8.0") {
[11:41:54.881]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:54.881]                               "", base::R.version$version.string), 
[11:41:54.881]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:54.881]                                 base::R.version$platform, 8 * 
[11:41:54.881]                                   base::.Machine$sizeof.pointer), 
[11:41:54.881]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:54.881]                                 "release", "version")], collapse = " "), 
[11:41:54.881]                               hostname = base::Sys.info()[["nodename"]])
[11:41:54.881]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:54.881]                               info)
[11:41:54.881]                             info <- base::paste(info, collapse = "; ")
[11:41:54.881]                             if (!has_future) {
[11:41:54.881]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:54.881]                                 info)
[11:41:54.881]                             }
[11:41:54.881]                             else {
[11:41:54.881]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:54.881]                                 info, version)
[11:41:54.881]                             }
[11:41:54.881]                             base::stop(msg)
[11:41:54.881]                           }
[11:41:54.881]                         })
[11:41:54.881]                       }
[11:41:54.881]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:54.881]                       base::options(mc.cores = 1L)
[11:41:54.881]                     }
[11:41:54.881]                     base::local({
[11:41:54.881]                       for (pkg in "mlr3") {
[11:41:54.881]                         base::loadNamespace(pkg)
[11:41:54.881]                         base::library(pkg, character.only = TRUE)
[11:41:54.881]                       }
[11:41:54.881]                     })
[11:41:54.881]                   }
[11:41:54.881]                   options(future.plan = NULL)
[11:41:54.881]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:54.881]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:54.881]                 }
[11:41:54.881]                 ...future.workdir <- getwd()
[11:41:54.881]             }
[11:41:54.881]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:54.881]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:54.881]         }
[11:41:54.881]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:54.881]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:54.881]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:54.881]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:54.881]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:54.881]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:54.881]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:54.881]             base::names(...future.oldOptions))
[11:41:54.881]     }
[11:41:54.881]     if (FALSE) {
[11:41:54.881]     }
[11:41:54.881]     else {
[11:41:54.881]         if (TRUE) {
[11:41:54.881]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:54.881]                 open = "w")
[11:41:54.881]         }
[11:41:54.881]         else {
[11:41:54.881]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:54.881]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:54.881]         }
[11:41:54.881]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:54.881]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:54.881]             base::sink(type = "output", split = FALSE)
[11:41:54.881]             base::close(...future.stdout)
[11:41:54.881]         }, add = TRUE)
[11:41:54.881]     }
[11:41:54.881]     ...future.frame <- base::sys.nframe()
[11:41:54.881]     ...future.conditions <- base::list()
[11:41:54.881]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:54.881]     if (FALSE) {
[11:41:54.881]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:54.881]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:54.881]     }
[11:41:54.881]     ...future.result <- base::tryCatch({
[11:41:54.881]         base::withCallingHandlers({
[11:41:54.881]             ...future.value <- base::withVisible(base::local({
[11:41:54.881]                 ...future.makeSendCondition <- local({
[11:41:54.881]                   sendCondition <- NULL
[11:41:54.881]                   function(frame = 1L) {
[11:41:54.881]                     if (is.function(sendCondition)) 
[11:41:54.881]                       return(sendCondition)
[11:41:54.881]                     ns <- getNamespace("parallel")
[11:41:54.881]                     if (exists("sendData", mode = "function", 
[11:41:54.881]                       envir = ns)) {
[11:41:54.881]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:54.881]                         envir = ns)
[11:41:54.881]                       envir <- sys.frame(frame)
[11:41:54.881]                       master <- NULL
[11:41:54.881]                       while (!identical(envir, .GlobalEnv) && 
[11:41:54.881]                         !identical(envir, emptyenv())) {
[11:41:54.881]                         if (exists("master", mode = "list", envir = envir, 
[11:41:54.881]                           inherits = FALSE)) {
[11:41:54.881]                           master <- get("master", mode = "list", 
[11:41:54.881]                             envir = envir, inherits = FALSE)
[11:41:54.881]                           if (inherits(master, c("SOCKnode", 
[11:41:54.881]                             "SOCK0node"))) {
[11:41:54.881]                             sendCondition <<- function(cond) {
[11:41:54.881]                               data <- list(type = "VALUE", value = cond, 
[11:41:54.881]                                 success = TRUE)
[11:41:54.881]                               parallel_sendData(master, data)
[11:41:54.881]                             }
[11:41:54.881]                             return(sendCondition)
[11:41:54.881]                           }
[11:41:54.881]                         }
[11:41:54.881]                         frame <- frame + 1L
[11:41:54.881]                         envir <- sys.frame(frame)
[11:41:54.881]                       }
[11:41:54.881]                     }
[11:41:54.881]                     sendCondition <<- function(cond) NULL
[11:41:54.881]                   }
[11:41:54.881]                 })
[11:41:54.881]                 withCallingHandlers({
[11:41:54.881]                   {
[11:41:54.881]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:54.881]                     if (!identical(...future.globals.maxSize.org, 
[11:41:54.881]                       ...future.globals.maxSize)) {
[11:41:54.881]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:54.881]                       on.exit(options(oopts), add = TRUE)
[11:41:54.881]                     }
[11:41:54.881]                     {
[11:41:54.881]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:54.881]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:54.881]                           envir = globalenv(), inherits = FALSE)
[11:41:54.881]                         ...future.FUN(...)
[11:41:54.881]                       }
[11:41:54.881]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:54.881]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:54.881]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:54.881]                         USE.NAMES = FALSE)
[11:41:54.881]                       do.call(mapply, args = args)
[11:41:54.881]                     }
[11:41:54.881]                   }
[11:41:54.881]                 }, immediateCondition = function(cond) {
[11:41:54.881]                   sendCondition <- ...future.makeSendCondition()
[11:41:54.881]                   sendCondition(cond)
[11:41:54.881]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:54.881]                   {
[11:41:54.881]                     inherits <- base::inherits
[11:41:54.881]                     invokeRestart <- base::invokeRestart
[11:41:54.881]                     is.null <- base::is.null
[11:41:54.881]                     muffled <- FALSE
[11:41:54.881]                     if (inherits(cond, "message")) {
[11:41:54.881]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:54.881]                       if (muffled) 
[11:41:54.881]                         invokeRestart("muffleMessage")
[11:41:54.881]                     }
[11:41:54.881]                     else if (inherits(cond, "warning")) {
[11:41:54.881]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:54.881]                       if (muffled) 
[11:41:54.881]                         invokeRestart("muffleWarning")
[11:41:54.881]                     }
[11:41:54.881]                     else if (inherits(cond, "condition")) {
[11:41:54.881]                       if (!is.null(pattern)) {
[11:41:54.881]                         computeRestarts <- base::computeRestarts
[11:41:54.881]                         grepl <- base::grepl
[11:41:54.881]                         restarts <- computeRestarts(cond)
[11:41:54.881]                         for (restart in restarts) {
[11:41:54.881]                           name <- restart$name
[11:41:54.881]                           if (is.null(name)) 
[11:41:54.881]                             next
[11:41:54.881]                           if (!grepl(pattern, name)) 
[11:41:54.881]                             next
[11:41:54.881]                           invokeRestart(restart)
[11:41:54.881]                           muffled <- TRUE
[11:41:54.881]                           break
[11:41:54.881]                         }
[11:41:54.881]                       }
[11:41:54.881]                     }
[11:41:54.881]                     invisible(muffled)
[11:41:54.881]                   }
[11:41:54.881]                   muffleCondition(cond)
[11:41:54.881]                 })
[11:41:54.881]             }))
[11:41:54.881]             future::FutureResult(value = ...future.value$value, 
[11:41:54.881]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:54.881]                   ...future.rng), globalenv = if (FALSE) 
[11:41:54.881]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:54.881]                     ...future.globalenv.names))
[11:41:54.881]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:54.881]         }, condition = base::local({
[11:41:54.881]             c <- base::c
[11:41:54.881]             inherits <- base::inherits
[11:41:54.881]             invokeRestart <- base::invokeRestart
[11:41:54.881]             length <- base::length
[11:41:54.881]             list <- base::list
[11:41:54.881]             seq.int <- base::seq.int
[11:41:54.881]             signalCondition <- base::signalCondition
[11:41:54.881]             sys.calls <- base::sys.calls
[11:41:54.881]             `[[` <- base::`[[`
[11:41:54.881]             `+` <- base::`+`
[11:41:54.881]             `<<-` <- base::`<<-`
[11:41:54.881]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:54.881]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:54.881]                   3L)]
[11:41:54.881]             }
[11:41:54.881]             function(cond) {
[11:41:54.881]                 is_error <- inherits(cond, "error")
[11:41:54.881]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:54.881]                   NULL)
[11:41:54.881]                 if (is_error) {
[11:41:54.881]                   sessionInformation <- function() {
[11:41:54.881]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:54.881]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:54.881]                       search = base::search(), system = base::Sys.info())
[11:41:54.881]                   }
[11:41:54.881]                   ...future.conditions[[length(...future.conditions) + 
[11:41:54.881]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:54.881]                     cond$call), session = sessionInformation(), 
[11:41:54.881]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:54.881]                   signalCondition(cond)
[11:41:54.881]                 }
[11:41:54.881]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:54.881]                 "immediateCondition"))) {
[11:41:54.881]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:54.881]                   ...future.conditions[[length(...future.conditions) + 
[11:41:54.881]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:54.881]                   if (TRUE && !signal) {
[11:41:54.881]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:54.881]                     {
[11:41:54.881]                       inherits <- base::inherits
[11:41:54.881]                       invokeRestart <- base::invokeRestart
[11:41:54.881]                       is.null <- base::is.null
[11:41:54.881]                       muffled <- FALSE
[11:41:54.881]                       if (inherits(cond, "message")) {
[11:41:54.881]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:54.881]                         if (muffled) 
[11:41:54.881]                           invokeRestart("muffleMessage")
[11:41:54.881]                       }
[11:41:54.881]                       else if (inherits(cond, "warning")) {
[11:41:54.881]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:54.881]                         if (muffled) 
[11:41:54.881]                           invokeRestart("muffleWarning")
[11:41:54.881]                       }
[11:41:54.881]                       else if (inherits(cond, "condition")) {
[11:41:54.881]                         if (!is.null(pattern)) {
[11:41:54.881]                           computeRestarts <- base::computeRestarts
[11:41:54.881]                           grepl <- base::grepl
[11:41:54.881]                           restarts <- computeRestarts(cond)
[11:41:54.881]                           for (restart in restarts) {
[11:41:54.881]                             name <- restart$name
[11:41:54.881]                             if (is.null(name)) 
[11:41:54.881]                               next
[11:41:54.881]                             if (!grepl(pattern, name)) 
[11:41:54.881]                               next
[11:41:54.881]                             invokeRestart(restart)
[11:41:54.881]                             muffled <- TRUE
[11:41:54.881]                             break
[11:41:54.881]                           }
[11:41:54.881]                         }
[11:41:54.881]                       }
[11:41:54.881]                       invisible(muffled)
[11:41:54.881]                     }
[11:41:54.881]                     muffleCondition(cond, pattern = "^muffle")
[11:41:54.881]                   }
[11:41:54.881]                 }
[11:41:54.881]                 else {
[11:41:54.881]                   if (TRUE) {
[11:41:54.881]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:54.881]                     {
[11:41:54.881]                       inherits <- base::inherits
[11:41:54.881]                       invokeRestart <- base::invokeRestart
[11:41:54.881]                       is.null <- base::is.null
[11:41:54.881]                       muffled <- FALSE
[11:41:54.881]                       if (inherits(cond, "message")) {
[11:41:54.881]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:54.881]                         if (muffled) 
[11:41:54.881]                           invokeRestart("muffleMessage")
[11:41:54.881]                       }
[11:41:54.881]                       else if (inherits(cond, "warning")) {
[11:41:54.881]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:54.881]                         if (muffled) 
[11:41:54.881]                           invokeRestart("muffleWarning")
[11:41:54.881]                       }
[11:41:54.881]                       else if (inherits(cond, "condition")) {
[11:41:54.881]                         if (!is.null(pattern)) {
[11:41:54.881]                           computeRestarts <- base::computeRestarts
[11:41:54.881]                           grepl <- base::grepl
[11:41:54.881]                           restarts <- computeRestarts(cond)
[11:41:54.881]                           for (restart in restarts) {
[11:41:54.881]                             name <- restart$name
[11:41:54.881]                             if (is.null(name)) 
[11:41:54.881]                               next
[11:41:54.881]                             if (!grepl(pattern, name)) 
[11:41:54.881]                               next
[11:41:54.881]                             invokeRestart(restart)
[11:41:54.881]                             muffled <- TRUE
[11:41:54.881]                             break
[11:41:54.881]                           }
[11:41:54.881]                         }
[11:41:54.881]                       }
[11:41:54.881]                       invisible(muffled)
[11:41:54.881]                     }
[11:41:54.881]                     muffleCondition(cond, pattern = "^muffle")
[11:41:54.881]                   }
[11:41:54.881]                 }
[11:41:54.881]             }
[11:41:54.881]         }))
[11:41:54.881]     }, error = function(ex) {
[11:41:54.881]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:54.881]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:54.881]                 ...future.rng), started = ...future.startTime, 
[11:41:54.881]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:54.881]             version = "1.8"), class = "FutureResult")
[11:41:54.881]     }, finally = {
[11:41:54.881]         if (!identical(...future.workdir, getwd())) 
[11:41:54.881]             setwd(...future.workdir)
[11:41:54.881]         {
[11:41:54.881]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:54.881]                 ...future.oldOptions$nwarnings <- NULL
[11:41:54.881]             }
[11:41:54.881]             base::options(...future.oldOptions)
[11:41:54.881]             if (.Platform$OS.type == "windows") {
[11:41:54.881]                 old_names <- names(...future.oldEnvVars)
[11:41:54.881]                 envs <- base::Sys.getenv()
[11:41:54.881]                 names <- names(envs)
[11:41:54.881]                 common <- intersect(names, old_names)
[11:41:54.881]                 added <- setdiff(names, old_names)
[11:41:54.881]                 removed <- setdiff(old_names, names)
[11:41:54.881]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:54.881]                   envs[common]]
[11:41:54.881]                 NAMES <- toupper(changed)
[11:41:54.881]                 args <- list()
[11:41:54.881]                 for (kk in seq_along(NAMES)) {
[11:41:54.881]                   name <- changed[[kk]]
[11:41:54.881]                   NAME <- NAMES[[kk]]
[11:41:54.881]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:54.881]                     next
[11:41:54.881]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:54.881]                 }
[11:41:54.881]                 NAMES <- toupper(added)
[11:41:54.881]                 for (kk in seq_along(NAMES)) {
[11:41:54.881]                   name <- added[[kk]]
[11:41:54.881]                   NAME <- NAMES[[kk]]
[11:41:54.881]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:54.881]                     next
[11:41:54.881]                   args[[name]] <- ""
[11:41:54.881]                 }
[11:41:54.881]                 NAMES <- toupper(removed)
[11:41:54.881]                 for (kk in seq_along(NAMES)) {
[11:41:54.881]                   name <- removed[[kk]]
[11:41:54.881]                   NAME <- NAMES[[kk]]
[11:41:54.881]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:54.881]                     next
[11:41:54.881]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:54.881]                 }
[11:41:54.881]                 if (length(args) > 0) 
[11:41:54.881]                   base::do.call(base::Sys.setenv, args = args)
[11:41:54.881]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:54.881]             }
[11:41:54.881]             else {
[11:41:54.881]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:54.881]             }
[11:41:54.881]             {
[11:41:54.881]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:54.881]                   0L) {
[11:41:54.881]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:54.881]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:54.881]                   base::options(opts)
[11:41:54.881]                 }
[11:41:54.881]                 {
[11:41:54.881]                   {
[11:41:54.881]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:54.881]                     NULL
[11:41:54.881]                   }
[11:41:54.881]                   options(future.plan = NULL)
[11:41:54.881]                   if (is.na(NA_character_)) 
[11:41:54.881]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:54.881]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:54.881]                   future::plan(list(function (..., workers = 2, 
[11:41:54.881]                     envir = parent.frame()) 
[11:41:54.881]                   strategy(..., workers = workers, envir = envir)), 
[11:41:54.881]                     .cleanup = FALSE, .init = FALSE)
[11:41:54.881]                 }
[11:41:54.881]             }
[11:41:54.881]         }
[11:41:54.881]     })
[11:41:54.881]     if (TRUE) {
[11:41:54.881]         base::sink(type = "output", split = FALSE)
[11:41:54.881]         if (TRUE) {
[11:41:54.881]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:54.881]         }
[11:41:54.881]         else {
[11:41:54.881]             ...future.result["stdout"] <- base::list(NULL)
[11:41:54.881]         }
[11:41:54.881]         base::close(...future.stdout)
[11:41:54.881]         ...future.stdout <- NULL
[11:41:54.881]     }
[11:41:54.881]     ...future.result$conditions <- ...future.conditions
[11:41:54.881]     ...future.result$finished <- base::Sys.time()
[11:41:54.881]     ...future.result
[11:41:54.881] }
[11:41:54.882] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:54.893] receiveMessageFromWorker() for ClusterFuture ...
[11:41:54.893] - Validating connection of MultisessionFuture
[11:41:54.893] - received message: FutureResult
[11:41:54.894] - Received FutureResult
[11:41:54.894] - Erased future from FutureRegistry
[11:41:54.894] result() for ClusterFuture ...
[11:41:54.894] - result already collected: FutureResult
[11:41:54.894] result() for ClusterFuture ... done
[11:41:54.894] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:54.894] result() for ClusterFuture ...
[11:41:54.894] - result already collected: FutureResult
[11:41:54.894] result() for ClusterFuture ... done
[11:41:54.894] result() for ClusterFuture ...
[11:41:54.894] - result already collected: FutureResult
[11:41:54.894] result() for ClusterFuture ... done
[11:41:54.895] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:54.895] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:54.938] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:54.942] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:54.944] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:54.944] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:54.990] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:54.991] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:54.993] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:54.993] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:54.995] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:54.995] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:54.996] MultisessionFuture started
[11:41:54.997] - Launch lazy future ... done
[11:41:54.997] run() for ‘MultisessionFuture’ ... done
[11:41:54.997] Created future:
[11:41:54.997] MultisessionFuture:
[11:41:54.997] Label: ‘future_mapply-51’
[11:41:54.997] Expression:
[11:41:54.997] {
[11:41:54.997]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:54.997]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:54.997]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:54.997]         on.exit(options(oopts), add = TRUE)
[11:41:54.997]     }
[11:41:54.997]     {
[11:41:54.997]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:54.997]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:54.997]                 inherits = FALSE)
[11:41:54.997]             ...future.FUN(...)
[11:41:54.997]         }
[11:41:54.997]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:54.997]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:54.997]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:54.997]         do.call(mapply, args = args)
[11:41:54.997]     }
[11:41:54.997] }
[11:41:54.997] Lazy evaluation: FALSE
[11:41:54.997] Asynchronous evaluation: TRUE
[11:41:54.997] Local evaluation: TRUE
[11:41:54.997] Environment: 0x560ef58e1768
[11:41:54.997] Capture standard output: TRUE
[11:41:54.997] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:54.997] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:54.997] Packages: 1 packages (‘mlr3’)
[11:41:54.997] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:54.997] Resolved: FALSE
[11:41:54.997] Value: <not collected>
[11:41:54.997] Conditions captured: <none>
[11:41:54.997] Early signaling: FALSE
[11:41:54.997] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:54.997] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:55.015] Chunk #51 of 90 ... DONE
[11:41:55.015] Chunk #52 of 90 ...
[11:41:55.015]  - seeds: [1] <seeds>
[11:41:55.016] getGlobalsAndPackages() ...
[11:41:55.016] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:55.016] Resolving globals: FALSE
[11:41:55.016] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:55.017] - packages: [1] ‘mlr3’
[11:41:55.017] getGlobalsAndPackages() ... DONE
[11:41:55.017] run() for ‘Future’ ...
[11:41:55.017] - state: ‘created’
[11:41:55.017] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:55.027] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:55.027] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:55.027]   - Field: ‘node’
[11:41:55.027]   - Field: ‘label’
[11:41:55.027]   - Field: ‘local’
[11:41:55.027]   - Field: ‘owner’
[11:41:55.027]   - Field: ‘envir’
[11:41:55.027]   - Field: ‘workers’
[11:41:55.027]   - Field: ‘packages’
[11:41:55.027]   - Field: ‘gc’
[11:41:55.027]   - Field: ‘conditions’
[11:41:55.027]   - Field: ‘persistent’
[11:41:55.028]   - Field: ‘expr’
[11:41:55.028]   - Field: ‘uuid’
[11:41:55.028]   - Field: ‘seed’
[11:41:55.028]   - Field: ‘version’
[11:41:55.028]   - Field: ‘result’
[11:41:55.028]   - Field: ‘asynchronous’
[11:41:55.028]   - Field: ‘calls’
[11:41:55.028]   - Field: ‘globals’
[11:41:55.028]   - Field: ‘stdout’
[11:41:55.028]   - Field: ‘earlySignal’
[11:41:55.028]   - Field: ‘lazy’
[11:41:55.028]   - Field: ‘state’
[11:41:55.028] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:55.028] - Launch lazy future ...
[11:41:55.028] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:55.028] Packages needed by future strategies (n = 0): <none>
[11:41:55.029] {
[11:41:55.029]     {
[11:41:55.029]         {
[11:41:55.029]             ...future.startTime <- base::Sys.time()
[11:41:55.029]             {
[11:41:55.029]                 {
[11:41:55.029]                   {
[11:41:55.029]                     {
[11:41:55.029]                       {
[11:41:55.029]                         base::local({
[11:41:55.029]                           has_future <- base::requireNamespace("future", 
[11:41:55.029]                             quietly = TRUE)
[11:41:55.029]                           if (has_future) {
[11:41:55.029]                             ns <- base::getNamespace("future")
[11:41:55.029]                             version <- ns[[".package"]][["version"]]
[11:41:55.029]                             if (is.null(version)) 
[11:41:55.029]                               version <- utils::packageVersion("future")
[11:41:55.029]                           }
[11:41:55.029]                           else {
[11:41:55.029]                             version <- NULL
[11:41:55.029]                           }
[11:41:55.029]                           if (!has_future || version < "1.8.0") {
[11:41:55.029]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:55.029]                               "", base::R.version$version.string), 
[11:41:55.029]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:55.029]                                 base::R.version$platform, 8 * 
[11:41:55.029]                                   base::.Machine$sizeof.pointer), 
[11:41:55.029]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:55.029]                                 "release", "version")], collapse = " "), 
[11:41:55.029]                               hostname = base::Sys.info()[["nodename"]])
[11:41:55.029]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:55.029]                               info)
[11:41:55.029]                             info <- base::paste(info, collapse = "; ")
[11:41:55.029]                             if (!has_future) {
[11:41:55.029]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:55.029]                                 info)
[11:41:55.029]                             }
[11:41:55.029]                             else {
[11:41:55.029]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:55.029]                                 info, version)
[11:41:55.029]                             }
[11:41:55.029]                             base::stop(msg)
[11:41:55.029]                           }
[11:41:55.029]                         })
[11:41:55.029]                       }
[11:41:55.029]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:55.029]                       base::options(mc.cores = 1L)
[11:41:55.029]                     }
[11:41:55.029]                     base::local({
[11:41:55.029]                       for (pkg in "mlr3") {
[11:41:55.029]                         base::loadNamespace(pkg)
[11:41:55.029]                         base::library(pkg, character.only = TRUE)
[11:41:55.029]                       }
[11:41:55.029]                     })
[11:41:55.029]                   }
[11:41:55.029]                   options(future.plan = NULL)
[11:41:55.029]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:55.029]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:55.029]                 }
[11:41:55.029]                 ...future.workdir <- getwd()
[11:41:55.029]             }
[11:41:55.029]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:55.029]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:55.029]         }
[11:41:55.029]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:55.029]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:55.029]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:55.029]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:55.029]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:55.029]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:55.029]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:55.029]             base::names(...future.oldOptions))
[11:41:55.029]     }
[11:41:55.029]     if (FALSE) {
[11:41:55.029]     }
[11:41:55.029]     else {
[11:41:55.029]         if (TRUE) {
[11:41:55.029]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:55.029]                 open = "w")
[11:41:55.029]         }
[11:41:55.029]         else {
[11:41:55.029]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:55.029]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:55.029]         }
[11:41:55.029]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:55.029]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:55.029]             base::sink(type = "output", split = FALSE)
[11:41:55.029]             base::close(...future.stdout)
[11:41:55.029]         }, add = TRUE)
[11:41:55.029]     }
[11:41:55.029]     ...future.frame <- base::sys.nframe()
[11:41:55.029]     ...future.conditions <- base::list()
[11:41:55.029]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:55.029]     if (FALSE) {
[11:41:55.029]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:55.029]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:55.029]     }
[11:41:55.029]     ...future.result <- base::tryCatch({
[11:41:55.029]         base::withCallingHandlers({
[11:41:55.029]             ...future.value <- base::withVisible(base::local({
[11:41:55.029]                 ...future.makeSendCondition <- local({
[11:41:55.029]                   sendCondition <- NULL
[11:41:55.029]                   function(frame = 1L) {
[11:41:55.029]                     if (is.function(sendCondition)) 
[11:41:55.029]                       return(sendCondition)
[11:41:55.029]                     ns <- getNamespace("parallel")
[11:41:55.029]                     if (exists("sendData", mode = "function", 
[11:41:55.029]                       envir = ns)) {
[11:41:55.029]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:55.029]                         envir = ns)
[11:41:55.029]                       envir <- sys.frame(frame)
[11:41:55.029]                       master <- NULL
[11:41:55.029]                       while (!identical(envir, .GlobalEnv) && 
[11:41:55.029]                         !identical(envir, emptyenv())) {
[11:41:55.029]                         if (exists("master", mode = "list", envir = envir, 
[11:41:55.029]                           inherits = FALSE)) {
[11:41:55.029]                           master <- get("master", mode = "list", 
[11:41:55.029]                             envir = envir, inherits = FALSE)
[11:41:55.029]                           if (inherits(master, c("SOCKnode", 
[11:41:55.029]                             "SOCK0node"))) {
[11:41:55.029]                             sendCondition <<- function(cond) {
[11:41:55.029]                               data <- list(type = "VALUE", value = cond, 
[11:41:55.029]                                 success = TRUE)
[11:41:55.029]                               parallel_sendData(master, data)
[11:41:55.029]                             }
[11:41:55.029]                             return(sendCondition)
[11:41:55.029]                           }
[11:41:55.029]                         }
[11:41:55.029]                         frame <- frame + 1L
[11:41:55.029]                         envir <- sys.frame(frame)
[11:41:55.029]                       }
[11:41:55.029]                     }
[11:41:55.029]                     sendCondition <<- function(cond) NULL
[11:41:55.029]                   }
[11:41:55.029]                 })
[11:41:55.029]                 withCallingHandlers({
[11:41:55.029]                   {
[11:41:55.029]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:55.029]                     if (!identical(...future.globals.maxSize.org, 
[11:41:55.029]                       ...future.globals.maxSize)) {
[11:41:55.029]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:55.029]                       on.exit(options(oopts), add = TRUE)
[11:41:55.029]                     }
[11:41:55.029]                     {
[11:41:55.029]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:55.029]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:55.029]                           envir = globalenv(), inherits = FALSE)
[11:41:55.029]                         ...future.FUN(...)
[11:41:55.029]                       }
[11:41:55.029]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:55.029]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:55.029]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:55.029]                         USE.NAMES = FALSE)
[11:41:55.029]                       do.call(mapply, args = args)
[11:41:55.029]                     }
[11:41:55.029]                   }
[11:41:55.029]                 }, immediateCondition = function(cond) {
[11:41:55.029]                   sendCondition <- ...future.makeSendCondition()
[11:41:55.029]                   sendCondition(cond)
[11:41:55.029]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:55.029]                   {
[11:41:55.029]                     inherits <- base::inherits
[11:41:55.029]                     invokeRestart <- base::invokeRestart
[11:41:55.029]                     is.null <- base::is.null
[11:41:55.029]                     muffled <- FALSE
[11:41:55.029]                     if (inherits(cond, "message")) {
[11:41:55.029]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:55.029]                       if (muffled) 
[11:41:55.029]                         invokeRestart("muffleMessage")
[11:41:55.029]                     }
[11:41:55.029]                     else if (inherits(cond, "warning")) {
[11:41:55.029]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:55.029]                       if (muffled) 
[11:41:55.029]                         invokeRestart("muffleWarning")
[11:41:55.029]                     }
[11:41:55.029]                     else if (inherits(cond, "condition")) {
[11:41:55.029]                       if (!is.null(pattern)) {
[11:41:55.029]                         computeRestarts <- base::computeRestarts
[11:41:55.029]                         grepl <- base::grepl
[11:41:55.029]                         restarts <- computeRestarts(cond)
[11:41:55.029]                         for (restart in restarts) {
[11:41:55.029]                           name <- restart$name
[11:41:55.029]                           if (is.null(name)) 
[11:41:55.029]                             next
[11:41:55.029]                           if (!grepl(pattern, name)) 
[11:41:55.029]                             next
[11:41:55.029]                           invokeRestart(restart)
[11:41:55.029]                           muffled <- TRUE
[11:41:55.029]                           break
[11:41:55.029]                         }
[11:41:55.029]                       }
[11:41:55.029]                     }
[11:41:55.029]                     invisible(muffled)
[11:41:55.029]                   }
[11:41:55.029]                   muffleCondition(cond)
[11:41:55.029]                 })
[11:41:55.029]             }))
[11:41:55.029]             future::FutureResult(value = ...future.value$value, 
[11:41:55.029]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:55.029]                   ...future.rng), globalenv = if (FALSE) 
[11:41:55.029]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:55.029]                     ...future.globalenv.names))
[11:41:55.029]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:55.029]         }, condition = base::local({
[11:41:55.029]             c <- base::c
[11:41:55.029]             inherits <- base::inherits
[11:41:55.029]             invokeRestart <- base::invokeRestart
[11:41:55.029]             length <- base::length
[11:41:55.029]             list <- base::list
[11:41:55.029]             seq.int <- base::seq.int
[11:41:55.029]             signalCondition <- base::signalCondition
[11:41:55.029]             sys.calls <- base::sys.calls
[11:41:55.029]             `[[` <- base::`[[`
[11:41:55.029]             `+` <- base::`+`
[11:41:55.029]             `<<-` <- base::`<<-`
[11:41:55.029]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:55.029]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:55.029]                   3L)]
[11:41:55.029]             }
[11:41:55.029]             function(cond) {
[11:41:55.029]                 is_error <- inherits(cond, "error")
[11:41:55.029]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:55.029]                   NULL)
[11:41:55.029]                 if (is_error) {
[11:41:55.029]                   sessionInformation <- function() {
[11:41:55.029]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:55.029]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:55.029]                       search = base::search(), system = base::Sys.info())
[11:41:55.029]                   }
[11:41:55.029]                   ...future.conditions[[length(...future.conditions) + 
[11:41:55.029]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:55.029]                     cond$call), session = sessionInformation(), 
[11:41:55.029]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:55.029]                   signalCondition(cond)
[11:41:55.029]                 }
[11:41:55.029]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:55.029]                 "immediateCondition"))) {
[11:41:55.029]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:55.029]                   ...future.conditions[[length(...future.conditions) + 
[11:41:55.029]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:55.029]                   if (TRUE && !signal) {
[11:41:55.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:55.029]                     {
[11:41:55.029]                       inherits <- base::inherits
[11:41:55.029]                       invokeRestart <- base::invokeRestart
[11:41:55.029]                       is.null <- base::is.null
[11:41:55.029]                       muffled <- FALSE
[11:41:55.029]                       if (inherits(cond, "message")) {
[11:41:55.029]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:55.029]                         if (muffled) 
[11:41:55.029]                           invokeRestart("muffleMessage")
[11:41:55.029]                       }
[11:41:55.029]                       else if (inherits(cond, "warning")) {
[11:41:55.029]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:55.029]                         if (muffled) 
[11:41:55.029]                           invokeRestart("muffleWarning")
[11:41:55.029]                       }
[11:41:55.029]                       else if (inherits(cond, "condition")) {
[11:41:55.029]                         if (!is.null(pattern)) {
[11:41:55.029]                           computeRestarts <- base::computeRestarts
[11:41:55.029]                           grepl <- base::grepl
[11:41:55.029]                           restarts <- computeRestarts(cond)
[11:41:55.029]                           for (restart in restarts) {
[11:41:55.029]                             name <- restart$name
[11:41:55.029]                             if (is.null(name)) 
[11:41:55.029]                               next
[11:41:55.029]                             if (!grepl(pattern, name)) 
[11:41:55.029]                               next
[11:41:55.029]                             invokeRestart(restart)
[11:41:55.029]                             muffled <- TRUE
[11:41:55.029]                             break
[11:41:55.029]                           }
[11:41:55.029]                         }
[11:41:55.029]                       }
[11:41:55.029]                       invisible(muffled)
[11:41:55.029]                     }
[11:41:55.029]                     muffleCondition(cond, pattern = "^muffle")
[11:41:55.029]                   }
[11:41:55.029]                 }
[11:41:55.029]                 else {
[11:41:55.029]                   if (TRUE) {
[11:41:55.029]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:55.029]                     {
[11:41:55.029]                       inherits <- base::inherits
[11:41:55.029]                       invokeRestart <- base::invokeRestart
[11:41:55.029]                       is.null <- base::is.null
[11:41:55.029]                       muffled <- FALSE
[11:41:55.029]                       if (inherits(cond, "message")) {
[11:41:55.029]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:55.029]                         if (muffled) 
[11:41:55.029]                           invokeRestart("muffleMessage")
[11:41:55.029]                       }
[11:41:55.029]                       else if (inherits(cond, "warning")) {
[11:41:55.029]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:55.029]                         if (muffled) 
[11:41:55.029]                           invokeRestart("muffleWarning")
[11:41:55.029]                       }
[11:41:55.029]                       else if (inherits(cond, "condition")) {
[11:41:55.029]                         if (!is.null(pattern)) {
[11:41:55.029]                           computeRestarts <- base::computeRestarts
[11:41:55.029]                           grepl <- base::grepl
[11:41:55.029]                           restarts <- computeRestarts(cond)
[11:41:55.029]                           for (restart in restarts) {
[11:41:55.029]                             name <- restart$name
[11:41:55.029]                             if (is.null(name)) 
[11:41:55.029]                               next
[11:41:55.029]                             if (!grepl(pattern, name)) 
[11:41:55.029]                               next
[11:41:55.029]                             invokeRestart(restart)
[11:41:55.029]                             muffled <- TRUE
[11:41:55.029]                             break
[11:41:55.029]                           }
[11:41:55.029]                         }
[11:41:55.029]                       }
[11:41:55.029]                       invisible(muffled)
[11:41:55.029]                     }
[11:41:55.029]                     muffleCondition(cond, pattern = "^muffle")
[11:41:55.029]                   }
[11:41:55.029]                 }
[11:41:55.029]             }
[11:41:55.029]         }))
[11:41:55.029]     }, error = function(ex) {
[11:41:55.029]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:55.029]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:55.029]                 ...future.rng), started = ...future.startTime, 
[11:41:55.029]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:55.029]             version = "1.8"), class = "FutureResult")
[11:41:55.029]     }, finally = {
[11:41:55.029]         if (!identical(...future.workdir, getwd())) 
[11:41:55.029]             setwd(...future.workdir)
[11:41:55.029]         {
[11:41:55.029]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:55.029]                 ...future.oldOptions$nwarnings <- NULL
[11:41:55.029]             }
[11:41:55.029]             base::options(...future.oldOptions)
[11:41:55.029]             if (.Platform$OS.type == "windows") {
[11:41:55.029]                 old_names <- names(...future.oldEnvVars)
[11:41:55.029]                 envs <- base::Sys.getenv()
[11:41:55.029]                 names <- names(envs)
[11:41:55.029]                 common <- intersect(names, old_names)
[11:41:55.029]                 added <- setdiff(names, old_names)
[11:41:55.029]                 removed <- setdiff(old_names, names)
[11:41:55.029]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:55.029]                   envs[common]]
[11:41:55.029]                 NAMES <- toupper(changed)
[11:41:55.029]                 args <- list()
[11:41:55.029]                 for (kk in seq_along(NAMES)) {
[11:41:55.029]                   name <- changed[[kk]]
[11:41:55.029]                   NAME <- NAMES[[kk]]
[11:41:55.029]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:55.029]                     next
[11:41:55.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:55.029]                 }
[11:41:55.029]                 NAMES <- toupper(added)
[11:41:55.029]                 for (kk in seq_along(NAMES)) {
[11:41:55.029]                   name <- added[[kk]]
[11:41:55.029]                   NAME <- NAMES[[kk]]
[11:41:55.029]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:55.029]                     next
[11:41:55.029]                   args[[name]] <- ""
[11:41:55.029]                 }
[11:41:55.029]                 NAMES <- toupper(removed)
[11:41:55.029]                 for (kk in seq_along(NAMES)) {
[11:41:55.029]                   name <- removed[[kk]]
[11:41:55.029]                   NAME <- NAMES[[kk]]
[11:41:55.029]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:55.029]                     next
[11:41:55.029]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:55.029]                 }
[11:41:55.029]                 if (length(args) > 0) 
[11:41:55.029]                   base::do.call(base::Sys.setenv, args = args)
[11:41:55.029]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:55.029]             }
[11:41:55.029]             else {
[11:41:55.029]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:55.029]             }
[11:41:55.029]             {
[11:41:55.029]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:55.029]                   0L) {
[11:41:55.029]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:55.029]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:55.029]                   base::options(opts)
[11:41:55.029]                 }
[11:41:55.029]                 {
[11:41:55.029]                   {
[11:41:55.029]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:55.029]                     NULL
[11:41:55.029]                   }
[11:41:55.029]                   options(future.plan = NULL)
[11:41:55.029]                   if (is.na(NA_character_)) 
[11:41:55.029]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:55.029]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:55.029]                   future::plan(list(function (..., workers = 2, 
[11:41:55.029]                     envir = parent.frame()) 
[11:41:55.029]                   strategy(..., workers = workers, envir = envir)), 
[11:41:55.029]                     .cleanup = FALSE, .init = FALSE)
[11:41:55.029]                 }
[11:41:55.029]             }
[11:41:55.029]         }
[11:41:55.029]     })
[11:41:55.029]     if (TRUE) {
[11:41:55.029]         base::sink(type = "output", split = FALSE)
[11:41:55.029]         if (TRUE) {
[11:41:55.029]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:55.029]         }
[11:41:55.029]         else {
[11:41:55.029]             ...future.result["stdout"] <- base::list(NULL)
[11:41:55.029]         }
[11:41:55.029]         base::close(...future.stdout)
[11:41:55.029]         ...future.stdout <- NULL
[11:41:55.029]     }
[11:41:55.029]     ...future.result$conditions <- ...future.conditions
[11:41:55.029]     ...future.result$finished <- base::Sys.time()
[11:41:55.029]     ...future.result
[11:41:55.029] }
[11:41:55.031] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:55.042] receiveMessageFromWorker() for ClusterFuture ...
[11:41:55.043] - Validating connection of MultisessionFuture
[11:41:55.043] - received message: FutureResult
[11:41:55.043] - Received FutureResult
[11:41:55.043] - Erased future from FutureRegistry
[11:41:55.043] result() for ClusterFuture ...
[11:41:55.043] - result already collected: FutureResult
[11:41:55.043] result() for ClusterFuture ... done
[11:41:55.044] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:55.044] result() for ClusterFuture ...
[11:41:55.044] - result already collected: FutureResult
[11:41:55.044] result() for ClusterFuture ... done
[11:41:55.044] result() for ClusterFuture ...
[11:41:55.044] - result already collected: FutureResult
[11:41:55.044] result() for ClusterFuture ... done
[11:41:55.045] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:55.045] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:55.090] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:55.095] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:55.138] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:55.139] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:55.186] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:55.187] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:55.192] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:55.192] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:55.194] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:55.194] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:55.195] MultisessionFuture started
[11:41:55.195] - Launch lazy future ... done
[11:41:55.195] run() for ‘MultisessionFuture’ ... done
[11:41:55.196] Created future:
[11:41:55.196] MultisessionFuture:
[11:41:55.196] Label: ‘future_mapply-52’
[11:41:55.196] Expression:
[11:41:55.196] {
[11:41:55.196]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:55.196]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:55.196]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:55.196]         on.exit(options(oopts), add = TRUE)
[11:41:55.196]     }
[11:41:55.196]     {
[11:41:55.196]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:55.196]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:55.196]                 inherits = FALSE)
[11:41:55.196]             ...future.FUN(...)
[11:41:55.196]         }
[11:41:55.196]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:55.196]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:55.196]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:55.196]         do.call(mapply, args = args)
[11:41:55.196]     }
[11:41:55.196] }
[11:41:55.196] Lazy evaluation: FALSE
[11:41:55.196] Asynchronous evaluation: TRUE
[11:41:55.196] Local evaluation: TRUE
[11:41:55.196] Environment: 0x560ef58e1768
[11:41:55.196] Capture standard output: TRUE
[11:41:55.196] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:55.196] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:55.196] Packages: 1 packages (‘mlr3’)
[11:41:55.196] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:55.196] Resolved: FALSE
[11:41:55.196] Value: <not collected>
[11:41:55.196] Conditions captured: <none>
[11:41:55.196] Early signaling: FALSE
[11:41:55.196] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:55.196] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:55.214] Chunk #52 of 90 ... DONE
[11:41:55.214] Chunk #53 of 90 ...
[11:41:55.214]  - seeds: [1] <seeds>
[11:41:55.215] getGlobalsAndPackages() ...
[11:41:55.215] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:55.215] Resolving globals: FALSE
[11:41:55.216] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:55.216] - packages: [1] ‘mlr3’
[11:41:55.216] getGlobalsAndPackages() ... DONE
[11:41:55.216] run() for ‘Future’ ...
[11:41:55.217] - state: ‘created’
[11:41:55.217] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:55.228] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:55.228] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:55.228]   - Field: ‘node’
[11:41:55.228]   - Field: ‘label’
[11:41:55.228]   - Field: ‘local’
[11:41:55.228]   - Field: ‘owner’
[11:41:55.228]   - Field: ‘envir’
[11:41:55.228]   - Field: ‘workers’
[11:41:55.228]   - Field: ‘packages’
[11:41:55.228]   - Field: ‘gc’
[11:41:55.228]   - Field: ‘conditions’
[11:41:55.228]   - Field: ‘persistent’
[11:41:55.229]   - Field: ‘expr’
[11:41:55.229]   - Field: ‘uuid’
[11:41:55.229]   - Field: ‘seed’
[11:41:55.229]   - Field: ‘version’
[11:41:55.229]   - Field: ‘result’
[11:41:55.229]   - Field: ‘asynchronous’
[11:41:55.229]   - Field: ‘calls’
[11:41:55.229]   - Field: ‘globals’
[11:41:55.229]   - Field: ‘stdout’
[11:41:55.229]   - Field: ‘earlySignal’
[11:41:55.229]   - Field: ‘lazy’
[11:41:55.229]   - Field: ‘state’
[11:41:55.229] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:55.229] - Launch lazy future ...
[11:41:55.229] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:55.230] Packages needed by future strategies (n = 0): <none>
[11:41:55.230] {
[11:41:55.230]     {
[11:41:55.230]         {
[11:41:55.230]             ...future.startTime <- base::Sys.time()
[11:41:55.230]             {
[11:41:55.230]                 {
[11:41:55.230]                   {
[11:41:55.230]                     {
[11:41:55.230]                       {
[11:41:55.230]                         base::local({
[11:41:55.230]                           has_future <- base::requireNamespace("future", 
[11:41:55.230]                             quietly = TRUE)
[11:41:55.230]                           if (has_future) {
[11:41:55.230]                             ns <- base::getNamespace("future")
[11:41:55.230]                             version <- ns[[".package"]][["version"]]
[11:41:55.230]                             if (is.null(version)) 
[11:41:55.230]                               version <- utils::packageVersion("future")
[11:41:55.230]                           }
[11:41:55.230]                           else {
[11:41:55.230]                             version <- NULL
[11:41:55.230]                           }
[11:41:55.230]                           if (!has_future || version < "1.8.0") {
[11:41:55.230]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:55.230]                               "", base::R.version$version.string), 
[11:41:55.230]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:55.230]                                 base::R.version$platform, 8 * 
[11:41:55.230]                                   base::.Machine$sizeof.pointer), 
[11:41:55.230]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:55.230]                                 "release", "version")], collapse = " "), 
[11:41:55.230]                               hostname = base::Sys.info()[["nodename"]])
[11:41:55.230]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:55.230]                               info)
[11:41:55.230]                             info <- base::paste(info, collapse = "; ")
[11:41:55.230]                             if (!has_future) {
[11:41:55.230]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:55.230]                                 info)
[11:41:55.230]                             }
[11:41:55.230]                             else {
[11:41:55.230]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:55.230]                                 info, version)
[11:41:55.230]                             }
[11:41:55.230]                             base::stop(msg)
[11:41:55.230]                           }
[11:41:55.230]                         })
[11:41:55.230]                       }
[11:41:55.230]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:55.230]                       base::options(mc.cores = 1L)
[11:41:55.230]                     }
[11:41:55.230]                     base::local({
[11:41:55.230]                       for (pkg in "mlr3") {
[11:41:55.230]                         base::loadNamespace(pkg)
[11:41:55.230]                         base::library(pkg, character.only = TRUE)
[11:41:55.230]                       }
[11:41:55.230]                     })
[11:41:55.230]                   }
[11:41:55.230]                   options(future.plan = NULL)
[11:41:55.230]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:55.230]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:55.230]                 }
[11:41:55.230]                 ...future.workdir <- getwd()
[11:41:55.230]             }
[11:41:55.230]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:55.230]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:55.230]         }
[11:41:55.230]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:55.230]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:55.230]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:55.230]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:55.230]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:55.230]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:55.230]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:55.230]             base::names(...future.oldOptions))
[11:41:55.230]     }
[11:41:55.230]     if (FALSE) {
[11:41:55.230]     }
[11:41:55.230]     else {
[11:41:55.230]         if (TRUE) {
[11:41:55.230]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:55.230]                 open = "w")
[11:41:55.230]         }
[11:41:55.230]         else {
[11:41:55.230]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:55.230]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:55.230]         }
[11:41:55.230]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:55.230]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:55.230]             base::sink(type = "output", split = FALSE)
[11:41:55.230]             base::close(...future.stdout)
[11:41:55.230]         }, add = TRUE)
[11:41:55.230]     }
[11:41:55.230]     ...future.frame <- base::sys.nframe()
[11:41:55.230]     ...future.conditions <- base::list()
[11:41:55.230]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:55.230]     if (FALSE) {
[11:41:55.230]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:55.230]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:55.230]     }
[11:41:55.230]     ...future.result <- base::tryCatch({
[11:41:55.230]         base::withCallingHandlers({
[11:41:55.230]             ...future.value <- base::withVisible(base::local({
[11:41:55.230]                 ...future.makeSendCondition <- local({
[11:41:55.230]                   sendCondition <- NULL
[11:41:55.230]                   function(frame = 1L) {
[11:41:55.230]                     if (is.function(sendCondition)) 
[11:41:55.230]                       return(sendCondition)
[11:41:55.230]                     ns <- getNamespace("parallel")
[11:41:55.230]                     if (exists("sendData", mode = "function", 
[11:41:55.230]                       envir = ns)) {
[11:41:55.230]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:55.230]                         envir = ns)
[11:41:55.230]                       envir <- sys.frame(frame)
[11:41:55.230]                       master <- NULL
[11:41:55.230]                       while (!identical(envir, .GlobalEnv) && 
[11:41:55.230]                         !identical(envir, emptyenv())) {
[11:41:55.230]                         if (exists("master", mode = "list", envir = envir, 
[11:41:55.230]                           inherits = FALSE)) {
[11:41:55.230]                           master <- get("master", mode = "list", 
[11:41:55.230]                             envir = envir, inherits = FALSE)
[11:41:55.230]                           if (inherits(master, c("SOCKnode", 
[11:41:55.230]                             "SOCK0node"))) {
[11:41:55.230]                             sendCondition <<- function(cond) {
[11:41:55.230]                               data <- list(type = "VALUE", value = cond, 
[11:41:55.230]                                 success = TRUE)
[11:41:55.230]                               parallel_sendData(master, data)
[11:41:55.230]                             }
[11:41:55.230]                             return(sendCondition)
[11:41:55.230]                           }
[11:41:55.230]                         }
[11:41:55.230]                         frame <- frame + 1L
[11:41:55.230]                         envir <- sys.frame(frame)
[11:41:55.230]                       }
[11:41:55.230]                     }
[11:41:55.230]                     sendCondition <<- function(cond) NULL
[11:41:55.230]                   }
[11:41:55.230]                 })
[11:41:55.230]                 withCallingHandlers({
[11:41:55.230]                   {
[11:41:55.230]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:55.230]                     if (!identical(...future.globals.maxSize.org, 
[11:41:55.230]                       ...future.globals.maxSize)) {
[11:41:55.230]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:55.230]                       on.exit(options(oopts), add = TRUE)
[11:41:55.230]                     }
[11:41:55.230]                     {
[11:41:55.230]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:55.230]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:55.230]                           envir = globalenv(), inherits = FALSE)
[11:41:55.230]                         ...future.FUN(...)
[11:41:55.230]                       }
[11:41:55.230]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:55.230]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:55.230]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:55.230]                         USE.NAMES = FALSE)
[11:41:55.230]                       do.call(mapply, args = args)
[11:41:55.230]                     }
[11:41:55.230]                   }
[11:41:55.230]                 }, immediateCondition = function(cond) {
[11:41:55.230]                   sendCondition <- ...future.makeSendCondition()
[11:41:55.230]                   sendCondition(cond)
[11:41:55.230]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:55.230]                   {
[11:41:55.230]                     inherits <- base::inherits
[11:41:55.230]                     invokeRestart <- base::invokeRestart
[11:41:55.230]                     is.null <- base::is.null
[11:41:55.230]                     muffled <- FALSE
[11:41:55.230]                     if (inherits(cond, "message")) {
[11:41:55.230]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:55.230]                       if (muffled) 
[11:41:55.230]                         invokeRestart("muffleMessage")
[11:41:55.230]                     }
[11:41:55.230]                     else if (inherits(cond, "warning")) {
[11:41:55.230]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:55.230]                       if (muffled) 
[11:41:55.230]                         invokeRestart("muffleWarning")
[11:41:55.230]                     }
[11:41:55.230]                     else if (inherits(cond, "condition")) {
[11:41:55.230]                       if (!is.null(pattern)) {
[11:41:55.230]                         computeRestarts <- base::computeRestarts
[11:41:55.230]                         grepl <- base::grepl
[11:41:55.230]                         restarts <- computeRestarts(cond)
[11:41:55.230]                         for (restart in restarts) {
[11:41:55.230]                           name <- restart$name
[11:41:55.230]                           if (is.null(name)) 
[11:41:55.230]                             next
[11:41:55.230]                           if (!grepl(pattern, name)) 
[11:41:55.230]                             next
[11:41:55.230]                           invokeRestart(restart)
[11:41:55.230]                           muffled <- TRUE
[11:41:55.230]                           break
[11:41:55.230]                         }
[11:41:55.230]                       }
[11:41:55.230]                     }
[11:41:55.230]                     invisible(muffled)
[11:41:55.230]                   }
[11:41:55.230]                   muffleCondition(cond)
[11:41:55.230]                 })
[11:41:55.230]             }))
[11:41:55.230]             future::FutureResult(value = ...future.value$value, 
[11:41:55.230]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:55.230]                   ...future.rng), globalenv = if (FALSE) 
[11:41:55.230]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:55.230]                     ...future.globalenv.names))
[11:41:55.230]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:55.230]         }, condition = base::local({
[11:41:55.230]             c <- base::c
[11:41:55.230]             inherits <- base::inherits
[11:41:55.230]             invokeRestart <- base::invokeRestart
[11:41:55.230]             length <- base::length
[11:41:55.230]             list <- base::list
[11:41:55.230]             seq.int <- base::seq.int
[11:41:55.230]             signalCondition <- base::signalCondition
[11:41:55.230]             sys.calls <- base::sys.calls
[11:41:55.230]             `[[` <- base::`[[`
[11:41:55.230]             `+` <- base::`+`
[11:41:55.230]             `<<-` <- base::`<<-`
[11:41:55.230]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:55.230]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:55.230]                   3L)]
[11:41:55.230]             }
[11:41:55.230]             function(cond) {
[11:41:55.230]                 is_error <- inherits(cond, "error")
[11:41:55.230]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:55.230]                   NULL)
[11:41:55.230]                 if (is_error) {
[11:41:55.230]                   sessionInformation <- function() {
[11:41:55.230]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:55.230]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:55.230]                       search = base::search(), system = base::Sys.info())
[11:41:55.230]                   }
[11:41:55.230]                   ...future.conditions[[length(...future.conditions) + 
[11:41:55.230]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:55.230]                     cond$call), session = sessionInformation(), 
[11:41:55.230]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:55.230]                   signalCondition(cond)
[11:41:55.230]                 }
[11:41:55.230]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:55.230]                 "immediateCondition"))) {
[11:41:55.230]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:55.230]                   ...future.conditions[[length(...future.conditions) + 
[11:41:55.230]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:55.230]                   if (TRUE && !signal) {
[11:41:55.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:55.230]                     {
[11:41:55.230]                       inherits <- base::inherits
[11:41:55.230]                       invokeRestart <- base::invokeRestart
[11:41:55.230]                       is.null <- base::is.null
[11:41:55.230]                       muffled <- FALSE
[11:41:55.230]                       if (inherits(cond, "message")) {
[11:41:55.230]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:55.230]                         if (muffled) 
[11:41:55.230]                           invokeRestart("muffleMessage")
[11:41:55.230]                       }
[11:41:55.230]                       else if (inherits(cond, "warning")) {
[11:41:55.230]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:55.230]                         if (muffled) 
[11:41:55.230]                           invokeRestart("muffleWarning")
[11:41:55.230]                       }
[11:41:55.230]                       else if (inherits(cond, "condition")) {
[11:41:55.230]                         if (!is.null(pattern)) {
[11:41:55.230]                           computeRestarts <- base::computeRestarts
[11:41:55.230]                           grepl <- base::grepl
[11:41:55.230]                           restarts <- computeRestarts(cond)
[11:41:55.230]                           for (restart in restarts) {
[11:41:55.230]                             name <- restart$name
[11:41:55.230]                             if (is.null(name)) 
[11:41:55.230]                               next
[11:41:55.230]                             if (!grepl(pattern, name)) 
[11:41:55.230]                               next
[11:41:55.230]                             invokeRestart(restart)
[11:41:55.230]                             muffled <- TRUE
[11:41:55.230]                             break
[11:41:55.230]                           }
[11:41:55.230]                         }
[11:41:55.230]                       }
[11:41:55.230]                       invisible(muffled)
[11:41:55.230]                     }
[11:41:55.230]                     muffleCondition(cond, pattern = "^muffle")
[11:41:55.230]                   }
[11:41:55.230]                 }
[11:41:55.230]                 else {
[11:41:55.230]                   if (TRUE) {
[11:41:55.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:55.230]                     {
[11:41:55.230]                       inherits <- base::inherits
[11:41:55.230]                       invokeRestart <- base::invokeRestart
[11:41:55.230]                       is.null <- base::is.null
[11:41:55.230]                       muffled <- FALSE
[11:41:55.230]                       if (inherits(cond, "message")) {
[11:41:55.230]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:55.230]                         if (muffled) 
[11:41:55.230]                           invokeRestart("muffleMessage")
[11:41:55.230]                       }
[11:41:55.230]                       else if (inherits(cond, "warning")) {
[11:41:55.230]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:55.230]                         if (muffled) 
[11:41:55.230]                           invokeRestart("muffleWarning")
[11:41:55.230]                       }
[11:41:55.230]                       else if (inherits(cond, "condition")) {
[11:41:55.230]                         if (!is.null(pattern)) {
[11:41:55.230]                           computeRestarts <- base::computeRestarts
[11:41:55.230]                           grepl <- base::grepl
[11:41:55.230]                           restarts <- computeRestarts(cond)
[11:41:55.230]                           for (restart in restarts) {
[11:41:55.230]                             name <- restart$name
[11:41:55.230]                             if (is.null(name)) 
[11:41:55.230]                               next
[11:41:55.230]                             if (!grepl(pattern, name)) 
[11:41:55.230]                               next
[11:41:55.230]                             invokeRestart(restart)
[11:41:55.230]                             muffled <- TRUE
[11:41:55.230]                             break
[11:41:55.230]                           }
[11:41:55.230]                         }
[11:41:55.230]                       }
[11:41:55.230]                       invisible(muffled)
[11:41:55.230]                     }
[11:41:55.230]                     muffleCondition(cond, pattern = "^muffle")
[11:41:55.230]                   }
[11:41:55.230]                 }
[11:41:55.230]             }
[11:41:55.230]         }))
[11:41:55.230]     }, error = function(ex) {
[11:41:55.230]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:55.230]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:55.230]                 ...future.rng), started = ...future.startTime, 
[11:41:55.230]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:55.230]             version = "1.8"), class = "FutureResult")
[11:41:55.230]     }, finally = {
[11:41:55.230]         if (!identical(...future.workdir, getwd())) 
[11:41:55.230]             setwd(...future.workdir)
[11:41:55.230]         {
[11:41:55.230]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:55.230]                 ...future.oldOptions$nwarnings <- NULL
[11:41:55.230]             }
[11:41:55.230]             base::options(...future.oldOptions)
[11:41:55.230]             if (.Platform$OS.type == "windows") {
[11:41:55.230]                 old_names <- names(...future.oldEnvVars)
[11:41:55.230]                 envs <- base::Sys.getenv()
[11:41:55.230]                 names <- names(envs)
[11:41:55.230]                 common <- intersect(names, old_names)
[11:41:55.230]                 added <- setdiff(names, old_names)
[11:41:55.230]                 removed <- setdiff(old_names, names)
[11:41:55.230]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:55.230]                   envs[common]]
[11:41:55.230]                 NAMES <- toupper(changed)
[11:41:55.230]                 args <- list()
[11:41:55.230]                 for (kk in seq_along(NAMES)) {
[11:41:55.230]                   name <- changed[[kk]]
[11:41:55.230]                   NAME <- NAMES[[kk]]
[11:41:55.230]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:55.230]                     next
[11:41:55.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:55.230]                 }
[11:41:55.230]                 NAMES <- toupper(added)
[11:41:55.230]                 for (kk in seq_along(NAMES)) {
[11:41:55.230]                   name <- added[[kk]]
[11:41:55.230]                   NAME <- NAMES[[kk]]
[11:41:55.230]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:55.230]                     next
[11:41:55.230]                   args[[name]] <- ""
[11:41:55.230]                 }
[11:41:55.230]                 NAMES <- toupper(removed)
[11:41:55.230]                 for (kk in seq_along(NAMES)) {
[11:41:55.230]                   name <- removed[[kk]]
[11:41:55.230]                   NAME <- NAMES[[kk]]
[11:41:55.230]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:55.230]                     next
[11:41:55.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:55.230]                 }
[11:41:55.230]                 if (length(args) > 0) 
[11:41:55.230]                   base::do.call(base::Sys.setenv, args = args)
[11:41:55.230]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:55.230]             }
[11:41:55.230]             else {
[11:41:55.230]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:55.230]             }
[11:41:55.230]             {
[11:41:55.230]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:55.230]                   0L) {
[11:41:55.230]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:55.230]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:55.230]                   base::options(opts)
[11:41:55.230]                 }
[11:41:55.230]                 {
[11:41:55.230]                   {
[11:41:55.230]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:55.230]                     NULL
[11:41:55.230]                   }
[11:41:55.230]                   options(future.plan = NULL)
[11:41:55.230]                   if (is.na(NA_character_)) 
[11:41:55.230]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:55.230]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:55.230]                   future::plan(list(function (..., workers = 2, 
[11:41:55.230]                     envir = parent.frame()) 
[11:41:55.230]                   strategy(..., workers = workers, envir = envir)), 
[11:41:55.230]                     .cleanup = FALSE, .init = FALSE)
[11:41:55.230]                 }
[11:41:55.230]             }
[11:41:55.230]         }
[11:41:55.230]     })
[11:41:55.230]     if (TRUE) {
[11:41:55.230]         base::sink(type = "output", split = FALSE)
[11:41:55.230]         if (TRUE) {
[11:41:55.230]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:55.230]         }
[11:41:55.230]         else {
[11:41:55.230]             ...future.result["stdout"] <- base::list(NULL)
[11:41:55.230]         }
[11:41:55.230]         base::close(...future.stdout)
[11:41:55.230]         ...future.stdout <- NULL
[11:41:55.230]     }
[11:41:55.230]     ...future.result$conditions <- ...future.conditions
[11:41:55.230]     ...future.result$finished <- base::Sys.time()
[11:41:55.230]     ...future.result
[11:41:55.230] }
[11:41:55.232] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:55.243] receiveMessageFromWorker() for ClusterFuture ...
[11:41:55.244] - Validating connection of MultisessionFuture
[11:41:55.244] - received message: FutureResult
[11:41:55.249] - Received FutureResult
[11:41:55.250] - Erased future from FutureRegistry
[11:41:55.250] result() for ClusterFuture ...
[11:41:55.250] - result already collected: FutureResult
[11:41:55.251] result() for ClusterFuture ... done
[11:41:55.251] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:55.251] result() for ClusterFuture ...
[11:41:55.251] - result already collected: FutureResult
[11:41:55.251] result() for ClusterFuture ... done
[11:41:55.251] result() for ClusterFuture ...
[11:41:55.251] - result already collected: FutureResult
[11:41:55.252] result() for ClusterFuture ... done
[11:41:55.252] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:55.253] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:55.298] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:55.307] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:55.309] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:55.309] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:55.354] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:55.355] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:55.357] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:55.358] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:55.359] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:55.360] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:55.361] MultisessionFuture started
[11:41:55.362] - Launch lazy future ... done
[11:41:55.362] run() for ‘MultisessionFuture’ ... done
[11:41:55.362] Created future:
[11:41:55.362] MultisessionFuture:
[11:41:55.362] Label: ‘future_mapply-53’
[11:41:55.362] Expression:
[11:41:55.362] {
[11:41:55.362]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:55.362]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:55.362]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:55.362]         on.exit(options(oopts), add = TRUE)
[11:41:55.362]     }
[11:41:55.362]     {
[11:41:55.362]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:55.362]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:55.362]                 inherits = FALSE)
[11:41:55.362]             ...future.FUN(...)
[11:41:55.362]         }
[11:41:55.362]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:55.362]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:55.362]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:55.362]         do.call(mapply, args = args)
[11:41:55.362]     }
[11:41:55.362] }
[11:41:55.362] Lazy evaluation: FALSE
[11:41:55.362] Asynchronous evaluation: TRUE
[11:41:55.362] Local evaluation: TRUE
[11:41:55.362] Environment: 0x560ef58e1768
[11:41:55.362] Capture standard output: TRUE
[11:41:55.362] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:55.362] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:55.362] Packages: 1 packages (‘mlr3’)
[11:41:55.362] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:55.362] Resolved: FALSE
[11:41:55.362] Value: <not collected>
[11:41:55.362] Conditions captured: <none>
[11:41:55.362] Early signaling: FALSE
[11:41:55.362] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:55.362] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:55.380] Chunk #53 of 90 ... DONE
[11:41:55.380] Chunk #54 of 90 ...
[11:41:55.381]  - seeds: [1] <seeds>
[11:41:55.381] getGlobalsAndPackages() ...
[11:41:55.381] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:55.381] Resolving globals: FALSE
[11:41:55.382] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:55.382] - packages: [1] ‘mlr3’
[11:41:55.382] getGlobalsAndPackages() ... DONE
[11:41:55.383] run() for ‘Future’ ...
[11:41:55.383] - state: ‘created’
[11:41:55.383] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:55.396] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:55.396] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:55.396]   - Field: ‘node’
[11:41:55.396]   - Field: ‘label’
[11:41:55.396]   - Field: ‘local’
[11:41:55.396]   - Field: ‘owner’
[11:41:55.396]   - Field: ‘envir’
[11:41:55.396]   - Field: ‘workers’
[11:41:55.396]   - Field: ‘packages’
[11:41:55.396]   - Field: ‘gc’
[11:41:55.396]   - Field: ‘conditions’
[11:41:55.396]   - Field: ‘persistent’
[11:41:55.396]   - Field: ‘expr’
[11:41:55.397]   - Field: ‘uuid’
[11:41:55.397]   - Field: ‘seed’
[11:41:55.397]   - Field: ‘version’
[11:41:55.397]   - Field: ‘result’
[11:41:55.397]   - Field: ‘asynchronous’
[11:41:55.397]   - Field: ‘calls’
[11:41:55.397]   - Field: ‘globals’
[11:41:55.397]   - Field: ‘stdout’
[11:41:55.397]   - Field: ‘earlySignal’
[11:41:55.397]   - Field: ‘lazy’
[11:41:55.397]   - Field: ‘state’
[11:41:55.397] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:55.397] - Launch lazy future ...
[11:41:55.397] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:55.397] Packages needed by future strategies (n = 0): <none>
[11:41:55.398] {
[11:41:55.398]     {
[11:41:55.398]         {
[11:41:55.398]             ...future.startTime <- base::Sys.time()
[11:41:55.398]             {
[11:41:55.398]                 {
[11:41:55.398]                   {
[11:41:55.398]                     {
[11:41:55.398]                       {
[11:41:55.398]                         base::local({
[11:41:55.398]                           has_future <- base::requireNamespace("future", 
[11:41:55.398]                             quietly = TRUE)
[11:41:55.398]                           if (has_future) {
[11:41:55.398]                             ns <- base::getNamespace("future")
[11:41:55.398]                             version <- ns[[".package"]][["version"]]
[11:41:55.398]                             if (is.null(version)) 
[11:41:55.398]                               version <- utils::packageVersion("future")
[11:41:55.398]                           }
[11:41:55.398]                           else {
[11:41:55.398]                             version <- NULL
[11:41:55.398]                           }
[11:41:55.398]                           if (!has_future || version < "1.8.0") {
[11:41:55.398]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:55.398]                               "", base::R.version$version.string), 
[11:41:55.398]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:55.398]                                 base::R.version$platform, 8 * 
[11:41:55.398]                                   base::.Machine$sizeof.pointer), 
[11:41:55.398]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:55.398]                                 "release", "version")], collapse = " "), 
[11:41:55.398]                               hostname = base::Sys.info()[["nodename"]])
[11:41:55.398]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:55.398]                               info)
[11:41:55.398]                             info <- base::paste(info, collapse = "; ")
[11:41:55.398]                             if (!has_future) {
[11:41:55.398]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:55.398]                                 info)
[11:41:55.398]                             }
[11:41:55.398]                             else {
[11:41:55.398]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:55.398]                                 info, version)
[11:41:55.398]                             }
[11:41:55.398]                             base::stop(msg)
[11:41:55.398]                           }
[11:41:55.398]                         })
[11:41:55.398]                       }
[11:41:55.398]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:55.398]                       base::options(mc.cores = 1L)
[11:41:55.398]                     }
[11:41:55.398]                     base::local({
[11:41:55.398]                       for (pkg in "mlr3") {
[11:41:55.398]                         base::loadNamespace(pkg)
[11:41:55.398]                         base::library(pkg, character.only = TRUE)
[11:41:55.398]                       }
[11:41:55.398]                     })
[11:41:55.398]                   }
[11:41:55.398]                   options(future.plan = NULL)
[11:41:55.398]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:55.398]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:55.398]                 }
[11:41:55.398]                 ...future.workdir <- getwd()
[11:41:55.398]             }
[11:41:55.398]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:55.398]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:55.398]         }
[11:41:55.398]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:55.398]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:55.398]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:55.398]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:55.398]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:55.398]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:55.398]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:55.398]             base::names(...future.oldOptions))
[11:41:55.398]     }
[11:41:55.398]     if (FALSE) {
[11:41:55.398]     }
[11:41:55.398]     else {
[11:41:55.398]         if (TRUE) {
[11:41:55.398]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:55.398]                 open = "w")
[11:41:55.398]         }
[11:41:55.398]         else {
[11:41:55.398]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:55.398]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:55.398]         }
[11:41:55.398]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:55.398]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:55.398]             base::sink(type = "output", split = FALSE)
[11:41:55.398]             base::close(...future.stdout)
[11:41:55.398]         }, add = TRUE)
[11:41:55.398]     }
[11:41:55.398]     ...future.frame <- base::sys.nframe()
[11:41:55.398]     ...future.conditions <- base::list()
[11:41:55.398]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:55.398]     if (FALSE) {
[11:41:55.398]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:55.398]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:55.398]     }
[11:41:55.398]     ...future.result <- base::tryCatch({
[11:41:55.398]         base::withCallingHandlers({
[11:41:55.398]             ...future.value <- base::withVisible(base::local({
[11:41:55.398]                 ...future.makeSendCondition <- local({
[11:41:55.398]                   sendCondition <- NULL
[11:41:55.398]                   function(frame = 1L) {
[11:41:55.398]                     if (is.function(sendCondition)) 
[11:41:55.398]                       return(sendCondition)
[11:41:55.398]                     ns <- getNamespace("parallel")
[11:41:55.398]                     if (exists("sendData", mode = "function", 
[11:41:55.398]                       envir = ns)) {
[11:41:55.398]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:55.398]                         envir = ns)
[11:41:55.398]                       envir <- sys.frame(frame)
[11:41:55.398]                       master <- NULL
[11:41:55.398]                       while (!identical(envir, .GlobalEnv) && 
[11:41:55.398]                         !identical(envir, emptyenv())) {
[11:41:55.398]                         if (exists("master", mode = "list", envir = envir, 
[11:41:55.398]                           inherits = FALSE)) {
[11:41:55.398]                           master <- get("master", mode = "list", 
[11:41:55.398]                             envir = envir, inherits = FALSE)
[11:41:55.398]                           if (inherits(master, c("SOCKnode", 
[11:41:55.398]                             "SOCK0node"))) {
[11:41:55.398]                             sendCondition <<- function(cond) {
[11:41:55.398]                               data <- list(type = "VALUE", value = cond, 
[11:41:55.398]                                 success = TRUE)
[11:41:55.398]                               parallel_sendData(master, data)
[11:41:55.398]                             }
[11:41:55.398]                             return(sendCondition)
[11:41:55.398]                           }
[11:41:55.398]                         }
[11:41:55.398]                         frame <- frame + 1L
[11:41:55.398]                         envir <- sys.frame(frame)
[11:41:55.398]                       }
[11:41:55.398]                     }
[11:41:55.398]                     sendCondition <<- function(cond) NULL
[11:41:55.398]                   }
[11:41:55.398]                 })
[11:41:55.398]                 withCallingHandlers({
[11:41:55.398]                   {
[11:41:55.398]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:55.398]                     if (!identical(...future.globals.maxSize.org, 
[11:41:55.398]                       ...future.globals.maxSize)) {
[11:41:55.398]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:55.398]                       on.exit(options(oopts), add = TRUE)
[11:41:55.398]                     }
[11:41:55.398]                     {
[11:41:55.398]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:55.398]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:55.398]                           envir = globalenv(), inherits = FALSE)
[11:41:55.398]                         ...future.FUN(...)
[11:41:55.398]                       }
[11:41:55.398]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:55.398]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:55.398]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:55.398]                         USE.NAMES = FALSE)
[11:41:55.398]                       do.call(mapply, args = args)
[11:41:55.398]                     }
[11:41:55.398]                   }
[11:41:55.398]                 }, immediateCondition = function(cond) {
[11:41:55.398]                   sendCondition <- ...future.makeSendCondition()
[11:41:55.398]                   sendCondition(cond)
[11:41:55.398]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:55.398]                   {
[11:41:55.398]                     inherits <- base::inherits
[11:41:55.398]                     invokeRestart <- base::invokeRestart
[11:41:55.398]                     is.null <- base::is.null
[11:41:55.398]                     muffled <- FALSE
[11:41:55.398]                     if (inherits(cond, "message")) {
[11:41:55.398]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:55.398]                       if (muffled) 
[11:41:55.398]                         invokeRestart("muffleMessage")
[11:41:55.398]                     }
[11:41:55.398]                     else if (inherits(cond, "warning")) {
[11:41:55.398]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:55.398]                       if (muffled) 
[11:41:55.398]                         invokeRestart("muffleWarning")
[11:41:55.398]                     }
[11:41:55.398]                     else if (inherits(cond, "condition")) {
[11:41:55.398]                       if (!is.null(pattern)) {
[11:41:55.398]                         computeRestarts <- base::computeRestarts
[11:41:55.398]                         grepl <- base::grepl
[11:41:55.398]                         restarts <- computeRestarts(cond)
[11:41:55.398]                         for (restart in restarts) {
[11:41:55.398]                           name <- restart$name
[11:41:55.398]                           if (is.null(name)) 
[11:41:55.398]                             next
[11:41:55.398]                           if (!grepl(pattern, name)) 
[11:41:55.398]                             next
[11:41:55.398]                           invokeRestart(restart)
[11:41:55.398]                           muffled <- TRUE
[11:41:55.398]                           break
[11:41:55.398]                         }
[11:41:55.398]                       }
[11:41:55.398]                     }
[11:41:55.398]                     invisible(muffled)
[11:41:55.398]                   }
[11:41:55.398]                   muffleCondition(cond)
[11:41:55.398]                 })
[11:41:55.398]             }))
[11:41:55.398]             future::FutureResult(value = ...future.value$value, 
[11:41:55.398]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:55.398]                   ...future.rng), globalenv = if (FALSE) 
[11:41:55.398]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:55.398]                     ...future.globalenv.names))
[11:41:55.398]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:55.398]         }, condition = base::local({
[11:41:55.398]             c <- base::c
[11:41:55.398]             inherits <- base::inherits
[11:41:55.398]             invokeRestart <- base::invokeRestart
[11:41:55.398]             length <- base::length
[11:41:55.398]             list <- base::list
[11:41:55.398]             seq.int <- base::seq.int
[11:41:55.398]             signalCondition <- base::signalCondition
[11:41:55.398]             sys.calls <- base::sys.calls
[11:41:55.398]             `[[` <- base::`[[`
[11:41:55.398]             `+` <- base::`+`
[11:41:55.398]             `<<-` <- base::`<<-`
[11:41:55.398]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:55.398]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:55.398]                   3L)]
[11:41:55.398]             }
[11:41:55.398]             function(cond) {
[11:41:55.398]                 is_error <- inherits(cond, "error")
[11:41:55.398]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:55.398]                   NULL)
[11:41:55.398]                 if (is_error) {
[11:41:55.398]                   sessionInformation <- function() {
[11:41:55.398]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:55.398]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:55.398]                       search = base::search(), system = base::Sys.info())
[11:41:55.398]                   }
[11:41:55.398]                   ...future.conditions[[length(...future.conditions) + 
[11:41:55.398]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:55.398]                     cond$call), session = sessionInformation(), 
[11:41:55.398]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:55.398]                   signalCondition(cond)
[11:41:55.398]                 }
[11:41:55.398]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:55.398]                 "immediateCondition"))) {
[11:41:55.398]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:55.398]                   ...future.conditions[[length(...future.conditions) + 
[11:41:55.398]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:55.398]                   if (TRUE && !signal) {
[11:41:55.398]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:55.398]                     {
[11:41:55.398]                       inherits <- base::inherits
[11:41:55.398]                       invokeRestart <- base::invokeRestart
[11:41:55.398]                       is.null <- base::is.null
[11:41:55.398]                       muffled <- FALSE
[11:41:55.398]                       if (inherits(cond, "message")) {
[11:41:55.398]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:55.398]                         if (muffled) 
[11:41:55.398]                           invokeRestart("muffleMessage")
[11:41:55.398]                       }
[11:41:55.398]                       else if (inherits(cond, "warning")) {
[11:41:55.398]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:55.398]                         if (muffled) 
[11:41:55.398]                           invokeRestart("muffleWarning")
[11:41:55.398]                       }
[11:41:55.398]                       else if (inherits(cond, "condition")) {
[11:41:55.398]                         if (!is.null(pattern)) {
[11:41:55.398]                           computeRestarts <- base::computeRestarts
[11:41:55.398]                           grepl <- base::grepl
[11:41:55.398]                           restarts <- computeRestarts(cond)
[11:41:55.398]                           for (restart in restarts) {
[11:41:55.398]                             name <- restart$name
[11:41:55.398]                             if (is.null(name)) 
[11:41:55.398]                               next
[11:41:55.398]                             if (!grepl(pattern, name)) 
[11:41:55.398]                               next
[11:41:55.398]                             invokeRestart(restart)
[11:41:55.398]                             muffled <- TRUE
[11:41:55.398]                             break
[11:41:55.398]                           }
[11:41:55.398]                         }
[11:41:55.398]                       }
[11:41:55.398]                       invisible(muffled)
[11:41:55.398]                     }
[11:41:55.398]                     muffleCondition(cond, pattern = "^muffle")
[11:41:55.398]                   }
[11:41:55.398]                 }
[11:41:55.398]                 else {
[11:41:55.398]                   if (TRUE) {
[11:41:55.398]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:55.398]                     {
[11:41:55.398]                       inherits <- base::inherits
[11:41:55.398]                       invokeRestart <- base::invokeRestart
[11:41:55.398]                       is.null <- base::is.null
[11:41:55.398]                       muffled <- FALSE
[11:41:55.398]                       if (inherits(cond, "message")) {
[11:41:55.398]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:55.398]                         if (muffled) 
[11:41:55.398]                           invokeRestart("muffleMessage")
[11:41:55.398]                       }
[11:41:55.398]                       else if (inherits(cond, "warning")) {
[11:41:55.398]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:55.398]                         if (muffled) 
[11:41:55.398]                           invokeRestart("muffleWarning")
[11:41:55.398]                       }
[11:41:55.398]                       else if (inherits(cond, "condition")) {
[11:41:55.398]                         if (!is.null(pattern)) {
[11:41:55.398]                           computeRestarts <- base::computeRestarts
[11:41:55.398]                           grepl <- base::grepl
[11:41:55.398]                           restarts <- computeRestarts(cond)
[11:41:55.398]                           for (restart in restarts) {
[11:41:55.398]                             name <- restart$name
[11:41:55.398]                             if (is.null(name)) 
[11:41:55.398]                               next
[11:41:55.398]                             if (!grepl(pattern, name)) 
[11:41:55.398]                               next
[11:41:55.398]                             invokeRestart(restart)
[11:41:55.398]                             muffled <- TRUE
[11:41:55.398]                             break
[11:41:55.398]                           }
[11:41:55.398]                         }
[11:41:55.398]                       }
[11:41:55.398]                       invisible(muffled)
[11:41:55.398]                     }
[11:41:55.398]                     muffleCondition(cond, pattern = "^muffle")
[11:41:55.398]                   }
[11:41:55.398]                 }
[11:41:55.398]             }
[11:41:55.398]         }))
[11:41:55.398]     }, error = function(ex) {
[11:41:55.398]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:55.398]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:55.398]                 ...future.rng), started = ...future.startTime, 
[11:41:55.398]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:55.398]             version = "1.8"), class = "FutureResult")
[11:41:55.398]     }, finally = {
[11:41:55.398]         if (!identical(...future.workdir, getwd())) 
[11:41:55.398]             setwd(...future.workdir)
[11:41:55.398]         {
[11:41:55.398]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:55.398]                 ...future.oldOptions$nwarnings <- NULL
[11:41:55.398]             }
[11:41:55.398]             base::options(...future.oldOptions)
[11:41:55.398]             if (.Platform$OS.type == "windows") {
[11:41:55.398]                 old_names <- names(...future.oldEnvVars)
[11:41:55.398]                 envs <- base::Sys.getenv()
[11:41:55.398]                 names <- names(envs)
[11:41:55.398]                 common <- intersect(names, old_names)
[11:41:55.398]                 added <- setdiff(names, old_names)
[11:41:55.398]                 removed <- setdiff(old_names, names)
[11:41:55.398]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:55.398]                   envs[common]]
[11:41:55.398]                 NAMES <- toupper(changed)
[11:41:55.398]                 args <- list()
[11:41:55.398]                 for (kk in seq_along(NAMES)) {
[11:41:55.398]                   name <- changed[[kk]]
[11:41:55.398]                   NAME <- NAMES[[kk]]
[11:41:55.398]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:55.398]                     next
[11:41:55.398]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:55.398]                 }
[11:41:55.398]                 NAMES <- toupper(added)
[11:41:55.398]                 for (kk in seq_along(NAMES)) {
[11:41:55.398]                   name <- added[[kk]]
[11:41:55.398]                   NAME <- NAMES[[kk]]
[11:41:55.398]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:55.398]                     next
[11:41:55.398]                   args[[name]] <- ""
[11:41:55.398]                 }
[11:41:55.398]                 NAMES <- toupper(removed)
[11:41:55.398]                 for (kk in seq_along(NAMES)) {
[11:41:55.398]                   name <- removed[[kk]]
[11:41:55.398]                   NAME <- NAMES[[kk]]
[11:41:55.398]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:55.398]                     next
[11:41:55.398]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:55.398]                 }
[11:41:55.398]                 if (length(args) > 0) 
[11:41:55.398]                   base::do.call(base::Sys.setenv, args = args)
[11:41:55.398]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:55.398]             }
[11:41:55.398]             else {
[11:41:55.398]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:55.398]             }
[11:41:55.398]             {
[11:41:55.398]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:55.398]                   0L) {
[11:41:55.398]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:55.398]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:55.398]                   base::options(opts)
[11:41:55.398]                 }
[11:41:55.398]                 {
[11:41:55.398]                   {
[11:41:55.398]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:55.398]                     NULL
[11:41:55.398]                   }
[11:41:55.398]                   options(future.plan = NULL)
[11:41:55.398]                   if (is.na(NA_character_)) 
[11:41:55.398]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:55.398]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:55.398]                   future::plan(list(function (..., workers = 2, 
[11:41:55.398]                     envir = parent.frame()) 
[11:41:55.398]                   strategy(..., workers = workers, envir = envir)), 
[11:41:55.398]                     .cleanup = FALSE, .init = FALSE)
[11:41:55.398]                 }
[11:41:55.398]             }
[11:41:55.398]         }
[11:41:55.398]     })
[11:41:55.398]     if (TRUE) {
[11:41:55.398]         base::sink(type = "output", split = FALSE)
[11:41:55.398]         if (TRUE) {
[11:41:55.398]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:55.398]         }
[11:41:55.398]         else {
[11:41:55.398]             ...future.result["stdout"] <- base::list(NULL)
[11:41:55.398]         }
[11:41:55.398]         base::close(...future.stdout)
[11:41:55.398]         ...future.stdout <- NULL
[11:41:55.398]     }
[11:41:55.398]     ...future.result$conditions <- ...future.conditions
[11:41:55.398]     ...future.result$finished <- base::Sys.time()
[11:41:55.398]     ...future.result
[11:41:55.398] }
[11:41:55.400] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:55.410] receiveMessageFromWorker() for ClusterFuture ...
[11:41:55.411] - Validating connection of MultisessionFuture
[11:41:55.411] - received message: FutureResult
[11:41:55.411] - Received FutureResult
[11:41:55.411] - Erased future from FutureRegistry
[11:41:55.411] result() for ClusterFuture ...
[11:41:55.411] - result already collected: FutureResult
[11:41:55.411] result() for ClusterFuture ... done
[11:41:55.411] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:55.412] result() for ClusterFuture ...
[11:41:55.412] - result already collected: FutureResult
[11:41:55.412] result() for ClusterFuture ... done
[11:41:55.412] result() for ClusterFuture ...
[11:41:55.412] - result already collected: FutureResult
[11:41:55.412] result() for ClusterFuture ... done
[11:41:55.413] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:55.413] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:55.458] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:55.465] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:55.467] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:55.467] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:55.510] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:55.511] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:55.512] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:55.512] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:55.514] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:55.514] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:55.515] MultisessionFuture started
[11:41:55.515] - Launch lazy future ... done
[11:41:55.516] run() for ‘MultisessionFuture’ ... done
[11:41:55.516] Created future:
[11:41:55.516] MultisessionFuture:
[11:41:55.516] Label: ‘future_mapply-54’
[11:41:55.516] Expression:
[11:41:55.516] {
[11:41:55.516]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:55.516]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:55.516]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:55.516]         on.exit(options(oopts), add = TRUE)
[11:41:55.516]     }
[11:41:55.516]     {
[11:41:55.516]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:55.516]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:55.516]                 inherits = FALSE)
[11:41:55.516]             ...future.FUN(...)
[11:41:55.516]         }
[11:41:55.516]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:55.516]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:55.516]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:55.516]         do.call(mapply, args = args)
[11:41:55.516]     }
[11:41:55.516] }
[11:41:55.516] Lazy evaluation: FALSE
[11:41:55.516] Asynchronous evaluation: TRUE
[11:41:55.516] Local evaluation: TRUE
[11:41:55.516] Environment: 0x560ef58e1768
[11:41:55.516] Capture standard output: TRUE
[11:41:55.516] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:55.516] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:55.516] Packages: 1 packages (‘mlr3’)
[11:41:55.516] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:55.516] Resolved: FALSE
[11:41:55.516] Value: <not collected>
[11:41:55.516] Conditions captured: <none>
[11:41:55.516] Early signaling: FALSE
[11:41:55.516] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:55.516] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:55.533] Chunk #54 of 90 ... DONE
[11:41:55.534] Chunk #55 of 90 ...
[11:41:55.534]  - seeds: [1] <seeds>
[11:41:55.534] getGlobalsAndPackages() ...
[11:41:55.534] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:55.534] Resolving globals: FALSE
[11:41:55.535] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:55.535] - packages: [1] ‘mlr3’
[11:41:55.535] getGlobalsAndPackages() ... DONE
[11:41:55.536] run() for ‘Future’ ...
[11:41:55.536] - state: ‘created’
[11:41:55.536] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:55.547] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:55.547] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:55.547]   - Field: ‘node’
[11:41:55.547]   - Field: ‘label’
[11:41:55.547]   - Field: ‘local’
[11:41:55.547]   - Field: ‘owner’
[11:41:55.547]   - Field: ‘envir’
[11:41:55.547]   - Field: ‘workers’
[11:41:55.547]   - Field: ‘packages’
[11:41:55.547]   - Field: ‘gc’
[11:41:55.548]   - Field: ‘conditions’
[11:41:55.548]   - Field: ‘persistent’
[11:41:55.548]   - Field: ‘expr’
[11:41:55.548]   - Field: ‘uuid’
[11:41:55.548]   - Field: ‘seed’
[11:41:55.548]   - Field: ‘version’
[11:41:55.548]   - Field: ‘result’
[11:41:55.548]   - Field: ‘asynchronous’
[11:41:55.548]   - Field: ‘calls’
[11:41:55.548]   - Field: ‘globals’
[11:41:55.548]   - Field: ‘stdout’
[11:41:55.548]   - Field: ‘earlySignal’
[11:41:55.548]   - Field: ‘lazy’
[11:41:55.548]   - Field: ‘state’
[11:41:55.548] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:55.548] - Launch lazy future ...
[11:41:55.549] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:55.549] Packages needed by future strategies (n = 0): <none>
[11:41:55.549] {
[11:41:55.549]     {
[11:41:55.549]         {
[11:41:55.549]             ...future.startTime <- base::Sys.time()
[11:41:55.549]             {
[11:41:55.549]                 {
[11:41:55.549]                   {
[11:41:55.549]                     {
[11:41:55.549]                       {
[11:41:55.549]                         base::local({
[11:41:55.549]                           has_future <- base::requireNamespace("future", 
[11:41:55.549]                             quietly = TRUE)
[11:41:55.549]                           if (has_future) {
[11:41:55.549]                             ns <- base::getNamespace("future")
[11:41:55.549]                             version <- ns[[".package"]][["version"]]
[11:41:55.549]                             if (is.null(version)) 
[11:41:55.549]                               version <- utils::packageVersion("future")
[11:41:55.549]                           }
[11:41:55.549]                           else {
[11:41:55.549]                             version <- NULL
[11:41:55.549]                           }
[11:41:55.549]                           if (!has_future || version < "1.8.0") {
[11:41:55.549]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:55.549]                               "", base::R.version$version.string), 
[11:41:55.549]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:55.549]                                 base::R.version$platform, 8 * 
[11:41:55.549]                                   base::.Machine$sizeof.pointer), 
[11:41:55.549]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:55.549]                                 "release", "version")], collapse = " "), 
[11:41:55.549]                               hostname = base::Sys.info()[["nodename"]])
[11:41:55.549]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:55.549]                               info)
[11:41:55.549]                             info <- base::paste(info, collapse = "; ")
[11:41:55.549]                             if (!has_future) {
[11:41:55.549]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:55.549]                                 info)
[11:41:55.549]                             }
[11:41:55.549]                             else {
[11:41:55.549]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:55.549]                                 info, version)
[11:41:55.549]                             }
[11:41:55.549]                             base::stop(msg)
[11:41:55.549]                           }
[11:41:55.549]                         })
[11:41:55.549]                       }
[11:41:55.549]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:55.549]                       base::options(mc.cores = 1L)
[11:41:55.549]                     }
[11:41:55.549]                     base::local({
[11:41:55.549]                       for (pkg in "mlr3") {
[11:41:55.549]                         base::loadNamespace(pkg)
[11:41:55.549]                         base::library(pkg, character.only = TRUE)
[11:41:55.549]                       }
[11:41:55.549]                     })
[11:41:55.549]                   }
[11:41:55.549]                   options(future.plan = NULL)
[11:41:55.549]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:55.549]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:55.549]                 }
[11:41:55.549]                 ...future.workdir <- getwd()
[11:41:55.549]             }
[11:41:55.549]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:55.549]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:55.549]         }
[11:41:55.549]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:55.549]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:55.549]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:55.549]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:55.549]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:55.549]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:55.549]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:55.549]             base::names(...future.oldOptions))
[11:41:55.549]     }
[11:41:55.549]     if (FALSE) {
[11:41:55.549]     }
[11:41:55.549]     else {
[11:41:55.549]         if (TRUE) {
[11:41:55.549]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:55.549]                 open = "w")
[11:41:55.549]         }
[11:41:55.549]         else {
[11:41:55.549]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:55.549]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:55.549]         }
[11:41:55.549]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:55.549]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:55.549]             base::sink(type = "output", split = FALSE)
[11:41:55.549]             base::close(...future.stdout)
[11:41:55.549]         }, add = TRUE)
[11:41:55.549]     }
[11:41:55.549]     ...future.frame <- base::sys.nframe()
[11:41:55.549]     ...future.conditions <- base::list()
[11:41:55.549]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:55.549]     if (FALSE) {
[11:41:55.549]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:55.549]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:55.549]     }
[11:41:55.549]     ...future.result <- base::tryCatch({
[11:41:55.549]         base::withCallingHandlers({
[11:41:55.549]             ...future.value <- base::withVisible(base::local({
[11:41:55.549]                 ...future.makeSendCondition <- local({
[11:41:55.549]                   sendCondition <- NULL
[11:41:55.549]                   function(frame = 1L) {
[11:41:55.549]                     if (is.function(sendCondition)) 
[11:41:55.549]                       return(sendCondition)
[11:41:55.549]                     ns <- getNamespace("parallel")
[11:41:55.549]                     if (exists("sendData", mode = "function", 
[11:41:55.549]                       envir = ns)) {
[11:41:55.549]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:55.549]                         envir = ns)
[11:41:55.549]                       envir <- sys.frame(frame)
[11:41:55.549]                       master <- NULL
[11:41:55.549]                       while (!identical(envir, .GlobalEnv) && 
[11:41:55.549]                         !identical(envir, emptyenv())) {
[11:41:55.549]                         if (exists("master", mode = "list", envir = envir, 
[11:41:55.549]                           inherits = FALSE)) {
[11:41:55.549]                           master <- get("master", mode = "list", 
[11:41:55.549]                             envir = envir, inherits = FALSE)
[11:41:55.549]                           if (inherits(master, c("SOCKnode", 
[11:41:55.549]                             "SOCK0node"))) {
[11:41:55.549]                             sendCondition <<- function(cond) {
[11:41:55.549]                               data <- list(type = "VALUE", value = cond, 
[11:41:55.549]                                 success = TRUE)
[11:41:55.549]                               parallel_sendData(master, data)
[11:41:55.549]                             }
[11:41:55.549]                             return(sendCondition)
[11:41:55.549]                           }
[11:41:55.549]                         }
[11:41:55.549]                         frame <- frame + 1L
[11:41:55.549]                         envir <- sys.frame(frame)
[11:41:55.549]                       }
[11:41:55.549]                     }
[11:41:55.549]                     sendCondition <<- function(cond) NULL
[11:41:55.549]                   }
[11:41:55.549]                 })
[11:41:55.549]                 withCallingHandlers({
[11:41:55.549]                   {
[11:41:55.549]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:55.549]                     if (!identical(...future.globals.maxSize.org, 
[11:41:55.549]                       ...future.globals.maxSize)) {
[11:41:55.549]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:55.549]                       on.exit(options(oopts), add = TRUE)
[11:41:55.549]                     }
[11:41:55.549]                     {
[11:41:55.549]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:55.549]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:55.549]                           envir = globalenv(), inherits = FALSE)
[11:41:55.549]                         ...future.FUN(...)
[11:41:55.549]                       }
[11:41:55.549]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:55.549]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:55.549]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:55.549]                         USE.NAMES = FALSE)
[11:41:55.549]                       do.call(mapply, args = args)
[11:41:55.549]                     }
[11:41:55.549]                   }
[11:41:55.549]                 }, immediateCondition = function(cond) {
[11:41:55.549]                   sendCondition <- ...future.makeSendCondition()
[11:41:55.549]                   sendCondition(cond)
[11:41:55.549]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:55.549]                   {
[11:41:55.549]                     inherits <- base::inherits
[11:41:55.549]                     invokeRestart <- base::invokeRestart
[11:41:55.549]                     is.null <- base::is.null
[11:41:55.549]                     muffled <- FALSE
[11:41:55.549]                     if (inherits(cond, "message")) {
[11:41:55.549]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:55.549]                       if (muffled) 
[11:41:55.549]                         invokeRestart("muffleMessage")
[11:41:55.549]                     }
[11:41:55.549]                     else if (inherits(cond, "warning")) {
[11:41:55.549]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:55.549]                       if (muffled) 
[11:41:55.549]                         invokeRestart("muffleWarning")
[11:41:55.549]                     }
[11:41:55.549]                     else if (inherits(cond, "condition")) {
[11:41:55.549]                       if (!is.null(pattern)) {
[11:41:55.549]                         computeRestarts <- base::computeRestarts
[11:41:55.549]                         grepl <- base::grepl
[11:41:55.549]                         restarts <- computeRestarts(cond)
[11:41:55.549]                         for (restart in restarts) {
[11:41:55.549]                           name <- restart$name
[11:41:55.549]                           if (is.null(name)) 
[11:41:55.549]                             next
[11:41:55.549]                           if (!grepl(pattern, name)) 
[11:41:55.549]                             next
[11:41:55.549]                           invokeRestart(restart)
[11:41:55.549]                           muffled <- TRUE
[11:41:55.549]                           break
[11:41:55.549]                         }
[11:41:55.549]                       }
[11:41:55.549]                     }
[11:41:55.549]                     invisible(muffled)
[11:41:55.549]                   }
[11:41:55.549]                   muffleCondition(cond)
[11:41:55.549]                 })
[11:41:55.549]             }))
[11:41:55.549]             future::FutureResult(value = ...future.value$value, 
[11:41:55.549]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:55.549]                   ...future.rng), globalenv = if (FALSE) 
[11:41:55.549]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:55.549]                     ...future.globalenv.names))
[11:41:55.549]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:55.549]         }, condition = base::local({
[11:41:55.549]             c <- base::c
[11:41:55.549]             inherits <- base::inherits
[11:41:55.549]             invokeRestart <- base::invokeRestart
[11:41:55.549]             length <- base::length
[11:41:55.549]             list <- base::list
[11:41:55.549]             seq.int <- base::seq.int
[11:41:55.549]             signalCondition <- base::signalCondition
[11:41:55.549]             sys.calls <- base::sys.calls
[11:41:55.549]             `[[` <- base::`[[`
[11:41:55.549]             `+` <- base::`+`
[11:41:55.549]             `<<-` <- base::`<<-`
[11:41:55.549]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:55.549]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:55.549]                   3L)]
[11:41:55.549]             }
[11:41:55.549]             function(cond) {
[11:41:55.549]                 is_error <- inherits(cond, "error")
[11:41:55.549]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:55.549]                   NULL)
[11:41:55.549]                 if (is_error) {
[11:41:55.549]                   sessionInformation <- function() {
[11:41:55.549]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:55.549]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:55.549]                       search = base::search(), system = base::Sys.info())
[11:41:55.549]                   }
[11:41:55.549]                   ...future.conditions[[length(...future.conditions) + 
[11:41:55.549]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:55.549]                     cond$call), session = sessionInformation(), 
[11:41:55.549]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:55.549]                   signalCondition(cond)
[11:41:55.549]                 }
[11:41:55.549]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:55.549]                 "immediateCondition"))) {
[11:41:55.549]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:55.549]                   ...future.conditions[[length(...future.conditions) + 
[11:41:55.549]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:55.549]                   if (TRUE && !signal) {
[11:41:55.549]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:55.549]                     {
[11:41:55.549]                       inherits <- base::inherits
[11:41:55.549]                       invokeRestart <- base::invokeRestart
[11:41:55.549]                       is.null <- base::is.null
[11:41:55.549]                       muffled <- FALSE
[11:41:55.549]                       if (inherits(cond, "message")) {
[11:41:55.549]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:55.549]                         if (muffled) 
[11:41:55.549]                           invokeRestart("muffleMessage")
[11:41:55.549]                       }
[11:41:55.549]                       else if (inherits(cond, "warning")) {
[11:41:55.549]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:55.549]                         if (muffled) 
[11:41:55.549]                           invokeRestart("muffleWarning")
[11:41:55.549]                       }
[11:41:55.549]                       else if (inherits(cond, "condition")) {
[11:41:55.549]                         if (!is.null(pattern)) {
[11:41:55.549]                           computeRestarts <- base::computeRestarts
[11:41:55.549]                           grepl <- base::grepl
[11:41:55.549]                           restarts <- computeRestarts(cond)
[11:41:55.549]                           for (restart in restarts) {
[11:41:55.549]                             name <- restart$name
[11:41:55.549]                             if (is.null(name)) 
[11:41:55.549]                               next
[11:41:55.549]                             if (!grepl(pattern, name)) 
[11:41:55.549]                               next
[11:41:55.549]                             invokeRestart(restart)
[11:41:55.549]                             muffled <- TRUE
[11:41:55.549]                             break
[11:41:55.549]                           }
[11:41:55.549]                         }
[11:41:55.549]                       }
[11:41:55.549]                       invisible(muffled)
[11:41:55.549]                     }
[11:41:55.549]                     muffleCondition(cond, pattern = "^muffle")
[11:41:55.549]                   }
[11:41:55.549]                 }
[11:41:55.549]                 else {
[11:41:55.549]                   if (TRUE) {
[11:41:55.549]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:55.549]                     {
[11:41:55.549]                       inherits <- base::inherits
[11:41:55.549]                       invokeRestart <- base::invokeRestart
[11:41:55.549]                       is.null <- base::is.null
[11:41:55.549]                       muffled <- FALSE
[11:41:55.549]                       if (inherits(cond, "message")) {
[11:41:55.549]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:55.549]                         if (muffled) 
[11:41:55.549]                           invokeRestart("muffleMessage")
[11:41:55.549]                       }
[11:41:55.549]                       else if (inherits(cond, "warning")) {
[11:41:55.549]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:55.549]                         if (muffled) 
[11:41:55.549]                           invokeRestart("muffleWarning")
[11:41:55.549]                       }
[11:41:55.549]                       else if (inherits(cond, "condition")) {
[11:41:55.549]                         if (!is.null(pattern)) {
[11:41:55.549]                           computeRestarts <- base::computeRestarts
[11:41:55.549]                           grepl <- base::grepl
[11:41:55.549]                           restarts <- computeRestarts(cond)
[11:41:55.549]                           for (restart in restarts) {
[11:41:55.549]                             name <- restart$name
[11:41:55.549]                             if (is.null(name)) 
[11:41:55.549]                               next
[11:41:55.549]                             if (!grepl(pattern, name)) 
[11:41:55.549]                               next
[11:41:55.549]                             invokeRestart(restart)
[11:41:55.549]                             muffled <- TRUE
[11:41:55.549]                             break
[11:41:55.549]                           }
[11:41:55.549]                         }
[11:41:55.549]                       }
[11:41:55.549]                       invisible(muffled)
[11:41:55.549]                     }
[11:41:55.549]                     muffleCondition(cond, pattern = "^muffle")
[11:41:55.549]                   }
[11:41:55.549]                 }
[11:41:55.549]             }
[11:41:55.549]         }))
[11:41:55.549]     }, error = function(ex) {
[11:41:55.549]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:55.549]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:55.549]                 ...future.rng), started = ...future.startTime, 
[11:41:55.549]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:55.549]             version = "1.8"), class = "FutureResult")
[11:41:55.549]     }, finally = {
[11:41:55.549]         if (!identical(...future.workdir, getwd())) 
[11:41:55.549]             setwd(...future.workdir)
[11:41:55.549]         {
[11:41:55.549]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:55.549]                 ...future.oldOptions$nwarnings <- NULL
[11:41:55.549]             }
[11:41:55.549]             base::options(...future.oldOptions)
[11:41:55.549]             if (.Platform$OS.type == "windows") {
[11:41:55.549]                 old_names <- names(...future.oldEnvVars)
[11:41:55.549]                 envs <- base::Sys.getenv()
[11:41:55.549]                 names <- names(envs)
[11:41:55.549]                 common <- intersect(names, old_names)
[11:41:55.549]                 added <- setdiff(names, old_names)
[11:41:55.549]                 removed <- setdiff(old_names, names)
[11:41:55.549]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:55.549]                   envs[common]]
[11:41:55.549]                 NAMES <- toupper(changed)
[11:41:55.549]                 args <- list()
[11:41:55.549]                 for (kk in seq_along(NAMES)) {
[11:41:55.549]                   name <- changed[[kk]]
[11:41:55.549]                   NAME <- NAMES[[kk]]
[11:41:55.549]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:55.549]                     next
[11:41:55.549]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:55.549]                 }
[11:41:55.549]                 NAMES <- toupper(added)
[11:41:55.549]                 for (kk in seq_along(NAMES)) {
[11:41:55.549]                   name <- added[[kk]]
[11:41:55.549]                   NAME <- NAMES[[kk]]
[11:41:55.549]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:55.549]                     next
[11:41:55.549]                   args[[name]] <- ""
[11:41:55.549]                 }
[11:41:55.549]                 NAMES <- toupper(removed)
[11:41:55.549]                 for (kk in seq_along(NAMES)) {
[11:41:55.549]                   name <- removed[[kk]]
[11:41:55.549]                   NAME <- NAMES[[kk]]
[11:41:55.549]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:55.549]                     next
[11:41:55.549]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:55.549]                 }
[11:41:55.549]                 if (length(args) > 0) 
[11:41:55.549]                   base::do.call(base::Sys.setenv, args = args)
[11:41:55.549]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:55.549]             }
[11:41:55.549]             else {
[11:41:55.549]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:55.549]             }
[11:41:55.549]             {
[11:41:55.549]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:55.549]                   0L) {
[11:41:55.549]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:55.549]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:55.549]                   base::options(opts)
[11:41:55.549]                 }
[11:41:55.549]                 {
[11:41:55.549]                   {
[11:41:55.549]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:55.549]                     NULL
[11:41:55.549]                   }
[11:41:55.549]                   options(future.plan = NULL)
[11:41:55.549]                   if (is.na(NA_character_)) 
[11:41:55.549]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:55.549]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:55.549]                   future::plan(list(function (..., workers = 2, 
[11:41:55.549]                     envir = parent.frame()) 
[11:41:55.549]                   strategy(..., workers = workers, envir = envir)), 
[11:41:55.549]                     .cleanup = FALSE, .init = FALSE)
[11:41:55.549]                 }
[11:41:55.549]             }
[11:41:55.549]         }
[11:41:55.549]     })
[11:41:55.549]     if (TRUE) {
[11:41:55.549]         base::sink(type = "output", split = FALSE)
[11:41:55.549]         if (TRUE) {
[11:41:55.549]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:55.549]         }
[11:41:55.549]         else {
[11:41:55.549]             ...future.result["stdout"] <- base::list(NULL)
[11:41:55.549]         }
[11:41:55.549]         base::close(...future.stdout)
[11:41:55.549]         ...future.stdout <- NULL
[11:41:55.549]     }
[11:41:55.549]     ...future.result$conditions <- ...future.conditions
[11:41:55.549]     ...future.result$finished <- base::Sys.time()
[11:41:55.549]     ...future.result
[11:41:55.549] }
[11:41:55.551] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:55.562] receiveMessageFromWorker() for ClusterFuture ...
[11:41:55.562] - Validating connection of MultisessionFuture
[11:41:55.563] - received message: FutureResult
[11:41:55.563] - Received FutureResult
[11:41:55.564] - Erased future from FutureRegistry
[11:41:55.564] result() for ClusterFuture ...
[11:41:55.564] - result already collected: FutureResult
[11:41:55.564] result() for ClusterFuture ... done
[11:41:55.564] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:55.564] result() for ClusterFuture ...
[11:41:55.564] - result already collected: FutureResult
[11:41:55.565] result() for ClusterFuture ... done
[11:41:55.565] result() for ClusterFuture ...
[11:41:55.565] - result already collected: FutureResult
[11:41:55.565] result() for ClusterFuture ... done
[11:41:55.566] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:55.566] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:55.610] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:55.617] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:55.662] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:55.663] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:55.710] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:55.711] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:55.712] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:55.713] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:55.714] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:55.714] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:55.716] MultisessionFuture started
[11:41:55.716] - Launch lazy future ... done
[11:41:55.716] run() for ‘MultisessionFuture’ ... done
[11:41:55.717] Created future:
[11:41:55.717] MultisessionFuture:
[11:41:55.717] Label: ‘future_mapply-55’
[11:41:55.717] Expression:
[11:41:55.717] {
[11:41:55.717]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:55.717]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:55.717]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:55.717]         on.exit(options(oopts), add = TRUE)
[11:41:55.717]     }
[11:41:55.717]     {
[11:41:55.717]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:55.717]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:55.717]                 inherits = FALSE)
[11:41:55.717]             ...future.FUN(...)
[11:41:55.717]         }
[11:41:55.717]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:55.717]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:55.717]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:55.717]         do.call(mapply, args = args)
[11:41:55.717]     }
[11:41:55.717] }
[11:41:55.717] Lazy evaluation: FALSE
[11:41:55.717] Asynchronous evaluation: TRUE
[11:41:55.717] Local evaluation: TRUE
[11:41:55.717] Environment: 0x560ef58e1768
[11:41:55.717] Capture standard output: TRUE
[11:41:55.717] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:55.717] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:55.717] Packages: 1 packages (‘mlr3’)
[11:41:55.717] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:55.717] Resolved: FALSE
[11:41:55.717] Value: <not collected>
[11:41:55.717] Conditions captured: <none>
[11:41:55.717] Early signaling: FALSE
[11:41:55.717] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:55.717] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:55.735] Chunk #55 of 90 ... DONE
[11:41:55.735] Chunk #56 of 90 ...
[11:41:55.735]  - seeds: [1] <seeds>
[11:41:55.735] getGlobalsAndPackages() ...
[11:41:55.735] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:55.736] Resolving globals: FALSE
[11:41:55.736] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:55.736] - packages: [1] ‘mlr3’
[11:41:55.737] getGlobalsAndPackages() ... DONE
[11:41:55.737] run() for ‘Future’ ...
[11:41:55.737] - state: ‘created’
[11:41:55.737] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:55.748] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:55.748] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:55.748]   - Field: ‘node’
[11:41:55.748]   - Field: ‘label’
[11:41:55.748]   - Field: ‘local’
[11:41:55.748]   - Field: ‘owner’
[11:41:55.748]   - Field: ‘envir’
[11:41:55.748]   - Field: ‘workers’
[11:41:55.749]   - Field: ‘packages’
[11:41:55.749]   - Field: ‘gc’
[11:41:55.749]   - Field: ‘conditions’
[11:41:55.749]   - Field: ‘persistent’
[11:41:55.749]   - Field: ‘expr’
[11:41:55.749]   - Field: ‘uuid’
[11:41:55.749]   - Field: ‘seed’
[11:41:55.749]   - Field: ‘version’
[11:41:55.749]   - Field: ‘result’
[11:41:55.749]   - Field: ‘asynchronous’
[11:41:55.749]   - Field: ‘calls’
[11:41:55.749]   - Field: ‘globals’
[11:41:55.749]   - Field: ‘stdout’
[11:41:55.749]   - Field: ‘earlySignal’
[11:41:55.749]   - Field: ‘lazy’
[11:41:55.749]   - Field: ‘state’
[11:41:55.749] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:55.749] - Launch lazy future ...
[11:41:55.750] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:55.750] Packages needed by future strategies (n = 0): <none>
[11:41:55.750] {
[11:41:55.750]     {
[11:41:55.750]         {
[11:41:55.750]             ...future.startTime <- base::Sys.time()
[11:41:55.750]             {
[11:41:55.750]                 {
[11:41:55.750]                   {
[11:41:55.750]                     {
[11:41:55.750]                       {
[11:41:55.750]                         base::local({
[11:41:55.750]                           has_future <- base::requireNamespace("future", 
[11:41:55.750]                             quietly = TRUE)
[11:41:55.750]                           if (has_future) {
[11:41:55.750]                             ns <- base::getNamespace("future")
[11:41:55.750]                             version <- ns[[".package"]][["version"]]
[11:41:55.750]                             if (is.null(version)) 
[11:41:55.750]                               version <- utils::packageVersion("future")
[11:41:55.750]                           }
[11:41:55.750]                           else {
[11:41:55.750]                             version <- NULL
[11:41:55.750]                           }
[11:41:55.750]                           if (!has_future || version < "1.8.0") {
[11:41:55.750]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:55.750]                               "", base::R.version$version.string), 
[11:41:55.750]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:55.750]                                 base::R.version$platform, 8 * 
[11:41:55.750]                                   base::.Machine$sizeof.pointer), 
[11:41:55.750]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:55.750]                                 "release", "version")], collapse = " "), 
[11:41:55.750]                               hostname = base::Sys.info()[["nodename"]])
[11:41:55.750]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:55.750]                               info)
[11:41:55.750]                             info <- base::paste(info, collapse = "; ")
[11:41:55.750]                             if (!has_future) {
[11:41:55.750]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:55.750]                                 info)
[11:41:55.750]                             }
[11:41:55.750]                             else {
[11:41:55.750]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:55.750]                                 info, version)
[11:41:55.750]                             }
[11:41:55.750]                             base::stop(msg)
[11:41:55.750]                           }
[11:41:55.750]                         })
[11:41:55.750]                       }
[11:41:55.750]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:55.750]                       base::options(mc.cores = 1L)
[11:41:55.750]                     }
[11:41:55.750]                     base::local({
[11:41:55.750]                       for (pkg in "mlr3") {
[11:41:55.750]                         base::loadNamespace(pkg)
[11:41:55.750]                         base::library(pkg, character.only = TRUE)
[11:41:55.750]                       }
[11:41:55.750]                     })
[11:41:55.750]                   }
[11:41:55.750]                   options(future.plan = NULL)
[11:41:55.750]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:55.750]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:55.750]                 }
[11:41:55.750]                 ...future.workdir <- getwd()
[11:41:55.750]             }
[11:41:55.750]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:55.750]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:55.750]         }
[11:41:55.750]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:55.750]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:55.750]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:55.750]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:55.750]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:55.750]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:55.750]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:55.750]             base::names(...future.oldOptions))
[11:41:55.750]     }
[11:41:55.750]     if (FALSE) {
[11:41:55.750]     }
[11:41:55.750]     else {
[11:41:55.750]         if (TRUE) {
[11:41:55.750]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:55.750]                 open = "w")
[11:41:55.750]         }
[11:41:55.750]         else {
[11:41:55.750]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:55.750]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:55.750]         }
[11:41:55.750]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:55.750]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:55.750]             base::sink(type = "output", split = FALSE)
[11:41:55.750]             base::close(...future.stdout)
[11:41:55.750]         }, add = TRUE)
[11:41:55.750]     }
[11:41:55.750]     ...future.frame <- base::sys.nframe()
[11:41:55.750]     ...future.conditions <- base::list()
[11:41:55.750]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:55.750]     if (FALSE) {
[11:41:55.750]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:55.750]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:55.750]     }
[11:41:55.750]     ...future.result <- base::tryCatch({
[11:41:55.750]         base::withCallingHandlers({
[11:41:55.750]             ...future.value <- base::withVisible(base::local({
[11:41:55.750]                 ...future.makeSendCondition <- local({
[11:41:55.750]                   sendCondition <- NULL
[11:41:55.750]                   function(frame = 1L) {
[11:41:55.750]                     if (is.function(sendCondition)) 
[11:41:55.750]                       return(sendCondition)
[11:41:55.750]                     ns <- getNamespace("parallel")
[11:41:55.750]                     if (exists("sendData", mode = "function", 
[11:41:55.750]                       envir = ns)) {
[11:41:55.750]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:55.750]                         envir = ns)
[11:41:55.750]                       envir <- sys.frame(frame)
[11:41:55.750]                       master <- NULL
[11:41:55.750]                       while (!identical(envir, .GlobalEnv) && 
[11:41:55.750]                         !identical(envir, emptyenv())) {
[11:41:55.750]                         if (exists("master", mode = "list", envir = envir, 
[11:41:55.750]                           inherits = FALSE)) {
[11:41:55.750]                           master <- get("master", mode = "list", 
[11:41:55.750]                             envir = envir, inherits = FALSE)
[11:41:55.750]                           if (inherits(master, c("SOCKnode", 
[11:41:55.750]                             "SOCK0node"))) {
[11:41:55.750]                             sendCondition <<- function(cond) {
[11:41:55.750]                               data <- list(type = "VALUE", value = cond, 
[11:41:55.750]                                 success = TRUE)
[11:41:55.750]                               parallel_sendData(master, data)
[11:41:55.750]                             }
[11:41:55.750]                             return(sendCondition)
[11:41:55.750]                           }
[11:41:55.750]                         }
[11:41:55.750]                         frame <- frame + 1L
[11:41:55.750]                         envir <- sys.frame(frame)
[11:41:55.750]                       }
[11:41:55.750]                     }
[11:41:55.750]                     sendCondition <<- function(cond) NULL
[11:41:55.750]                   }
[11:41:55.750]                 })
[11:41:55.750]                 withCallingHandlers({
[11:41:55.750]                   {
[11:41:55.750]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:55.750]                     if (!identical(...future.globals.maxSize.org, 
[11:41:55.750]                       ...future.globals.maxSize)) {
[11:41:55.750]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:55.750]                       on.exit(options(oopts), add = TRUE)
[11:41:55.750]                     }
[11:41:55.750]                     {
[11:41:55.750]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:55.750]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:55.750]                           envir = globalenv(), inherits = FALSE)
[11:41:55.750]                         ...future.FUN(...)
[11:41:55.750]                       }
[11:41:55.750]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:55.750]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:55.750]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:55.750]                         USE.NAMES = FALSE)
[11:41:55.750]                       do.call(mapply, args = args)
[11:41:55.750]                     }
[11:41:55.750]                   }
[11:41:55.750]                 }, immediateCondition = function(cond) {
[11:41:55.750]                   sendCondition <- ...future.makeSendCondition()
[11:41:55.750]                   sendCondition(cond)
[11:41:55.750]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:55.750]                   {
[11:41:55.750]                     inherits <- base::inherits
[11:41:55.750]                     invokeRestart <- base::invokeRestart
[11:41:55.750]                     is.null <- base::is.null
[11:41:55.750]                     muffled <- FALSE
[11:41:55.750]                     if (inherits(cond, "message")) {
[11:41:55.750]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:55.750]                       if (muffled) 
[11:41:55.750]                         invokeRestart("muffleMessage")
[11:41:55.750]                     }
[11:41:55.750]                     else if (inherits(cond, "warning")) {
[11:41:55.750]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:55.750]                       if (muffled) 
[11:41:55.750]                         invokeRestart("muffleWarning")
[11:41:55.750]                     }
[11:41:55.750]                     else if (inherits(cond, "condition")) {
[11:41:55.750]                       if (!is.null(pattern)) {
[11:41:55.750]                         computeRestarts <- base::computeRestarts
[11:41:55.750]                         grepl <- base::grepl
[11:41:55.750]                         restarts <- computeRestarts(cond)
[11:41:55.750]                         for (restart in restarts) {
[11:41:55.750]                           name <- restart$name
[11:41:55.750]                           if (is.null(name)) 
[11:41:55.750]                             next
[11:41:55.750]                           if (!grepl(pattern, name)) 
[11:41:55.750]                             next
[11:41:55.750]                           invokeRestart(restart)
[11:41:55.750]                           muffled <- TRUE
[11:41:55.750]                           break
[11:41:55.750]                         }
[11:41:55.750]                       }
[11:41:55.750]                     }
[11:41:55.750]                     invisible(muffled)
[11:41:55.750]                   }
[11:41:55.750]                   muffleCondition(cond)
[11:41:55.750]                 })
[11:41:55.750]             }))
[11:41:55.750]             future::FutureResult(value = ...future.value$value, 
[11:41:55.750]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:55.750]                   ...future.rng), globalenv = if (FALSE) 
[11:41:55.750]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:55.750]                     ...future.globalenv.names))
[11:41:55.750]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:55.750]         }, condition = base::local({
[11:41:55.750]             c <- base::c
[11:41:55.750]             inherits <- base::inherits
[11:41:55.750]             invokeRestart <- base::invokeRestart
[11:41:55.750]             length <- base::length
[11:41:55.750]             list <- base::list
[11:41:55.750]             seq.int <- base::seq.int
[11:41:55.750]             signalCondition <- base::signalCondition
[11:41:55.750]             sys.calls <- base::sys.calls
[11:41:55.750]             `[[` <- base::`[[`
[11:41:55.750]             `+` <- base::`+`
[11:41:55.750]             `<<-` <- base::`<<-`
[11:41:55.750]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:55.750]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:55.750]                   3L)]
[11:41:55.750]             }
[11:41:55.750]             function(cond) {
[11:41:55.750]                 is_error <- inherits(cond, "error")
[11:41:55.750]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:55.750]                   NULL)
[11:41:55.750]                 if (is_error) {
[11:41:55.750]                   sessionInformation <- function() {
[11:41:55.750]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:55.750]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:55.750]                       search = base::search(), system = base::Sys.info())
[11:41:55.750]                   }
[11:41:55.750]                   ...future.conditions[[length(...future.conditions) + 
[11:41:55.750]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:55.750]                     cond$call), session = sessionInformation(), 
[11:41:55.750]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:55.750]                   signalCondition(cond)
[11:41:55.750]                 }
[11:41:55.750]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:55.750]                 "immediateCondition"))) {
[11:41:55.750]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:55.750]                   ...future.conditions[[length(...future.conditions) + 
[11:41:55.750]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:55.750]                   if (TRUE && !signal) {
[11:41:55.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:55.750]                     {
[11:41:55.750]                       inherits <- base::inherits
[11:41:55.750]                       invokeRestart <- base::invokeRestart
[11:41:55.750]                       is.null <- base::is.null
[11:41:55.750]                       muffled <- FALSE
[11:41:55.750]                       if (inherits(cond, "message")) {
[11:41:55.750]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:55.750]                         if (muffled) 
[11:41:55.750]                           invokeRestart("muffleMessage")
[11:41:55.750]                       }
[11:41:55.750]                       else if (inherits(cond, "warning")) {
[11:41:55.750]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:55.750]                         if (muffled) 
[11:41:55.750]                           invokeRestart("muffleWarning")
[11:41:55.750]                       }
[11:41:55.750]                       else if (inherits(cond, "condition")) {
[11:41:55.750]                         if (!is.null(pattern)) {
[11:41:55.750]                           computeRestarts <- base::computeRestarts
[11:41:55.750]                           grepl <- base::grepl
[11:41:55.750]                           restarts <- computeRestarts(cond)
[11:41:55.750]                           for (restart in restarts) {
[11:41:55.750]                             name <- restart$name
[11:41:55.750]                             if (is.null(name)) 
[11:41:55.750]                               next
[11:41:55.750]                             if (!grepl(pattern, name)) 
[11:41:55.750]                               next
[11:41:55.750]                             invokeRestart(restart)
[11:41:55.750]                             muffled <- TRUE
[11:41:55.750]                             break
[11:41:55.750]                           }
[11:41:55.750]                         }
[11:41:55.750]                       }
[11:41:55.750]                       invisible(muffled)
[11:41:55.750]                     }
[11:41:55.750]                     muffleCondition(cond, pattern = "^muffle")
[11:41:55.750]                   }
[11:41:55.750]                 }
[11:41:55.750]                 else {
[11:41:55.750]                   if (TRUE) {
[11:41:55.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:55.750]                     {
[11:41:55.750]                       inherits <- base::inherits
[11:41:55.750]                       invokeRestart <- base::invokeRestart
[11:41:55.750]                       is.null <- base::is.null
[11:41:55.750]                       muffled <- FALSE
[11:41:55.750]                       if (inherits(cond, "message")) {
[11:41:55.750]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:55.750]                         if (muffled) 
[11:41:55.750]                           invokeRestart("muffleMessage")
[11:41:55.750]                       }
[11:41:55.750]                       else if (inherits(cond, "warning")) {
[11:41:55.750]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:55.750]                         if (muffled) 
[11:41:55.750]                           invokeRestart("muffleWarning")
[11:41:55.750]                       }
[11:41:55.750]                       else if (inherits(cond, "condition")) {
[11:41:55.750]                         if (!is.null(pattern)) {
[11:41:55.750]                           computeRestarts <- base::computeRestarts
[11:41:55.750]                           grepl <- base::grepl
[11:41:55.750]                           restarts <- computeRestarts(cond)
[11:41:55.750]                           for (restart in restarts) {
[11:41:55.750]                             name <- restart$name
[11:41:55.750]                             if (is.null(name)) 
[11:41:55.750]                               next
[11:41:55.750]                             if (!grepl(pattern, name)) 
[11:41:55.750]                               next
[11:41:55.750]                             invokeRestart(restart)
[11:41:55.750]                             muffled <- TRUE
[11:41:55.750]                             break
[11:41:55.750]                           }
[11:41:55.750]                         }
[11:41:55.750]                       }
[11:41:55.750]                       invisible(muffled)
[11:41:55.750]                     }
[11:41:55.750]                     muffleCondition(cond, pattern = "^muffle")
[11:41:55.750]                   }
[11:41:55.750]                 }
[11:41:55.750]             }
[11:41:55.750]         }))
[11:41:55.750]     }, error = function(ex) {
[11:41:55.750]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:55.750]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:55.750]                 ...future.rng), started = ...future.startTime, 
[11:41:55.750]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:55.750]             version = "1.8"), class = "FutureResult")
[11:41:55.750]     }, finally = {
[11:41:55.750]         if (!identical(...future.workdir, getwd())) 
[11:41:55.750]             setwd(...future.workdir)
[11:41:55.750]         {
[11:41:55.750]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:55.750]                 ...future.oldOptions$nwarnings <- NULL
[11:41:55.750]             }
[11:41:55.750]             base::options(...future.oldOptions)
[11:41:55.750]             if (.Platform$OS.type == "windows") {
[11:41:55.750]                 old_names <- names(...future.oldEnvVars)
[11:41:55.750]                 envs <- base::Sys.getenv()
[11:41:55.750]                 names <- names(envs)
[11:41:55.750]                 common <- intersect(names, old_names)
[11:41:55.750]                 added <- setdiff(names, old_names)
[11:41:55.750]                 removed <- setdiff(old_names, names)
[11:41:55.750]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:55.750]                   envs[common]]
[11:41:55.750]                 NAMES <- toupper(changed)
[11:41:55.750]                 args <- list()
[11:41:55.750]                 for (kk in seq_along(NAMES)) {
[11:41:55.750]                   name <- changed[[kk]]
[11:41:55.750]                   NAME <- NAMES[[kk]]
[11:41:55.750]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:55.750]                     next
[11:41:55.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:55.750]                 }
[11:41:55.750]                 NAMES <- toupper(added)
[11:41:55.750]                 for (kk in seq_along(NAMES)) {
[11:41:55.750]                   name <- added[[kk]]
[11:41:55.750]                   NAME <- NAMES[[kk]]
[11:41:55.750]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:55.750]                     next
[11:41:55.750]                   args[[name]] <- ""
[11:41:55.750]                 }
[11:41:55.750]                 NAMES <- toupper(removed)
[11:41:55.750]                 for (kk in seq_along(NAMES)) {
[11:41:55.750]                   name <- removed[[kk]]
[11:41:55.750]                   NAME <- NAMES[[kk]]
[11:41:55.750]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:55.750]                     next
[11:41:55.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:55.750]                 }
[11:41:55.750]                 if (length(args) > 0) 
[11:41:55.750]                   base::do.call(base::Sys.setenv, args = args)
[11:41:55.750]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:55.750]             }
[11:41:55.750]             else {
[11:41:55.750]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:55.750]             }
[11:41:55.750]             {
[11:41:55.750]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:55.750]                   0L) {
[11:41:55.750]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:55.750]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:55.750]                   base::options(opts)
[11:41:55.750]                 }
[11:41:55.750]                 {
[11:41:55.750]                   {
[11:41:55.750]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:55.750]                     NULL
[11:41:55.750]                   }
[11:41:55.750]                   options(future.plan = NULL)
[11:41:55.750]                   if (is.na(NA_character_)) 
[11:41:55.750]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:55.750]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:55.750]                   future::plan(list(function (..., workers = 2, 
[11:41:55.750]                     envir = parent.frame()) 
[11:41:55.750]                   strategy(..., workers = workers, envir = envir)), 
[11:41:55.750]                     .cleanup = FALSE, .init = FALSE)
[11:41:55.750]                 }
[11:41:55.750]             }
[11:41:55.750]         }
[11:41:55.750]     })
[11:41:55.750]     if (TRUE) {
[11:41:55.750]         base::sink(type = "output", split = FALSE)
[11:41:55.750]         if (TRUE) {
[11:41:55.750]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:55.750]         }
[11:41:55.750]         else {
[11:41:55.750]             ...future.result["stdout"] <- base::list(NULL)
[11:41:55.750]         }
[11:41:55.750]         base::close(...future.stdout)
[11:41:55.750]         ...future.stdout <- NULL
[11:41:55.750]     }
[11:41:55.750]     ...future.result$conditions <- ...future.conditions
[11:41:55.750]     ...future.result$finished <- base::Sys.time()
[11:41:55.750]     ...future.result
[11:41:55.750] }
[11:41:55.752] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:55.763] receiveMessageFromWorker() for ClusterFuture ...
[11:41:55.763] - Validating connection of MultisessionFuture
[11:41:55.763] - received message: FutureResult
[11:41:55.763] - Received FutureResult
[11:41:55.764] - Erased future from FutureRegistry
[11:41:55.764] result() for ClusterFuture ...
[11:41:55.764] - result already collected: FutureResult
[11:41:55.765] result() for ClusterFuture ... done
[11:41:55.765] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:55.765] result() for ClusterFuture ...
[11:41:55.765] - result already collected: FutureResult
[11:41:55.766] result() for ClusterFuture ... done
[11:41:55.766] result() for ClusterFuture ...
[11:41:55.766] - result already collected: FutureResult
[11:41:55.766] result() for ClusterFuture ... done
[11:41:55.768] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:55.768] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:55.814] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:55.825] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:55.870] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:55.871] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:55.918] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:55.919] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:55.921] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:55.921] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:55.941] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:55.941] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:55.941] MultisessionFuture started
[11:41:55.941] - Launch lazy future ... done
[11:41:55.941] run() for ‘MultisessionFuture’ ... done
[11:41:55.942] Created future:
[11:41:55.942] MultisessionFuture:
[11:41:55.942] Label: ‘future_mapply-56’
[11:41:55.942] Expression:
[11:41:55.942] {
[11:41:55.942]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:55.942]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:55.942]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:55.942]         on.exit(options(oopts), add = TRUE)
[11:41:55.942]     }
[11:41:55.942]     {
[11:41:55.942]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:55.942]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:55.942]                 inherits = FALSE)
[11:41:55.942]             ...future.FUN(...)
[11:41:55.942]         }
[11:41:55.942]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:55.942]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:55.942]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:55.942]         do.call(mapply, args = args)
[11:41:55.942]     }
[11:41:55.942] }
[11:41:55.942] Lazy evaluation: FALSE
[11:41:55.942] Asynchronous evaluation: TRUE
[11:41:55.942] Local evaluation: TRUE
[11:41:55.942] Environment: 0x560ef58e1768
[11:41:55.942] Capture standard output: TRUE
[11:41:55.942] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:55.942] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:55.942] Packages: 1 packages (‘mlr3’)
[11:41:55.942] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:55.942] Resolved: FALSE
[11:41:55.942] Value: <not collected>
[11:41:55.942] Conditions captured: <none>
[11:41:55.942] Early signaling: FALSE
[11:41:55.942] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:55.942] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:55.956] Chunk #56 of 90 ... DONE
[11:41:55.956] Chunk #57 of 90 ...
[11:41:55.957]  - seeds: [1] <seeds>
[11:41:55.957] getGlobalsAndPackages() ...
[11:41:55.957] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:55.957] Resolving globals: FALSE
[11:41:55.957] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:55.957] - packages: [1] ‘mlr3’
[11:41:55.957] getGlobalsAndPackages() ... DONE
[11:41:55.958] run() for ‘Future’ ...
[11:41:55.958] - state: ‘created’
[11:41:55.958] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:55.966] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:55.966] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:55.966]   - Field: ‘node’
[11:41:55.966]   - Field: ‘label’
[11:41:55.967]   - Field: ‘local’
[11:41:55.967]   - Field: ‘owner’
[11:41:55.967]   - Field: ‘envir’
[11:41:55.967]   - Field: ‘workers’
[11:41:55.967]   - Field: ‘packages’
[11:41:55.967]   - Field: ‘gc’
[11:41:55.967]   - Field: ‘conditions’
[11:41:55.967]   - Field: ‘persistent’
[11:41:55.967]   - Field: ‘expr’
[11:41:55.967]   - Field: ‘uuid’
[11:41:55.967]   - Field: ‘seed’
[11:41:55.967]   - Field: ‘version’
[11:41:55.967]   - Field: ‘result’
[11:41:55.967]   - Field: ‘asynchronous’
[11:41:55.967]   - Field: ‘calls’
[11:41:55.967]   - Field: ‘globals’
[11:41:55.967]   - Field: ‘stdout’
[11:41:55.967]   - Field: ‘earlySignal’
[11:41:55.967]   - Field: ‘lazy’
[11:41:55.967]   - Field: ‘state’
[11:41:55.968] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:55.968] - Launch lazy future ...
[11:41:55.968] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:55.968] Packages needed by future strategies (n = 0): <none>
[11:41:55.968] {
[11:41:55.968]     {
[11:41:55.968]         {
[11:41:55.968]             ...future.startTime <- base::Sys.time()
[11:41:55.968]             {
[11:41:55.968]                 {
[11:41:55.968]                   {
[11:41:55.968]                     {
[11:41:55.968]                       {
[11:41:55.968]                         base::local({
[11:41:55.968]                           has_future <- base::requireNamespace("future", 
[11:41:55.968]                             quietly = TRUE)
[11:41:55.968]                           if (has_future) {
[11:41:55.968]                             ns <- base::getNamespace("future")
[11:41:55.968]                             version <- ns[[".package"]][["version"]]
[11:41:55.968]                             if (is.null(version)) 
[11:41:55.968]                               version <- utils::packageVersion("future")
[11:41:55.968]                           }
[11:41:55.968]                           else {
[11:41:55.968]                             version <- NULL
[11:41:55.968]                           }
[11:41:55.968]                           if (!has_future || version < "1.8.0") {
[11:41:55.968]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:55.968]                               "", base::R.version$version.string), 
[11:41:55.968]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:55.968]                                 base::R.version$platform, 8 * 
[11:41:55.968]                                   base::.Machine$sizeof.pointer), 
[11:41:55.968]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:55.968]                                 "release", "version")], collapse = " "), 
[11:41:55.968]                               hostname = base::Sys.info()[["nodename"]])
[11:41:55.968]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:55.968]                               info)
[11:41:55.968]                             info <- base::paste(info, collapse = "; ")
[11:41:55.968]                             if (!has_future) {
[11:41:55.968]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:55.968]                                 info)
[11:41:55.968]                             }
[11:41:55.968]                             else {
[11:41:55.968]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:55.968]                                 info, version)
[11:41:55.968]                             }
[11:41:55.968]                             base::stop(msg)
[11:41:55.968]                           }
[11:41:55.968]                         })
[11:41:55.968]                       }
[11:41:55.968]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:55.968]                       base::options(mc.cores = 1L)
[11:41:55.968]                     }
[11:41:55.968]                     base::local({
[11:41:55.968]                       for (pkg in "mlr3") {
[11:41:55.968]                         base::loadNamespace(pkg)
[11:41:55.968]                         base::library(pkg, character.only = TRUE)
[11:41:55.968]                       }
[11:41:55.968]                     })
[11:41:55.968]                   }
[11:41:55.968]                   options(future.plan = NULL)
[11:41:55.968]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:55.968]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:55.968]                 }
[11:41:55.968]                 ...future.workdir <- getwd()
[11:41:55.968]             }
[11:41:55.968]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:55.968]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:55.968]         }
[11:41:55.968]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:55.968]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:55.968]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:55.968]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:55.968]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:55.968]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:55.968]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:55.968]             base::names(...future.oldOptions))
[11:41:55.968]     }
[11:41:55.968]     if (FALSE) {
[11:41:55.968]     }
[11:41:55.968]     else {
[11:41:55.968]         if (TRUE) {
[11:41:55.968]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:55.968]                 open = "w")
[11:41:55.968]         }
[11:41:55.968]         else {
[11:41:55.968]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:55.968]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:55.968]         }
[11:41:55.968]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:55.968]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:55.968]             base::sink(type = "output", split = FALSE)
[11:41:55.968]             base::close(...future.stdout)
[11:41:55.968]         }, add = TRUE)
[11:41:55.968]     }
[11:41:55.968]     ...future.frame <- base::sys.nframe()
[11:41:55.968]     ...future.conditions <- base::list()
[11:41:55.968]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:55.968]     if (FALSE) {
[11:41:55.968]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:55.968]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:55.968]     }
[11:41:55.968]     ...future.result <- base::tryCatch({
[11:41:55.968]         base::withCallingHandlers({
[11:41:55.968]             ...future.value <- base::withVisible(base::local({
[11:41:55.968]                 ...future.makeSendCondition <- local({
[11:41:55.968]                   sendCondition <- NULL
[11:41:55.968]                   function(frame = 1L) {
[11:41:55.968]                     if (is.function(sendCondition)) 
[11:41:55.968]                       return(sendCondition)
[11:41:55.968]                     ns <- getNamespace("parallel")
[11:41:55.968]                     if (exists("sendData", mode = "function", 
[11:41:55.968]                       envir = ns)) {
[11:41:55.968]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:55.968]                         envir = ns)
[11:41:55.968]                       envir <- sys.frame(frame)
[11:41:55.968]                       master <- NULL
[11:41:55.968]                       while (!identical(envir, .GlobalEnv) && 
[11:41:55.968]                         !identical(envir, emptyenv())) {
[11:41:55.968]                         if (exists("master", mode = "list", envir = envir, 
[11:41:55.968]                           inherits = FALSE)) {
[11:41:55.968]                           master <- get("master", mode = "list", 
[11:41:55.968]                             envir = envir, inherits = FALSE)
[11:41:55.968]                           if (inherits(master, c("SOCKnode", 
[11:41:55.968]                             "SOCK0node"))) {
[11:41:55.968]                             sendCondition <<- function(cond) {
[11:41:55.968]                               data <- list(type = "VALUE", value = cond, 
[11:41:55.968]                                 success = TRUE)
[11:41:55.968]                               parallel_sendData(master, data)
[11:41:55.968]                             }
[11:41:55.968]                             return(sendCondition)
[11:41:55.968]                           }
[11:41:55.968]                         }
[11:41:55.968]                         frame <- frame + 1L
[11:41:55.968]                         envir <- sys.frame(frame)
[11:41:55.968]                       }
[11:41:55.968]                     }
[11:41:55.968]                     sendCondition <<- function(cond) NULL
[11:41:55.968]                   }
[11:41:55.968]                 })
[11:41:55.968]                 withCallingHandlers({
[11:41:55.968]                   {
[11:41:55.968]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:55.968]                     if (!identical(...future.globals.maxSize.org, 
[11:41:55.968]                       ...future.globals.maxSize)) {
[11:41:55.968]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:55.968]                       on.exit(options(oopts), add = TRUE)
[11:41:55.968]                     }
[11:41:55.968]                     {
[11:41:55.968]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:55.968]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:55.968]                           envir = globalenv(), inherits = FALSE)
[11:41:55.968]                         ...future.FUN(...)
[11:41:55.968]                       }
[11:41:55.968]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:55.968]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:55.968]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:55.968]                         USE.NAMES = FALSE)
[11:41:55.968]                       do.call(mapply, args = args)
[11:41:55.968]                     }
[11:41:55.968]                   }
[11:41:55.968]                 }, immediateCondition = function(cond) {
[11:41:55.968]                   sendCondition <- ...future.makeSendCondition()
[11:41:55.968]                   sendCondition(cond)
[11:41:55.968]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:55.968]                   {
[11:41:55.968]                     inherits <- base::inherits
[11:41:55.968]                     invokeRestart <- base::invokeRestart
[11:41:55.968]                     is.null <- base::is.null
[11:41:55.968]                     muffled <- FALSE
[11:41:55.968]                     if (inherits(cond, "message")) {
[11:41:55.968]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:55.968]                       if (muffled) 
[11:41:55.968]                         invokeRestart("muffleMessage")
[11:41:55.968]                     }
[11:41:55.968]                     else if (inherits(cond, "warning")) {
[11:41:55.968]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:55.968]                       if (muffled) 
[11:41:55.968]                         invokeRestart("muffleWarning")
[11:41:55.968]                     }
[11:41:55.968]                     else if (inherits(cond, "condition")) {
[11:41:55.968]                       if (!is.null(pattern)) {
[11:41:55.968]                         computeRestarts <- base::computeRestarts
[11:41:55.968]                         grepl <- base::grepl
[11:41:55.968]                         restarts <- computeRestarts(cond)
[11:41:55.968]                         for (restart in restarts) {
[11:41:55.968]                           name <- restart$name
[11:41:55.968]                           if (is.null(name)) 
[11:41:55.968]                             next
[11:41:55.968]                           if (!grepl(pattern, name)) 
[11:41:55.968]                             next
[11:41:55.968]                           invokeRestart(restart)
[11:41:55.968]                           muffled <- TRUE
[11:41:55.968]                           break
[11:41:55.968]                         }
[11:41:55.968]                       }
[11:41:55.968]                     }
[11:41:55.968]                     invisible(muffled)
[11:41:55.968]                   }
[11:41:55.968]                   muffleCondition(cond)
[11:41:55.968]                 })
[11:41:55.968]             }))
[11:41:55.968]             future::FutureResult(value = ...future.value$value, 
[11:41:55.968]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:55.968]                   ...future.rng), globalenv = if (FALSE) 
[11:41:55.968]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:55.968]                     ...future.globalenv.names))
[11:41:55.968]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:55.968]         }, condition = base::local({
[11:41:55.968]             c <- base::c
[11:41:55.968]             inherits <- base::inherits
[11:41:55.968]             invokeRestart <- base::invokeRestart
[11:41:55.968]             length <- base::length
[11:41:55.968]             list <- base::list
[11:41:55.968]             seq.int <- base::seq.int
[11:41:55.968]             signalCondition <- base::signalCondition
[11:41:55.968]             sys.calls <- base::sys.calls
[11:41:55.968]             `[[` <- base::`[[`
[11:41:55.968]             `+` <- base::`+`
[11:41:55.968]             `<<-` <- base::`<<-`
[11:41:55.968]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:55.968]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:55.968]                   3L)]
[11:41:55.968]             }
[11:41:55.968]             function(cond) {
[11:41:55.968]                 is_error <- inherits(cond, "error")
[11:41:55.968]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:55.968]                   NULL)
[11:41:55.968]                 if (is_error) {
[11:41:55.968]                   sessionInformation <- function() {
[11:41:55.968]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:55.968]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:55.968]                       search = base::search(), system = base::Sys.info())
[11:41:55.968]                   }
[11:41:55.968]                   ...future.conditions[[length(...future.conditions) + 
[11:41:55.968]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:55.968]                     cond$call), session = sessionInformation(), 
[11:41:55.968]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:55.968]                   signalCondition(cond)
[11:41:55.968]                 }
[11:41:55.968]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:55.968]                 "immediateCondition"))) {
[11:41:55.968]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:55.968]                   ...future.conditions[[length(...future.conditions) + 
[11:41:55.968]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:55.968]                   if (TRUE && !signal) {
[11:41:55.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:55.968]                     {
[11:41:55.968]                       inherits <- base::inherits
[11:41:55.968]                       invokeRestart <- base::invokeRestart
[11:41:55.968]                       is.null <- base::is.null
[11:41:55.968]                       muffled <- FALSE
[11:41:55.968]                       if (inherits(cond, "message")) {
[11:41:55.968]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:55.968]                         if (muffled) 
[11:41:55.968]                           invokeRestart("muffleMessage")
[11:41:55.968]                       }
[11:41:55.968]                       else if (inherits(cond, "warning")) {
[11:41:55.968]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:55.968]                         if (muffled) 
[11:41:55.968]                           invokeRestart("muffleWarning")
[11:41:55.968]                       }
[11:41:55.968]                       else if (inherits(cond, "condition")) {
[11:41:55.968]                         if (!is.null(pattern)) {
[11:41:55.968]                           computeRestarts <- base::computeRestarts
[11:41:55.968]                           grepl <- base::grepl
[11:41:55.968]                           restarts <- computeRestarts(cond)
[11:41:55.968]                           for (restart in restarts) {
[11:41:55.968]                             name <- restart$name
[11:41:55.968]                             if (is.null(name)) 
[11:41:55.968]                               next
[11:41:55.968]                             if (!grepl(pattern, name)) 
[11:41:55.968]                               next
[11:41:55.968]                             invokeRestart(restart)
[11:41:55.968]                             muffled <- TRUE
[11:41:55.968]                             break
[11:41:55.968]                           }
[11:41:55.968]                         }
[11:41:55.968]                       }
[11:41:55.968]                       invisible(muffled)
[11:41:55.968]                     }
[11:41:55.968]                     muffleCondition(cond, pattern = "^muffle")
[11:41:55.968]                   }
[11:41:55.968]                 }
[11:41:55.968]                 else {
[11:41:55.968]                   if (TRUE) {
[11:41:55.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:55.968]                     {
[11:41:55.968]                       inherits <- base::inherits
[11:41:55.968]                       invokeRestart <- base::invokeRestart
[11:41:55.968]                       is.null <- base::is.null
[11:41:55.968]                       muffled <- FALSE
[11:41:55.968]                       if (inherits(cond, "message")) {
[11:41:55.968]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:55.968]                         if (muffled) 
[11:41:55.968]                           invokeRestart("muffleMessage")
[11:41:55.968]                       }
[11:41:55.968]                       else if (inherits(cond, "warning")) {
[11:41:55.968]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:55.968]                         if (muffled) 
[11:41:55.968]                           invokeRestart("muffleWarning")
[11:41:55.968]                       }
[11:41:55.968]                       else if (inherits(cond, "condition")) {
[11:41:55.968]                         if (!is.null(pattern)) {
[11:41:55.968]                           computeRestarts <- base::computeRestarts
[11:41:55.968]                           grepl <- base::grepl
[11:41:55.968]                           restarts <- computeRestarts(cond)
[11:41:55.968]                           for (restart in restarts) {
[11:41:55.968]                             name <- restart$name
[11:41:55.968]                             if (is.null(name)) 
[11:41:55.968]                               next
[11:41:55.968]                             if (!grepl(pattern, name)) 
[11:41:55.968]                               next
[11:41:55.968]                             invokeRestart(restart)
[11:41:55.968]                             muffled <- TRUE
[11:41:55.968]                             break
[11:41:55.968]                           }
[11:41:55.968]                         }
[11:41:55.968]                       }
[11:41:55.968]                       invisible(muffled)
[11:41:55.968]                     }
[11:41:55.968]                     muffleCondition(cond, pattern = "^muffle")
[11:41:55.968]                   }
[11:41:55.968]                 }
[11:41:55.968]             }
[11:41:55.968]         }))
[11:41:55.968]     }, error = function(ex) {
[11:41:55.968]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:55.968]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:55.968]                 ...future.rng), started = ...future.startTime, 
[11:41:55.968]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:55.968]             version = "1.8"), class = "FutureResult")
[11:41:55.968]     }, finally = {
[11:41:55.968]         if (!identical(...future.workdir, getwd())) 
[11:41:55.968]             setwd(...future.workdir)
[11:41:55.968]         {
[11:41:55.968]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:55.968]                 ...future.oldOptions$nwarnings <- NULL
[11:41:55.968]             }
[11:41:55.968]             base::options(...future.oldOptions)
[11:41:55.968]             if (.Platform$OS.type == "windows") {
[11:41:55.968]                 old_names <- names(...future.oldEnvVars)
[11:41:55.968]                 envs <- base::Sys.getenv()
[11:41:55.968]                 names <- names(envs)
[11:41:55.968]                 common <- intersect(names, old_names)
[11:41:55.968]                 added <- setdiff(names, old_names)
[11:41:55.968]                 removed <- setdiff(old_names, names)
[11:41:55.968]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:55.968]                   envs[common]]
[11:41:55.968]                 NAMES <- toupper(changed)
[11:41:55.968]                 args <- list()
[11:41:55.968]                 for (kk in seq_along(NAMES)) {
[11:41:55.968]                   name <- changed[[kk]]
[11:41:55.968]                   NAME <- NAMES[[kk]]
[11:41:55.968]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:55.968]                     next
[11:41:55.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:55.968]                 }
[11:41:55.968]                 NAMES <- toupper(added)
[11:41:55.968]                 for (kk in seq_along(NAMES)) {
[11:41:55.968]                   name <- added[[kk]]
[11:41:55.968]                   NAME <- NAMES[[kk]]
[11:41:55.968]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:55.968]                     next
[11:41:55.968]                   args[[name]] <- ""
[11:41:55.968]                 }
[11:41:55.968]                 NAMES <- toupper(removed)
[11:41:55.968]                 for (kk in seq_along(NAMES)) {
[11:41:55.968]                   name <- removed[[kk]]
[11:41:55.968]                   NAME <- NAMES[[kk]]
[11:41:55.968]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:55.968]                     next
[11:41:55.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:55.968]                 }
[11:41:55.968]                 if (length(args) > 0) 
[11:41:55.968]                   base::do.call(base::Sys.setenv, args = args)
[11:41:55.968]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:55.968]             }
[11:41:55.968]             else {
[11:41:55.968]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:55.968]             }
[11:41:55.968]             {
[11:41:55.968]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:55.968]                   0L) {
[11:41:55.968]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:55.968]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:55.968]                   base::options(opts)
[11:41:55.968]                 }
[11:41:55.968]                 {
[11:41:55.968]                   {
[11:41:55.968]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:55.968]                     NULL
[11:41:55.968]                   }
[11:41:55.968]                   options(future.plan = NULL)
[11:41:55.968]                   if (is.na(NA_character_)) 
[11:41:55.968]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:55.968]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:55.968]                   future::plan(list(function (..., workers = 2, 
[11:41:55.968]                     envir = parent.frame()) 
[11:41:55.968]                   strategy(..., workers = workers, envir = envir)), 
[11:41:55.968]                     .cleanup = FALSE, .init = FALSE)
[11:41:55.968]                 }
[11:41:55.968]             }
[11:41:55.968]         }
[11:41:55.968]     })
[11:41:55.968]     if (TRUE) {
[11:41:55.968]         base::sink(type = "output", split = FALSE)
[11:41:55.968]         if (TRUE) {
[11:41:55.968]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:55.968]         }
[11:41:55.968]         else {
[11:41:55.968]             ...future.result["stdout"] <- base::list(NULL)
[11:41:55.968]         }
[11:41:55.968]         base::close(...future.stdout)
[11:41:55.968]         ...future.stdout <- NULL
[11:41:55.968]     }
[11:41:55.968]     ...future.result$conditions <- ...future.conditions
[11:41:55.968]     ...future.result$finished <- base::Sys.time()
[11:41:55.968]     ...future.result
[11:41:55.968] }
[11:41:55.970] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:55.981] receiveMessageFromWorker() for ClusterFuture ...
[11:41:55.981] - Validating connection of MultisessionFuture
[11:41:55.981] - received message: FutureResult
[11:41:55.981] - Received FutureResult
[11:41:55.981] - Erased future from FutureRegistry
[11:41:55.981] result() for ClusterFuture ...
[11:41:55.981] - result already collected: FutureResult
[11:41:55.981] result() for ClusterFuture ... done
[11:41:55.982] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:55.982] result() for ClusterFuture ...
[11:41:55.982] - result already collected: FutureResult
[11:41:55.982] result() for ClusterFuture ... done
[11:41:55.982] result() for ClusterFuture ...
[11:41:55.982] - result already collected: FutureResult
[11:41:55.982] result() for ClusterFuture ... done
[11:41:55.982] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:55.983] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:56.025] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:56.033] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:56.078] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:56.078] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:56.126] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:56.126] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:56.127] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:56.128] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:56.129] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:56.129] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:56.130] MultisessionFuture started
[11:41:56.130] - Launch lazy future ... done
[11:41:56.131] run() for ‘MultisessionFuture’ ... done
[11:41:56.131] Created future:
[11:41:56.131] MultisessionFuture:
[11:41:56.131] Label: ‘future_mapply-57’
[11:41:56.131] Expression:
[11:41:56.131] {
[11:41:56.131]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:56.131]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:56.131]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:56.131]         on.exit(options(oopts), add = TRUE)
[11:41:56.131]     }
[11:41:56.131]     {
[11:41:56.131]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:56.131]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:56.131]                 inherits = FALSE)
[11:41:56.131]             ...future.FUN(...)
[11:41:56.131]         }
[11:41:56.131]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:56.131]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:56.131]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:56.131]         do.call(mapply, args = args)
[11:41:56.131]     }
[11:41:56.131] }
[11:41:56.131] Lazy evaluation: FALSE
[11:41:56.131] Asynchronous evaluation: TRUE
[11:41:56.131] Local evaluation: TRUE
[11:41:56.131] Environment: 0x560ef58e1768
[11:41:56.131] Capture standard output: TRUE
[11:41:56.131] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:56.131] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:56.131] Packages: 1 packages (‘mlr3’)
[11:41:56.131] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:56.131] Resolved: FALSE
[11:41:56.131] Value: <not collected>
[11:41:56.131] Conditions captured: <none>
[11:41:56.131] Early signaling: FALSE
[11:41:56.131] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:56.131] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:56.147] Chunk #57 of 90 ... DONE
[11:41:56.147] Chunk #58 of 90 ...
[11:41:56.147]  - seeds: [1] <seeds>
[11:41:56.147] getGlobalsAndPackages() ...
[11:41:56.147] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:56.147] Resolving globals: FALSE
[11:41:56.148] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:56.148] - packages: [1] ‘mlr3’
[11:41:56.148] getGlobalsAndPackages() ... DONE
[11:41:56.148] run() for ‘Future’ ...
[11:41:56.148] - state: ‘created’
[11:41:56.148] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:56.158] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:56.158] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:56.158]   - Field: ‘node’
[11:41:56.158]   - Field: ‘label’
[11:41:56.158]   - Field: ‘local’
[11:41:56.158]   - Field: ‘owner’
[11:41:56.158]   - Field: ‘envir’
[11:41:56.158]   - Field: ‘workers’
[11:41:56.158]   - Field: ‘packages’
[11:41:56.158]   - Field: ‘gc’
[11:41:56.158]   - Field: ‘conditions’
[11:41:56.158]   - Field: ‘persistent’
[11:41:56.158]   - Field: ‘expr’
[11:41:56.158]   - Field: ‘uuid’
[11:41:56.158]   - Field: ‘seed’
[11:41:56.158]   - Field: ‘version’
[11:41:56.159]   - Field: ‘result’
[11:41:56.159]   - Field: ‘asynchronous’
[11:41:56.159]   - Field: ‘calls’
[11:41:56.159]   - Field: ‘globals’
[11:41:56.159]   - Field: ‘stdout’
[11:41:56.159]   - Field: ‘earlySignal’
[11:41:56.159]   - Field: ‘lazy’
[11:41:56.159]   - Field: ‘state’
[11:41:56.159] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:56.159] - Launch lazy future ...
[11:41:56.159] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:56.159] Packages needed by future strategies (n = 0): <none>
[11:41:56.160] {
[11:41:56.160]     {
[11:41:56.160]         {
[11:41:56.160]             ...future.startTime <- base::Sys.time()
[11:41:56.160]             {
[11:41:56.160]                 {
[11:41:56.160]                   {
[11:41:56.160]                     {
[11:41:56.160]                       {
[11:41:56.160]                         base::local({
[11:41:56.160]                           has_future <- base::requireNamespace("future", 
[11:41:56.160]                             quietly = TRUE)
[11:41:56.160]                           if (has_future) {
[11:41:56.160]                             ns <- base::getNamespace("future")
[11:41:56.160]                             version <- ns[[".package"]][["version"]]
[11:41:56.160]                             if (is.null(version)) 
[11:41:56.160]                               version <- utils::packageVersion("future")
[11:41:56.160]                           }
[11:41:56.160]                           else {
[11:41:56.160]                             version <- NULL
[11:41:56.160]                           }
[11:41:56.160]                           if (!has_future || version < "1.8.0") {
[11:41:56.160]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:56.160]                               "", base::R.version$version.string), 
[11:41:56.160]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:56.160]                                 base::R.version$platform, 8 * 
[11:41:56.160]                                   base::.Machine$sizeof.pointer), 
[11:41:56.160]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:56.160]                                 "release", "version")], collapse = " "), 
[11:41:56.160]                               hostname = base::Sys.info()[["nodename"]])
[11:41:56.160]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:56.160]                               info)
[11:41:56.160]                             info <- base::paste(info, collapse = "; ")
[11:41:56.160]                             if (!has_future) {
[11:41:56.160]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:56.160]                                 info)
[11:41:56.160]                             }
[11:41:56.160]                             else {
[11:41:56.160]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:56.160]                                 info, version)
[11:41:56.160]                             }
[11:41:56.160]                             base::stop(msg)
[11:41:56.160]                           }
[11:41:56.160]                         })
[11:41:56.160]                       }
[11:41:56.160]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:56.160]                       base::options(mc.cores = 1L)
[11:41:56.160]                     }
[11:41:56.160]                     base::local({
[11:41:56.160]                       for (pkg in "mlr3") {
[11:41:56.160]                         base::loadNamespace(pkg)
[11:41:56.160]                         base::library(pkg, character.only = TRUE)
[11:41:56.160]                       }
[11:41:56.160]                     })
[11:41:56.160]                   }
[11:41:56.160]                   options(future.plan = NULL)
[11:41:56.160]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:56.160]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:56.160]                 }
[11:41:56.160]                 ...future.workdir <- getwd()
[11:41:56.160]             }
[11:41:56.160]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:56.160]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:56.160]         }
[11:41:56.160]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:56.160]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:56.160]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:56.160]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:56.160]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:56.160]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:56.160]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:56.160]             base::names(...future.oldOptions))
[11:41:56.160]     }
[11:41:56.160]     if (FALSE) {
[11:41:56.160]     }
[11:41:56.160]     else {
[11:41:56.160]         if (TRUE) {
[11:41:56.160]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:56.160]                 open = "w")
[11:41:56.160]         }
[11:41:56.160]         else {
[11:41:56.160]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:56.160]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:56.160]         }
[11:41:56.160]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:56.160]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:56.160]             base::sink(type = "output", split = FALSE)
[11:41:56.160]             base::close(...future.stdout)
[11:41:56.160]         }, add = TRUE)
[11:41:56.160]     }
[11:41:56.160]     ...future.frame <- base::sys.nframe()
[11:41:56.160]     ...future.conditions <- base::list()
[11:41:56.160]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:56.160]     if (FALSE) {
[11:41:56.160]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:56.160]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:56.160]     }
[11:41:56.160]     ...future.result <- base::tryCatch({
[11:41:56.160]         base::withCallingHandlers({
[11:41:56.160]             ...future.value <- base::withVisible(base::local({
[11:41:56.160]                 ...future.makeSendCondition <- local({
[11:41:56.160]                   sendCondition <- NULL
[11:41:56.160]                   function(frame = 1L) {
[11:41:56.160]                     if (is.function(sendCondition)) 
[11:41:56.160]                       return(sendCondition)
[11:41:56.160]                     ns <- getNamespace("parallel")
[11:41:56.160]                     if (exists("sendData", mode = "function", 
[11:41:56.160]                       envir = ns)) {
[11:41:56.160]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:56.160]                         envir = ns)
[11:41:56.160]                       envir <- sys.frame(frame)
[11:41:56.160]                       master <- NULL
[11:41:56.160]                       while (!identical(envir, .GlobalEnv) && 
[11:41:56.160]                         !identical(envir, emptyenv())) {
[11:41:56.160]                         if (exists("master", mode = "list", envir = envir, 
[11:41:56.160]                           inherits = FALSE)) {
[11:41:56.160]                           master <- get("master", mode = "list", 
[11:41:56.160]                             envir = envir, inherits = FALSE)
[11:41:56.160]                           if (inherits(master, c("SOCKnode", 
[11:41:56.160]                             "SOCK0node"))) {
[11:41:56.160]                             sendCondition <<- function(cond) {
[11:41:56.160]                               data <- list(type = "VALUE", value = cond, 
[11:41:56.160]                                 success = TRUE)
[11:41:56.160]                               parallel_sendData(master, data)
[11:41:56.160]                             }
[11:41:56.160]                             return(sendCondition)
[11:41:56.160]                           }
[11:41:56.160]                         }
[11:41:56.160]                         frame <- frame + 1L
[11:41:56.160]                         envir <- sys.frame(frame)
[11:41:56.160]                       }
[11:41:56.160]                     }
[11:41:56.160]                     sendCondition <<- function(cond) NULL
[11:41:56.160]                   }
[11:41:56.160]                 })
[11:41:56.160]                 withCallingHandlers({
[11:41:56.160]                   {
[11:41:56.160]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:56.160]                     if (!identical(...future.globals.maxSize.org, 
[11:41:56.160]                       ...future.globals.maxSize)) {
[11:41:56.160]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:56.160]                       on.exit(options(oopts), add = TRUE)
[11:41:56.160]                     }
[11:41:56.160]                     {
[11:41:56.160]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:56.160]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:56.160]                           envir = globalenv(), inherits = FALSE)
[11:41:56.160]                         ...future.FUN(...)
[11:41:56.160]                       }
[11:41:56.160]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:56.160]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:56.160]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:56.160]                         USE.NAMES = FALSE)
[11:41:56.160]                       do.call(mapply, args = args)
[11:41:56.160]                     }
[11:41:56.160]                   }
[11:41:56.160]                 }, immediateCondition = function(cond) {
[11:41:56.160]                   sendCondition <- ...future.makeSendCondition()
[11:41:56.160]                   sendCondition(cond)
[11:41:56.160]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:56.160]                   {
[11:41:56.160]                     inherits <- base::inherits
[11:41:56.160]                     invokeRestart <- base::invokeRestart
[11:41:56.160]                     is.null <- base::is.null
[11:41:56.160]                     muffled <- FALSE
[11:41:56.160]                     if (inherits(cond, "message")) {
[11:41:56.160]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:56.160]                       if (muffled) 
[11:41:56.160]                         invokeRestart("muffleMessage")
[11:41:56.160]                     }
[11:41:56.160]                     else if (inherits(cond, "warning")) {
[11:41:56.160]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:56.160]                       if (muffled) 
[11:41:56.160]                         invokeRestart("muffleWarning")
[11:41:56.160]                     }
[11:41:56.160]                     else if (inherits(cond, "condition")) {
[11:41:56.160]                       if (!is.null(pattern)) {
[11:41:56.160]                         computeRestarts <- base::computeRestarts
[11:41:56.160]                         grepl <- base::grepl
[11:41:56.160]                         restarts <- computeRestarts(cond)
[11:41:56.160]                         for (restart in restarts) {
[11:41:56.160]                           name <- restart$name
[11:41:56.160]                           if (is.null(name)) 
[11:41:56.160]                             next
[11:41:56.160]                           if (!grepl(pattern, name)) 
[11:41:56.160]                             next
[11:41:56.160]                           invokeRestart(restart)
[11:41:56.160]                           muffled <- TRUE
[11:41:56.160]                           break
[11:41:56.160]                         }
[11:41:56.160]                       }
[11:41:56.160]                     }
[11:41:56.160]                     invisible(muffled)
[11:41:56.160]                   }
[11:41:56.160]                   muffleCondition(cond)
[11:41:56.160]                 })
[11:41:56.160]             }))
[11:41:56.160]             future::FutureResult(value = ...future.value$value, 
[11:41:56.160]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:56.160]                   ...future.rng), globalenv = if (FALSE) 
[11:41:56.160]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:56.160]                     ...future.globalenv.names))
[11:41:56.160]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:56.160]         }, condition = base::local({
[11:41:56.160]             c <- base::c
[11:41:56.160]             inherits <- base::inherits
[11:41:56.160]             invokeRestart <- base::invokeRestart
[11:41:56.160]             length <- base::length
[11:41:56.160]             list <- base::list
[11:41:56.160]             seq.int <- base::seq.int
[11:41:56.160]             signalCondition <- base::signalCondition
[11:41:56.160]             sys.calls <- base::sys.calls
[11:41:56.160]             `[[` <- base::`[[`
[11:41:56.160]             `+` <- base::`+`
[11:41:56.160]             `<<-` <- base::`<<-`
[11:41:56.160]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:56.160]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:56.160]                   3L)]
[11:41:56.160]             }
[11:41:56.160]             function(cond) {
[11:41:56.160]                 is_error <- inherits(cond, "error")
[11:41:56.160]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:56.160]                   NULL)
[11:41:56.160]                 if (is_error) {
[11:41:56.160]                   sessionInformation <- function() {
[11:41:56.160]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:56.160]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:56.160]                       search = base::search(), system = base::Sys.info())
[11:41:56.160]                   }
[11:41:56.160]                   ...future.conditions[[length(...future.conditions) + 
[11:41:56.160]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:56.160]                     cond$call), session = sessionInformation(), 
[11:41:56.160]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:56.160]                   signalCondition(cond)
[11:41:56.160]                 }
[11:41:56.160]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:56.160]                 "immediateCondition"))) {
[11:41:56.160]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:56.160]                   ...future.conditions[[length(...future.conditions) + 
[11:41:56.160]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:56.160]                   if (TRUE && !signal) {
[11:41:56.160]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:56.160]                     {
[11:41:56.160]                       inherits <- base::inherits
[11:41:56.160]                       invokeRestart <- base::invokeRestart
[11:41:56.160]                       is.null <- base::is.null
[11:41:56.160]                       muffled <- FALSE
[11:41:56.160]                       if (inherits(cond, "message")) {
[11:41:56.160]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:56.160]                         if (muffled) 
[11:41:56.160]                           invokeRestart("muffleMessage")
[11:41:56.160]                       }
[11:41:56.160]                       else if (inherits(cond, "warning")) {
[11:41:56.160]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:56.160]                         if (muffled) 
[11:41:56.160]                           invokeRestart("muffleWarning")
[11:41:56.160]                       }
[11:41:56.160]                       else if (inherits(cond, "condition")) {
[11:41:56.160]                         if (!is.null(pattern)) {
[11:41:56.160]                           computeRestarts <- base::computeRestarts
[11:41:56.160]                           grepl <- base::grepl
[11:41:56.160]                           restarts <- computeRestarts(cond)
[11:41:56.160]                           for (restart in restarts) {
[11:41:56.160]                             name <- restart$name
[11:41:56.160]                             if (is.null(name)) 
[11:41:56.160]                               next
[11:41:56.160]                             if (!grepl(pattern, name)) 
[11:41:56.160]                               next
[11:41:56.160]                             invokeRestart(restart)
[11:41:56.160]                             muffled <- TRUE
[11:41:56.160]                             break
[11:41:56.160]                           }
[11:41:56.160]                         }
[11:41:56.160]                       }
[11:41:56.160]                       invisible(muffled)
[11:41:56.160]                     }
[11:41:56.160]                     muffleCondition(cond, pattern = "^muffle")
[11:41:56.160]                   }
[11:41:56.160]                 }
[11:41:56.160]                 else {
[11:41:56.160]                   if (TRUE) {
[11:41:56.160]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:56.160]                     {
[11:41:56.160]                       inherits <- base::inherits
[11:41:56.160]                       invokeRestart <- base::invokeRestart
[11:41:56.160]                       is.null <- base::is.null
[11:41:56.160]                       muffled <- FALSE
[11:41:56.160]                       if (inherits(cond, "message")) {
[11:41:56.160]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:56.160]                         if (muffled) 
[11:41:56.160]                           invokeRestart("muffleMessage")
[11:41:56.160]                       }
[11:41:56.160]                       else if (inherits(cond, "warning")) {
[11:41:56.160]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:56.160]                         if (muffled) 
[11:41:56.160]                           invokeRestart("muffleWarning")
[11:41:56.160]                       }
[11:41:56.160]                       else if (inherits(cond, "condition")) {
[11:41:56.160]                         if (!is.null(pattern)) {
[11:41:56.160]                           computeRestarts <- base::computeRestarts
[11:41:56.160]                           grepl <- base::grepl
[11:41:56.160]                           restarts <- computeRestarts(cond)
[11:41:56.160]                           for (restart in restarts) {
[11:41:56.160]                             name <- restart$name
[11:41:56.160]                             if (is.null(name)) 
[11:41:56.160]                               next
[11:41:56.160]                             if (!grepl(pattern, name)) 
[11:41:56.160]                               next
[11:41:56.160]                             invokeRestart(restart)
[11:41:56.160]                             muffled <- TRUE
[11:41:56.160]                             break
[11:41:56.160]                           }
[11:41:56.160]                         }
[11:41:56.160]                       }
[11:41:56.160]                       invisible(muffled)
[11:41:56.160]                     }
[11:41:56.160]                     muffleCondition(cond, pattern = "^muffle")
[11:41:56.160]                   }
[11:41:56.160]                 }
[11:41:56.160]             }
[11:41:56.160]         }))
[11:41:56.160]     }, error = function(ex) {
[11:41:56.160]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:56.160]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:56.160]                 ...future.rng), started = ...future.startTime, 
[11:41:56.160]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:56.160]             version = "1.8"), class = "FutureResult")
[11:41:56.160]     }, finally = {
[11:41:56.160]         if (!identical(...future.workdir, getwd())) 
[11:41:56.160]             setwd(...future.workdir)
[11:41:56.160]         {
[11:41:56.160]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:56.160]                 ...future.oldOptions$nwarnings <- NULL
[11:41:56.160]             }
[11:41:56.160]             base::options(...future.oldOptions)
[11:41:56.160]             if (.Platform$OS.type == "windows") {
[11:41:56.160]                 old_names <- names(...future.oldEnvVars)
[11:41:56.160]                 envs <- base::Sys.getenv()
[11:41:56.160]                 names <- names(envs)
[11:41:56.160]                 common <- intersect(names, old_names)
[11:41:56.160]                 added <- setdiff(names, old_names)
[11:41:56.160]                 removed <- setdiff(old_names, names)
[11:41:56.160]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:56.160]                   envs[common]]
[11:41:56.160]                 NAMES <- toupper(changed)
[11:41:56.160]                 args <- list()
[11:41:56.160]                 for (kk in seq_along(NAMES)) {
[11:41:56.160]                   name <- changed[[kk]]
[11:41:56.160]                   NAME <- NAMES[[kk]]
[11:41:56.160]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:56.160]                     next
[11:41:56.160]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:56.160]                 }
[11:41:56.160]                 NAMES <- toupper(added)
[11:41:56.160]                 for (kk in seq_along(NAMES)) {
[11:41:56.160]                   name <- added[[kk]]
[11:41:56.160]                   NAME <- NAMES[[kk]]
[11:41:56.160]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:56.160]                     next
[11:41:56.160]                   args[[name]] <- ""
[11:41:56.160]                 }
[11:41:56.160]                 NAMES <- toupper(removed)
[11:41:56.160]                 for (kk in seq_along(NAMES)) {
[11:41:56.160]                   name <- removed[[kk]]
[11:41:56.160]                   NAME <- NAMES[[kk]]
[11:41:56.160]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:56.160]                     next
[11:41:56.160]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:56.160]                 }
[11:41:56.160]                 if (length(args) > 0) 
[11:41:56.160]                   base::do.call(base::Sys.setenv, args = args)
[11:41:56.160]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:56.160]             }
[11:41:56.160]             else {
[11:41:56.160]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:56.160]             }
[11:41:56.160]             {
[11:41:56.160]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:56.160]                   0L) {
[11:41:56.160]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:56.160]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:56.160]                   base::options(opts)
[11:41:56.160]                 }
[11:41:56.160]                 {
[11:41:56.160]                   {
[11:41:56.160]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:56.160]                     NULL
[11:41:56.160]                   }
[11:41:56.160]                   options(future.plan = NULL)
[11:41:56.160]                   if (is.na(NA_character_)) 
[11:41:56.160]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:56.160]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:56.160]                   future::plan(list(function (..., workers = 2, 
[11:41:56.160]                     envir = parent.frame()) 
[11:41:56.160]                   strategy(..., workers = workers, envir = envir)), 
[11:41:56.160]                     .cleanup = FALSE, .init = FALSE)
[11:41:56.160]                 }
[11:41:56.160]             }
[11:41:56.160]         }
[11:41:56.160]     })
[11:41:56.160]     if (TRUE) {
[11:41:56.160]         base::sink(type = "output", split = FALSE)
[11:41:56.160]         if (TRUE) {
[11:41:56.160]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:56.160]         }
[11:41:56.160]         else {
[11:41:56.160]             ...future.result["stdout"] <- base::list(NULL)
[11:41:56.160]         }
[11:41:56.160]         base::close(...future.stdout)
[11:41:56.160]         ...future.stdout <- NULL
[11:41:56.160]     }
[11:41:56.160]     ...future.result$conditions <- ...future.conditions
[11:41:56.160]     ...future.result$finished <- base::Sys.time()
[11:41:56.160]     ...future.result
[11:41:56.160] }
[11:41:56.161] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:56.172] receiveMessageFromWorker() for ClusterFuture ...
[11:41:56.172] - Validating connection of MultisessionFuture
[11:41:56.173] - received message: FutureResult
[11:41:56.173] - Received FutureResult
[11:41:56.173] - Erased future from FutureRegistry
[11:41:56.173] result() for ClusterFuture ...
[11:41:56.173] - result already collected: FutureResult
[11:41:56.173] result() for ClusterFuture ... done
[11:41:56.173] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:56.173] result() for ClusterFuture ...
[11:41:56.173] - result already collected: FutureResult
[11:41:56.173] result() for ClusterFuture ... done
[11:41:56.173] result() for ClusterFuture ...
[11:41:56.173] - result already collected: FutureResult
[11:41:56.173] result() for ClusterFuture ... done
[11:41:56.174] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:56.174] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:56.218] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:56.222] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:56.266] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:56.267] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:56.318] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:56.319] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:56.320] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:56.321] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:56.322] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:56.323] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:56.324] MultisessionFuture started
[11:41:56.324] - Launch lazy future ... done
[11:41:56.324] run() for ‘MultisessionFuture’ ... done
[11:41:56.324] Created future:
[11:41:56.324] MultisessionFuture:
[11:41:56.324] Label: ‘future_mapply-58’
[11:41:56.324] Expression:
[11:41:56.324] {
[11:41:56.324]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:56.324]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:56.324]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:56.324]         on.exit(options(oopts), add = TRUE)
[11:41:56.324]     }
[11:41:56.324]     {
[11:41:56.324]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:56.324]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:56.324]                 inherits = FALSE)
[11:41:56.324]             ...future.FUN(...)
[11:41:56.324]         }
[11:41:56.324]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:56.324]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:56.324]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:56.324]         do.call(mapply, args = args)
[11:41:56.324]     }
[11:41:56.324] }
[11:41:56.324] Lazy evaluation: FALSE
[11:41:56.324] Asynchronous evaluation: TRUE
[11:41:56.324] Local evaluation: TRUE
[11:41:56.324] Environment: 0x560ef58e1768
[11:41:56.324] Capture standard output: TRUE
[11:41:56.324] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:56.324] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:56.324] Packages: 1 packages (‘mlr3’)
[11:41:56.324] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:56.324] Resolved: FALSE
[11:41:56.324] Value: <not collected>
[11:41:56.324] Conditions captured: <none>
[11:41:56.324] Early signaling: FALSE
[11:41:56.324] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:56.324] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:56.341] Chunk #58 of 90 ... DONE
[11:41:56.341] Chunk #59 of 90 ...
[11:41:56.341]  - seeds: [1] <seeds>
[11:41:56.342] getGlobalsAndPackages() ...
[11:41:56.342] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:56.342] Resolving globals: FALSE
[11:41:56.343] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:56.343] - packages: [1] ‘mlr3’
[11:41:56.343] getGlobalsAndPackages() ... DONE
[11:41:56.343] run() for ‘Future’ ...
[11:41:56.343] - state: ‘created’
[11:41:56.343] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:56.354] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:56.354] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:56.354]   - Field: ‘node’
[11:41:56.354]   - Field: ‘label’
[11:41:56.355]   - Field: ‘local’
[11:41:56.355]   - Field: ‘owner’
[11:41:56.355]   - Field: ‘envir’
[11:41:56.355]   - Field: ‘workers’
[11:41:56.355]   - Field: ‘packages’
[11:41:56.355]   - Field: ‘gc’
[11:41:56.355]   - Field: ‘conditions’
[11:41:56.355]   - Field: ‘persistent’
[11:41:56.355]   - Field: ‘expr’
[11:41:56.355]   - Field: ‘uuid’
[11:41:56.355]   - Field: ‘seed’
[11:41:56.355]   - Field: ‘version’
[11:41:56.355]   - Field: ‘result’
[11:41:56.355]   - Field: ‘asynchronous’
[11:41:56.355]   - Field: ‘calls’
[11:41:56.355]   - Field: ‘globals’
[11:41:56.355]   - Field: ‘stdout’
[11:41:56.355]   - Field: ‘earlySignal’
[11:41:56.355]   - Field: ‘lazy’
[11:41:56.355]   - Field: ‘state’
[11:41:56.356] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:56.356] - Launch lazy future ...
[11:41:56.356] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:56.356] Packages needed by future strategies (n = 0): <none>
[11:41:56.356] {
[11:41:56.356]     {
[11:41:56.356]         {
[11:41:56.356]             ...future.startTime <- base::Sys.time()
[11:41:56.356]             {
[11:41:56.356]                 {
[11:41:56.356]                   {
[11:41:56.356]                     {
[11:41:56.356]                       {
[11:41:56.356]                         base::local({
[11:41:56.356]                           has_future <- base::requireNamespace("future", 
[11:41:56.356]                             quietly = TRUE)
[11:41:56.356]                           if (has_future) {
[11:41:56.356]                             ns <- base::getNamespace("future")
[11:41:56.356]                             version <- ns[[".package"]][["version"]]
[11:41:56.356]                             if (is.null(version)) 
[11:41:56.356]                               version <- utils::packageVersion("future")
[11:41:56.356]                           }
[11:41:56.356]                           else {
[11:41:56.356]                             version <- NULL
[11:41:56.356]                           }
[11:41:56.356]                           if (!has_future || version < "1.8.0") {
[11:41:56.356]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:56.356]                               "", base::R.version$version.string), 
[11:41:56.356]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:56.356]                                 base::R.version$platform, 8 * 
[11:41:56.356]                                   base::.Machine$sizeof.pointer), 
[11:41:56.356]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:56.356]                                 "release", "version")], collapse = " "), 
[11:41:56.356]                               hostname = base::Sys.info()[["nodename"]])
[11:41:56.356]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:56.356]                               info)
[11:41:56.356]                             info <- base::paste(info, collapse = "; ")
[11:41:56.356]                             if (!has_future) {
[11:41:56.356]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:56.356]                                 info)
[11:41:56.356]                             }
[11:41:56.356]                             else {
[11:41:56.356]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:56.356]                                 info, version)
[11:41:56.356]                             }
[11:41:56.356]                             base::stop(msg)
[11:41:56.356]                           }
[11:41:56.356]                         })
[11:41:56.356]                       }
[11:41:56.356]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:56.356]                       base::options(mc.cores = 1L)
[11:41:56.356]                     }
[11:41:56.356]                     base::local({
[11:41:56.356]                       for (pkg in "mlr3") {
[11:41:56.356]                         base::loadNamespace(pkg)
[11:41:56.356]                         base::library(pkg, character.only = TRUE)
[11:41:56.356]                       }
[11:41:56.356]                     })
[11:41:56.356]                   }
[11:41:56.356]                   options(future.plan = NULL)
[11:41:56.356]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:56.356]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:56.356]                 }
[11:41:56.356]                 ...future.workdir <- getwd()
[11:41:56.356]             }
[11:41:56.356]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:56.356]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:56.356]         }
[11:41:56.356]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:56.356]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:56.356]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:56.356]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:56.356]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:56.356]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:56.356]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:56.356]             base::names(...future.oldOptions))
[11:41:56.356]     }
[11:41:56.356]     if (FALSE) {
[11:41:56.356]     }
[11:41:56.356]     else {
[11:41:56.356]         if (TRUE) {
[11:41:56.356]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:56.356]                 open = "w")
[11:41:56.356]         }
[11:41:56.356]         else {
[11:41:56.356]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:56.356]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:56.356]         }
[11:41:56.356]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:56.356]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:56.356]             base::sink(type = "output", split = FALSE)
[11:41:56.356]             base::close(...future.stdout)
[11:41:56.356]         }, add = TRUE)
[11:41:56.356]     }
[11:41:56.356]     ...future.frame <- base::sys.nframe()
[11:41:56.356]     ...future.conditions <- base::list()
[11:41:56.356]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:56.356]     if (FALSE) {
[11:41:56.356]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:56.356]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:56.356]     }
[11:41:56.356]     ...future.result <- base::tryCatch({
[11:41:56.356]         base::withCallingHandlers({
[11:41:56.356]             ...future.value <- base::withVisible(base::local({
[11:41:56.356]                 ...future.makeSendCondition <- local({
[11:41:56.356]                   sendCondition <- NULL
[11:41:56.356]                   function(frame = 1L) {
[11:41:56.356]                     if (is.function(sendCondition)) 
[11:41:56.356]                       return(sendCondition)
[11:41:56.356]                     ns <- getNamespace("parallel")
[11:41:56.356]                     if (exists("sendData", mode = "function", 
[11:41:56.356]                       envir = ns)) {
[11:41:56.356]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:56.356]                         envir = ns)
[11:41:56.356]                       envir <- sys.frame(frame)
[11:41:56.356]                       master <- NULL
[11:41:56.356]                       while (!identical(envir, .GlobalEnv) && 
[11:41:56.356]                         !identical(envir, emptyenv())) {
[11:41:56.356]                         if (exists("master", mode = "list", envir = envir, 
[11:41:56.356]                           inherits = FALSE)) {
[11:41:56.356]                           master <- get("master", mode = "list", 
[11:41:56.356]                             envir = envir, inherits = FALSE)
[11:41:56.356]                           if (inherits(master, c("SOCKnode", 
[11:41:56.356]                             "SOCK0node"))) {
[11:41:56.356]                             sendCondition <<- function(cond) {
[11:41:56.356]                               data <- list(type = "VALUE", value = cond, 
[11:41:56.356]                                 success = TRUE)
[11:41:56.356]                               parallel_sendData(master, data)
[11:41:56.356]                             }
[11:41:56.356]                             return(sendCondition)
[11:41:56.356]                           }
[11:41:56.356]                         }
[11:41:56.356]                         frame <- frame + 1L
[11:41:56.356]                         envir <- sys.frame(frame)
[11:41:56.356]                       }
[11:41:56.356]                     }
[11:41:56.356]                     sendCondition <<- function(cond) NULL
[11:41:56.356]                   }
[11:41:56.356]                 })
[11:41:56.356]                 withCallingHandlers({
[11:41:56.356]                   {
[11:41:56.356]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:56.356]                     if (!identical(...future.globals.maxSize.org, 
[11:41:56.356]                       ...future.globals.maxSize)) {
[11:41:56.356]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:56.356]                       on.exit(options(oopts), add = TRUE)
[11:41:56.356]                     }
[11:41:56.356]                     {
[11:41:56.356]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:56.356]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:56.356]                           envir = globalenv(), inherits = FALSE)
[11:41:56.356]                         ...future.FUN(...)
[11:41:56.356]                       }
[11:41:56.356]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:56.356]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:56.356]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:56.356]                         USE.NAMES = FALSE)
[11:41:56.356]                       do.call(mapply, args = args)
[11:41:56.356]                     }
[11:41:56.356]                   }
[11:41:56.356]                 }, immediateCondition = function(cond) {
[11:41:56.356]                   sendCondition <- ...future.makeSendCondition()
[11:41:56.356]                   sendCondition(cond)
[11:41:56.356]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:56.356]                   {
[11:41:56.356]                     inherits <- base::inherits
[11:41:56.356]                     invokeRestart <- base::invokeRestart
[11:41:56.356]                     is.null <- base::is.null
[11:41:56.356]                     muffled <- FALSE
[11:41:56.356]                     if (inherits(cond, "message")) {
[11:41:56.356]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:56.356]                       if (muffled) 
[11:41:56.356]                         invokeRestart("muffleMessage")
[11:41:56.356]                     }
[11:41:56.356]                     else if (inherits(cond, "warning")) {
[11:41:56.356]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:56.356]                       if (muffled) 
[11:41:56.356]                         invokeRestart("muffleWarning")
[11:41:56.356]                     }
[11:41:56.356]                     else if (inherits(cond, "condition")) {
[11:41:56.356]                       if (!is.null(pattern)) {
[11:41:56.356]                         computeRestarts <- base::computeRestarts
[11:41:56.356]                         grepl <- base::grepl
[11:41:56.356]                         restarts <- computeRestarts(cond)
[11:41:56.356]                         for (restart in restarts) {
[11:41:56.356]                           name <- restart$name
[11:41:56.356]                           if (is.null(name)) 
[11:41:56.356]                             next
[11:41:56.356]                           if (!grepl(pattern, name)) 
[11:41:56.356]                             next
[11:41:56.356]                           invokeRestart(restart)
[11:41:56.356]                           muffled <- TRUE
[11:41:56.356]                           break
[11:41:56.356]                         }
[11:41:56.356]                       }
[11:41:56.356]                     }
[11:41:56.356]                     invisible(muffled)
[11:41:56.356]                   }
[11:41:56.356]                   muffleCondition(cond)
[11:41:56.356]                 })
[11:41:56.356]             }))
[11:41:56.356]             future::FutureResult(value = ...future.value$value, 
[11:41:56.356]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:56.356]                   ...future.rng), globalenv = if (FALSE) 
[11:41:56.356]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:56.356]                     ...future.globalenv.names))
[11:41:56.356]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:56.356]         }, condition = base::local({
[11:41:56.356]             c <- base::c
[11:41:56.356]             inherits <- base::inherits
[11:41:56.356]             invokeRestart <- base::invokeRestart
[11:41:56.356]             length <- base::length
[11:41:56.356]             list <- base::list
[11:41:56.356]             seq.int <- base::seq.int
[11:41:56.356]             signalCondition <- base::signalCondition
[11:41:56.356]             sys.calls <- base::sys.calls
[11:41:56.356]             `[[` <- base::`[[`
[11:41:56.356]             `+` <- base::`+`
[11:41:56.356]             `<<-` <- base::`<<-`
[11:41:56.356]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:56.356]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:56.356]                   3L)]
[11:41:56.356]             }
[11:41:56.356]             function(cond) {
[11:41:56.356]                 is_error <- inherits(cond, "error")
[11:41:56.356]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:56.356]                   NULL)
[11:41:56.356]                 if (is_error) {
[11:41:56.356]                   sessionInformation <- function() {
[11:41:56.356]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:56.356]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:56.356]                       search = base::search(), system = base::Sys.info())
[11:41:56.356]                   }
[11:41:56.356]                   ...future.conditions[[length(...future.conditions) + 
[11:41:56.356]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:56.356]                     cond$call), session = sessionInformation(), 
[11:41:56.356]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:56.356]                   signalCondition(cond)
[11:41:56.356]                 }
[11:41:56.356]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:56.356]                 "immediateCondition"))) {
[11:41:56.356]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:56.356]                   ...future.conditions[[length(...future.conditions) + 
[11:41:56.356]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:56.356]                   if (TRUE && !signal) {
[11:41:56.356]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:56.356]                     {
[11:41:56.356]                       inherits <- base::inherits
[11:41:56.356]                       invokeRestart <- base::invokeRestart
[11:41:56.356]                       is.null <- base::is.null
[11:41:56.356]                       muffled <- FALSE
[11:41:56.356]                       if (inherits(cond, "message")) {
[11:41:56.356]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:56.356]                         if (muffled) 
[11:41:56.356]                           invokeRestart("muffleMessage")
[11:41:56.356]                       }
[11:41:56.356]                       else if (inherits(cond, "warning")) {
[11:41:56.356]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:56.356]                         if (muffled) 
[11:41:56.356]                           invokeRestart("muffleWarning")
[11:41:56.356]                       }
[11:41:56.356]                       else if (inherits(cond, "condition")) {
[11:41:56.356]                         if (!is.null(pattern)) {
[11:41:56.356]                           computeRestarts <- base::computeRestarts
[11:41:56.356]                           grepl <- base::grepl
[11:41:56.356]                           restarts <- computeRestarts(cond)
[11:41:56.356]                           for (restart in restarts) {
[11:41:56.356]                             name <- restart$name
[11:41:56.356]                             if (is.null(name)) 
[11:41:56.356]                               next
[11:41:56.356]                             if (!grepl(pattern, name)) 
[11:41:56.356]                               next
[11:41:56.356]                             invokeRestart(restart)
[11:41:56.356]                             muffled <- TRUE
[11:41:56.356]                             break
[11:41:56.356]                           }
[11:41:56.356]                         }
[11:41:56.356]                       }
[11:41:56.356]                       invisible(muffled)
[11:41:56.356]                     }
[11:41:56.356]                     muffleCondition(cond, pattern = "^muffle")
[11:41:56.356]                   }
[11:41:56.356]                 }
[11:41:56.356]                 else {
[11:41:56.356]                   if (TRUE) {
[11:41:56.356]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:56.356]                     {
[11:41:56.356]                       inherits <- base::inherits
[11:41:56.356]                       invokeRestart <- base::invokeRestart
[11:41:56.356]                       is.null <- base::is.null
[11:41:56.356]                       muffled <- FALSE
[11:41:56.356]                       if (inherits(cond, "message")) {
[11:41:56.356]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:56.356]                         if (muffled) 
[11:41:56.356]                           invokeRestart("muffleMessage")
[11:41:56.356]                       }
[11:41:56.356]                       else if (inherits(cond, "warning")) {
[11:41:56.356]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:56.356]                         if (muffled) 
[11:41:56.356]                           invokeRestart("muffleWarning")
[11:41:56.356]                       }
[11:41:56.356]                       else if (inherits(cond, "condition")) {
[11:41:56.356]                         if (!is.null(pattern)) {
[11:41:56.356]                           computeRestarts <- base::computeRestarts
[11:41:56.356]                           grepl <- base::grepl
[11:41:56.356]                           restarts <- computeRestarts(cond)
[11:41:56.356]                           for (restart in restarts) {
[11:41:56.356]                             name <- restart$name
[11:41:56.356]                             if (is.null(name)) 
[11:41:56.356]                               next
[11:41:56.356]                             if (!grepl(pattern, name)) 
[11:41:56.356]                               next
[11:41:56.356]                             invokeRestart(restart)
[11:41:56.356]                             muffled <- TRUE
[11:41:56.356]                             break
[11:41:56.356]                           }
[11:41:56.356]                         }
[11:41:56.356]                       }
[11:41:56.356]                       invisible(muffled)
[11:41:56.356]                     }
[11:41:56.356]                     muffleCondition(cond, pattern = "^muffle")
[11:41:56.356]                   }
[11:41:56.356]                 }
[11:41:56.356]             }
[11:41:56.356]         }))
[11:41:56.356]     }, error = function(ex) {
[11:41:56.356]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:56.356]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:56.356]                 ...future.rng), started = ...future.startTime, 
[11:41:56.356]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:56.356]             version = "1.8"), class = "FutureResult")
[11:41:56.356]     }, finally = {
[11:41:56.356]         if (!identical(...future.workdir, getwd())) 
[11:41:56.356]             setwd(...future.workdir)
[11:41:56.356]         {
[11:41:56.356]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:56.356]                 ...future.oldOptions$nwarnings <- NULL
[11:41:56.356]             }
[11:41:56.356]             base::options(...future.oldOptions)
[11:41:56.356]             if (.Platform$OS.type == "windows") {
[11:41:56.356]                 old_names <- names(...future.oldEnvVars)
[11:41:56.356]                 envs <- base::Sys.getenv()
[11:41:56.356]                 names <- names(envs)
[11:41:56.356]                 common <- intersect(names, old_names)
[11:41:56.356]                 added <- setdiff(names, old_names)
[11:41:56.356]                 removed <- setdiff(old_names, names)
[11:41:56.356]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:56.356]                   envs[common]]
[11:41:56.356]                 NAMES <- toupper(changed)
[11:41:56.356]                 args <- list()
[11:41:56.356]                 for (kk in seq_along(NAMES)) {
[11:41:56.356]                   name <- changed[[kk]]
[11:41:56.356]                   NAME <- NAMES[[kk]]
[11:41:56.356]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:56.356]                     next
[11:41:56.356]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:56.356]                 }
[11:41:56.356]                 NAMES <- toupper(added)
[11:41:56.356]                 for (kk in seq_along(NAMES)) {
[11:41:56.356]                   name <- added[[kk]]
[11:41:56.356]                   NAME <- NAMES[[kk]]
[11:41:56.356]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:56.356]                     next
[11:41:56.356]                   args[[name]] <- ""
[11:41:56.356]                 }
[11:41:56.356]                 NAMES <- toupper(removed)
[11:41:56.356]                 for (kk in seq_along(NAMES)) {
[11:41:56.356]                   name <- removed[[kk]]
[11:41:56.356]                   NAME <- NAMES[[kk]]
[11:41:56.356]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:56.356]                     next
[11:41:56.356]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:56.356]                 }
[11:41:56.356]                 if (length(args) > 0) 
[11:41:56.356]                   base::do.call(base::Sys.setenv, args = args)
[11:41:56.356]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:56.356]             }
[11:41:56.356]             else {
[11:41:56.356]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:56.356]             }
[11:41:56.356]             {
[11:41:56.356]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:56.356]                   0L) {
[11:41:56.356]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:56.356]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:56.356]                   base::options(opts)
[11:41:56.356]                 }
[11:41:56.356]                 {
[11:41:56.356]                   {
[11:41:56.356]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:56.356]                     NULL
[11:41:56.356]                   }
[11:41:56.356]                   options(future.plan = NULL)
[11:41:56.356]                   if (is.na(NA_character_)) 
[11:41:56.356]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:56.356]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:56.356]                   future::plan(list(function (..., workers = 2, 
[11:41:56.356]                     envir = parent.frame()) 
[11:41:56.356]                   strategy(..., workers = workers, envir = envir)), 
[11:41:56.356]                     .cleanup = FALSE, .init = FALSE)
[11:41:56.356]                 }
[11:41:56.356]             }
[11:41:56.356]         }
[11:41:56.356]     })
[11:41:56.356]     if (TRUE) {
[11:41:56.356]         base::sink(type = "output", split = FALSE)
[11:41:56.356]         if (TRUE) {
[11:41:56.356]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:56.356]         }
[11:41:56.356]         else {
[11:41:56.356]             ...future.result["stdout"] <- base::list(NULL)
[11:41:56.356]         }
[11:41:56.356]         base::close(...future.stdout)
[11:41:56.356]         ...future.stdout <- NULL
[11:41:56.356]     }
[11:41:56.356]     ...future.result$conditions <- ...future.conditions
[11:41:56.356]     ...future.result$finished <- base::Sys.time()
[11:41:56.356]     ...future.result
[11:41:56.356] }
[11:41:56.358] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:56.369] receiveMessageFromWorker() for ClusterFuture ...
[11:41:56.369] - Validating connection of MultisessionFuture
[11:41:56.369] - received message: FutureResult
[11:41:56.369] - Received FutureResult
[11:41:56.369] - Erased future from FutureRegistry
[11:41:56.369] result() for ClusterFuture ...
[11:41:56.369] - result already collected: FutureResult
[11:41:56.369] result() for ClusterFuture ... done
[11:41:56.369] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:56.369] result() for ClusterFuture ...
[11:41:56.369] - result already collected: FutureResult
[11:41:56.370] result() for ClusterFuture ... done
[11:41:56.370] result() for ClusterFuture ...
[11:41:56.370] - result already collected: FutureResult
[11:41:56.370] result() for ClusterFuture ... done
[11:41:56.370] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:56.370] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:56.414] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:56.419] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:56.462] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:56.463] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:56.510] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:56.511] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:56.513] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:56.513] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:56.515] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:56.515] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:56.516] MultisessionFuture started
[11:41:56.517] - Launch lazy future ... done
[11:41:56.517] run() for ‘MultisessionFuture’ ... done
[11:41:56.517] Created future:
[11:41:56.517] MultisessionFuture:
[11:41:56.517] Label: ‘future_mapply-59’
[11:41:56.517] Expression:
[11:41:56.517] {
[11:41:56.517]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:56.517]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:56.517]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:56.517]         on.exit(options(oopts), add = TRUE)
[11:41:56.517]     }
[11:41:56.517]     {
[11:41:56.517]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:56.517]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:56.517]                 inherits = FALSE)
[11:41:56.517]             ...future.FUN(...)
[11:41:56.517]         }
[11:41:56.517]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:56.517]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:56.517]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:56.517]         do.call(mapply, args = args)
[11:41:56.517]     }
[11:41:56.517] }
[11:41:56.517] Lazy evaluation: FALSE
[11:41:56.517] Asynchronous evaluation: TRUE
[11:41:56.517] Local evaluation: TRUE
[11:41:56.517] Environment: 0x560ef58e1768
[11:41:56.517] Capture standard output: TRUE
[11:41:56.517] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:56.517] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:56.517] Packages: 1 packages (‘mlr3’)
[11:41:56.517] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:56.517] Resolved: FALSE
[11:41:56.517] Value: <not collected>
[11:41:56.517] Conditions captured: <none>
[11:41:56.517] Early signaling: FALSE
[11:41:56.517] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:56.517] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:56.535] Chunk #59 of 90 ... DONE
[11:41:56.536] Chunk #60 of 90 ...
[11:41:56.536]  - seeds: [1] <seeds>
[11:41:56.536] getGlobalsAndPackages() ...
[11:41:56.536] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:56.536] Resolving globals: FALSE
[11:41:56.537] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:56.537] - packages: [1] ‘mlr3’
[11:41:56.537] getGlobalsAndPackages() ... DONE
[11:41:56.538] run() for ‘Future’ ...
[11:41:56.538] - state: ‘created’
[11:41:56.538] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:56.549] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:56.549] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:56.549]   - Field: ‘node’
[11:41:56.549]   - Field: ‘label’
[11:41:56.549]   - Field: ‘local’
[11:41:56.549]   - Field: ‘owner’
[11:41:56.549]   - Field: ‘envir’
[11:41:56.550]   - Field: ‘workers’
[11:41:56.550]   - Field: ‘packages’
[11:41:56.550]   - Field: ‘gc’
[11:41:56.550]   - Field: ‘conditions’
[11:41:56.553]   - Field: ‘persistent’
[11:41:56.553]   - Field: ‘expr’
[11:41:56.553]   - Field: ‘uuid’
[11:41:56.553]   - Field: ‘seed’
[11:41:56.553]   - Field: ‘version’
[11:41:56.553]   - Field: ‘result’
[11:41:56.554]   - Field: ‘asynchronous’
[11:41:56.554]   - Field: ‘calls’
[11:41:56.554]   - Field: ‘globals’
[11:41:56.554]   - Field: ‘stdout’
[11:41:56.554]   - Field: ‘earlySignal’
[11:41:56.554]   - Field: ‘lazy’
[11:41:56.554]   - Field: ‘state’
[11:41:56.554] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:56.554] - Launch lazy future ...
[11:41:56.554] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:56.555] Packages needed by future strategies (n = 0): <none>
[11:41:56.555] {
[11:41:56.555]     {
[11:41:56.555]         {
[11:41:56.555]             ...future.startTime <- base::Sys.time()
[11:41:56.555]             {
[11:41:56.555]                 {
[11:41:56.555]                   {
[11:41:56.555]                     {
[11:41:56.555]                       {
[11:41:56.555]                         base::local({
[11:41:56.555]                           has_future <- base::requireNamespace("future", 
[11:41:56.555]                             quietly = TRUE)
[11:41:56.555]                           if (has_future) {
[11:41:56.555]                             ns <- base::getNamespace("future")
[11:41:56.555]                             version <- ns[[".package"]][["version"]]
[11:41:56.555]                             if (is.null(version)) 
[11:41:56.555]                               version <- utils::packageVersion("future")
[11:41:56.555]                           }
[11:41:56.555]                           else {
[11:41:56.555]                             version <- NULL
[11:41:56.555]                           }
[11:41:56.555]                           if (!has_future || version < "1.8.0") {
[11:41:56.555]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:56.555]                               "", base::R.version$version.string), 
[11:41:56.555]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:56.555]                                 base::R.version$platform, 8 * 
[11:41:56.555]                                   base::.Machine$sizeof.pointer), 
[11:41:56.555]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:56.555]                                 "release", "version")], collapse = " "), 
[11:41:56.555]                               hostname = base::Sys.info()[["nodename"]])
[11:41:56.555]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:56.555]                               info)
[11:41:56.555]                             info <- base::paste(info, collapse = "; ")
[11:41:56.555]                             if (!has_future) {
[11:41:56.555]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:56.555]                                 info)
[11:41:56.555]                             }
[11:41:56.555]                             else {
[11:41:56.555]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:56.555]                                 info, version)
[11:41:56.555]                             }
[11:41:56.555]                             base::stop(msg)
[11:41:56.555]                           }
[11:41:56.555]                         })
[11:41:56.555]                       }
[11:41:56.555]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:56.555]                       base::options(mc.cores = 1L)
[11:41:56.555]                     }
[11:41:56.555]                     base::local({
[11:41:56.555]                       for (pkg in "mlr3") {
[11:41:56.555]                         base::loadNamespace(pkg)
[11:41:56.555]                         base::library(pkg, character.only = TRUE)
[11:41:56.555]                       }
[11:41:56.555]                     })
[11:41:56.555]                   }
[11:41:56.555]                   options(future.plan = NULL)
[11:41:56.555]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:56.555]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:56.555]                 }
[11:41:56.555]                 ...future.workdir <- getwd()
[11:41:56.555]             }
[11:41:56.555]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:56.555]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:56.555]         }
[11:41:56.555]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:56.555]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:56.555]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:56.555]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:56.555]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:56.555]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:56.555]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:56.555]             base::names(...future.oldOptions))
[11:41:56.555]     }
[11:41:56.555]     if (FALSE) {
[11:41:56.555]     }
[11:41:56.555]     else {
[11:41:56.555]         if (TRUE) {
[11:41:56.555]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:56.555]                 open = "w")
[11:41:56.555]         }
[11:41:56.555]         else {
[11:41:56.555]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:56.555]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:56.555]         }
[11:41:56.555]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:56.555]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:56.555]             base::sink(type = "output", split = FALSE)
[11:41:56.555]             base::close(...future.stdout)
[11:41:56.555]         }, add = TRUE)
[11:41:56.555]     }
[11:41:56.555]     ...future.frame <- base::sys.nframe()
[11:41:56.555]     ...future.conditions <- base::list()
[11:41:56.555]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:56.555]     if (FALSE) {
[11:41:56.555]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:56.555]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:56.555]     }
[11:41:56.555]     ...future.result <- base::tryCatch({
[11:41:56.555]         base::withCallingHandlers({
[11:41:56.555]             ...future.value <- base::withVisible(base::local({
[11:41:56.555]                 ...future.makeSendCondition <- local({
[11:41:56.555]                   sendCondition <- NULL
[11:41:56.555]                   function(frame = 1L) {
[11:41:56.555]                     if (is.function(sendCondition)) 
[11:41:56.555]                       return(sendCondition)
[11:41:56.555]                     ns <- getNamespace("parallel")
[11:41:56.555]                     if (exists("sendData", mode = "function", 
[11:41:56.555]                       envir = ns)) {
[11:41:56.555]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:56.555]                         envir = ns)
[11:41:56.555]                       envir <- sys.frame(frame)
[11:41:56.555]                       master <- NULL
[11:41:56.555]                       while (!identical(envir, .GlobalEnv) && 
[11:41:56.555]                         !identical(envir, emptyenv())) {
[11:41:56.555]                         if (exists("master", mode = "list", envir = envir, 
[11:41:56.555]                           inherits = FALSE)) {
[11:41:56.555]                           master <- get("master", mode = "list", 
[11:41:56.555]                             envir = envir, inherits = FALSE)
[11:41:56.555]                           if (inherits(master, c("SOCKnode", 
[11:41:56.555]                             "SOCK0node"))) {
[11:41:56.555]                             sendCondition <<- function(cond) {
[11:41:56.555]                               data <- list(type = "VALUE", value = cond, 
[11:41:56.555]                                 success = TRUE)
[11:41:56.555]                               parallel_sendData(master, data)
[11:41:56.555]                             }
[11:41:56.555]                             return(sendCondition)
[11:41:56.555]                           }
[11:41:56.555]                         }
[11:41:56.555]                         frame <- frame + 1L
[11:41:56.555]                         envir <- sys.frame(frame)
[11:41:56.555]                       }
[11:41:56.555]                     }
[11:41:56.555]                     sendCondition <<- function(cond) NULL
[11:41:56.555]                   }
[11:41:56.555]                 })
[11:41:56.555]                 withCallingHandlers({
[11:41:56.555]                   {
[11:41:56.555]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:56.555]                     if (!identical(...future.globals.maxSize.org, 
[11:41:56.555]                       ...future.globals.maxSize)) {
[11:41:56.555]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:56.555]                       on.exit(options(oopts), add = TRUE)
[11:41:56.555]                     }
[11:41:56.555]                     {
[11:41:56.555]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:56.555]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:56.555]                           envir = globalenv(), inherits = FALSE)
[11:41:56.555]                         ...future.FUN(...)
[11:41:56.555]                       }
[11:41:56.555]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:56.555]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:56.555]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:56.555]                         USE.NAMES = FALSE)
[11:41:56.555]                       do.call(mapply, args = args)
[11:41:56.555]                     }
[11:41:56.555]                   }
[11:41:56.555]                 }, immediateCondition = function(cond) {
[11:41:56.555]                   sendCondition <- ...future.makeSendCondition()
[11:41:56.555]                   sendCondition(cond)
[11:41:56.555]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:56.555]                   {
[11:41:56.555]                     inherits <- base::inherits
[11:41:56.555]                     invokeRestart <- base::invokeRestart
[11:41:56.555]                     is.null <- base::is.null
[11:41:56.555]                     muffled <- FALSE
[11:41:56.555]                     if (inherits(cond, "message")) {
[11:41:56.555]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:56.555]                       if (muffled) 
[11:41:56.555]                         invokeRestart("muffleMessage")
[11:41:56.555]                     }
[11:41:56.555]                     else if (inherits(cond, "warning")) {
[11:41:56.555]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:56.555]                       if (muffled) 
[11:41:56.555]                         invokeRestart("muffleWarning")
[11:41:56.555]                     }
[11:41:56.555]                     else if (inherits(cond, "condition")) {
[11:41:56.555]                       if (!is.null(pattern)) {
[11:41:56.555]                         computeRestarts <- base::computeRestarts
[11:41:56.555]                         grepl <- base::grepl
[11:41:56.555]                         restarts <- computeRestarts(cond)
[11:41:56.555]                         for (restart in restarts) {
[11:41:56.555]                           name <- restart$name
[11:41:56.555]                           if (is.null(name)) 
[11:41:56.555]                             next
[11:41:56.555]                           if (!grepl(pattern, name)) 
[11:41:56.555]                             next
[11:41:56.555]                           invokeRestart(restart)
[11:41:56.555]                           muffled <- TRUE
[11:41:56.555]                           break
[11:41:56.555]                         }
[11:41:56.555]                       }
[11:41:56.555]                     }
[11:41:56.555]                     invisible(muffled)
[11:41:56.555]                   }
[11:41:56.555]                   muffleCondition(cond)
[11:41:56.555]                 })
[11:41:56.555]             }))
[11:41:56.555]             future::FutureResult(value = ...future.value$value, 
[11:41:56.555]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:56.555]                   ...future.rng), globalenv = if (FALSE) 
[11:41:56.555]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:56.555]                     ...future.globalenv.names))
[11:41:56.555]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:56.555]         }, condition = base::local({
[11:41:56.555]             c <- base::c
[11:41:56.555]             inherits <- base::inherits
[11:41:56.555]             invokeRestart <- base::invokeRestart
[11:41:56.555]             length <- base::length
[11:41:56.555]             list <- base::list
[11:41:56.555]             seq.int <- base::seq.int
[11:41:56.555]             signalCondition <- base::signalCondition
[11:41:56.555]             sys.calls <- base::sys.calls
[11:41:56.555]             `[[` <- base::`[[`
[11:41:56.555]             `+` <- base::`+`
[11:41:56.555]             `<<-` <- base::`<<-`
[11:41:56.555]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:56.555]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:56.555]                   3L)]
[11:41:56.555]             }
[11:41:56.555]             function(cond) {
[11:41:56.555]                 is_error <- inherits(cond, "error")
[11:41:56.555]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:56.555]                   NULL)
[11:41:56.555]                 if (is_error) {
[11:41:56.555]                   sessionInformation <- function() {
[11:41:56.555]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:56.555]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:56.555]                       search = base::search(), system = base::Sys.info())
[11:41:56.555]                   }
[11:41:56.555]                   ...future.conditions[[length(...future.conditions) + 
[11:41:56.555]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:56.555]                     cond$call), session = sessionInformation(), 
[11:41:56.555]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:56.555]                   signalCondition(cond)
[11:41:56.555]                 }
[11:41:56.555]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:56.555]                 "immediateCondition"))) {
[11:41:56.555]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:56.555]                   ...future.conditions[[length(...future.conditions) + 
[11:41:56.555]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:56.555]                   if (TRUE && !signal) {
[11:41:56.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:56.555]                     {
[11:41:56.555]                       inherits <- base::inherits
[11:41:56.555]                       invokeRestart <- base::invokeRestart
[11:41:56.555]                       is.null <- base::is.null
[11:41:56.555]                       muffled <- FALSE
[11:41:56.555]                       if (inherits(cond, "message")) {
[11:41:56.555]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:56.555]                         if (muffled) 
[11:41:56.555]                           invokeRestart("muffleMessage")
[11:41:56.555]                       }
[11:41:56.555]                       else if (inherits(cond, "warning")) {
[11:41:56.555]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:56.555]                         if (muffled) 
[11:41:56.555]                           invokeRestart("muffleWarning")
[11:41:56.555]                       }
[11:41:56.555]                       else if (inherits(cond, "condition")) {
[11:41:56.555]                         if (!is.null(pattern)) {
[11:41:56.555]                           computeRestarts <- base::computeRestarts
[11:41:56.555]                           grepl <- base::grepl
[11:41:56.555]                           restarts <- computeRestarts(cond)
[11:41:56.555]                           for (restart in restarts) {
[11:41:56.555]                             name <- restart$name
[11:41:56.555]                             if (is.null(name)) 
[11:41:56.555]                               next
[11:41:56.555]                             if (!grepl(pattern, name)) 
[11:41:56.555]                               next
[11:41:56.555]                             invokeRestart(restart)
[11:41:56.555]                             muffled <- TRUE
[11:41:56.555]                             break
[11:41:56.555]                           }
[11:41:56.555]                         }
[11:41:56.555]                       }
[11:41:56.555]                       invisible(muffled)
[11:41:56.555]                     }
[11:41:56.555]                     muffleCondition(cond, pattern = "^muffle")
[11:41:56.555]                   }
[11:41:56.555]                 }
[11:41:56.555]                 else {
[11:41:56.555]                   if (TRUE) {
[11:41:56.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:56.555]                     {
[11:41:56.555]                       inherits <- base::inherits
[11:41:56.555]                       invokeRestart <- base::invokeRestart
[11:41:56.555]                       is.null <- base::is.null
[11:41:56.555]                       muffled <- FALSE
[11:41:56.555]                       if (inherits(cond, "message")) {
[11:41:56.555]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:56.555]                         if (muffled) 
[11:41:56.555]                           invokeRestart("muffleMessage")
[11:41:56.555]                       }
[11:41:56.555]                       else if (inherits(cond, "warning")) {
[11:41:56.555]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:56.555]                         if (muffled) 
[11:41:56.555]                           invokeRestart("muffleWarning")
[11:41:56.555]                       }
[11:41:56.555]                       else if (inherits(cond, "condition")) {
[11:41:56.555]                         if (!is.null(pattern)) {
[11:41:56.555]                           computeRestarts <- base::computeRestarts
[11:41:56.555]                           grepl <- base::grepl
[11:41:56.555]                           restarts <- computeRestarts(cond)
[11:41:56.555]                           for (restart in restarts) {
[11:41:56.555]                             name <- restart$name
[11:41:56.555]                             if (is.null(name)) 
[11:41:56.555]                               next
[11:41:56.555]                             if (!grepl(pattern, name)) 
[11:41:56.555]                               next
[11:41:56.555]                             invokeRestart(restart)
[11:41:56.555]                             muffled <- TRUE
[11:41:56.555]                             break
[11:41:56.555]                           }
[11:41:56.555]                         }
[11:41:56.555]                       }
[11:41:56.555]                       invisible(muffled)
[11:41:56.555]                     }
[11:41:56.555]                     muffleCondition(cond, pattern = "^muffle")
[11:41:56.555]                   }
[11:41:56.555]                 }
[11:41:56.555]             }
[11:41:56.555]         }))
[11:41:56.555]     }, error = function(ex) {
[11:41:56.555]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:56.555]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:56.555]                 ...future.rng), started = ...future.startTime, 
[11:41:56.555]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:56.555]             version = "1.8"), class = "FutureResult")
[11:41:56.555]     }, finally = {
[11:41:56.555]         if (!identical(...future.workdir, getwd())) 
[11:41:56.555]             setwd(...future.workdir)
[11:41:56.555]         {
[11:41:56.555]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:56.555]                 ...future.oldOptions$nwarnings <- NULL
[11:41:56.555]             }
[11:41:56.555]             base::options(...future.oldOptions)
[11:41:56.555]             if (.Platform$OS.type == "windows") {
[11:41:56.555]                 old_names <- names(...future.oldEnvVars)
[11:41:56.555]                 envs <- base::Sys.getenv()
[11:41:56.555]                 names <- names(envs)
[11:41:56.555]                 common <- intersect(names, old_names)
[11:41:56.555]                 added <- setdiff(names, old_names)
[11:41:56.555]                 removed <- setdiff(old_names, names)
[11:41:56.555]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:56.555]                   envs[common]]
[11:41:56.555]                 NAMES <- toupper(changed)
[11:41:56.555]                 args <- list()
[11:41:56.555]                 for (kk in seq_along(NAMES)) {
[11:41:56.555]                   name <- changed[[kk]]
[11:41:56.555]                   NAME <- NAMES[[kk]]
[11:41:56.555]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:56.555]                     next
[11:41:56.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:56.555]                 }
[11:41:56.555]                 NAMES <- toupper(added)
[11:41:56.555]                 for (kk in seq_along(NAMES)) {
[11:41:56.555]                   name <- added[[kk]]
[11:41:56.555]                   NAME <- NAMES[[kk]]
[11:41:56.555]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:56.555]                     next
[11:41:56.555]                   args[[name]] <- ""
[11:41:56.555]                 }
[11:41:56.555]                 NAMES <- toupper(removed)
[11:41:56.555]                 for (kk in seq_along(NAMES)) {
[11:41:56.555]                   name <- removed[[kk]]
[11:41:56.555]                   NAME <- NAMES[[kk]]
[11:41:56.555]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:56.555]                     next
[11:41:56.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:56.555]                 }
[11:41:56.555]                 if (length(args) > 0) 
[11:41:56.555]                   base::do.call(base::Sys.setenv, args = args)
[11:41:56.555]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:56.555]             }
[11:41:56.555]             else {
[11:41:56.555]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:56.555]             }
[11:41:56.555]             {
[11:41:56.555]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:56.555]                   0L) {
[11:41:56.555]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:56.555]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:56.555]                   base::options(opts)
[11:41:56.555]                 }
[11:41:56.555]                 {
[11:41:56.555]                   {
[11:41:56.555]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:56.555]                     NULL
[11:41:56.555]                   }
[11:41:56.555]                   options(future.plan = NULL)
[11:41:56.555]                   if (is.na(NA_character_)) 
[11:41:56.555]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:56.555]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:56.555]                   future::plan(list(function (..., workers = 2, 
[11:41:56.555]                     envir = parent.frame()) 
[11:41:56.555]                   strategy(..., workers = workers, envir = envir)), 
[11:41:56.555]                     .cleanup = FALSE, .init = FALSE)
[11:41:56.555]                 }
[11:41:56.555]             }
[11:41:56.555]         }
[11:41:56.555]     })
[11:41:56.555]     if (TRUE) {
[11:41:56.555]         base::sink(type = "output", split = FALSE)
[11:41:56.555]         if (TRUE) {
[11:41:56.555]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:56.555]         }
[11:41:56.555]         else {
[11:41:56.555]             ...future.result["stdout"] <- base::list(NULL)
[11:41:56.555]         }
[11:41:56.555]         base::close(...future.stdout)
[11:41:56.555]         ...future.stdout <- NULL
[11:41:56.555]     }
[11:41:56.555]     ...future.result$conditions <- ...future.conditions
[11:41:56.555]     ...future.result$finished <- base::Sys.time()
[11:41:56.555]     ...future.result
[11:41:56.555] }
[11:41:56.557] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:56.568] receiveMessageFromWorker() for ClusterFuture ...
[11:41:56.568] - Validating connection of MultisessionFuture
[11:41:56.568] - received message: FutureResult
[11:41:56.568] - Received FutureResult
[11:41:56.569] - Erased future from FutureRegistry
[11:41:56.569] result() for ClusterFuture ...
[11:41:56.569] - result already collected: FutureResult
[11:41:56.569] result() for ClusterFuture ... done
[11:41:56.569] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:56.569] result() for ClusterFuture ...
[11:41:56.569] - result already collected: FutureResult
[11:41:56.569] result() for ClusterFuture ... done
[11:41:56.570] result() for ClusterFuture ...
[11:41:56.570] - result already collected: FutureResult
[11:41:56.570] result() for ClusterFuture ... done
[11:41:56.571] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:56.571] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:56.618] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:56.627] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:56.674] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:56.674] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:56.718] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:56.719] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:56.720] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:56.721] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:56.722] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:56.722] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:56.724] MultisessionFuture started
[11:41:56.724] - Launch lazy future ... done
[11:41:56.725] run() for ‘MultisessionFuture’ ... done
[11:41:56.725] Created future:
[11:41:56.725] MultisessionFuture:
[11:41:56.725] Label: ‘future_mapply-60’
[11:41:56.725] Expression:
[11:41:56.725] {
[11:41:56.725]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:56.725]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:56.725]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:56.725]         on.exit(options(oopts), add = TRUE)
[11:41:56.725]     }
[11:41:56.725]     {
[11:41:56.725]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:56.725]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:56.725]                 inherits = FALSE)
[11:41:56.725]             ...future.FUN(...)
[11:41:56.725]         }
[11:41:56.725]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:56.725]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:56.725]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:56.725]         do.call(mapply, args = args)
[11:41:56.725]     }
[11:41:56.725] }
[11:41:56.725] Lazy evaluation: FALSE
[11:41:56.725] Asynchronous evaluation: TRUE
[11:41:56.725] Local evaluation: TRUE
[11:41:56.725] Environment: 0x560ef58e1768
[11:41:56.725] Capture standard output: TRUE
[11:41:56.725] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:56.725] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:56.725] Packages: 1 packages (‘mlr3’)
[11:41:56.725] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:56.725] Resolved: FALSE
[11:41:56.725] Value: <not collected>
[11:41:56.725] Conditions captured: <none>
[11:41:56.725] Early signaling: FALSE
[11:41:56.725] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:56.725] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:56.745] Chunk #60 of 90 ... DONE
[11:41:56.746] Chunk #61 of 90 ...
[11:41:56.746]  - seeds: [1] <seeds>
[11:41:56.746] getGlobalsAndPackages() ...
[11:41:56.746] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:56.746] Resolving globals: FALSE
[11:41:56.747] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:56.747] - packages: [1] ‘mlr3’
[11:41:56.747] getGlobalsAndPackages() ... DONE
[11:41:56.748] run() for ‘Future’ ...
[11:41:56.748] - state: ‘created’
[11:41:56.748] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:56.759] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:56.759] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:56.759]   - Field: ‘node’
[11:41:56.759]   - Field: ‘label’
[11:41:56.760]   - Field: ‘local’
[11:41:56.760]   - Field: ‘owner’
[11:41:56.760]   - Field: ‘envir’
[11:41:56.760]   - Field: ‘workers’
[11:41:56.760]   - Field: ‘packages’
[11:41:56.760]   - Field: ‘gc’
[11:41:56.760]   - Field: ‘conditions’
[11:41:56.760]   - Field: ‘persistent’
[11:41:56.760]   - Field: ‘expr’
[11:41:56.760]   - Field: ‘uuid’
[11:41:56.760]   - Field: ‘seed’
[11:41:56.760]   - Field: ‘version’
[11:41:56.760]   - Field: ‘result’
[11:41:56.760]   - Field: ‘asynchronous’
[11:41:56.760]   - Field: ‘calls’
[11:41:56.760]   - Field: ‘globals’
[11:41:56.760]   - Field: ‘stdout’
[11:41:56.760]   - Field: ‘earlySignal’
[11:41:56.760]   - Field: ‘lazy’
[11:41:56.761]   - Field: ‘state’
[11:41:56.761] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:56.761] - Launch lazy future ...
[11:41:56.761] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:56.761] Packages needed by future strategies (n = 0): <none>
[11:41:56.761] {
[11:41:56.761]     {
[11:41:56.761]         {
[11:41:56.761]             ...future.startTime <- base::Sys.time()
[11:41:56.761]             {
[11:41:56.761]                 {
[11:41:56.761]                   {
[11:41:56.761]                     {
[11:41:56.761]                       {
[11:41:56.761]                         base::local({
[11:41:56.761]                           has_future <- base::requireNamespace("future", 
[11:41:56.761]                             quietly = TRUE)
[11:41:56.761]                           if (has_future) {
[11:41:56.761]                             ns <- base::getNamespace("future")
[11:41:56.761]                             version <- ns[[".package"]][["version"]]
[11:41:56.761]                             if (is.null(version)) 
[11:41:56.761]                               version <- utils::packageVersion("future")
[11:41:56.761]                           }
[11:41:56.761]                           else {
[11:41:56.761]                             version <- NULL
[11:41:56.761]                           }
[11:41:56.761]                           if (!has_future || version < "1.8.0") {
[11:41:56.761]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:56.761]                               "", base::R.version$version.string), 
[11:41:56.761]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:56.761]                                 base::R.version$platform, 8 * 
[11:41:56.761]                                   base::.Machine$sizeof.pointer), 
[11:41:56.761]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:56.761]                                 "release", "version")], collapse = " "), 
[11:41:56.761]                               hostname = base::Sys.info()[["nodename"]])
[11:41:56.761]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:56.761]                               info)
[11:41:56.761]                             info <- base::paste(info, collapse = "; ")
[11:41:56.761]                             if (!has_future) {
[11:41:56.761]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:56.761]                                 info)
[11:41:56.761]                             }
[11:41:56.761]                             else {
[11:41:56.761]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:56.761]                                 info, version)
[11:41:56.761]                             }
[11:41:56.761]                             base::stop(msg)
[11:41:56.761]                           }
[11:41:56.761]                         })
[11:41:56.761]                       }
[11:41:56.761]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:56.761]                       base::options(mc.cores = 1L)
[11:41:56.761]                     }
[11:41:56.761]                     base::local({
[11:41:56.761]                       for (pkg in "mlr3") {
[11:41:56.761]                         base::loadNamespace(pkg)
[11:41:56.761]                         base::library(pkg, character.only = TRUE)
[11:41:56.761]                       }
[11:41:56.761]                     })
[11:41:56.761]                   }
[11:41:56.761]                   options(future.plan = NULL)
[11:41:56.761]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:56.761]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:56.761]                 }
[11:41:56.761]                 ...future.workdir <- getwd()
[11:41:56.761]             }
[11:41:56.761]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:56.761]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:56.761]         }
[11:41:56.761]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:56.761]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:56.761]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:56.761]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:56.761]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:56.761]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:56.761]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:56.761]             base::names(...future.oldOptions))
[11:41:56.761]     }
[11:41:56.761]     if (FALSE) {
[11:41:56.761]     }
[11:41:56.761]     else {
[11:41:56.761]         if (TRUE) {
[11:41:56.761]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:56.761]                 open = "w")
[11:41:56.761]         }
[11:41:56.761]         else {
[11:41:56.761]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:56.761]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:56.761]         }
[11:41:56.761]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:56.761]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:56.761]             base::sink(type = "output", split = FALSE)
[11:41:56.761]             base::close(...future.stdout)
[11:41:56.761]         }, add = TRUE)
[11:41:56.761]     }
[11:41:56.761]     ...future.frame <- base::sys.nframe()
[11:41:56.761]     ...future.conditions <- base::list()
[11:41:56.761]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:56.761]     if (FALSE) {
[11:41:56.761]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:56.761]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:56.761]     }
[11:41:56.761]     ...future.result <- base::tryCatch({
[11:41:56.761]         base::withCallingHandlers({
[11:41:56.761]             ...future.value <- base::withVisible(base::local({
[11:41:56.761]                 ...future.makeSendCondition <- local({
[11:41:56.761]                   sendCondition <- NULL
[11:41:56.761]                   function(frame = 1L) {
[11:41:56.761]                     if (is.function(sendCondition)) 
[11:41:56.761]                       return(sendCondition)
[11:41:56.761]                     ns <- getNamespace("parallel")
[11:41:56.761]                     if (exists("sendData", mode = "function", 
[11:41:56.761]                       envir = ns)) {
[11:41:56.761]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:56.761]                         envir = ns)
[11:41:56.761]                       envir <- sys.frame(frame)
[11:41:56.761]                       master <- NULL
[11:41:56.761]                       while (!identical(envir, .GlobalEnv) && 
[11:41:56.761]                         !identical(envir, emptyenv())) {
[11:41:56.761]                         if (exists("master", mode = "list", envir = envir, 
[11:41:56.761]                           inherits = FALSE)) {
[11:41:56.761]                           master <- get("master", mode = "list", 
[11:41:56.761]                             envir = envir, inherits = FALSE)
[11:41:56.761]                           if (inherits(master, c("SOCKnode", 
[11:41:56.761]                             "SOCK0node"))) {
[11:41:56.761]                             sendCondition <<- function(cond) {
[11:41:56.761]                               data <- list(type = "VALUE", value = cond, 
[11:41:56.761]                                 success = TRUE)
[11:41:56.761]                               parallel_sendData(master, data)
[11:41:56.761]                             }
[11:41:56.761]                             return(sendCondition)
[11:41:56.761]                           }
[11:41:56.761]                         }
[11:41:56.761]                         frame <- frame + 1L
[11:41:56.761]                         envir <- sys.frame(frame)
[11:41:56.761]                       }
[11:41:56.761]                     }
[11:41:56.761]                     sendCondition <<- function(cond) NULL
[11:41:56.761]                   }
[11:41:56.761]                 })
[11:41:56.761]                 withCallingHandlers({
[11:41:56.761]                   {
[11:41:56.761]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:56.761]                     if (!identical(...future.globals.maxSize.org, 
[11:41:56.761]                       ...future.globals.maxSize)) {
[11:41:56.761]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:56.761]                       on.exit(options(oopts), add = TRUE)
[11:41:56.761]                     }
[11:41:56.761]                     {
[11:41:56.761]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:56.761]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:56.761]                           envir = globalenv(), inherits = FALSE)
[11:41:56.761]                         ...future.FUN(...)
[11:41:56.761]                       }
[11:41:56.761]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:56.761]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:56.761]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:56.761]                         USE.NAMES = FALSE)
[11:41:56.761]                       do.call(mapply, args = args)
[11:41:56.761]                     }
[11:41:56.761]                   }
[11:41:56.761]                 }, immediateCondition = function(cond) {
[11:41:56.761]                   sendCondition <- ...future.makeSendCondition()
[11:41:56.761]                   sendCondition(cond)
[11:41:56.761]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:56.761]                   {
[11:41:56.761]                     inherits <- base::inherits
[11:41:56.761]                     invokeRestart <- base::invokeRestart
[11:41:56.761]                     is.null <- base::is.null
[11:41:56.761]                     muffled <- FALSE
[11:41:56.761]                     if (inherits(cond, "message")) {
[11:41:56.761]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:56.761]                       if (muffled) 
[11:41:56.761]                         invokeRestart("muffleMessage")
[11:41:56.761]                     }
[11:41:56.761]                     else if (inherits(cond, "warning")) {
[11:41:56.761]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:56.761]                       if (muffled) 
[11:41:56.761]                         invokeRestart("muffleWarning")
[11:41:56.761]                     }
[11:41:56.761]                     else if (inherits(cond, "condition")) {
[11:41:56.761]                       if (!is.null(pattern)) {
[11:41:56.761]                         computeRestarts <- base::computeRestarts
[11:41:56.761]                         grepl <- base::grepl
[11:41:56.761]                         restarts <- computeRestarts(cond)
[11:41:56.761]                         for (restart in restarts) {
[11:41:56.761]                           name <- restart$name
[11:41:56.761]                           if (is.null(name)) 
[11:41:56.761]                             next
[11:41:56.761]                           if (!grepl(pattern, name)) 
[11:41:56.761]                             next
[11:41:56.761]                           invokeRestart(restart)
[11:41:56.761]                           muffled <- TRUE
[11:41:56.761]                           break
[11:41:56.761]                         }
[11:41:56.761]                       }
[11:41:56.761]                     }
[11:41:56.761]                     invisible(muffled)
[11:41:56.761]                   }
[11:41:56.761]                   muffleCondition(cond)
[11:41:56.761]                 })
[11:41:56.761]             }))
[11:41:56.761]             future::FutureResult(value = ...future.value$value, 
[11:41:56.761]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:56.761]                   ...future.rng), globalenv = if (FALSE) 
[11:41:56.761]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:56.761]                     ...future.globalenv.names))
[11:41:56.761]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:56.761]         }, condition = base::local({
[11:41:56.761]             c <- base::c
[11:41:56.761]             inherits <- base::inherits
[11:41:56.761]             invokeRestart <- base::invokeRestart
[11:41:56.761]             length <- base::length
[11:41:56.761]             list <- base::list
[11:41:56.761]             seq.int <- base::seq.int
[11:41:56.761]             signalCondition <- base::signalCondition
[11:41:56.761]             sys.calls <- base::sys.calls
[11:41:56.761]             `[[` <- base::`[[`
[11:41:56.761]             `+` <- base::`+`
[11:41:56.761]             `<<-` <- base::`<<-`
[11:41:56.761]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:56.761]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:56.761]                   3L)]
[11:41:56.761]             }
[11:41:56.761]             function(cond) {
[11:41:56.761]                 is_error <- inherits(cond, "error")
[11:41:56.761]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:56.761]                   NULL)
[11:41:56.761]                 if (is_error) {
[11:41:56.761]                   sessionInformation <- function() {
[11:41:56.761]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:56.761]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:56.761]                       search = base::search(), system = base::Sys.info())
[11:41:56.761]                   }
[11:41:56.761]                   ...future.conditions[[length(...future.conditions) + 
[11:41:56.761]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:56.761]                     cond$call), session = sessionInformation(), 
[11:41:56.761]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:56.761]                   signalCondition(cond)
[11:41:56.761]                 }
[11:41:56.761]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:56.761]                 "immediateCondition"))) {
[11:41:56.761]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:56.761]                   ...future.conditions[[length(...future.conditions) + 
[11:41:56.761]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:56.761]                   if (TRUE && !signal) {
[11:41:56.761]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:56.761]                     {
[11:41:56.761]                       inherits <- base::inherits
[11:41:56.761]                       invokeRestart <- base::invokeRestart
[11:41:56.761]                       is.null <- base::is.null
[11:41:56.761]                       muffled <- FALSE
[11:41:56.761]                       if (inherits(cond, "message")) {
[11:41:56.761]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:56.761]                         if (muffled) 
[11:41:56.761]                           invokeRestart("muffleMessage")
[11:41:56.761]                       }
[11:41:56.761]                       else if (inherits(cond, "warning")) {
[11:41:56.761]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:56.761]                         if (muffled) 
[11:41:56.761]                           invokeRestart("muffleWarning")
[11:41:56.761]                       }
[11:41:56.761]                       else if (inherits(cond, "condition")) {
[11:41:56.761]                         if (!is.null(pattern)) {
[11:41:56.761]                           computeRestarts <- base::computeRestarts
[11:41:56.761]                           grepl <- base::grepl
[11:41:56.761]                           restarts <- computeRestarts(cond)
[11:41:56.761]                           for (restart in restarts) {
[11:41:56.761]                             name <- restart$name
[11:41:56.761]                             if (is.null(name)) 
[11:41:56.761]                               next
[11:41:56.761]                             if (!grepl(pattern, name)) 
[11:41:56.761]                               next
[11:41:56.761]                             invokeRestart(restart)
[11:41:56.761]                             muffled <- TRUE
[11:41:56.761]                             break
[11:41:56.761]                           }
[11:41:56.761]                         }
[11:41:56.761]                       }
[11:41:56.761]                       invisible(muffled)
[11:41:56.761]                     }
[11:41:56.761]                     muffleCondition(cond, pattern = "^muffle")
[11:41:56.761]                   }
[11:41:56.761]                 }
[11:41:56.761]                 else {
[11:41:56.761]                   if (TRUE) {
[11:41:56.761]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:56.761]                     {
[11:41:56.761]                       inherits <- base::inherits
[11:41:56.761]                       invokeRestart <- base::invokeRestart
[11:41:56.761]                       is.null <- base::is.null
[11:41:56.761]                       muffled <- FALSE
[11:41:56.761]                       if (inherits(cond, "message")) {
[11:41:56.761]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:56.761]                         if (muffled) 
[11:41:56.761]                           invokeRestart("muffleMessage")
[11:41:56.761]                       }
[11:41:56.761]                       else if (inherits(cond, "warning")) {
[11:41:56.761]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:56.761]                         if (muffled) 
[11:41:56.761]                           invokeRestart("muffleWarning")
[11:41:56.761]                       }
[11:41:56.761]                       else if (inherits(cond, "condition")) {
[11:41:56.761]                         if (!is.null(pattern)) {
[11:41:56.761]                           computeRestarts <- base::computeRestarts
[11:41:56.761]                           grepl <- base::grepl
[11:41:56.761]                           restarts <- computeRestarts(cond)
[11:41:56.761]                           for (restart in restarts) {
[11:41:56.761]                             name <- restart$name
[11:41:56.761]                             if (is.null(name)) 
[11:41:56.761]                               next
[11:41:56.761]                             if (!grepl(pattern, name)) 
[11:41:56.761]                               next
[11:41:56.761]                             invokeRestart(restart)
[11:41:56.761]                             muffled <- TRUE
[11:41:56.761]                             break
[11:41:56.761]                           }
[11:41:56.761]                         }
[11:41:56.761]                       }
[11:41:56.761]                       invisible(muffled)
[11:41:56.761]                     }
[11:41:56.761]                     muffleCondition(cond, pattern = "^muffle")
[11:41:56.761]                   }
[11:41:56.761]                 }
[11:41:56.761]             }
[11:41:56.761]         }))
[11:41:56.761]     }, error = function(ex) {
[11:41:56.761]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:56.761]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:56.761]                 ...future.rng), started = ...future.startTime, 
[11:41:56.761]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:56.761]             version = "1.8"), class = "FutureResult")
[11:41:56.761]     }, finally = {
[11:41:56.761]         if (!identical(...future.workdir, getwd())) 
[11:41:56.761]             setwd(...future.workdir)
[11:41:56.761]         {
[11:41:56.761]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:56.761]                 ...future.oldOptions$nwarnings <- NULL
[11:41:56.761]             }
[11:41:56.761]             base::options(...future.oldOptions)
[11:41:56.761]             if (.Platform$OS.type == "windows") {
[11:41:56.761]                 old_names <- names(...future.oldEnvVars)
[11:41:56.761]                 envs <- base::Sys.getenv()
[11:41:56.761]                 names <- names(envs)
[11:41:56.761]                 common <- intersect(names, old_names)
[11:41:56.761]                 added <- setdiff(names, old_names)
[11:41:56.761]                 removed <- setdiff(old_names, names)
[11:41:56.761]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:56.761]                   envs[common]]
[11:41:56.761]                 NAMES <- toupper(changed)
[11:41:56.761]                 args <- list()
[11:41:56.761]                 for (kk in seq_along(NAMES)) {
[11:41:56.761]                   name <- changed[[kk]]
[11:41:56.761]                   NAME <- NAMES[[kk]]
[11:41:56.761]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:56.761]                     next
[11:41:56.761]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:56.761]                 }
[11:41:56.761]                 NAMES <- toupper(added)
[11:41:56.761]                 for (kk in seq_along(NAMES)) {
[11:41:56.761]                   name <- added[[kk]]
[11:41:56.761]                   NAME <- NAMES[[kk]]
[11:41:56.761]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:56.761]                     next
[11:41:56.761]                   args[[name]] <- ""
[11:41:56.761]                 }
[11:41:56.761]                 NAMES <- toupper(removed)
[11:41:56.761]                 for (kk in seq_along(NAMES)) {
[11:41:56.761]                   name <- removed[[kk]]
[11:41:56.761]                   NAME <- NAMES[[kk]]
[11:41:56.761]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:56.761]                     next
[11:41:56.761]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:56.761]                 }
[11:41:56.761]                 if (length(args) > 0) 
[11:41:56.761]                   base::do.call(base::Sys.setenv, args = args)
[11:41:56.761]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:56.761]             }
[11:41:56.761]             else {
[11:41:56.761]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:56.761]             }
[11:41:56.761]             {
[11:41:56.761]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:56.761]                   0L) {
[11:41:56.761]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:56.761]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:56.761]                   base::options(opts)
[11:41:56.761]                 }
[11:41:56.761]                 {
[11:41:56.761]                   {
[11:41:56.761]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:56.761]                     NULL
[11:41:56.761]                   }
[11:41:56.761]                   options(future.plan = NULL)
[11:41:56.761]                   if (is.na(NA_character_)) 
[11:41:56.761]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:56.761]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:56.761]                   future::plan(list(function (..., workers = 2, 
[11:41:56.761]                     envir = parent.frame()) 
[11:41:56.761]                   strategy(..., workers = workers, envir = envir)), 
[11:41:56.761]                     .cleanup = FALSE, .init = FALSE)
[11:41:56.761]                 }
[11:41:56.761]             }
[11:41:56.761]         }
[11:41:56.761]     })
[11:41:56.761]     if (TRUE) {
[11:41:56.761]         base::sink(type = "output", split = FALSE)
[11:41:56.761]         if (TRUE) {
[11:41:56.761]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:56.761]         }
[11:41:56.761]         else {
[11:41:56.761]             ...future.result["stdout"] <- base::list(NULL)
[11:41:56.761]         }
[11:41:56.761]         base::close(...future.stdout)
[11:41:56.761]         ...future.stdout <- NULL
[11:41:56.761]     }
[11:41:56.761]     ...future.result$conditions <- ...future.conditions
[11:41:56.761]     ...future.result$finished <- base::Sys.time()
[11:41:56.761]     ...future.result
[11:41:56.761] }
[11:41:56.763] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:56.775] receiveMessageFromWorker() for ClusterFuture ...
[11:41:56.775] - Validating connection of MultisessionFuture
[11:41:56.776] - received message: FutureResult
[11:41:56.776] - Received FutureResult
[11:41:56.776] - Erased future from FutureRegistry
[11:41:56.777] result() for ClusterFuture ...
[11:41:56.777] - result already collected: FutureResult
[11:41:56.777] result() for ClusterFuture ... done
[11:41:56.777] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:56.777] result() for ClusterFuture ...
[11:41:56.777] - result already collected: FutureResult
[11:41:56.777] result() for ClusterFuture ... done
[11:41:56.777] result() for ClusterFuture ...
[11:41:56.777] - result already collected: FutureResult
[11:41:56.777] result() for ClusterFuture ... done
[11:41:56.778] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:56.779] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:56.822] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:56.827] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:56.870] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:56.871] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:56.918] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:56.919] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:56.921] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:56.921] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:56.922] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:56.923] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:56.924] MultisessionFuture started
[11:41:56.924] - Launch lazy future ... done
[11:41:56.924] run() for ‘MultisessionFuture’ ... done
[11:41:56.925] Created future:
[11:41:56.925] MultisessionFuture:
[11:41:56.925] Label: ‘future_mapply-61’
[11:41:56.925] Expression:
[11:41:56.925] {
[11:41:56.925]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:56.925]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:56.925]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:56.925]         on.exit(options(oopts), add = TRUE)
[11:41:56.925]     }
[11:41:56.925]     {
[11:41:56.925]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:56.925]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:56.925]                 inherits = FALSE)
[11:41:56.925]             ...future.FUN(...)
[11:41:56.925]         }
[11:41:56.925]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:56.925]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:56.925]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:56.925]         do.call(mapply, args = args)
[11:41:56.925]     }
[11:41:56.925] }
[11:41:56.925] Lazy evaluation: FALSE
[11:41:56.925] Asynchronous evaluation: TRUE
[11:41:56.925] Local evaluation: TRUE
[11:41:56.925] Environment: 0x560ef58e1768
[11:41:56.925] Capture standard output: TRUE
[11:41:56.925] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:56.925] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:56.925] Packages: 1 packages (‘mlr3’)
[11:41:56.925] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:56.925] Resolved: FALSE
[11:41:56.925] Value: <not collected>
[11:41:56.925] Conditions captured: <none>
[11:41:56.925] Early signaling: FALSE
[11:41:56.925] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:56.925] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:56.943] Chunk #61 of 90 ... DONE
[11:41:56.943] Chunk #62 of 90 ...
[11:41:56.943]  - seeds: [1] <seeds>
[11:41:56.943] getGlobalsAndPackages() ...
[11:41:56.943] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:56.944] Resolving globals: FALSE
[11:41:56.944] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:56.944] - packages: [1] ‘mlr3’
[11:41:56.944] getGlobalsAndPackages() ... DONE
[11:41:56.945] run() for ‘Future’ ...
[11:41:56.945] - state: ‘created’
[11:41:56.945] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:56.955] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:56.955] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:56.955]   - Field: ‘node’
[11:41:56.955]   - Field: ‘label’
[11:41:56.955]   - Field: ‘local’
[11:41:56.955]   - Field: ‘owner’
[11:41:56.955]   - Field: ‘envir’
[11:41:56.955]   - Field: ‘workers’
[11:41:56.956]   - Field: ‘packages’
[11:41:56.956]   - Field: ‘gc’
[11:41:56.956]   - Field: ‘conditions’
[11:41:56.956]   - Field: ‘persistent’
[11:41:56.956]   - Field: ‘expr’
[11:41:56.956]   - Field: ‘uuid’
[11:41:56.956]   - Field: ‘seed’
[11:41:56.956]   - Field: ‘version’
[11:41:56.956]   - Field: ‘result’
[11:41:56.956]   - Field: ‘asynchronous’
[11:41:56.956]   - Field: ‘calls’
[11:41:56.956]   - Field: ‘globals’
[11:41:56.956]   - Field: ‘stdout’
[11:41:56.956]   - Field: ‘earlySignal’
[11:41:56.956]   - Field: ‘lazy’
[11:41:56.956]   - Field: ‘state’
[11:41:56.956] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:56.956] - Launch lazy future ...
[11:41:56.957] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:56.957] Packages needed by future strategies (n = 0): <none>
[11:41:56.957] {
[11:41:56.957]     {
[11:41:56.957]         {
[11:41:56.957]             ...future.startTime <- base::Sys.time()
[11:41:56.957]             {
[11:41:56.957]                 {
[11:41:56.957]                   {
[11:41:56.957]                     {
[11:41:56.957]                       {
[11:41:56.957]                         base::local({
[11:41:56.957]                           has_future <- base::requireNamespace("future", 
[11:41:56.957]                             quietly = TRUE)
[11:41:56.957]                           if (has_future) {
[11:41:56.957]                             ns <- base::getNamespace("future")
[11:41:56.957]                             version <- ns[[".package"]][["version"]]
[11:41:56.957]                             if (is.null(version)) 
[11:41:56.957]                               version <- utils::packageVersion("future")
[11:41:56.957]                           }
[11:41:56.957]                           else {
[11:41:56.957]                             version <- NULL
[11:41:56.957]                           }
[11:41:56.957]                           if (!has_future || version < "1.8.0") {
[11:41:56.957]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:56.957]                               "", base::R.version$version.string), 
[11:41:56.957]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:56.957]                                 base::R.version$platform, 8 * 
[11:41:56.957]                                   base::.Machine$sizeof.pointer), 
[11:41:56.957]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:56.957]                                 "release", "version")], collapse = " "), 
[11:41:56.957]                               hostname = base::Sys.info()[["nodename"]])
[11:41:56.957]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:56.957]                               info)
[11:41:56.957]                             info <- base::paste(info, collapse = "; ")
[11:41:56.957]                             if (!has_future) {
[11:41:56.957]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:56.957]                                 info)
[11:41:56.957]                             }
[11:41:56.957]                             else {
[11:41:56.957]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:56.957]                                 info, version)
[11:41:56.957]                             }
[11:41:56.957]                             base::stop(msg)
[11:41:56.957]                           }
[11:41:56.957]                         })
[11:41:56.957]                       }
[11:41:56.957]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:56.957]                       base::options(mc.cores = 1L)
[11:41:56.957]                     }
[11:41:56.957]                     base::local({
[11:41:56.957]                       for (pkg in "mlr3") {
[11:41:56.957]                         base::loadNamespace(pkg)
[11:41:56.957]                         base::library(pkg, character.only = TRUE)
[11:41:56.957]                       }
[11:41:56.957]                     })
[11:41:56.957]                   }
[11:41:56.957]                   options(future.plan = NULL)
[11:41:56.957]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:56.957]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:56.957]                 }
[11:41:56.957]                 ...future.workdir <- getwd()
[11:41:56.957]             }
[11:41:56.957]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:56.957]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:56.957]         }
[11:41:56.957]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:56.957]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:56.957]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:56.957]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:56.957]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:56.957]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:56.957]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:56.957]             base::names(...future.oldOptions))
[11:41:56.957]     }
[11:41:56.957]     if (FALSE) {
[11:41:56.957]     }
[11:41:56.957]     else {
[11:41:56.957]         if (TRUE) {
[11:41:56.957]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:56.957]                 open = "w")
[11:41:56.957]         }
[11:41:56.957]         else {
[11:41:56.957]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:56.957]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:56.957]         }
[11:41:56.957]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:56.957]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:56.957]             base::sink(type = "output", split = FALSE)
[11:41:56.957]             base::close(...future.stdout)
[11:41:56.957]         }, add = TRUE)
[11:41:56.957]     }
[11:41:56.957]     ...future.frame <- base::sys.nframe()
[11:41:56.957]     ...future.conditions <- base::list()
[11:41:56.957]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:56.957]     if (FALSE) {
[11:41:56.957]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:56.957]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:56.957]     }
[11:41:56.957]     ...future.result <- base::tryCatch({
[11:41:56.957]         base::withCallingHandlers({
[11:41:56.957]             ...future.value <- base::withVisible(base::local({
[11:41:56.957]                 ...future.makeSendCondition <- local({
[11:41:56.957]                   sendCondition <- NULL
[11:41:56.957]                   function(frame = 1L) {
[11:41:56.957]                     if (is.function(sendCondition)) 
[11:41:56.957]                       return(sendCondition)
[11:41:56.957]                     ns <- getNamespace("parallel")
[11:41:56.957]                     if (exists("sendData", mode = "function", 
[11:41:56.957]                       envir = ns)) {
[11:41:56.957]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:56.957]                         envir = ns)
[11:41:56.957]                       envir <- sys.frame(frame)
[11:41:56.957]                       master <- NULL
[11:41:56.957]                       while (!identical(envir, .GlobalEnv) && 
[11:41:56.957]                         !identical(envir, emptyenv())) {
[11:41:56.957]                         if (exists("master", mode = "list", envir = envir, 
[11:41:56.957]                           inherits = FALSE)) {
[11:41:56.957]                           master <- get("master", mode = "list", 
[11:41:56.957]                             envir = envir, inherits = FALSE)
[11:41:56.957]                           if (inherits(master, c("SOCKnode", 
[11:41:56.957]                             "SOCK0node"))) {
[11:41:56.957]                             sendCondition <<- function(cond) {
[11:41:56.957]                               data <- list(type = "VALUE", value = cond, 
[11:41:56.957]                                 success = TRUE)
[11:41:56.957]                               parallel_sendData(master, data)
[11:41:56.957]                             }
[11:41:56.957]                             return(sendCondition)
[11:41:56.957]                           }
[11:41:56.957]                         }
[11:41:56.957]                         frame <- frame + 1L
[11:41:56.957]                         envir <- sys.frame(frame)
[11:41:56.957]                       }
[11:41:56.957]                     }
[11:41:56.957]                     sendCondition <<- function(cond) NULL
[11:41:56.957]                   }
[11:41:56.957]                 })
[11:41:56.957]                 withCallingHandlers({
[11:41:56.957]                   {
[11:41:56.957]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:56.957]                     if (!identical(...future.globals.maxSize.org, 
[11:41:56.957]                       ...future.globals.maxSize)) {
[11:41:56.957]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:56.957]                       on.exit(options(oopts), add = TRUE)
[11:41:56.957]                     }
[11:41:56.957]                     {
[11:41:56.957]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:56.957]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:56.957]                           envir = globalenv(), inherits = FALSE)
[11:41:56.957]                         ...future.FUN(...)
[11:41:56.957]                       }
[11:41:56.957]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:56.957]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:56.957]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:56.957]                         USE.NAMES = FALSE)
[11:41:56.957]                       do.call(mapply, args = args)
[11:41:56.957]                     }
[11:41:56.957]                   }
[11:41:56.957]                 }, immediateCondition = function(cond) {
[11:41:56.957]                   sendCondition <- ...future.makeSendCondition()
[11:41:56.957]                   sendCondition(cond)
[11:41:56.957]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:56.957]                   {
[11:41:56.957]                     inherits <- base::inherits
[11:41:56.957]                     invokeRestart <- base::invokeRestart
[11:41:56.957]                     is.null <- base::is.null
[11:41:56.957]                     muffled <- FALSE
[11:41:56.957]                     if (inherits(cond, "message")) {
[11:41:56.957]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:56.957]                       if (muffled) 
[11:41:56.957]                         invokeRestart("muffleMessage")
[11:41:56.957]                     }
[11:41:56.957]                     else if (inherits(cond, "warning")) {
[11:41:56.957]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:56.957]                       if (muffled) 
[11:41:56.957]                         invokeRestart("muffleWarning")
[11:41:56.957]                     }
[11:41:56.957]                     else if (inherits(cond, "condition")) {
[11:41:56.957]                       if (!is.null(pattern)) {
[11:41:56.957]                         computeRestarts <- base::computeRestarts
[11:41:56.957]                         grepl <- base::grepl
[11:41:56.957]                         restarts <- computeRestarts(cond)
[11:41:56.957]                         for (restart in restarts) {
[11:41:56.957]                           name <- restart$name
[11:41:56.957]                           if (is.null(name)) 
[11:41:56.957]                             next
[11:41:56.957]                           if (!grepl(pattern, name)) 
[11:41:56.957]                             next
[11:41:56.957]                           invokeRestart(restart)
[11:41:56.957]                           muffled <- TRUE
[11:41:56.957]                           break
[11:41:56.957]                         }
[11:41:56.957]                       }
[11:41:56.957]                     }
[11:41:56.957]                     invisible(muffled)
[11:41:56.957]                   }
[11:41:56.957]                   muffleCondition(cond)
[11:41:56.957]                 })
[11:41:56.957]             }))
[11:41:56.957]             future::FutureResult(value = ...future.value$value, 
[11:41:56.957]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:56.957]                   ...future.rng), globalenv = if (FALSE) 
[11:41:56.957]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:56.957]                     ...future.globalenv.names))
[11:41:56.957]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:56.957]         }, condition = base::local({
[11:41:56.957]             c <- base::c
[11:41:56.957]             inherits <- base::inherits
[11:41:56.957]             invokeRestart <- base::invokeRestart
[11:41:56.957]             length <- base::length
[11:41:56.957]             list <- base::list
[11:41:56.957]             seq.int <- base::seq.int
[11:41:56.957]             signalCondition <- base::signalCondition
[11:41:56.957]             sys.calls <- base::sys.calls
[11:41:56.957]             `[[` <- base::`[[`
[11:41:56.957]             `+` <- base::`+`
[11:41:56.957]             `<<-` <- base::`<<-`
[11:41:56.957]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:56.957]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:56.957]                   3L)]
[11:41:56.957]             }
[11:41:56.957]             function(cond) {
[11:41:56.957]                 is_error <- inherits(cond, "error")
[11:41:56.957]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:56.957]                   NULL)
[11:41:56.957]                 if (is_error) {
[11:41:56.957]                   sessionInformation <- function() {
[11:41:56.957]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:56.957]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:56.957]                       search = base::search(), system = base::Sys.info())
[11:41:56.957]                   }
[11:41:56.957]                   ...future.conditions[[length(...future.conditions) + 
[11:41:56.957]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:56.957]                     cond$call), session = sessionInformation(), 
[11:41:56.957]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:56.957]                   signalCondition(cond)
[11:41:56.957]                 }
[11:41:56.957]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:56.957]                 "immediateCondition"))) {
[11:41:56.957]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:56.957]                   ...future.conditions[[length(...future.conditions) + 
[11:41:56.957]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:56.957]                   if (TRUE && !signal) {
[11:41:56.957]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:56.957]                     {
[11:41:56.957]                       inherits <- base::inherits
[11:41:56.957]                       invokeRestart <- base::invokeRestart
[11:41:56.957]                       is.null <- base::is.null
[11:41:56.957]                       muffled <- FALSE
[11:41:56.957]                       if (inherits(cond, "message")) {
[11:41:56.957]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:56.957]                         if (muffled) 
[11:41:56.957]                           invokeRestart("muffleMessage")
[11:41:56.957]                       }
[11:41:56.957]                       else if (inherits(cond, "warning")) {
[11:41:56.957]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:56.957]                         if (muffled) 
[11:41:56.957]                           invokeRestart("muffleWarning")
[11:41:56.957]                       }
[11:41:56.957]                       else if (inherits(cond, "condition")) {
[11:41:56.957]                         if (!is.null(pattern)) {
[11:41:56.957]                           computeRestarts <- base::computeRestarts
[11:41:56.957]                           grepl <- base::grepl
[11:41:56.957]                           restarts <- computeRestarts(cond)
[11:41:56.957]                           for (restart in restarts) {
[11:41:56.957]                             name <- restart$name
[11:41:56.957]                             if (is.null(name)) 
[11:41:56.957]                               next
[11:41:56.957]                             if (!grepl(pattern, name)) 
[11:41:56.957]                               next
[11:41:56.957]                             invokeRestart(restart)
[11:41:56.957]                             muffled <- TRUE
[11:41:56.957]                             break
[11:41:56.957]                           }
[11:41:56.957]                         }
[11:41:56.957]                       }
[11:41:56.957]                       invisible(muffled)
[11:41:56.957]                     }
[11:41:56.957]                     muffleCondition(cond, pattern = "^muffle")
[11:41:56.957]                   }
[11:41:56.957]                 }
[11:41:56.957]                 else {
[11:41:56.957]                   if (TRUE) {
[11:41:56.957]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:56.957]                     {
[11:41:56.957]                       inherits <- base::inherits
[11:41:56.957]                       invokeRestart <- base::invokeRestart
[11:41:56.957]                       is.null <- base::is.null
[11:41:56.957]                       muffled <- FALSE
[11:41:56.957]                       if (inherits(cond, "message")) {
[11:41:56.957]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:56.957]                         if (muffled) 
[11:41:56.957]                           invokeRestart("muffleMessage")
[11:41:56.957]                       }
[11:41:56.957]                       else if (inherits(cond, "warning")) {
[11:41:56.957]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:56.957]                         if (muffled) 
[11:41:56.957]                           invokeRestart("muffleWarning")
[11:41:56.957]                       }
[11:41:56.957]                       else if (inherits(cond, "condition")) {
[11:41:56.957]                         if (!is.null(pattern)) {
[11:41:56.957]                           computeRestarts <- base::computeRestarts
[11:41:56.957]                           grepl <- base::grepl
[11:41:56.957]                           restarts <- computeRestarts(cond)
[11:41:56.957]                           for (restart in restarts) {
[11:41:56.957]                             name <- restart$name
[11:41:56.957]                             if (is.null(name)) 
[11:41:56.957]                               next
[11:41:56.957]                             if (!grepl(pattern, name)) 
[11:41:56.957]                               next
[11:41:56.957]                             invokeRestart(restart)
[11:41:56.957]                             muffled <- TRUE
[11:41:56.957]                             break
[11:41:56.957]                           }
[11:41:56.957]                         }
[11:41:56.957]                       }
[11:41:56.957]                       invisible(muffled)
[11:41:56.957]                     }
[11:41:56.957]                     muffleCondition(cond, pattern = "^muffle")
[11:41:56.957]                   }
[11:41:56.957]                 }
[11:41:56.957]             }
[11:41:56.957]         }))
[11:41:56.957]     }, error = function(ex) {
[11:41:56.957]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:56.957]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:56.957]                 ...future.rng), started = ...future.startTime, 
[11:41:56.957]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:56.957]             version = "1.8"), class = "FutureResult")
[11:41:56.957]     }, finally = {
[11:41:56.957]         if (!identical(...future.workdir, getwd())) 
[11:41:56.957]             setwd(...future.workdir)
[11:41:56.957]         {
[11:41:56.957]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:56.957]                 ...future.oldOptions$nwarnings <- NULL
[11:41:56.957]             }
[11:41:56.957]             base::options(...future.oldOptions)
[11:41:56.957]             if (.Platform$OS.type == "windows") {
[11:41:56.957]                 old_names <- names(...future.oldEnvVars)
[11:41:56.957]                 envs <- base::Sys.getenv()
[11:41:56.957]                 names <- names(envs)
[11:41:56.957]                 common <- intersect(names, old_names)
[11:41:56.957]                 added <- setdiff(names, old_names)
[11:41:56.957]                 removed <- setdiff(old_names, names)
[11:41:56.957]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:56.957]                   envs[common]]
[11:41:56.957]                 NAMES <- toupper(changed)
[11:41:56.957]                 args <- list()
[11:41:56.957]                 for (kk in seq_along(NAMES)) {
[11:41:56.957]                   name <- changed[[kk]]
[11:41:56.957]                   NAME <- NAMES[[kk]]
[11:41:56.957]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:56.957]                     next
[11:41:56.957]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:56.957]                 }
[11:41:56.957]                 NAMES <- toupper(added)
[11:41:56.957]                 for (kk in seq_along(NAMES)) {
[11:41:56.957]                   name <- added[[kk]]
[11:41:56.957]                   NAME <- NAMES[[kk]]
[11:41:56.957]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:56.957]                     next
[11:41:56.957]                   args[[name]] <- ""
[11:41:56.957]                 }
[11:41:56.957]                 NAMES <- toupper(removed)
[11:41:56.957]                 for (kk in seq_along(NAMES)) {
[11:41:56.957]                   name <- removed[[kk]]
[11:41:56.957]                   NAME <- NAMES[[kk]]
[11:41:56.957]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:56.957]                     next
[11:41:56.957]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:56.957]                 }
[11:41:56.957]                 if (length(args) > 0) 
[11:41:56.957]                   base::do.call(base::Sys.setenv, args = args)
[11:41:56.957]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:56.957]             }
[11:41:56.957]             else {
[11:41:56.957]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:56.957]             }
[11:41:56.957]             {
[11:41:56.957]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:56.957]                   0L) {
[11:41:56.957]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:56.957]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:56.957]                   base::options(opts)
[11:41:56.957]                 }
[11:41:56.957]                 {
[11:41:56.957]                   {
[11:41:56.957]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:56.957]                     NULL
[11:41:56.957]                   }
[11:41:56.957]                   options(future.plan = NULL)
[11:41:56.957]                   if (is.na(NA_character_)) 
[11:41:56.957]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:56.957]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:56.957]                   future::plan(list(function (..., workers = 2, 
[11:41:56.957]                     envir = parent.frame()) 
[11:41:56.957]                   strategy(..., workers = workers, envir = envir)), 
[11:41:56.957]                     .cleanup = FALSE, .init = FALSE)
[11:41:56.957]                 }
[11:41:56.957]             }
[11:41:56.957]         }
[11:41:56.957]     })
[11:41:56.957]     if (TRUE) {
[11:41:56.957]         base::sink(type = "output", split = FALSE)
[11:41:56.957]         if (TRUE) {
[11:41:56.957]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:56.957]         }
[11:41:56.957]         else {
[11:41:56.957]             ...future.result["stdout"] <- base::list(NULL)
[11:41:56.957]         }
[11:41:56.957]         base::close(...future.stdout)
[11:41:56.957]         ...future.stdout <- NULL
[11:41:56.957]     }
[11:41:56.957]     ...future.result$conditions <- ...future.conditions
[11:41:56.957]     ...future.result$finished <- base::Sys.time()
[11:41:56.957]     ...future.result
[11:41:56.957] }
[11:41:56.959] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:56.970] receiveMessageFromWorker() for ClusterFuture ...
[11:41:56.970] - Validating connection of MultisessionFuture
[11:41:56.971] - received message: FutureResult
[11:41:56.971] - Received FutureResult
[11:41:56.971] - Erased future from FutureRegistry
[11:41:56.971] result() for ClusterFuture ...
[11:41:56.971] - result already collected: FutureResult
[11:41:56.971] result() for ClusterFuture ... done
[11:41:56.971] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:56.972] result() for ClusterFuture ...
[11:41:56.972] - result already collected: FutureResult
[11:41:56.972] result() for ClusterFuture ... done
[11:41:56.972] result() for ClusterFuture ...
[11:41:56.972] - result already collected: FutureResult
[11:41:56.972] result() for ClusterFuture ... done
[11:41:56.973] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:56.973] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:57.018] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:57.029] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:57.031] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:57.031] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:57.074] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:57.075] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:57.076] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:57.077] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:57.078] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:57.079] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:57.080] MultisessionFuture started
[11:41:57.081] - Launch lazy future ... done
[11:41:57.081] run() for ‘MultisessionFuture’ ... done
[11:41:57.081] Created future:
[11:41:57.082] MultisessionFuture:
[11:41:57.082] Label: ‘future_mapply-62’
[11:41:57.082] Expression:
[11:41:57.082] {
[11:41:57.082]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:57.082]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:57.082]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:57.082]         on.exit(options(oopts), add = TRUE)
[11:41:57.082]     }
[11:41:57.082]     {
[11:41:57.082]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:57.082]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:57.082]                 inherits = FALSE)
[11:41:57.082]             ...future.FUN(...)
[11:41:57.082]         }
[11:41:57.082]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:57.082]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:57.082]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:57.082]         do.call(mapply, args = args)
[11:41:57.082]     }
[11:41:57.082] }
[11:41:57.082] Lazy evaluation: FALSE
[11:41:57.082] Asynchronous evaluation: TRUE
[11:41:57.082] Local evaluation: TRUE
[11:41:57.082] Environment: 0x560ef58e1768
[11:41:57.082] Capture standard output: TRUE
[11:41:57.082] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:57.082] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:57.082] Packages: 1 packages (‘mlr3’)
[11:41:57.082] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:57.082] Resolved: FALSE
[11:41:57.082] Value: <not collected>
[11:41:57.082] Conditions captured: <none>
[11:41:57.082] Early signaling: FALSE
[11:41:57.082] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:57.082] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:57.098] Chunk #62 of 90 ... DONE
[11:41:57.099] Chunk #63 of 90 ...
[11:41:57.099]  - seeds: [1] <seeds>
[11:41:57.099] getGlobalsAndPackages() ...
[11:41:57.099] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:57.099] Resolving globals: FALSE
[11:41:57.100] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:57.100] - packages: [1] ‘mlr3’
[11:41:57.100] getGlobalsAndPackages() ... DONE
[11:41:57.100] run() for ‘Future’ ...
[11:41:57.100] - state: ‘created’
[11:41:57.101] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:57.116] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:57.116] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:57.116]   - Field: ‘node’
[11:41:57.116]   - Field: ‘label’
[11:41:57.116]   - Field: ‘local’
[11:41:57.117]   - Field: ‘owner’
[11:41:57.117]   - Field: ‘envir’
[11:41:57.117]   - Field: ‘workers’
[11:41:57.117]   - Field: ‘packages’
[11:41:57.117]   - Field: ‘gc’
[11:41:57.117]   - Field: ‘conditions’
[11:41:57.117]   - Field: ‘persistent’
[11:41:57.117]   - Field: ‘expr’
[11:41:57.117]   - Field: ‘uuid’
[11:41:57.117]   - Field: ‘seed’
[11:41:57.117]   - Field: ‘version’
[11:41:57.117]   - Field: ‘result’
[11:41:57.118]   - Field: ‘asynchronous’
[11:41:57.118]   - Field: ‘calls’
[11:41:57.118]   - Field: ‘globals’
[11:41:57.118]   - Field: ‘stdout’
[11:41:57.118]   - Field: ‘earlySignal’
[11:41:57.118]   - Field: ‘lazy’
[11:41:57.118]   - Field: ‘state’
[11:41:57.118] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:57.118] - Launch lazy future ...
[11:41:57.118] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:57.118] Packages needed by future strategies (n = 0): <none>
[11:41:57.119] {
[11:41:57.119]     {
[11:41:57.119]         {
[11:41:57.119]             ...future.startTime <- base::Sys.time()
[11:41:57.119]             {
[11:41:57.119]                 {
[11:41:57.119]                   {
[11:41:57.119]                     {
[11:41:57.119]                       {
[11:41:57.119]                         base::local({
[11:41:57.119]                           has_future <- base::requireNamespace("future", 
[11:41:57.119]                             quietly = TRUE)
[11:41:57.119]                           if (has_future) {
[11:41:57.119]                             ns <- base::getNamespace("future")
[11:41:57.119]                             version <- ns[[".package"]][["version"]]
[11:41:57.119]                             if (is.null(version)) 
[11:41:57.119]                               version <- utils::packageVersion("future")
[11:41:57.119]                           }
[11:41:57.119]                           else {
[11:41:57.119]                             version <- NULL
[11:41:57.119]                           }
[11:41:57.119]                           if (!has_future || version < "1.8.0") {
[11:41:57.119]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:57.119]                               "", base::R.version$version.string), 
[11:41:57.119]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:57.119]                                 base::R.version$platform, 8 * 
[11:41:57.119]                                   base::.Machine$sizeof.pointer), 
[11:41:57.119]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:57.119]                                 "release", "version")], collapse = " "), 
[11:41:57.119]                               hostname = base::Sys.info()[["nodename"]])
[11:41:57.119]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:57.119]                               info)
[11:41:57.119]                             info <- base::paste(info, collapse = "; ")
[11:41:57.119]                             if (!has_future) {
[11:41:57.119]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:57.119]                                 info)
[11:41:57.119]                             }
[11:41:57.119]                             else {
[11:41:57.119]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:57.119]                                 info, version)
[11:41:57.119]                             }
[11:41:57.119]                             base::stop(msg)
[11:41:57.119]                           }
[11:41:57.119]                         })
[11:41:57.119]                       }
[11:41:57.119]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:57.119]                       base::options(mc.cores = 1L)
[11:41:57.119]                     }
[11:41:57.119]                     base::local({
[11:41:57.119]                       for (pkg in "mlr3") {
[11:41:57.119]                         base::loadNamespace(pkg)
[11:41:57.119]                         base::library(pkg, character.only = TRUE)
[11:41:57.119]                       }
[11:41:57.119]                     })
[11:41:57.119]                   }
[11:41:57.119]                   options(future.plan = NULL)
[11:41:57.119]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:57.119]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:57.119]                 }
[11:41:57.119]                 ...future.workdir <- getwd()
[11:41:57.119]             }
[11:41:57.119]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:57.119]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:57.119]         }
[11:41:57.119]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:57.119]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:57.119]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:57.119]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:57.119]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:57.119]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:57.119]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:57.119]             base::names(...future.oldOptions))
[11:41:57.119]     }
[11:41:57.119]     if (FALSE) {
[11:41:57.119]     }
[11:41:57.119]     else {
[11:41:57.119]         if (TRUE) {
[11:41:57.119]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:57.119]                 open = "w")
[11:41:57.119]         }
[11:41:57.119]         else {
[11:41:57.119]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:57.119]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:57.119]         }
[11:41:57.119]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:57.119]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:57.119]             base::sink(type = "output", split = FALSE)
[11:41:57.119]             base::close(...future.stdout)
[11:41:57.119]         }, add = TRUE)
[11:41:57.119]     }
[11:41:57.119]     ...future.frame <- base::sys.nframe()
[11:41:57.119]     ...future.conditions <- base::list()
[11:41:57.119]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:57.119]     if (FALSE) {
[11:41:57.119]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:57.119]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:57.119]     }
[11:41:57.119]     ...future.result <- base::tryCatch({
[11:41:57.119]         base::withCallingHandlers({
[11:41:57.119]             ...future.value <- base::withVisible(base::local({
[11:41:57.119]                 ...future.makeSendCondition <- local({
[11:41:57.119]                   sendCondition <- NULL
[11:41:57.119]                   function(frame = 1L) {
[11:41:57.119]                     if (is.function(sendCondition)) 
[11:41:57.119]                       return(sendCondition)
[11:41:57.119]                     ns <- getNamespace("parallel")
[11:41:57.119]                     if (exists("sendData", mode = "function", 
[11:41:57.119]                       envir = ns)) {
[11:41:57.119]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:57.119]                         envir = ns)
[11:41:57.119]                       envir <- sys.frame(frame)
[11:41:57.119]                       master <- NULL
[11:41:57.119]                       while (!identical(envir, .GlobalEnv) && 
[11:41:57.119]                         !identical(envir, emptyenv())) {
[11:41:57.119]                         if (exists("master", mode = "list", envir = envir, 
[11:41:57.119]                           inherits = FALSE)) {
[11:41:57.119]                           master <- get("master", mode = "list", 
[11:41:57.119]                             envir = envir, inherits = FALSE)
[11:41:57.119]                           if (inherits(master, c("SOCKnode", 
[11:41:57.119]                             "SOCK0node"))) {
[11:41:57.119]                             sendCondition <<- function(cond) {
[11:41:57.119]                               data <- list(type = "VALUE", value = cond, 
[11:41:57.119]                                 success = TRUE)
[11:41:57.119]                               parallel_sendData(master, data)
[11:41:57.119]                             }
[11:41:57.119]                             return(sendCondition)
[11:41:57.119]                           }
[11:41:57.119]                         }
[11:41:57.119]                         frame <- frame + 1L
[11:41:57.119]                         envir <- sys.frame(frame)
[11:41:57.119]                       }
[11:41:57.119]                     }
[11:41:57.119]                     sendCondition <<- function(cond) NULL
[11:41:57.119]                   }
[11:41:57.119]                 })
[11:41:57.119]                 withCallingHandlers({
[11:41:57.119]                   {
[11:41:57.119]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:57.119]                     if (!identical(...future.globals.maxSize.org, 
[11:41:57.119]                       ...future.globals.maxSize)) {
[11:41:57.119]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:57.119]                       on.exit(options(oopts), add = TRUE)
[11:41:57.119]                     }
[11:41:57.119]                     {
[11:41:57.119]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:57.119]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:57.119]                           envir = globalenv(), inherits = FALSE)
[11:41:57.119]                         ...future.FUN(...)
[11:41:57.119]                       }
[11:41:57.119]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:57.119]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:57.119]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:57.119]                         USE.NAMES = FALSE)
[11:41:57.119]                       do.call(mapply, args = args)
[11:41:57.119]                     }
[11:41:57.119]                   }
[11:41:57.119]                 }, immediateCondition = function(cond) {
[11:41:57.119]                   sendCondition <- ...future.makeSendCondition()
[11:41:57.119]                   sendCondition(cond)
[11:41:57.119]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:57.119]                   {
[11:41:57.119]                     inherits <- base::inherits
[11:41:57.119]                     invokeRestart <- base::invokeRestart
[11:41:57.119]                     is.null <- base::is.null
[11:41:57.119]                     muffled <- FALSE
[11:41:57.119]                     if (inherits(cond, "message")) {
[11:41:57.119]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:57.119]                       if (muffled) 
[11:41:57.119]                         invokeRestart("muffleMessage")
[11:41:57.119]                     }
[11:41:57.119]                     else if (inherits(cond, "warning")) {
[11:41:57.119]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:57.119]                       if (muffled) 
[11:41:57.119]                         invokeRestart("muffleWarning")
[11:41:57.119]                     }
[11:41:57.119]                     else if (inherits(cond, "condition")) {
[11:41:57.119]                       if (!is.null(pattern)) {
[11:41:57.119]                         computeRestarts <- base::computeRestarts
[11:41:57.119]                         grepl <- base::grepl
[11:41:57.119]                         restarts <- computeRestarts(cond)
[11:41:57.119]                         for (restart in restarts) {
[11:41:57.119]                           name <- restart$name
[11:41:57.119]                           if (is.null(name)) 
[11:41:57.119]                             next
[11:41:57.119]                           if (!grepl(pattern, name)) 
[11:41:57.119]                             next
[11:41:57.119]                           invokeRestart(restart)
[11:41:57.119]                           muffled <- TRUE
[11:41:57.119]                           break
[11:41:57.119]                         }
[11:41:57.119]                       }
[11:41:57.119]                     }
[11:41:57.119]                     invisible(muffled)
[11:41:57.119]                   }
[11:41:57.119]                   muffleCondition(cond)
[11:41:57.119]                 })
[11:41:57.119]             }))
[11:41:57.119]             future::FutureResult(value = ...future.value$value, 
[11:41:57.119]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:57.119]                   ...future.rng), globalenv = if (FALSE) 
[11:41:57.119]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:57.119]                     ...future.globalenv.names))
[11:41:57.119]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:57.119]         }, condition = base::local({
[11:41:57.119]             c <- base::c
[11:41:57.119]             inherits <- base::inherits
[11:41:57.119]             invokeRestart <- base::invokeRestart
[11:41:57.119]             length <- base::length
[11:41:57.119]             list <- base::list
[11:41:57.119]             seq.int <- base::seq.int
[11:41:57.119]             signalCondition <- base::signalCondition
[11:41:57.119]             sys.calls <- base::sys.calls
[11:41:57.119]             `[[` <- base::`[[`
[11:41:57.119]             `+` <- base::`+`
[11:41:57.119]             `<<-` <- base::`<<-`
[11:41:57.119]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:57.119]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:57.119]                   3L)]
[11:41:57.119]             }
[11:41:57.119]             function(cond) {
[11:41:57.119]                 is_error <- inherits(cond, "error")
[11:41:57.119]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:57.119]                   NULL)
[11:41:57.119]                 if (is_error) {
[11:41:57.119]                   sessionInformation <- function() {
[11:41:57.119]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:57.119]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:57.119]                       search = base::search(), system = base::Sys.info())
[11:41:57.119]                   }
[11:41:57.119]                   ...future.conditions[[length(...future.conditions) + 
[11:41:57.119]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:57.119]                     cond$call), session = sessionInformation(), 
[11:41:57.119]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:57.119]                   signalCondition(cond)
[11:41:57.119]                 }
[11:41:57.119]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:57.119]                 "immediateCondition"))) {
[11:41:57.119]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:57.119]                   ...future.conditions[[length(...future.conditions) + 
[11:41:57.119]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:57.119]                   if (TRUE && !signal) {
[11:41:57.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:57.119]                     {
[11:41:57.119]                       inherits <- base::inherits
[11:41:57.119]                       invokeRestart <- base::invokeRestart
[11:41:57.119]                       is.null <- base::is.null
[11:41:57.119]                       muffled <- FALSE
[11:41:57.119]                       if (inherits(cond, "message")) {
[11:41:57.119]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:57.119]                         if (muffled) 
[11:41:57.119]                           invokeRestart("muffleMessage")
[11:41:57.119]                       }
[11:41:57.119]                       else if (inherits(cond, "warning")) {
[11:41:57.119]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:57.119]                         if (muffled) 
[11:41:57.119]                           invokeRestart("muffleWarning")
[11:41:57.119]                       }
[11:41:57.119]                       else if (inherits(cond, "condition")) {
[11:41:57.119]                         if (!is.null(pattern)) {
[11:41:57.119]                           computeRestarts <- base::computeRestarts
[11:41:57.119]                           grepl <- base::grepl
[11:41:57.119]                           restarts <- computeRestarts(cond)
[11:41:57.119]                           for (restart in restarts) {
[11:41:57.119]                             name <- restart$name
[11:41:57.119]                             if (is.null(name)) 
[11:41:57.119]                               next
[11:41:57.119]                             if (!grepl(pattern, name)) 
[11:41:57.119]                               next
[11:41:57.119]                             invokeRestart(restart)
[11:41:57.119]                             muffled <- TRUE
[11:41:57.119]                             break
[11:41:57.119]                           }
[11:41:57.119]                         }
[11:41:57.119]                       }
[11:41:57.119]                       invisible(muffled)
[11:41:57.119]                     }
[11:41:57.119]                     muffleCondition(cond, pattern = "^muffle")
[11:41:57.119]                   }
[11:41:57.119]                 }
[11:41:57.119]                 else {
[11:41:57.119]                   if (TRUE) {
[11:41:57.119]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:57.119]                     {
[11:41:57.119]                       inherits <- base::inherits
[11:41:57.119]                       invokeRestart <- base::invokeRestart
[11:41:57.119]                       is.null <- base::is.null
[11:41:57.119]                       muffled <- FALSE
[11:41:57.119]                       if (inherits(cond, "message")) {
[11:41:57.119]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:57.119]                         if (muffled) 
[11:41:57.119]                           invokeRestart("muffleMessage")
[11:41:57.119]                       }
[11:41:57.119]                       else if (inherits(cond, "warning")) {
[11:41:57.119]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:57.119]                         if (muffled) 
[11:41:57.119]                           invokeRestart("muffleWarning")
[11:41:57.119]                       }
[11:41:57.119]                       else if (inherits(cond, "condition")) {
[11:41:57.119]                         if (!is.null(pattern)) {
[11:41:57.119]                           computeRestarts <- base::computeRestarts
[11:41:57.119]                           grepl <- base::grepl
[11:41:57.119]                           restarts <- computeRestarts(cond)
[11:41:57.119]                           for (restart in restarts) {
[11:41:57.119]                             name <- restart$name
[11:41:57.119]                             if (is.null(name)) 
[11:41:57.119]                               next
[11:41:57.119]                             if (!grepl(pattern, name)) 
[11:41:57.119]                               next
[11:41:57.119]                             invokeRestart(restart)
[11:41:57.119]                             muffled <- TRUE
[11:41:57.119]                             break
[11:41:57.119]                           }
[11:41:57.119]                         }
[11:41:57.119]                       }
[11:41:57.119]                       invisible(muffled)
[11:41:57.119]                     }
[11:41:57.119]                     muffleCondition(cond, pattern = "^muffle")
[11:41:57.119]                   }
[11:41:57.119]                 }
[11:41:57.119]             }
[11:41:57.119]         }))
[11:41:57.119]     }, error = function(ex) {
[11:41:57.119]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:57.119]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:57.119]                 ...future.rng), started = ...future.startTime, 
[11:41:57.119]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:57.119]             version = "1.8"), class = "FutureResult")
[11:41:57.119]     }, finally = {
[11:41:57.119]         if (!identical(...future.workdir, getwd())) 
[11:41:57.119]             setwd(...future.workdir)
[11:41:57.119]         {
[11:41:57.119]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:57.119]                 ...future.oldOptions$nwarnings <- NULL
[11:41:57.119]             }
[11:41:57.119]             base::options(...future.oldOptions)
[11:41:57.119]             if (.Platform$OS.type == "windows") {
[11:41:57.119]                 old_names <- names(...future.oldEnvVars)
[11:41:57.119]                 envs <- base::Sys.getenv()
[11:41:57.119]                 names <- names(envs)
[11:41:57.119]                 common <- intersect(names, old_names)
[11:41:57.119]                 added <- setdiff(names, old_names)
[11:41:57.119]                 removed <- setdiff(old_names, names)
[11:41:57.119]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:57.119]                   envs[common]]
[11:41:57.119]                 NAMES <- toupper(changed)
[11:41:57.119]                 args <- list()
[11:41:57.119]                 for (kk in seq_along(NAMES)) {
[11:41:57.119]                   name <- changed[[kk]]
[11:41:57.119]                   NAME <- NAMES[[kk]]
[11:41:57.119]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:57.119]                     next
[11:41:57.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:57.119]                 }
[11:41:57.119]                 NAMES <- toupper(added)
[11:41:57.119]                 for (kk in seq_along(NAMES)) {
[11:41:57.119]                   name <- added[[kk]]
[11:41:57.119]                   NAME <- NAMES[[kk]]
[11:41:57.119]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:57.119]                     next
[11:41:57.119]                   args[[name]] <- ""
[11:41:57.119]                 }
[11:41:57.119]                 NAMES <- toupper(removed)
[11:41:57.119]                 for (kk in seq_along(NAMES)) {
[11:41:57.119]                   name <- removed[[kk]]
[11:41:57.119]                   NAME <- NAMES[[kk]]
[11:41:57.119]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:57.119]                     next
[11:41:57.119]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:57.119]                 }
[11:41:57.119]                 if (length(args) > 0) 
[11:41:57.119]                   base::do.call(base::Sys.setenv, args = args)
[11:41:57.119]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:57.119]             }
[11:41:57.119]             else {
[11:41:57.119]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:57.119]             }
[11:41:57.119]             {
[11:41:57.119]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:57.119]                   0L) {
[11:41:57.119]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:57.119]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:57.119]                   base::options(opts)
[11:41:57.119]                 }
[11:41:57.119]                 {
[11:41:57.119]                   {
[11:41:57.119]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:57.119]                     NULL
[11:41:57.119]                   }
[11:41:57.119]                   options(future.plan = NULL)
[11:41:57.119]                   if (is.na(NA_character_)) 
[11:41:57.119]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:57.119]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:57.119]                   future::plan(list(function (..., workers = 2, 
[11:41:57.119]                     envir = parent.frame()) 
[11:41:57.119]                   strategy(..., workers = workers, envir = envir)), 
[11:41:57.119]                     .cleanup = FALSE, .init = FALSE)
[11:41:57.119]                 }
[11:41:57.119]             }
[11:41:57.119]         }
[11:41:57.119]     })
[11:41:57.119]     if (TRUE) {
[11:41:57.119]         base::sink(type = "output", split = FALSE)
[11:41:57.119]         if (TRUE) {
[11:41:57.119]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:57.119]         }
[11:41:57.119]         else {
[11:41:57.119]             ...future.result["stdout"] <- base::list(NULL)
[11:41:57.119]         }
[11:41:57.119]         base::close(...future.stdout)
[11:41:57.119]         ...future.stdout <- NULL
[11:41:57.119]     }
[11:41:57.119]     ...future.result$conditions <- ...future.conditions
[11:41:57.119]     ...future.result$finished <- base::Sys.time()
[11:41:57.119]     ...future.result
[11:41:57.119] }
[11:41:57.120] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:57.131] receiveMessageFromWorker() for ClusterFuture ...
[11:41:57.131] - Validating connection of MultisessionFuture
[11:41:57.132] - received message: FutureResult
[11:41:57.132] - Received FutureResult
[11:41:57.132] - Erased future from FutureRegistry
[11:41:57.132] result() for ClusterFuture ...
[11:41:57.132] - result already collected: FutureResult
[11:41:57.132] result() for ClusterFuture ... done
[11:41:57.132] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:57.133] result() for ClusterFuture ...
[11:41:57.133] - result already collected: FutureResult
[11:41:57.133] result() for ClusterFuture ... done
[11:41:57.133] result() for ClusterFuture ...
[11:41:57.133] - result already collected: FutureResult
[11:41:57.133] result() for ClusterFuture ... done
[11:41:57.134] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:57.134] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:57.177] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:57.182] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:57.184] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:57.184] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:57.233] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:57.234] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:57.234] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:57.235] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:57.235] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:57.235] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:57.236] MultisessionFuture started
[11:41:57.236] - Launch lazy future ... done
[11:41:57.236] run() for ‘MultisessionFuture’ ... done
[11:41:57.237] Created future:
[11:41:57.237] MultisessionFuture:
[11:41:57.237] Label: ‘future_mapply-63’
[11:41:57.237] Expression:
[11:41:57.237] {
[11:41:57.237]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:57.237]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:57.237]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:57.237]         on.exit(options(oopts), add = TRUE)
[11:41:57.237]     }
[11:41:57.237]     {
[11:41:57.237]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:57.237]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:57.237]                 inherits = FALSE)
[11:41:57.237]             ...future.FUN(...)
[11:41:57.237]         }
[11:41:57.237]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:57.237]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:57.237]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:57.237]         do.call(mapply, args = args)
[11:41:57.237]     }
[11:41:57.237] }
[11:41:57.237] Lazy evaluation: FALSE
[11:41:57.237] Asynchronous evaluation: TRUE
[11:41:57.237] Local evaluation: TRUE
[11:41:57.237] Environment: 0x560ef58e1768
[11:41:57.237] Capture standard output: TRUE
[11:41:57.237] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:57.237] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:57.237] Packages: 1 packages (‘mlr3’)
[11:41:57.237] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:57.237] Resolved: FALSE
[11:41:57.237] Value: <not collected>
[11:41:57.237] Conditions captured: <none>
[11:41:57.237] Early signaling: FALSE
[11:41:57.237] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:57.237] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:57.253] Chunk #63 of 90 ... DONE
[11:41:57.253] Chunk #64 of 90 ...
[11:41:57.254]  - seeds: [1] <seeds>
[11:41:57.254] getGlobalsAndPackages() ...
[11:41:57.254] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:57.254] Resolving globals: FALSE
[11:41:57.254] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:57.255] - packages: [1] ‘mlr3’
[11:41:57.255] getGlobalsAndPackages() ... DONE
[11:41:57.255] run() for ‘Future’ ...
[11:41:57.255] - state: ‘created’
[11:41:57.255] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:57.267] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:57.267] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:57.267]   - Field: ‘node’
[11:41:57.268]   - Field: ‘label’
[11:41:57.268]   - Field: ‘local’
[11:41:57.268]   - Field: ‘owner’
[11:41:57.268]   - Field: ‘envir’
[11:41:57.268]   - Field: ‘workers’
[11:41:57.268]   - Field: ‘packages’
[11:41:57.268]   - Field: ‘gc’
[11:41:57.268]   - Field: ‘conditions’
[11:41:57.268]   - Field: ‘persistent’
[11:41:57.268]   - Field: ‘expr’
[11:41:57.268]   - Field: ‘uuid’
[11:41:57.268]   - Field: ‘seed’
[11:41:57.268]   - Field: ‘version’
[11:41:57.268]   - Field: ‘result’
[11:41:57.268]   - Field: ‘asynchronous’
[11:41:57.268]   - Field: ‘calls’
[11:41:57.268]   - Field: ‘globals’
[11:41:57.268]   - Field: ‘stdout’
[11:41:57.268]   - Field: ‘earlySignal’
[11:41:57.269]   - Field: ‘lazy’
[11:41:57.269]   - Field: ‘state’
[11:41:57.269] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:57.269] - Launch lazy future ...
[11:41:57.269] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:57.269] Packages needed by future strategies (n = 0): <none>
[11:41:57.269] {
[11:41:57.269]     {
[11:41:57.269]         {
[11:41:57.269]             ...future.startTime <- base::Sys.time()
[11:41:57.269]             {
[11:41:57.269]                 {
[11:41:57.269]                   {
[11:41:57.269]                     {
[11:41:57.269]                       {
[11:41:57.269]                         base::local({
[11:41:57.269]                           has_future <- base::requireNamespace("future", 
[11:41:57.269]                             quietly = TRUE)
[11:41:57.269]                           if (has_future) {
[11:41:57.269]                             ns <- base::getNamespace("future")
[11:41:57.269]                             version <- ns[[".package"]][["version"]]
[11:41:57.269]                             if (is.null(version)) 
[11:41:57.269]                               version <- utils::packageVersion("future")
[11:41:57.269]                           }
[11:41:57.269]                           else {
[11:41:57.269]                             version <- NULL
[11:41:57.269]                           }
[11:41:57.269]                           if (!has_future || version < "1.8.0") {
[11:41:57.269]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:57.269]                               "", base::R.version$version.string), 
[11:41:57.269]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:57.269]                                 base::R.version$platform, 8 * 
[11:41:57.269]                                   base::.Machine$sizeof.pointer), 
[11:41:57.269]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:57.269]                                 "release", "version")], collapse = " "), 
[11:41:57.269]                               hostname = base::Sys.info()[["nodename"]])
[11:41:57.269]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:57.269]                               info)
[11:41:57.269]                             info <- base::paste(info, collapse = "; ")
[11:41:57.269]                             if (!has_future) {
[11:41:57.269]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:57.269]                                 info)
[11:41:57.269]                             }
[11:41:57.269]                             else {
[11:41:57.269]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:57.269]                                 info, version)
[11:41:57.269]                             }
[11:41:57.269]                             base::stop(msg)
[11:41:57.269]                           }
[11:41:57.269]                         })
[11:41:57.269]                       }
[11:41:57.269]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:57.269]                       base::options(mc.cores = 1L)
[11:41:57.269]                     }
[11:41:57.269]                     base::local({
[11:41:57.269]                       for (pkg in "mlr3") {
[11:41:57.269]                         base::loadNamespace(pkg)
[11:41:57.269]                         base::library(pkg, character.only = TRUE)
[11:41:57.269]                       }
[11:41:57.269]                     })
[11:41:57.269]                   }
[11:41:57.269]                   options(future.plan = NULL)
[11:41:57.269]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:57.269]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:57.269]                 }
[11:41:57.269]                 ...future.workdir <- getwd()
[11:41:57.269]             }
[11:41:57.269]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:57.269]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:57.269]         }
[11:41:57.269]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:57.269]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:57.269]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:57.269]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:57.269]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:57.269]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:57.269]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:57.269]             base::names(...future.oldOptions))
[11:41:57.269]     }
[11:41:57.269]     if (FALSE) {
[11:41:57.269]     }
[11:41:57.269]     else {
[11:41:57.269]         if (TRUE) {
[11:41:57.269]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:57.269]                 open = "w")
[11:41:57.269]         }
[11:41:57.269]         else {
[11:41:57.269]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:57.269]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:57.269]         }
[11:41:57.269]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:57.269]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:57.269]             base::sink(type = "output", split = FALSE)
[11:41:57.269]             base::close(...future.stdout)
[11:41:57.269]         }, add = TRUE)
[11:41:57.269]     }
[11:41:57.269]     ...future.frame <- base::sys.nframe()
[11:41:57.269]     ...future.conditions <- base::list()
[11:41:57.269]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:57.269]     if (FALSE) {
[11:41:57.269]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:57.269]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:57.269]     }
[11:41:57.269]     ...future.result <- base::tryCatch({
[11:41:57.269]         base::withCallingHandlers({
[11:41:57.269]             ...future.value <- base::withVisible(base::local({
[11:41:57.269]                 ...future.makeSendCondition <- local({
[11:41:57.269]                   sendCondition <- NULL
[11:41:57.269]                   function(frame = 1L) {
[11:41:57.269]                     if (is.function(sendCondition)) 
[11:41:57.269]                       return(sendCondition)
[11:41:57.269]                     ns <- getNamespace("parallel")
[11:41:57.269]                     if (exists("sendData", mode = "function", 
[11:41:57.269]                       envir = ns)) {
[11:41:57.269]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:57.269]                         envir = ns)
[11:41:57.269]                       envir <- sys.frame(frame)
[11:41:57.269]                       master <- NULL
[11:41:57.269]                       while (!identical(envir, .GlobalEnv) && 
[11:41:57.269]                         !identical(envir, emptyenv())) {
[11:41:57.269]                         if (exists("master", mode = "list", envir = envir, 
[11:41:57.269]                           inherits = FALSE)) {
[11:41:57.269]                           master <- get("master", mode = "list", 
[11:41:57.269]                             envir = envir, inherits = FALSE)
[11:41:57.269]                           if (inherits(master, c("SOCKnode", 
[11:41:57.269]                             "SOCK0node"))) {
[11:41:57.269]                             sendCondition <<- function(cond) {
[11:41:57.269]                               data <- list(type = "VALUE", value = cond, 
[11:41:57.269]                                 success = TRUE)
[11:41:57.269]                               parallel_sendData(master, data)
[11:41:57.269]                             }
[11:41:57.269]                             return(sendCondition)
[11:41:57.269]                           }
[11:41:57.269]                         }
[11:41:57.269]                         frame <- frame + 1L
[11:41:57.269]                         envir <- sys.frame(frame)
[11:41:57.269]                       }
[11:41:57.269]                     }
[11:41:57.269]                     sendCondition <<- function(cond) NULL
[11:41:57.269]                   }
[11:41:57.269]                 })
[11:41:57.269]                 withCallingHandlers({
[11:41:57.269]                   {
[11:41:57.269]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:57.269]                     if (!identical(...future.globals.maxSize.org, 
[11:41:57.269]                       ...future.globals.maxSize)) {
[11:41:57.269]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:57.269]                       on.exit(options(oopts), add = TRUE)
[11:41:57.269]                     }
[11:41:57.269]                     {
[11:41:57.269]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:57.269]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:57.269]                           envir = globalenv(), inherits = FALSE)
[11:41:57.269]                         ...future.FUN(...)
[11:41:57.269]                       }
[11:41:57.269]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:57.269]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:57.269]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:57.269]                         USE.NAMES = FALSE)
[11:41:57.269]                       do.call(mapply, args = args)
[11:41:57.269]                     }
[11:41:57.269]                   }
[11:41:57.269]                 }, immediateCondition = function(cond) {
[11:41:57.269]                   sendCondition <- ...future.makeSendCondition()
[11:41:57.269]                   sendCondition(cond)
[11:41:57.269]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:57.269]                   {
[11:41:57.269]                     inherits <- base::inherits
[11:41:57.269]                     invokeRestart <- base::invokeRestart
[11:41:57.269]                     is.null <- base::is.null
[11:41:57.269]                     muffled <- FALSE
[11:41:57.269]                     if (inherits(cond, "message")) {
[11:41:57.269]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:57.269]                       if (muffled) 
[11:41:57.269]                         invokeRestart("muffleMessage")
[11:41:57.269]                     }
[11:41:57.269]                     else if (inherits(cond, "warning")) {
[11:41:57.269]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:57.269]                       if (muffled) 
[11:41:57.269]                         invokeRestart("muffleWarning")
[11:41:57.269]                     }
[11:41:57.269]                     else if (inherits(cond, "condition")) {
[11:41:57.269]                       if (!is.null(pattern)) {
[11:41:57.269]                         computeRestarts <- base::computeRestarts
[11:41:57.269]                         grepl <- base::grepl
[11:41:57.269]                         restarts <- computeRestarts(cond)
[11:41:57.269]                         for (restart in restarts) {
[11:41:57.269]                           name <- restart$name
[11:41:57.269]                           if (is.null(name)) 
[11:41:57.269]                             next
[11:41:57.269]                           if (!grepl(pattern, name)) 
[11:41:57.269]                             next
[11:41:57.269]                           invokeRestart(restart)
[11:41:57.269]                           muffled <- TRUE
[11:41:57.269]                           break
[11:41:57.269]                         }
[11:41:57.269]                       }
[11:41:57.269]                     }
[11:41:57.269]                     invisible(muffled)
[11:41:57.269]                   }
[11:41:57.269]                   muffleCondition(cond)
[11:41:57.269]                 })
[11:41:57.269]             }))
[11:41:57.269]             future::FutureResult(value = ...future.value$value, 
[11:41:57.269]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:57.269]                   ...future.rng), globalenv = if (FALSE) 
[11:41:57.269]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:57.269]                     ...future.globalenv.names))
[11:41:57.269]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:57.269]         }, condition = base::local({
[11:41:57.269]             c <- base::c
[11:41:57.269]             inherits <- base::inherits
[11:41:57.269]             invokeRestart <- base::invokeRestart
[11:41:57.269]             length <- base::length
[11:41:57.269]             list <- base::list
[11:41:57.269]             seq.int <- base::seq.int
[11:41:57.269]             signalCondition <- base::signalCondition
[11:41:57.269]             sys.calls <- base::sys.calls
[11:41:57.269]             `[[` <- base::`[[`
[11:41:57.269]             `+` <- base::`+`
[11:41:57.269]             `<<-` <- base::`<<-`
[11:41:57.269]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:57.269]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:57.269]                   3L)]
[11:41:57.269]             }
[11:41:57.269]             function(cond) {
[11:41:57.269]                 is_error <- inherits(cond, "error")
[11:41:57.269]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:57.269]                   NULL)
[11:41:57.269]                 if (is_error) {
[11:41:57.269]                   sessionInformation <- function() {
[11:41:57.269]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:57.269]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:57.269]                       search = base::search(), system = base::Sys.info())
[11:41:57.269]                   }
[11:41:57.269]                   ...future.conditions[[length(...future.conditions) + 
[11:41:57.269]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:57.269]                     cond$call), session = sessionInformation(), 
[11:41:57.269]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:57.269]                   signalCondition(cond)
[11:41:57.269]                 }
[11:41:57.269]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:57.269]                 "immediateCondition"))) {
[11:41:57.269]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:57.269]                   ...future.conditions[[length(...future.conditions) + 
[11:41:57.269]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:57.269]                   if (TRUE && !signal) {
[11:41:57.269]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:57.269]                     {
[11:41:57.269]                       inherits <- base::inherits
[11:41:57.269]                       invokeRestart <- base::invokeRestart
[11:41:57.269]                       is.null <- base::is.null
[11:41:57.269]                       muffled <- FALSE
[11:41:57.269]                       if (inherits(cond, "message")) {
[11:41:57.269]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:57.269]                         if (muffled) 
[11:41:57.269]                           invokeRestart("muffleMessage")
[11:41:57.269]                       }
[11:41:57.269]                       else if (inherits(cond, "warning")) {
[11:41:57.269]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:57.269]                         if (muffled) 
[11:41:57.269]                           invokeRestart("muffleWarning")
[11:41:57.269]                       }
[11:41:57.269]                       else if (inherits(cond, "condition")) {
[11:41:57.269]                         if (!is.null(pattern)) {
[11:41:57.269]                           computeRestarts <- base::computeRestarts
[11:41:57.269]                           grepl <- base::grepl
[11:41:57.269]                           restarts <- computeRestarts(cond)
[11:41:57.269]                           for (restart in restarts) {
[11:41:57.269]                             name <- restart$name
[11:41:57.269]                             if (is.null(name)) 
[11:41:57.269]                               next
[11:41:57.269]                             if (!grepl(pattern, name)) 
[11:41:57.269]                               next
[11:41:57.269]                             invokeRestart(restart)
[11:41:57.269]                             muffled <- TRUE
[11:41:57.269]                             break
[11:41:57.269]                           }
[11:41:57.269]                         }
[11:41:57.269]                       }
[11:41:57.269]                       invisible(muffled)
[11:41:57.269]                     }
[11:41:57.269]                     muffleCondition(cond, pattern = "^muffle")
[11:41:57.269]                   }
[11:41:57.269]                 }
[11:41:57.269]                 else {
[11:41:57.269]                   if (TRUE) {
[11:41:57.269]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:57.269]                     {
[11:41:57.269]                       inherits <- base::inherits
[11:41:57.269]                       invokeRestart <- base::invokeRestart
[11:41:57.269]                       is.null <- base::is.null
[11:41:57.269]                       muffled <- FALSE
[11:41:57.269]                       if (inherits(cond, "message")) {
[11:41:57.269]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:57.269]                         if (muffled) 
[11:41:57.269]                           invokeRestart("muffleMessage")
[11:41:57.269]                       }
[11:41:57.269]                       else if (inherits(cond, "warning")) {
[11:41:57.269]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:57.269]                         if (muffled) 
[11:41:57.269]                           invokeRestart("muffleWarning")
[11:41:57.269]                       }
[11:41:57.269]                       else if (inherits(cond, "condition")) {
[11:41:57.269]                         if (!is.null(pattern)) {
[11:41:57.269]                           computeRestarts <- base::computeRestarts
[11:41:57.269]                           grepl <- base::grepl
[11:41:57.269]                           restarts <- computeRestarts(cond)
[11:41:57.269]                           for (restart in restarts) {
[11:41:57.269]                             name <- restart$name
[11:41:57.269]                             if (is.null(name)) 
[11:41:57.269]                               next
[11:41:57.269]                             if (!grepl(pattern, name)) 
[11:41:57.269]                               next
[11:41:57.269]                             invokeRestart(restart)
[11:41:57.269]                             muffled <- TRUE
[11:41:57.269]                             break
[11:41:57.269]                           }
[11:41:57.269]                         }
[11:41:57.269]                       }
[11:41:57.269]                       invisible(muffled)
[11:41:57.269]                     }
[11:41:57.269]                     muffleCondition(cond, pattern = "^muffle")
[11:41:57.269]                   }
[11:41:57.269]                 }
[11:41:57.269]             }
[11:41:57.269]         }))
[11:41:57.269]     }, error = function(ex) {
[11:41:57.269]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:57.269]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:57.269]                 ...future.rng), started = ...future.startTime, 
[11:41:57.269]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:57.269]             version = "1.8"), class = "FutureResult")
[11:41:57.269]     }, finally = {
[11:41:57.269]         if (!identical(...future.workdir, getwd())) 
[11:41:57.269]             setwd(...future.workdir)
[11:41:57.269]         {
[11:41:57.269]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:57.269]                 ...future.oldOptions$nwarnings <- NULL
[11:41:57.269]             }
[11:41:57.269]             base::options(...future.oldOptions)
[11:41:57.269]             if (.Platform$OS.type == "windows") {
[11:41:57.269]                 old_names <- names(...future.oldEnvVars)
[11:41:57.269]                 envs <- base::Sys.getenv()
[11:41:57.269]                 names <- names(envs)
[11:41:57.269]                 common <- intersect(names, old_names)
[11:41:57.269]                 added <- setdiff(names, old_names)
[11:41:57.269]                 removed <- setdiff(old_names, names)
[11:41:57.269]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:57.269]                   envs[common]]
[11:41:57.269]                 NAMES <- toupper(changed)
[11:41:57.269]                 args <- list()
[11:41:57.269]                 for (kk in seq_along(NAMES)) {
[11:41:57.269]                   name <- changed[[kk]]
[11:41:57.269]                   NAME <- NAMES[[kk]]
[11:41:57.269]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:57.269]                     next
[11:41:57.269]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:57.269]                 }
[11:41:57.269]                 NAMES <- toupper(added)
[11:41:57.269]                 for (kk in seq_along(NAMES)) {
[11:41:57.269]                   name <- added[[kk]]
[11:41:57.269]                   NAME <- NAMES[[kk]]
[11:41:57.269]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:57.269]                     next
[11:41:57.269]                   args[[name]] <- ""
[11:41:57.269]                 }
[11:41:57.269]                 NAMES <- toupper(removed)
[11:41:57.269]                 for (kk in seq_along(NAMES)) {
[11:41:57.269]                   name <- removed[[kk]]
[11:41:57.269]                   NAME <- NAMES[[kk]]
[11:41:57.269]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:57.269]                     next
[11:41:57.269]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:57.269]                 }
[11:41:57.269]                 if (length(args) > 0) 
[11:41:57.269]                   base::do.call(base::Sys.setenv, args = args)
[11:41:57.269]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:57.269]             }
[11:41:57.269]             else {
[11:41:57.269]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:57.269]             }
[11:41:57.269]             {
[11:41:57.269]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:57.269]                   0L) {
[11:41:57.269]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:57.269]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:57.269]                   base::options(opts)
[11:41:57.269]                 }
[11:41:57.269]                 {
[11:41:57.269]                   {
[11:41:57.269]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:57.269]                     NULL
[11:41:57.269]                   }
[11:41:57.269]                   options(future.plan = NULL)
[11:41:57.269]                   if (is.na(NA_character_)) 
[11:41:57.269]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:57.269]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:57.269]                   future::plan(list(function (..., workers = 2, 
[11:41:57.269]                     envir = parent.frame()) 
[11:41:57.269]                   strategy(..., workers = workers, envir = envir)), 
[11:41:57.269]                     .cleanup = FALSE, .init = FALSE)
[11:41:57.269]                 }
[11:41:57.269]             }
[11:41:57.269]         }
[11:41:57.269]     })
[11:41:57.269]     if (TRUE) {
[11:41:57.269]         base::sink(type = "output", split = FALSE)
[11:41:57.269]         if (TRUE) {
[11:41:57.269]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:57.269]         }
[11:41:57.269]         else {
[11:41:57.269]             ...future.result["stdout"] <- base::list(NULL)
[11:41:57.269]         }
[11:41:57.269]         base::close(...future.stdout)
[11:41:57.269]         ...future.stdout <- NULL
[11:41:57.269]     }
[11:41:57.269]     ...future.result$conditions <- ...future.conditions
[11:41:57.269]     ...future.result$finished <- base::Sys.time()
[11:41:57.269]     ...future.result
[11:41:57.269] }
[11:41:57.271] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:57.282] receiveMessageFromWorker() for ClusterFuture ...
[11:41:57.282] - Validating connection of MultisessionFuture
[11:41:57.283] - received message: FutureResult
[11:41:57.283] - Received FutureResult
[11:41:57.283] - Erased future from FutureRegistry
[11:41:57.283] result() for ClusterFuture ...
[11:41:57.283] - result already collected: FutureResult
[11:41:57.283] result() for ClusterFuture ... done
[11:41:57.283] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:57.283] result() for ClusterFuture ...
[11:41:57.283] - result already collected: FutureResult
[11:41:57.283] result() for ClusterFuture ... done
[11:41:57.284] result() for ClusterFuture ...
[11:41:57.284] - result already collected: FutureResult
[11:41:57.284] result() for ClusterFuture ... done
[11:41:57.284] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:57.285] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:57.329] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:57.334] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:57.377] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:57.377] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:57.421] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:57.421] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:57.422] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:57.422] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:57.423] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:57.423] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:57.424] MultisessionFuture started
[11:41:57.424] - Launch lazy future ... done
[11:41:57.424] run() for ‘MultisessionFuture’ ... done
[11:41:57.425] Created future:
[11:41:57.425] MultisessionFuture:
[11:41:57.425] Label: ‘future_mapply-64’
[11:41:57.425] Expression:
[11:41:57.425] {
[11:41:57.425]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:57.425]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:57.425]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:57.425]         on.exit(options(oopts), add = TRUE)
[11:41:57.425]     }
[11:41:57.425]     {
[11:41:57.425]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:57.425]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:57.425]                 inherits = FALSE)
[11:41:57.425]             ...future.FUN(...)
[11:41:57.425]         }
[11:41:57.425]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:57.425]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:57.425]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:57.425]         do.call(mapply, args = args)
[11:41:57.425]     }
[11:41:57.425] }
[11:41:57.425] Lazy evaluation: FALSE
[11:41:57.425] Asynchronous evaluation: TRUE
[11:41:57.425] Local evaluation: TRUE
[11:41:57.425] Environment: 0x560ef58e1768
[11:41:57.425] Capture standard output: TRUE
[11:41:57.425] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:57.425] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:57.425] Packages: 1 packages (‘mlr3’)
[11:41:57.425] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:57.425] Resolved: FALSE
[11:41:57.425] Value: <not collected>
[11:41:57.425] Conditions captured: <none>
[11:41:57.425] Early signaling: FALSE
[11:41:57.425] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:57.425] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:57.442] Chunk #64 of 90 ... DONE
[11:41:57.443] Chunk #65 of 90 ...
[11:41:57.443]  - seeds: [1] <seeds>
[11:41:57.443] getGlobalsAndPackages() ...
[11:41:57.443] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:57.443] Resolving globals: FALSE
[11:41:57.444] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:57.444] - packages: [1] ‘mlr3’
[11:41:57.444] getGlobalsAndPackages() ... DONE
[11:41:57.445] run() for ‘Future’ ...
[11:41:57.445] - state: ‘created’
[11:41:57.445] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:57.458] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:57.458] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:57.458]   - Field: ‘node’
[11:41:57.458]   - Field: ‘label’
[11:41:57.459]   - Field: ‘local’
[11:41:57.459]   - Field: ‘owner’
[11:41:57.459]   - Field: ‘envir’
[11:41:57.459]   - Field: ‘workers’
[11:41:57.459]   - Field: ‘packages’
[11:41:57.459]   - Field: ‘gc’
[11:41:57.459]   - Field: ‘conditions’
[11:41:57.459]   - Field: ‘persistent’
[11:41:57.459]   - Field: ‘expr’
[11:41:57.459]   - Field: ‘uuid’
[11:41:57.459]   - Field: ‘seed’
[11:41:57.459]   - Field: ‘version’
[11:41:57.459]   - Field: ‘result’
[11:41:57.459]   - Field: ‘asynchronous’
[11:41:57.459]   - Field: ‘calls’
[11:41:57.459]   - Field: ‘globals’
[11:41:57.460]   - Field: ‘stdout’
[11:41:57.460]   - Field: ‘earlySignal’
[11:41:57.460]   - Field: ‘lazy’
[11:41:57.460]   - Field: ‘state’
[11:41:57.460] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:57.460] - Launch lazy future ...
[11:41:57.460] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:57.460] Packages needed by future strategies (n = 0): <none>
[11:41:57.461] {
[11:41:57.461]     {
[11:41:57.461]         {
[11:41:57.461]             ...future.startTime <- base::Sys.time()
[11:41:57.461]             {
[11:41:57.461]                 {
[11:41:57.461]                   {
[11:41:57.461]                     {
[11:41:57.461]                       {
[11:41:57.461]                         base::local({
[11:41:57.461]                           has_future <- base::requireNamespace("future", 
[11:41:57.461]                             quietly = TRUE)
[11:41:57.461]                           if (has_future) {
[11:41:57.461]                             ns <- base::getNamespace("future")
[11:41:57.461]                             version <- ns[[".package"]][["version"]]
[11:41:57.461]                             if (is.null(version)) 
[11:41:57.461]                               version <- utils::packageVersion("future")
[11:41:57.461]                           }
[11:41:57.461]                           else {
[11:41:57.461]                             version <- NULL
[11:41:57.461]                           }
[11:41:57.461]                           if (!has_future || version < "1.8.0") {
[11:41:57.461]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:57.461]                               "", base::R.version$version.string), 
[11:41:57.461]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:57.461]                                 base::R.version$platform, 8 * 
[11:41:57.461]                                   base::.Machine$sizeof.pointer), 
[11:41:57.461]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:57.461]                                 "release", "version")], collapse = " "), 
[11:41:57.461]                               hostname = base::Sys.info()[["nodename"]])
[11:41:57.461]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:57.461]                               info)
[11:41:57.461]                             info <- base::paste(info, collapse = "; ")
[11:41:57.461]                             if (!has_future) {
[11:41:57.461]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:57.461]                                 info)
[11:41:57.461]                             }
[11:41:57.461]                             else {
[11:41:57.461]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:57.461]                                 info, version)
[11:41:57.461]                             }
[11:41:57.461]                             base::stop(msg)
[11:41:57.461]                           }
[11:41:57.461]                         })
[11:41:57.461]                       }
[11:41:57.461]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:57.461]                       base::options(mc.cores = 1L)
[11:41:57.461]                     }
[11:41:57.461]                     base::local({
[11:41:57.461]                       for (pkg in "mlr3") {
[11:41:57.461]                         base::loadNamespace(pkg)
[11:41:57.461]                         base::library(pkg, character.only = TRUE)
[11:41:57.461]                       }
[11:41:57.461]                     })
[11:41:57.461]                   }
[11:41:57.461]                   options(future.plan = NULL)
[11:41:57.461]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:57.461]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:57.461]                 }
[11:41:57.461]                 ...future.workdir <- getwd()
[11:41:57.461]             }
[11:41:57.461]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:57.461]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:57.461]         }
[11:41:57.461]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:57.461]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:57.461]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:57.461]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:57.461]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:57.461]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:57.461]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:57.461]             base::names(...future.oldOptions))
[11:41:57.461]     }
[11:41:57.461]     if (FALSE) {
[11:41:57.461]     }
[11:41:57.461]     else {
[11:41:57.461]         if (TRUE) {
[11:41:57.461]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:57.461]                 open = "w")
[11:41:57.461]         }
[11:41:57.461]         else {
[11:41:57.461]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:57.461]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:57.461]         }
[11:41:57.461]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:57.461]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:57.461]             base::sink(type = "output", split = FALSE)
[11:41:57.461]             base::close(...future.stdout)
[11:41:57.461]         }, add = TRUE)
[11:41:57.461]     }
[11:41:57.461]     ...future.frame <- base::sys.nframe()
[11:41:57.461]     ...future.conditions <- base::list()
[11:41:57.461]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:57.461]     if (FALSE) {
[11:41:57.461]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:57.461]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:57.461]     }
[11:41:57.461]     ...future.result <- base::tryCatch({
[11:41:57.461]         base::withCallingHandlers({
[11:41:57.461]             ...future.value <- base::withVisible(base::local({
[11:41:57.461]                 ...future.makeSendCondition <- local({
[11:41:57.461]                   sendCondition <- NULL
[11:41:57.461]                   function(frame = 1L) {
[11:41:57.461]                     if (is.function(sendCondition)) 
[11:41:57.461]                       return(sendCondition)
[11:41:57.461]                     ns <- getNamespace("parallel")
[11:41:57.461]                     if (exists("sendData", mode = "function", 
[11:41:57.461]                       envir = ns)) {
[11:41:57.461]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:57.461]                         envir = ns)
[11:41:57.461]                       envir <- sys.frame(frame)
[11:41:57.461]                       master <- NULL
[11:41:57.461]                       while (!identical(envir, .GlobalEnv) && 
[11:41:57.461]                         !identical(envir, emptyenv())) {
[11:41:57.461]                         if (exists("master", mode = "list", envir = envir, 
[11:41:57.461]                           inherits = FALSE)) {
[11:41:57.461]                           master <- get("master", mode = "list", 
[11:41:57.461]                             envir = envir, inherits = FALSE)
[11:41:57.461]                           if (inherits(master, c("SOCKnode", 
[11:41:57.461]                             "SOCK0node"))) {
[11:41:57.461]                             sendCondition <<- function(cond) {
[11:41:57.461]                               data <- list(type = "VALUE", value = cond, 
[11:41:57.461]                                 success = TRUE)
[11:41:57.461]                               parallel_sendData(master, data)
[11:41:57.461]                             }
[11:41:57.461]                             return(sendCondition)
[11:41:57.461]                           }
[11:41:57.461]                         }
[11:41:57.461]                         frame <- frame + 1L
[11:41:57.461]                         envir <- sys.frame(frame)
[11:41:57.461]                       }
[11:41:57.461]                     }
[11:41:57.461]                     sendCondition <<- function(cond) NULL
[11:41:57.461]                   }
[11:41:57.461]                 })
[11:41:57.461]                 withCallingHandlers({
[11:41:57.461]                   {
[11:41:57.461]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:57.461]                     if (!identical(...future.globals.maxSize.org, 
[11:41:57.461]                       ...future.globals.maxSize)) {
[11:41:57.461]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:57.461]                       on.exit(options(oopts), add = TRUE)
[11:41:57.461]                     }
[11:41:57.461]                     {
[11:41:57.461]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:57.461]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:57.461]                           envir = globalenv(), inherits = FALSE)
[11:41:57.461]                         ...future.FUN(...)
[11:41:57.461]                       }
[11:41:57.461]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:57.461]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:57.461]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:57.461]                         USE.NAMES = FALSE)
[11:41:57.461]                       do.call(mapply, args = args)
[11:41:57.461]                     }
[11:41:57.461]                   }
[11:41:57.461]                 }, immediateCondition = function(cond) {
[11:41:57.461]                   sendCondition <- ...future.makeSendCondition()
[11:41:57.461]                   sendCondition(cond)
[11:41:57.461]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:57.461]                   {
[11:41:57.461]                     inherits <- base::inherits
[11:41:57.461]                     invokeRestart <- base::invokeRestart
[11:41:57.461]                     is.null <- base::is.null
[11:41:57.461]                     muffled <- FALSE
[11:41:57.461]                     if (inherits(cond, "message")) {
[11:41:57.461]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:57.461]                       if (muffled) 
[11:41:57.461]                         invokeRestart("muffleMessage")
[11:41:57.461]                     }
[11:41:57.461]                     else if (inherits(cond, "warning")) {
[11:41:57.461]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:57.461]                       if (muffled) 
[11:41:57.461]                         invokeRestart("muffleWarning")
[11:41:57.461]                     }
[11:41:57.461]                     else if (inherits(cond, "condition")) {
[11:41:57.461]                       if (!is.null(pattern)) {
[11:41:57.461]                         computeRestarts <- base::computeRestarts
[11:41:57.461]                         grepl <- base::grepl
[11:41:57.461]                         restarts <- computeRestarts(cond)
[11:41:57.461]                         for (restart in restarts) {
[11:41:57.461]                           name <- restart$name
[11:41:57.461]                           if (is.null(name)) 
[11:41:57.461]                             next
[11:41:57.461]                           if (!grepl(pattern, name)) 
[11:41:57.461]                             next
[11:41:57.461]                           invokeRestart(restart)
[11:41:57.461]                           muffled <- TRUE
[11:41:57.461]                           break
[11:41:57.461]                         }
[11:41:57.461]                       }
[11:41:57.461]                     }
[11:41:57.461]                     invisible(muffled)
[11:41:57.461]                   }
[11:41:57.461]                   muffleCondition(cond)
[11:41:57.461]                 })
[11:41:57.461]             }))
[11:41:57.461]             future::FutureResult(value = ...future.value$value, 
[11:41:57.461]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:57.461]                   ...future.rng), globalenv = if (FALSE) 
[11:41:57.461]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:57.461]                     ...future.globalenv.names))
[11:41:57.461]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:57.461]         }, condition = base::local({
[11:41:57.461]             c <- base::c
[11:41:57.461]             inherits <- base::inherits
[11:41:57.461]             invokeRestart <- base::invokeRestart
[11:41:57.461]             length <- base::length
[11:41:57.461]             list <- base::list
[11:41:57.461]             seq.int <- base::seq.int
[11:41:57.461]             signalCondition <- base::signalCondition
[11:41:57.461]             sys.calls <- base::sys.calls
[11:41:57.461]             `[[` <- base::`[[`
[11:41:57.461]             `+` <- base::`+`
[11:41:57.461]             `<<-` <- base::`<<-`
[11:41:57.461]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:57.461]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:57.461]                   3L)]
[11:41:57.461]             }
[11:41:57.461]             function(cond) {
[11:41:57.461]                 is_error <- inherits(cond, "error")
[11:41:57.461]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:57.461]                   NULL)
[11:41:57.461]                 if (is_error) {
[11:41:57.461]                   sessionInformation <- function() {
[11:41:57.461]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:57.461]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:57.461]                       search = base::search(), system = base::Sys.info())
[11:41:57.461]                   }
[11:41:57.461]                   ...future.conditions[[length(...future.conditions) + 
[11:41:57.461]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:57.461]                     cond$call), session = sessionInformation(), 
[11:41:57.461]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:57.461]                   signalCondition(cond)
[11:41:57.461]                 }
[11:41:57.461]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:57.461]                 "immediateCondition"))) {
[11:41:57.461]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:57.461]                   ...future.conditions[[length(...future.conditions) + 
[11:41:57.461]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:57.461]                   if (TRUE && !signal) {
[11:41:57.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:57.461]                     {
[11:41:57.461]                       inherits <- base::inherits
[11:41:57.461]                       invokeRestart <- base::invokeRestart
[11:41:57.461]                       is.null <- base::is.null
[11:41:57.461]                       muffled <- FALSE
[11:41:57.461]                       if (inherits(cond, "message")) {
[11:41:57.461]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:57.461]                         if (muffled) 
[11:41:57.461]                           invokeRestart("muffleMessage")
[11:41:57.461]                       }
[11:41:57.461]                       else if (inherits(cond, "warning")) {
[11:41:57.461]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:57.461]                         if (muffled) 
[11:41:57.461]                           invokeRestart("muffleWarning")
[11:41:57.461]                       }
[11:41:57.461]                       else if (inherits(cond, "condition")) {
[11:41:57.461]                         if (!is.null(pattern)) {
[11:41:57.461]                           computeRestarts <- base::computeRestarts
[11:41:57.461]                           grepl <- base::grepl
[11:41:57.461]                           restarts <- computeRestarts(cond)
[11:41:57.461]                           for (restart in restarts) {
[11:41:57.461]                             name <- restart$name
[11:41:57.461]                             if (is.null(name)) 
[11:41:57.461]                               next
[11:41:57.461]                             if (!grepl(pattern, name)) 
[11:41:57.461]                               next
[11:41:57.461]                             invokeRestart(restart)
[11:41:57.461]                             muffled <- TRUE
[11:41:57.461]                             break
[11:41:57.461]                           }
[11:41:57.461]                         }
[11:41:57.461]                       }
[11:41:57.461]                       invisible(muffled)
[11:41:57.461]                     }
[11:41:57.461]                     muffleCondition(cond, pattern = "^muffle")
[11:41:57.461]                   }
[11:41:57.461]                 }
[11:41:57.461]                 else {
[11:41:57.461]                   if (TRUE) {
[11:41:57.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:57.461]                     {
[11:41:57.461]                       inherits <- base::inherits
[11:41:57.461]                       invokeRestart <- base::invokeRestart
[11:41:57.461]                       is.null <- base::is.null
[11:41:57.461]                       muffled <- FALSE
[11:41:57.461]                       if (inherits(cond, "message")) {
[11:41:57.461]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:57.461]                         if (muffled) 
[11:41:57.461]                           invokeRestart("muffleMessage")
[11:41:57.461]                       }
[11:41:57.461]                       else if (inherits(cond, "warning")) {
[11:41:57.461]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:57.461]                         if (muffled) 
[11:41:57.461]                           invokeRestart("muffleWarning")
[11:41:57.461]                       }
[11:41:57.461]                       else if (inherits(cond, "condition")) {
[11:41:57.461]                         if (!is.null(pattern)) {
[11:41:57.461]                           computeRestarts <- base::computeRestarts
[11:41:57.461]                           grepl <- base::grepl
[11:41:57.461]                           restarts <- computeRestarts(cond)
[11:41:57.461]                           for (restart in restarts) {
[11:41:57.461]                             name <- restart$name
[11:41:57.461]                             if (is.null(name)) 
[11:41:57.461]                               next
[11:41:57.461]                             if (!grepl(pattern, name)) 
[11:41:57.461]                               next
[11:41:57.461]                             invokeRestart(restart)
[11:41:57.461]                             muffled <- TRUE
[11:41:57.461]                             break
[11:41:57.461]                           }
[11:41:57.461]                         }
[11:41:57.461]                       }
[11:41:57.461]                       invisible(muffled)
[11:41:57.461]                     }
[11:41:57.461]                     muffleCondition(cond, pattern = "^muffle")
[11:41:57.461]                   }
[11:41:57.461]                 }
[11:41:57.461]             }
[11:41:57.461]         }))
[11:41:57.461]     }, error = function(ex) {
[11:41:57.461]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:57.461]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:57.461]                 ...future.rng), started = ...future.startTime, 
[11:41:57.461]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:57.461]             version = "1.8"), class = "FutureResult")
[11:41:57.461]     }, finally = {
[11:41:57.461]         if (!identical(...future.workdir, getwd())) 
[11:41:57.461]             setwd(...future.workdir)
[11:41:57.461]         {
[11:41:57.461]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:57.461]                 ...future.oldOptions$nwarnings <- NULL
[11:41:57.461]             }
[11:41:57.461]             base::options(...future.oldOptions)
[11:41:57.461]             if (.Platform$OS.type == "windows") {
[11:41:57.461]                 old_names <- names(...future.oldEnvVars)
[11:41:57.461]                 envs <- base::Sys.getenv()
[11:41:57.461]                 names <- names(envs)
[11:41:57.461]                 common <- intersect(names, old_names)
[11:41:57.461]                 added <- setdiff(names, old_names)
[11:41:57.461]                 removed <- setdiff(old_names, names)
[11:41:57.461]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:57.461]                   envs[common]]
[11:41:57.461]                 NAMES <- toupper(changed)
[11:41:57.461]                 args <- list()
[11:41:57.461]                 for (kk in seq_along(NAMES)) {
[11:41:57.461]                   name <- changed[[kk]]
[11:41:57.461]                   NAME <- NAMES[[kk]]
[11:41:57.461]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:57.461]                     next
[11:41:57.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:57.461]                 }
[11:41:57.461]                 NAMES <- toupper(added)
[11:41:57.461]                 for (kk in seq_along(NAMES)) {
[11:41:57.461]                   name <- added[[kk]]
[11:41:57.461]                   NAME <- NAMES[[kk]]
[11:41:57.461]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:57.461]                     next
[11:41:57.461]                   args[[name]] <- ""
[11:41:57.461]                 }
[11:41:57.461]                 NAMES <- toupper(removed)
[11:41:57.461]                 for (kk in seq_along(NAMES)) {
[11:41:57.461]                   name <- removed[[kk]]
[11:41:57.461]                   NAME <- NAMES[[kk]]
[11:41:57.461]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:57.461]                     next
[11:41:57.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:57.461]                 }
[11:41:57.461]                 if (length(args) > 0) 
[11:41:57.461]                   base::do.call(base::Sys.setenv, args = args)
[11:41:57.461]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:57.461]             }
[11:41:57.461]             else {
[11:41:57.461]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:57.461]             }
[11:41:57.461]             {
[11:41:57.461]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:57.461]                   0L) {
[11:41:57.461]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:57.461]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:57.461]                   base::options(opts)
[11:41:57.461]                 }
[11:41:57.461]                 {
[11:41:57.461]                   {
[11:41:57.461]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:57.461]                     NULL
[11:41:57.461]                   }
[11:41:57.461]                   options(future.plan = NULL)
[11:41:57.461]                   if (is.na(NA_character_)) 
[11:41:57.461]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:57.461]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:57.461]                   future::plan(list(function (..., workers = 2, 
[11:41:57.461]                     envir = parent.frame()) 
[11:41:57.461]                   strategy(..., workers = workers, envir = envir)), 
[11:41:57.461]                     .cleanup = FALSE, .init = FALSE)
[11:41:57.461]                 }
[11:41:57.461]             }
[11:41:57.461]         }
[11:41:57.461]     })
[11:41:57.461]     if (TRUE) {
[11:41:57.461]         base::sink(type = "output", split = FALSE)
[11:41:57.461]         if (TRUE) {
[11:41:57.461]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:57.461]         }
[11:41:57.461]         else {
[11:41:57.461]             ...future.result["stdout"] <- base::list(NULL)
[11:41:57.461]         }
[11:41:57.461]         base::close(...future.stdout)
[11:41:57.461]         ...future.stdout <- NULL
[11:41:57.461]     }
[11:41:57.461]     ...future.result$conditions <- ...future.conditions
[11:41:57.461]     ...future.result$finished <- base::Sys.time()
[11:41:57.461]     ...future.result
[11:41:57.461] }
[11:41:57.463] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:57.474] receiveMessageFromWorker() for ClusterFuture ...
[11:41:57.474] - Validating connection of MultisessionFuture
[11:41:57.474] - received message: FutureResult
[11:41:57.474] - Received FutureResult
[11:41:57.475] - Erased future from FutureRegistry
[11:41:57.475] result() for ClusterFuture ...
[11:41:57.475] - result already collected: FutureResult
[11:41:57.475] result() for ClusterFuture ... done
[11:41:57.475] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:57.475] result() for ClusterFuture ...
[11:41:57.475] - result already collected: FutureResult
[11:41:57.475] result() for ClusterFuture ... done
[11:41:57.475] result() for ClusterFuture ...
[11:41:57.476] - result already collected: FutureResult
[11:41:57.476] result() for ClusterFuture ... done
[11:41:57.477] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:57.477] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:57.521] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:57.524] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:57.526] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:57.526] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:57.569] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:57.570] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:57.570] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:57.570] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:57.571] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:57.571] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:57.572] MultisessionFuture started
[11:41:57.572] - Launch lazy future ... done
[11:41:57.572] run() for ‘MultisessionFuture’ ... done
[11:41:57.573] Created future:
[11:41:57.573] MultisessionFuture:
[11:41:57.573] Label: ‘future_mapply-65’
[11:41:57.573] Expression:
[11:41:57.573] {
[11:41:57.573]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:57.573]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:57.573]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:57.573]         on.exit(options(oopts), add = TRUE)
[11:41:57.573]     }
[11:41:57.573]     {
[11:41:57.573]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:57.573]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:57.573]                 inherits = FALSE)
[11:41:57.573]             ...future.FUN(...)
[11:41:57.573]         }
[11:41:57.573]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:57.573]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:57.573]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:57.573]         do.call(mapply, args = args)
[11:41:57.573]     }
[11:41:57.573] }
[11:41:57.573] Lazy evaluation: FALSE
[11:41:57.573] Asynchronous evaluation: TRUE
[11:41:57.573] Local evaluation: TRUE
[11:41:57.573] Environment: 0x560ef58e1768
[11:41:57.573] Capture standard output: TRUE
[11:41:57.573] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:57.573] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:57.573] Packages: 1 packages (‘mlr3’)
[11:41:57.573] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:57.573] Resolved: FALSE
[11:41:57.573] Value: <not collected>
[11:41:57.573] Conditions captured: <none>
[11:41:57.573] Early signaling: FALSE
[11:41:57.573] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:57.573] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:57.591] Chunk #65 of 90 ... DONE
[11:41:57.591] Chunk #66 of 90 ...
[11:41:57.591]  - seeds: [1] <seeds>
[11:41:57.591] getGlobalsAndPackages() ...
[11:41:57.592] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:57.592] Resolving globals: FALSE
[11:41:57.593] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:57.593] - packages: [1] ‘mlr3’
[11:41:57.593] getGlobalsAndPackages() ... DONE
[11:41:57.593] run() for ‘Future’ ...
[11:41:57.593] - state: ‘created’
[11:41:57.594] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:57.610] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:57.610] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:57.610]   - Field: ‘node’
[11:41:57.610]   - Field: ‘label’
[11:41:57.610]   - Field: ‘local’
[11:41:57.611]   - Field: ‘owner’
[11:41:57.611]   - Field: ‘envir’
[11:41:57.611]   - Field: ‘workers’
[11:41:57.611]   - Field: ‘packages’
[11:41:57.611]   - Field: ‘gc’
[11:41:57.611]   - Field: ‘conditions’
[11:41:57.611]   - Field: ‘persistent’
[11:41:57.611]   - Field: ‘expr’
[11:41:57.611]   - Field: ‘uuid’
[11:41:57.612]   - Field: ‘seed’
[11:41:57.612]   - Field: ‘version’
[11:41:57.612]   - Field: ‘result’
[11:41:57.612]   - Field: ‘asynchronous’
[11:41:57.612]   - Field: ‘calls’
[11:41:57.612]   - Field: ‘globals’
[11:41:57.612]   - Field: ‘stdout’
[11:41:57.612]   - Field: ‘earlySignal’
[11:41:57.612]   - Field: ‘lazy’
[11:41:57.613]   - Field: ‘state’
[11:41:57.613] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:57.613] - Launch lazy future ...
[11:41:57.613] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:57.614] Packages needed by future strategies (n = 0): <none>
[11:41:57.614] {
[11:41:57.614]     {
[11:41:57.614]         {
[11:41:57.614]             ...future.startTime <- base::Sys.time()
[11:41:57.614]             {
[11:41:57.614]                 {
[11:41:57.614]                   {
[11:41:57.614]                     {
[11:41:57.614]                       {
[11:41:57.614]                         base::local({
[11:41:57.614]                           has_future <- base::requireNamespace("future", 
[11:41:57.614]                             quietly = TRUE)
[11:41:57.614]                           if (has_future) {
[11:41:57.614]                             ns <- base::getNamespace("future")
[11:41:57.614]                             version <- ns[[".package"]][["version"]]
[11:41:57.614]                             if (is.null(version)) 
[11:41:57.614]                               version <- utils::packageVersion("future")
[11:41:57.614]                           }
[11:41:57.614]                           else {
[11:41:57.614]                             version <- NULL
[11:41:57.614]                           }
[11:41:57.614]                           if (!has_future || version < "1.8.0") {
[11:41:57.614]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:57.614]                               "", base::R.version$version.string), 
[11:41:57.614]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:57.614]                                 base::R.version$platform, 8 * 
[11:41:57.614]                                   base::.Machine$sizeof.pointer), 
[11:41:57.614]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:57.614]                                 "release", "version")], collapse = " "), 
[11:41:57.614]                               hostname = base::Sys.info()[["nodename"]])
[11:41:57.614]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:57.614]                               info)
[11:41:57.614]                             info <- base::paste(info, collapse = "; ")
[11:41:57.614]                             if (!has_future) {
[11:41:57.614]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:57.614]                                 info)
[11:41:57.614]                             }
[11:41:57.614]                             else {
[11:41:57.614]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:57.614]                                 info, version)
[11:41:57.614]                             }
[11:41:57.614]                             base::stop(msg)
[11:41:57.614]                           }
[11:41:57.614]                         })
[11:41:57.614]                       }
[11:41:57.614]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:57.614]                       base::options(mc.cores = 1L)
[11:41:57.614]                     }
[11:41:57.614]                     base::local({
[11:41:57.614]                       for (pkg in "mlr3") {
[11:41:57.614]                         base::loadNamespace(pkg)
[11:41:57.614]                         base::library(pkg, character.only = TRUE)
[11:41:57.614]                       }
[11:41:57.614]                     })
[11:41:57.614]                   }
[11:41:57.614]                   options(future.plan = NULL)
[11:41:57.614]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:57.614]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:57.614]                 }
[11:41:57.614]                 ...future.workdir <- getwd()
[11:41:57.614]             }
[11:41:57.614]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:57.614]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:57.614]         }
[11:41:57.614]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:57.614]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:57.614]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:57.614]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:57.614]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:57.614]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:57.614]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:57.614]             base::names(...future.oldOptions))
[11:41:57.614]     }
[11:41:57.614]     if (FALSE) {
[11:41:57.614]     }
[11:41:57.614]     else {
[11:41:57.614]         if (TRUE) {
[11:41:57.614]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:57.614]                 open = "w")
[11:41:57.614]         }
[11:41:57.614]         else {
[11:41:57.614]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:57.614]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:57.614]         }
[11:41:57.614]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:57.614]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:57.614]             base::sink(type = "output", split = FALSE)
[11:41:57.614]             base::close(...future.stdout)
[11:41:57.614]         }, add = TRUE)
[11:41:57.614]     }
[11:41:57.614]     ...future.frame <- base::sys.nframe()
[11:41:57.614]     ...future.conditions <- base::list()
[11:41:57.614]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:57.614]     if (FALSE) {
[11:41:57.614]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:57.614]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:57.614]     }
[11:41:57.614]     ...future.result <- base::tryCatch({
[11:41:57.614]         base::withCallingHandlers({
[11:41:57.614]             ...future.value <- base::withVisible(base::local({
[11:41:57.614]                 ...future.makeSendCondition <- local({
[11:41:57.614]                   sendCondition <- NULL
[11:41:57.614]                   function(frame = 1L) {
[11:41:57.614]                     if (is.function(sendCondition)) 
[11:41:57.614]                       return(sendCondition)
[11:41:57.614]                     ns <- getNamespace("parallel")
[11:41:57.614]                     if (exists("sendData", mode = "function", 
[11:41:57.614]                       envir = ns)) {
[11:41:57.614]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:57.614]                         envir = ns)
[11:41:57.614]                       envir <- sys.frame(frame)
[11:41:57.614]                       master <- NULL
[11:41:57.614]                       while (!identical(envir, .GlobalEnv) && 
[11:41:57.614]                         !identical(envir, emptyenv())) {
[11:41:57.614]                         if (exists("master", mode = "list", envir = envir, 
[11:41:57.614]                           inherits = FALSE)) {
[11:41:57.614]                           master <- get("master", mode = "list", 
[11:41:57.614]                             envir = envir, inherits = FALSE)
[11:41:57.614]                           if (inherits(master, c("SOCKnode", 
[11:41:57.614]                             "SOCK0node"))) {
[11:41:57.614]                             sendCondition <<- function(cond) {
[11:41:57.614]                               data <- list(type = "VALUE", value = cond, 
[11:41:57.614]                                 success = TRUE)
[11:41:57.614]                               parallel_sendData(master, data)
[11:41:57.614]                             }
[11:41:57.614]                             return(sendCondition)
[11:41:57.614]                           }
[11:41:57.614]                         }
[11:41:57.614]                         frame <- frame + 1L
[11:41:57.614]                         envir <- sys.frame(frame)
[11:41:57.614]                       }
[11:41:57.614]                     }
[11:41:57.614]                     sendCondition <<- function(cond) NULL
[11:41:57.614]                   }
[11:41:57.614]                 })
[11:41:57.614]                 withCallingHandlers({
[11:41:57.614]                   {
[11:41:57.614]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:57.614]                     if (!identical(...future.globals.maxSize.org, 
[11:41:57.614]                       ...future.globals.maxSize)) {
[11:41:57.614]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:57.614]                       on.exit(options(oopts), add = TRUE)
[11:41:57.614]                     }
[11:41:57.614]                     {
[11:41:57.614]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:57.614]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:57.614]                           envir = globalenv(), inherits = FALSE)
[11:41:57.614]                         ...future.FUN(...)
[11:41:57.614]                       }
[11:41:57.614]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:57.614]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:57.614]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:57.614]                         USE.NAMES = FALSE)
[11:41:57.614]                       do.call(mapply, args = args)
[11:41:57.614]                     }
[11:41:57.614]                   }
[11:41:57.614]                 }, immediateCondition = function(cond) {
[11:41:57.614]                   sendCondition <- ...future.makeSendCondition()
[11:41:57.614]                   sendCondition(cond)
[11:41:57.614]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:57.614]                   {
[11:41:57.614]                     inherits <- base::inherits
[11:41:57.614]                     invokeRestart <- base::invokeRestart
[11:41:57.614]                     is.null <- base::is.null
[11:41:57.614]                     muffled <- FALSE
[11:41:57.614]                     if (inherits(cond, "message")) {
[11:41:57.614]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:57.614]                       if (muffled) 
[11:41:57.614]                         invokeRestart("muffleMessage")
[11:41:57.614]                     }
[11:41:57.614]                     else if (inherits(cond, "warning")) {
[11:41:57.614]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:57.614]                       if (muffled) 
[11:41:57.614]                         invokeRestart("muffleWarning")
[11:41:57.614]                     }
[11:41:57.614]                     else if (inherits(cond, "condition")) {
[11:41:57.614]                       if (!is.null(pattern)) {
[11:41:57.614]                         computeRestarts <- base::computeRestarts
[11:41:57.614]                         grepl <- base::grepl
[11:41:57.614]                         restarts <- computeRestarts(cond)
[11:41:57.614]                         for (restart in restarts) {
[11:41:57.614]                           name <- restart$name
[11:41:57.614]                           if (is.null(name)) 
[11:41:57.614]                             next
[11:41:57.614]                           if (!grepl(pattern, name)) 
[11:41:57.614]                             next
[11:41:57.614]                           invokeRestart(restart)
[11:41:57.614]                           muffled <- TRUE
[11:41:57.614]                           break
[11:41:57.614]                         }
[11:41:57.614]                       }
[11:41:57.614]                     }
[11:41:57.614]                     invisible(muffled)
[11:41:57.614]                   }
[11:41:57.614]                   muffleCondition(cond)
[11:41:57.614]                 })
[11:41:57.614]             }))
[11:41:57.614]             future::FutureResult(value = ...future.value$value, 
[11:41:57.614]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:57.614]                   ...future.rng), globalenv = if (FALSE) 
[11:41:57.614]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:57.614]                     ...future.globalenv.names))
[11:41:57.614]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:57.614]         }, condition = base::local({
[11:41:57.614]             c <- base::c
[11:41:57.614]             inherits <- base::inherits
[11:41:57.614]             invokeRestart <- base::invokeRestart
[11:41:57.614]             length <- base::length
[11:41:57.614]             list <- base::list
[11:41:57.614]             seq.int <- base::seq.int
[11:41:57.614]             signalCondition <- base::signalCondition
[11:41:57.614]             sys.calls <- base::sys.calls
[11:41:57.614]             `[[` <- base::`[[`
[11:41:57.614]             `+` <- base::`+`
[11:41:57.614]             `<<-` <- base::`<<-`
[11:41:57.614]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:57.614]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:57.614]                   3L)]
[11:41:57.614]             }
[11:41:57.614]             function(cond) {
[11:41:57.614]                 is_error <- inherits(cond, "error")
[11:41:57.614]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:57.614]                   NULL)
[11:41:57.614]                 if (is_error) {
[11:41:57.614]                   sessionInformation <- function() {
[11:41:57.614]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:57.614]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:57.614]                       search = base::search(), system = base::Sys.info())
[11:41:57.614]                   }
[11:41:57.614]                   ...future.conditions[[length(...future.conditions) + 
[11:41:57.614]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:57.614]                     cond$call), session = sessionInformation(), 
[11:41:57.614]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:57.614]                   signalCondition(cond)
[11:41:57.614]                 }
[11:41:57.614]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:57.614]                 "immediateCondition"))) {
[11:41:57.614]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:57.614]                   ...future.conditions[[length(...future.conditions) + 
[11:41:57.614]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:57.614]                   if (TRUE && !signal) {
[11:41:57.614]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:57.614]                     {
[11:41:57.614]                       inherits <- base::inherits
[11:41:57.614]                       invokeRestart <- base::invokeRestart
[11:41:57.614]                       is.null <- base::is.null
[11:41:57.614]                       muffled <- FALSE
[11:41:57.614]                       if (inherits(cond, "message")) {
[11:41:57.614]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:57.614]                         if (muffled) 
[11:41:57.614]                           invokeRestart("muffleMessage")
[11:41:57.614]                       }
[11:41:57.614]                       else if (inherits(cond, "warning")) {
[11:41:57.614]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:57.614]                         if (muffled) 
[11:41:57.614]                           invokeRestart("muffleWarning")
[11:41:57.614]                       }
[11:41:57.614]                       else if (inherits(cond, "condition")) {
[11:41:57.614]                         if (!is.null(pattern)) {
[11:41:57.614]                           computeRestarts <- base::computeRestarts
[11:41:57.614]                           grepl <- base::grepl
[11:41:57.614]                           restarts <- computeRestarts(cond)
[11:41:57.614]                           for (restart in restarts) {
[11:41:57.614]                             name <- restart$name
[11:41:57.614]                             if (is.null(name)) 
[11:41:57.614]                               next
[11:41:57.614]                             if (!grepl(pattern, name)) 
[11:41:57.614]                               next
[11:41:57.614]                             invokeRestart(restart)
[11:41:57.614]                             muffled <- TRUE
[11:41:57.614]                             break
[11:41:57.614]                           }
[11:41:57.614]                         }
[11:41:57.614]                       }
[11:41:57.614]                       invisible(muffled)
[11:41:57.614]                     }
[11:41:57.614]                     muffleCondition(cond, pattern = "^muffle")
[11:41:57.614]                   }
[11:41:57.614]                 }
[11:41:57.614]                 else {
[11:41:57.614]                   if (TRUE) {
[11:41:57.614]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:57.614]                     {
[11:41:57.614]                       inherits <- base::inherits
[11:41:57.614]                       invokeRestart <- base::invokeRestart
[11:41:57.614]                       is.null <- base::is.null
[11:41:57.614]                       muffled <- FALSE
[11:41:57.614]                       if (inherits(cond, "message")) {
[11:41:57.614]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:57.614]                         if (muffled) 
[11:41:57.614]                           invokeRestart("muffleMessage")
[11:41:57.614]                       }
[11:41:57.614]                       else if (inherits(cond, "warning")) {
[11:41:57.614]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:57.614]                         if (muffled) 
[11:41:57.614]                           invokeRestart("muffleWarning")
[11:41:57.614]                       }
[11:41:57.614]                       else if (inherits(cond, "condition")) {
[11:41:57.614]                         if (!is.null(pattern)) {
[11:41:57.614]                           computeRestarts <- base::computeRestarts
[11:41:57.614]                           grepl <- base::grepl
[11:41:57.614]                           restarts <- computeRestarts(cond)
[11:41:57.614]                           for (restart in restarts) {
[11:41:57.614]                             name <- restart$name
[11:41:57.614]                             if (is.null(name)) 
[11:41:57.614]                               next
[11:41:57.614]                             if (!grepl(pattern, name)) 
[11:41:57.614]                               next
[11:41:57.614]                             invokeRestart(restart)
[11:41:57.614]                             muffled <- TRUE
[11:41:57.614]                             break
[11:41:57.614]                           }
[11:41:57.614]                         }
[11:41:57.614]                       }
[11:41:57.614]                       invisible(muffled)
[11:41:57.614]                     }
[11:41:57.614]                     muffleCondition(cond, pattern = "^muffle")
[11:41:57.614]                   }
[11:41:57.614]                 }
[11:41:57.614]             }
[11:41:57.614]         }))
[11:41:57.614]     }, error = function(ex) {
[11:41:57.614]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:57.614]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:57.614]                 ...future.rng), started = ...future.startTime, 
[11:41:57.614]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:57.614]             version = "1.8"), class = "FutureResult")
[11:41:57.614]     }, finally = {
[11:41:57.614]         if (!identical(...future.workdir, getwd())) 
[11:41:57.614]             setwd(...future.workdir)
[11:41:57.614]         {
[11:41:57.614]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:57.614]                 ...future.oldOptions$nwarnings <- NULL
[11:41:57.614]             }
[11:41:57.614]             base::options(...future.oldOptions)
[11:41:57.614]             if (.Platform$OS.type == "windows") {
[11:41:57.614]                 old_names <- names(...future.oldEnvVars)
[11:41:57.614]                 envs <- base::Sys.getenv()
[11:41:57.614]                 names <- names(envs)
[11:41:57.614]                 common <- intersect(names, old_names)
[11:41:57.614]                 added <- setdiff(names, old_names)
[11:41:57.614]                 removed <- setdiff(old_names, names)
[11:41:57.614]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:57.614]                   envs[common]]
[11:41:57.614]                 NAMES <- toupper(changed)
[11:41:57.614]                 args <- list()
[11:41:57.614]                 for (kk in seq_along(NAMES)) {
[11:41:57.614]                   name <- changed[[kk]]
[11:41:57.614]                   NAME <- NAMES[[kk]]
[11:41:57.614]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:57.614]                     next
[11:41:57.614]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:57.614]                 }
[11:41:57.614]                 NAMES <- toupper(added)
[11:41:57.614]                 for (kk in seq_along(NAMES)) {
[11:41:57.614]                   name <- added[[kk]]
[11:41:57.614]                   NAME <- NAMES[[kk]]
[11:41:57.614]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:57.614]                     next
[11:41:57.614]                   args[[name]] <- ""
[11:41:57.614]                 }
[11:41:57.614]                 NAMES <- toupper(removed)
[11:41:57.614]                 for (kk in seq_along(NAMES)) {
[11:41:57.614]                   name <- removed[[kk]]
[11:41:57.614]                   NAME <- NAMES[[kk]]
[11:41:57.614]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:57.614]                     next
[11:41:57.614]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:57.614]                 }
[11:41:57.614]                 if (length(args) > 0) 
[11:41:57.614]                   base::do.call(base::Sys.setenv, args = args)
[11:41:57.614]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:57.614]             }
[11:41:57.614]             else {
[11:41:57.614]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:57.614]             }
[11:41:57.614]             {
[11:41:57.614]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:57.614]                   0L) {
[11:41:57.614]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:57.614]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:57.614]                   base::options(opts)
[11:41:57.614]                 }
[11:41:57.614]                 {
[11:41:57.614]                   {
[11:41:57.614]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:57.614]                     NULL
[11:41:57.614]                   }
[11:41:57.614]                   options(future.plan = NULL)
[11:41:57.614]                   if (is.na(NA_character_)) 
[11:41:57.614]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:57.614]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:57.614]                   future::plan(list(function (..., workers = 2, 
[11:41:57.614]                     envir = parent.frame()) 
[11:41:57.614]                   strategy(..., workers = workers, envir = envir)), 
[11:41:57.614]                     .cleanup = FALSE, .init = FALSE)
[11:41:57.614]                 }
[11:41:57.614]             }
[11:41:57.614]         }
[11:41:57.614]     })
[11:41:57.614]     if (TRUE) {
[11:41:57.614]         base::sink(type = "output", split = FALSE)
[11:41:57.614]         if (TRUE) {
[11:41:57.614]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:57.614]         }
[11:41:57.614]         else {
[11:41:57.614]             ...future.result["stdout"] <- base::list(NULL)
[11:41:57.614]         }
[11:41:57.614]         base::close(...future.stdout)
[11:41:57.614]         ...future.stdout <- NULL
[11:41:57.614]     }
[11:41:57.614]     ...future.result$conditions <- ...future.conditions
[11:41:57.614]     ...future.result$finished <- base::Sys.time()
[11:41:57.614]     ...future.result
[11:41:57.614] }
[11:41:57.617] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:57.628] receiveMessageFromWorker() for ClusterFuture ...
[11:41:57.628] - Validating connection of MultisessionFuture
[11:41:57.628] - received message: FutureResult
[11:41:57.628] - Received FutureResult
[11:41:57.629] - Erased future from FutureRegistry
[11:41:57.629] result() for ClusterFuture ...
[11:41:57.629] - result already collected: FutureResult
[11:41:57.629] result() for ClusterFuture ... done
[11:41:57.629] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:57.629] result() for ClusterFuture ...
[11:41:57.629] - result already collected: FutureResult
[11:41:57.629] result() for ClusterFuture ... done
[11:41:57.629] result() for ClusterFuture ...
[11:41:57.629] - result already collected: FutureResult
[11:41:57.629] result() for ClusterFuture ... done
[11:41:57.630] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:57.630] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:57.673] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:57.678] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:57.721] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:57.721] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:57.765] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:57.766] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:57.766] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:57.766] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:57.767] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:57.767] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:57.767] MultisessionFuture started
[11:41:57.768] - Launch lazy future ... done
[11:41:57.768] run() for ‘MultisessionFuture’ ... done
[11:41:57.768] Created future:
[11:41:57.768] MultisessionFuture:
[11:41:57.768] Label: ‘future_mapply-66’
[11:41:57.768] Expression:
[11:41:57.768] {
[11:41:57.768]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:57.768]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:57.768]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:57.768]         on.exit(options(oopts), add = TRUE)
[11:41:57.768]     }
[11:41:57.768]     {
[11:41:57.768]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:57.768]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:57.768]                 inherits = FALSE)
[11:41:57.768]             ...future.FUN(...)
[11:41:57.768]         }
[11:41:57.768]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:57.768]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:57.768]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:57.768]         do.call(mapply, args = args)
[11:41:57.768]     }
[11:41:57.768] }
[11:41:57.768] Lazy evaluation: FALSE
[11:41:57.768] Asynchronous evaluation: TRUE
[11:41:57.768] Local evaluation: TRUE
[11:41:57.768] Environment: 0x560ef58e1768
[11:41:57.768] Capture standard output: TRUE
[11:41:57.768] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:57.768] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:57.768] Packages: 1 packages (‘mlr3’)
[11:41:57.768] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:57.768] Resolved: FALSE
[11:41:57.768] Value: <not collected>
[11:41:57.768] Conditions captured: <none>
[11:41:57.768] Early signaling: FALSE
[11:41:57.768] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:57.768] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:57.784] Chunk #66 of 90 ... DONE
[11:41:57.784] Chunk #67 of 90 ...
[11:41:57.784]  - seeds: [1] <seeds>
[11:41:57.784] getGlobalsAndPackages() ...
[11:41:57.784] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:57.785] Resolving globals: FALSE
[11:41:57.785] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:57.785] - packages: [1] ‘mlr3’
[11:41:57.785] getGlobalsAndPackages() ... DONE
[11:41:57.786] run() for ‘Future’ ...
[11:41:57.786] - state: ‘created’
[11:41:57.786] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:57.806] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:57.806] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:57.806]   - Field: ‘node’
[11:41:57.806]   - Field: ‘label’
[11:41:57.806]   - Field: ‘local’
[11:41:57.807]   - Field: ‘owner’
[11:41:57.807]   - Field: ‘envir’
[11:41:57.807]   - Field: ‘workers’
[11:41:57.807]   - Field: ‘packages’
[11:41:57.807]   - Field: ‘gc’
[11:41:57.807]   - Field: ‘conditions’
[11:41:57.807]   - Field: ‘persistent’
[11:41:57.807]   - Field: ‘expr’
[11:41:57.807]   - Field: ‘uuid’
[11:41:57.807]   - Field: ‘seed’
[11:41:57.807]   - Field: ‘version’
[11:41:57.807]   - Field: ‘result’
[11:41:57.808]   - Field: ‘asynchronous’
[11:41:57.808]   - Field: ‘calls’
[11:41:57.808]   - Field: ‘globals’
[11:41:57.808]   - Field: ‘stdout’
[11:41:57.808]   - Field: ‘earlySignal’
[11:41:57.808]   - Field: ‘lazy’
[11:41:57.808]   - Field: ‘state’
[11:41:57.808] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:57.808] - Launch lazy future ...
[11:41:57.809] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:57.809] Packages needed by future strategies (n = 0): <none>
[11:41:57.809] {
[11:41:57.809]     {
[11:41:57.809]         {
[11:41:57.809]             ...future.startTime <- base::Sys.time()
[11:41:57.809]             {
[11:41:57.809]                 {
[11:41:57.809]                   {
[11:41:57.809]                     {
[11:41:57.809]                       {
[11:41:57.809]                         base::local({
[11:41:57.809]                           has_future <- base::requireNamespace("future", 
[11:41:57.809]                             quietly = TRUE)
[11:41:57.809]                           if (has_future) {
[11:41:57.809]                             ns <- base::getNamespace("future")
[11:41:57.809]                             version <- ns[[".package"]][["version"]]
[11:41:57.809]                             if (is.null(version)) 
[11:41:57.809]                               version <- utils::packageVersion("future")
[11:41:57.809]                           }
[11:41:57.809]                           else {
[11:41:57.809]                             version <- NULL
[11:41:57.809]                           }
[11:41:57.809]                           if (!has_future || version < "1.8.0") {
[11:41:57.809]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:57.809]                               "", base::R.version$version.string), 
[11:41:57.809]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:57.809]                                 base::R.version$platform, 8 * 
[11:41:57.809]                                   base::.Machine$sizeof.pointer), 
[11:41:57.809]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:57.809]                                 "release", "version")], collapse = " "), 
[11:41:57.809]                               hostname = base::Sys.info()[["nodename"]])
[11:41:57.809]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:57.809]                               info)
[11:41:57.809]                             info <- base::paste(info, collapse = "; ")
[11:41:57.809]                             if (!has_future) {
[11:41:57.809]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:57.809]                                 info)
[11:41:57.809]                             }
[11:41:57.809]                             else {
[11:41:57.809]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:57.809]                                 info, version)
[11:41:57.809]                             }
[11:41:57.809]                             base::stop(msg)
[11:41:57.809]                           }
[11:41:57.809]                         })
[11:41:57.809]                       }
[11:41:57.809]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:57.809]                       base::options(mc.cores = 1L)
[11:41:57.809]                     }
[11:41:57.809]                     base::local({
[11:41:57.809]                       for (pkg in "mlr3") {
[11:41:57.809]                         base::loadNamespace(pkg)
[11:41:57.809]                         base::library(pkg, character.only = TRUE)
[11:41:57.809]                       }
[11:41:57.809]                     })
[11:41:57.809]                   }
[11:41:57.809]                   options(future.plan = NULL)
[11:41:57.809]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:57.809]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:57.809]                 }
[11:41:57.809]                 ...future.workdir <- getwd()
[11:41:57.809]             }
[11:41:57.809]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:57.809]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:57.809]         }
[11:41:57.809]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:57.809]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:57.809]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:57.809]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:57.809]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:57.809]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:57.809]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:57.809]             base::names(...future.oldOptions))
[11:41:57.809]     }
[11:41:57.809]     if (FALSE) {
[11:41:57.809]     }
[11:41:57.809]     else {
[11:41:57.809]         if (TRUE) {
[11:41:57.809]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:57.809]                 open = "w")
[11:41:57.809]         }
[11:41:57.809]         else {
[11:41:57.809]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:57.809]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:57.809]         }
[11:41:57.809]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:57.809]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:57.809]             base::sink(type = "output", split = FALSE)
[11:41:57.809]             base::close(...future.stdout)
[11:41:57.809]         }, add = TRUE)
[11:41:57.809]     }
[11:41:57.809]     ...future.frame <- base::sys.nframe()
[11:41:57.809]     ...future.conditions <- base::list()
[11:41:57.809]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:57.809]     if (FALSE) {
[11:41:57.809]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:57.809]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:57.809]     }
[11:41:57.809]     ...future.result <- base::tryCatch({
[11:41:57.809]         base::withCallingHandlers({
[11:41:57.809]             ...future.value <- base::withVisible(base::local({
[11:41:57.809]                 ...future.makeSendCondition <- local({
[11:41:57.809]                   sendCondition <- NULL
[11:41:57.809]                   function(frame = 1L) {
[11:41:57.809]                     if (is.function(sendCondition)) 
[11:41:57.809]                       return(sendCondition)
[11:41:57.809]                     ns <- getNamespace("parallel")
[11:41:57.809]                     if (exists("sendData", mode = "function", 
[11:41:57.809]                       envir = ns)) {
[11:41:57.809]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:57.809]                         envir = ns)
[11:41:57.809]                       envir <- sys.frame(frame)
[11:41:57.809]                       master <- NULL
[11:41:57.809]                       while (!identical(envir, .GlobalEnv) && 
[11:41:57.809]                         !identical(envir, emptyenv())) {
[11:41:57.809]                         if (exists("master", mode = "list", envir = envir, 
[11:41:57.809]                           inherits = FALSE)) {
[11:41:57.809]                           master <- get("master", mode = "list", 
[11:41:57.809]                             envir = envir, inherits = FALSE)
[11:41:57.809]                           if (inherits(master, c("SOCKnode", 
[11:41:57.809]                             "SOCK0node"))) {
[11:41:57.809]                             sendCondition <<- function(cond) {
[11:41:57.809]                               data <- list(type = "VALUE", value = cond, 
[11:41:57.809]                                 success = TRUE)
[11:41:57.809]                               parallel_sendData(master, data)
[11:41:57.809]                             }
[11:41:57.809]                             return(sendCondition)
[11:41:57.809]                           }
[11:41:57.809]                         }
[11:41:57.809]                         frame <- frame + 1L
[11:41:57.809]                         envir <- sys.frame(frame)
[11:41:57.809]                       }
[11:41:57.809]                     }
[11:41:57.809]                     sendCondition <<- function(cond) NULL
[11:41:57.809]                   }
[11:41:57.809]                 })
[11:41:57.809]                 withCallingHandlers({
[11:41:57.809]                   {
[11:41:57.809]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:57.809]                     if (!identical(...future.globals.maxSize.org, 
[11:41:57.809]                       ...future.globals.maxSize)) {
[11:41:57.809]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:57.809]                       on.exit(options(oopts), add = TRUE)
[11:41:57.809]                     }
[11:41:57.809]                     {
[11:41:57.809]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:57.809]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:57.809]                           envir = globalenv(), inherits = FALSE)
[11:41:57.809]                         ...future.FUN(...)
[11:41:57.809]                       }
[11:41:57.809]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:57.809]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:57.809]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:57.809]                         USE.NAMES = FALSE)
[11:41:57.809]                       do.call(mapply, args = args)
[11:41:57.809]                     }
[11:41:57.809]                   }
[11:41:57.809]                 }, immediateCondition = function(cond) {
[11:41:57.809]                   sendCondition <- ...future.makeSendCondition()
[11:41:57.809]                   sendCondition(cond)
[11:41:57.809]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:57.809]                   {
[11:41:57.809]                     inherits <- base::inherits
[11:41:57.809]                     invokeRestart <- base::invokeRestart
[11:41:57.809]                     is.null <- base::is.null
[11:41:57.809]                     muffled <- FALSE
[11:41:57.809]                     if (inherits(cond, "message")) {
[11:41:57.809]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:57.809]                       if (muffled) 
[11:41:57.809]                         invokeRestart("muffleMessage")
[11:41:57.809]                     }
[11:41:57.809]                     else if (inherits(cond, "warning")) {
[11:41:57.809]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:57.809]                       if (muffled) 
[11:41:57.809]                         invokeRestart("muffleWarning")
[11:41:57.809]                     }
[11:41:57.809]                     else if (inherits(cond, "condition")) {
[11:41:57.809]                       if (!is.null(pattern)) {
[11:41:57.809]                         computeRestarts <- base::computeRestarts
[11:41:57.809]                         grepl <- base::grepl
[11:41:57.809]                         restarts <- computeRestarts(cond)
[11:41:57.809]                         for (restart in restarts) {
[11:41:57.809]                           name <- restart$name
[11:41:57.809]                           if (is.null(name)) 
[11:41:57.809]                             next
[11:41:57.809]                           if (!grepl(pattern, name)) 
[11:41:57.809]                             next
[11:41:57.809]                           invokeRestart(restart)
[11:41:57.809]                           muffled <- TRUE
[11:41:57.809]                           break
[11:41:57.809]                         }
[11:41:57.809]                       }
[11:41:57.809]                     }
[11:41:57.809]                     invisible(muffled)
[11:41:57.809]                   }
[11:41:57.809]                   muffleCondition(cond)
[11:41:57.809]                 })
[11:41:57.809]             }))
[11:41:57.809]             future::FutureResult(value = ...future.value$value, 
[11:41:57.809]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:57.809]                   ...future.rng), globalenv = if (FALSE) 
[11:41:57.809]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:57.809]                     ...future.globalenv.names))
[11:41:57.809]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:57.809]         }, condition = base::local({
[11:41:57.809]             c <- base::c
[11:41:57.809]             inherits <- base::inherits
[11:41:57.809]             invokeRestart <- base::invokeRestart
[11:41:57.809]             length <- base::length
[11:41:57.809]             list <- base::list
[11:41:57.809]             seq.int <- base::seq.int
[11:41:57.809]             signalCondition <- base::signalCondition
[11:41:57.809]             sys.calls <- base::sys.calls
[11:41:57.809]             `[[` <- base::`[[`
[11:41:57.809]             `+` <- base::`+`
[11:41:57.809]             `<<-` <- base::`<<-`
[11:41:57.809]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:57.809]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:57.809]                   3L)]
[11:41:57.809]             }
[11:41:57.809]             function(cond) {
[11:41:57.809]                 is_error <- inherits(cond, "error")
[11:41:57.809]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:57.809]                   NULL)
[11:41:57.809]                 if (is_error) {
[11:41:57.809]                   sessionInformation <- function() {
[11:41:57.809]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:57.809]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:57.809]                       search = base::search(), system = base::Sys.info())
[11:41:57.809]                   }
[11:41:57.809]                   ...future.conditions[[length(...future.conditions) + 
[11:41:57.809]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:57.809]                     cond$call), session = sessionInformation(), 
[11:41:57.809]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:57.809]                   signalCondition(cond)
[11:41:57.809]                 }
[11:41:57.809]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:57.809]                 "immediateCondition"))) {
[11:41:57.809]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:57.809]                   ...future.conditions[[length(...future.conditions) + 
[11:41:57.809]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:57.809]                   if (TRUE && !signal) {
[11:41:57.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:57.809]                     {
[11:41:57.809]                       inherits <- base::inherits
[11:41:57.809]                       invokeRestart <- base::invokeRestart
[11:41:57.809]                       is.null <- base::is.null
[11:41:57.809]                       muffled <- FALSE
[11:41:57.809]                       if (inherits(cond, "message")) {
[11:41:57.809]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:57.809]                         if (muffled) 
[11:41:57.809]                           invokeRestart("muffleMessage")
[11:41:57.809]                       }
[11:41:57.809]                       else if (inherits(cond, "warning")) {
[11:41:57.809]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:57.809]                         if (muffled) 
[11:41:57.809]                           invokeRestart("muffleWarning")
[11:41:57.809]                       }
[11:41:57.809]                       else if (inherits(cond, "condition")) {
[11:41:57.809]                         if (!is.null(pattern)) {
[11:41:57.809]                           computeRestarts <- base::computeRestarts
[11:41:57.809]                           grepl <- base::grepl
[11:41:57.809]                           restarts <- computeRestarts(cond)
[11:41:57.809]                           for (restart in restarts) {
[11:41:57.809]                             name <- restart$name
[11:41:57.809]                             if (is.null(name)) 
[11:41:57.809]                               next
[11:41:57.809]                             if (!grepl(pattern, name)) 
[11:41:57.809]                               next
[11:41:57.809]                             invokeRestart(restart)
[11:41:57.809]                             muffled <- TRUE
[11:41:57.809]                             break
[11:41:57.809]                           }
[11:41:57.809]                         }
[11:41:57.809]                       }
[11:41:57.809]                       invisible(muffled)
[11:41:57.809]                     }
[11:41:57.809]                     muffleCondition(cond, pattern = "^muffle")
[11:41:57.809]                   }
[11:41:57.809]                 }
[11:41:57.809]                 else {
[11:41:57.809]                   if (TRUE) {
[11:41:57.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:57.809]                     {
[11:41:57.809]                       inherits <- base::inherits
[11:41:57.809]                       invokeRestart <- base::invokeRestart
[11:41:57.809]                       is.null <- base::is.null
[11:41:57.809]                       muffled <- FALSE
[11:41:57.809]                       if (inherits(cond, "message")) {
[11:41:57.809]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:57.809]                         if (muffled) 
[11:41:57.809]                           invokeRestart("muffleMessage")
[11:41:57.809]                       }
[11:41:57.809]                       else if (inherits(cond, "warning")) {
[11:41:57.809]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:57.809]                         if (muffled) 
[11:41:57.809]                           invokeRestart("muffleWarning")
[11:41:57.809]                       }
[11:41:57.809]                       else if (inherits(cond, "condition")) {
[11:41:57.809]                         if (!is.null(pattern)) {
[11:41:57.809]                           computeRestarts <- base::computeRestarts
[11:41:57.809]                           grepl <- base::grepl
[11:41:57.809]                           restarts <- computeRestarts(cond)
[11:41:57.809]                           for (restart in restarts) {
[11:41:57.809]                             name <- restart$name
[11:41:57.809]                             if (is.null(name)) 
[11:41:57.809]                               next
[11:41:57.809]                             if (!grepl(pattern, name)) 
[11:41:57.809]                               next
[11:41:57.809]                             invokeRestart(restart)
[11:41:57.809]                             muffled <- TRUE
[11:41:57.809]                             break
[11:41:57.809]                           }
[11:41:57.809]                         }
[11:41:57.809]                       }
[11:41:57.809]                       invisible(muffled)
[11:41:57.809]                     }
[11:41:57.809]                     muffleCondition(cond, pattern = "^muffle")
[11:41:57.809]                   }
[11:41:57.809]                 }
[11:41:57.809]             }
[11:41:57.809]         }))
[11:41:57.809]     }, error = function(ex) {
[11:41:57.809]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:57.809]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:57.809]                 ...future.rng), started = ...future.startTime, 
[11:41:57.809]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:57.809]             version = "1.8"), class = "FutureResult")
[11:41:57.809]     }, finally = {
[11:41:57.809]         if (!identical(...future.workdir, getwd())) 
[11:41:57.809]             setwd(...future.workdir)
[11:41:57.809]         {
[11:41:57.809]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:57.809]                 ...future.oldOptions$nwarnings <- NULL
[11:41:57.809]             }
[11:41:57.809]             base::options(...future.oldOptions)
[11:41:57.809]             if (.Platform$OS.type == "windows") {
[11:41:57.809]                 old_names <- names(...future.oldEnvVars)
[11:41:57.809]                 envs <- base::Sys.getenv()
[11:41:57.809]                 names <- names(envs)
[11:41:57.809]                 common <- intersect(names, old_names)
[11:41:57.809]                 added <- setdiff(names, old_names)
[11:41:57.809]                 removed <- setdiff(old_names, names)
[11:41:57.809]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:57.809]                   envs[common]]
[11:41:57.809]                 NAMES <- toupper(changed)
[11:41:57.809]                 args <- list()
[11:41:57.809]                 for (kk in seq_along(NAMES)) {
[11:41:57.809]                   name <- changed[[kk]]
[11:41:57.809]                   NAME <- NAMES[[kk]]
[11:41:57.809]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:57.809]                     next
[11:41:57.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:57.809]                 }
[11:41:57.809]                 NAMES <- toupper(added)
[11:41:57.809]                 for (kk in seq_along(NAMES)) {
[11:41:57.809]                   name <- added[[kk]]
[11:41:57.809]                   NAME <- NAMES[[kk]]
[11:41:57.809]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:57.809]                     next
[11:41:57.809]                   args[[name]] <- ""
[11:41:57.809]                 }
[11:41:57.809]                 NAMES <- toupper(removed)
[11:41:57.809]                 for (kk in seq_along(NAMES)) {
[11:41:57.809]                   name <- removed[[kk]]
[11:41:57.809]                   NAME <- NAMES[[kk]]
[11:41:57.809]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:57.809]                     next
[11:41:57.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:57.809]                 }
[11:41:57.809]                 if (length(args) > 0) 
[11:41:57.809]                   base::do.call(base::Sys.setenv, args = args)
[11:41:57.809]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:57.809]             }
[11:41:57.809]             else {
[11:41:57.809]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:57.809]             }
[11:41:57.809]             {
[11:41:57.809]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:57.809]                   0L) {
[11:41:57.809]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:57.809]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:57.809]                   base::options(opts)
[11:41:57.809]                 }
[11:41:57.809]                 {
[11:41:57.809]                   {
[11:41:57.809]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:57.809]                     NULL
[11:41:57.809]                   }
[11:41:57.809]                   options(future.plan = NULL)
[11:41:57.809]                   if (is.na(NA_character_)) 
[11:41:57.809]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:57.809]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:57.809]                   future::plan(list(function (..., workers = 2, 
[11:41:57.809]                     envir = parent.frame()) 
[11:41:57.809]                   strategy(..., workers = workers, envir = envir)), 
[11:41:57.809]                     .cleanup = FALSE, .init = FALSE)
[11:41:57.809]                 }
[11:41:57.809]             }
[11:41:57.809]         }
[11:41:57.809]     })
[11:41:57.809]     if (TRUE) {
[11:41:57.809]         base::sink(type = "output", split = FALSE)
[11:41:57.809]         if (TRUE) {
[11:41:57.809]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:57.809]         }
[11:41:57.809]         else {
[11:41:57.809]             ...future.result["stdout"] <- base::list(NULL)
[11:41:57.809]         }
[11:41:57.809]         base::close(...future.stdout)
[11:41:57.809]         ...future.stdout <- NULL
[11:41:57.809]     }
[11:41:57.809]     ...future.result$conditions <- ...future.conditions
[11:41:57.809]     ...future.result$finished <- base::Sys.time()
[11:41:57.809]     ...future.result
[11:41:57.809] }
[11:41:57.811] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:57.822] receiveMessageFromWorker() for ClusterFuture ...
[11:41:57.822] - Validating connection of MultisessionFuture
[11:41:57.822] - received message: FutureResult
[11:41:57.822] - Received FutureResult
[11:41:57.823] - Erased future from FutureRegistry
[11:41:57.823] result() for ClusterFuture ...
[11:41:57.823] - result already collected: FutureResult
[11:41:57.823] result() for ClusterFuture ... done
[11:41:57.823] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:57.823] result() for ClusterFuture ...
[11:41:57.823] - result already collected: FutureResult
[11:41:57.823] result() for ClusterFuture ... done
[11:41:57.823] result() for ClusterFuture ...
[11:41:57.823] - result already collected: FutureResult
[11:41:57.823] result() for ClusterFuture ... done
[11:41:57.824] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:57.824] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:57.865] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:57.868] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:57.870] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:57.870] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:57.913] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:57.914] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:57.914] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:57.914] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:57.915] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:57.915] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:57.915] MultisessionFuture started
[11:41:57.915] - Launch lazy future ... done
[11:41:57.915] run() for ‘MultisessionFuture’ ... done
[11:41:57.916] Created future:
[11:41:57.916] MultisessionFuture:
[11:41:57.916] Label: ‘future_mapply-67’
[11:41:57.916] Expression:
[11:41:57.916] {
[11:41:57.916]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:57.916]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:57.916]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:57.916]         on.exit(options(oopts), add = TRUE)
[11:41:57.916]     }
[11:41:57.916]     {
[11:41:57.916]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:57.916]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:57.916]                 inherits = FALSE)
[11:41:57.916]             ...future.FUN(...)
[11:41:57.916]         }
[11:41:57.916]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:57.916]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:57.916]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:57.916]         do.call(mapply, args = args)
[11:41:57.916]     }
[11:41:57.916] }
[11:41:57.916] Lazy evaluation: FALSE
[11:41:57.916] Asynchronous evaluation: TRUE
[11:41:57.916] Local evaluation: TRUE
[11:41:57.916] Environment: 0x560ef58e1768
[11:41:57.916] Capture standard output: TRUE
[11:41:57.916] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:57.916] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:57.916] Packages: 1 packages (‘mlr3’)
[11:41:57.916] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:57.916] Resolved: FALSE
[11:41:57.916] Value: <not collected>
[11:41:57.916] Conditions captured: <none>
[11:41:57.916] Early signaling: FALSE
[11:41:57.916] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:57.916] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:57.930] Chunk #67 of 90 ... DONE
[11:41:57.930] Chunk #68 of 90 ...
[11:41:57.930]  - seeds: [1] <seeds>
[11:41:57.930] getGlobalsAndPackages() ...
[11:41:57.930] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:57.930] Resolving globals: FALSE
[11:41:57.930] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:57.931] - packages: [1] ‘mlr3’
[11:41:57.931] getGlobalsAndPackages() ... DONE
[11:41:57.931] run() for ‘Future’ ...
[11:41:57.931] - state: ‘created’
[11:41:57.931] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:57.941] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:57.941] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:57.941]   - Field: ‘node’
[11:41:57.941]   - Field: ‘label’
[11:41:57.941]   - Field: ‘local’
[11:41:57.941]   - Field: ‘owner’
[11:41:57.941]   - Field: ‘envir’
[11:41:57.941]   - Field: ‘workers’
[11:41:57.942]   - Field: ‘packages’
[11:41:57.942]   - Field: ‘gc’
[11:41:57.942]   - Field: ‘conditions’
[11:41:57.942]   - Field: ‘persistent’
[11:41:57.942]   - Field: ‘expr’
[11:41:57.942]   - Field: ‘uuid’
[11:41:57.942]   - Field: ‘seed’
[11:41:57.942]   - Field: ‘version’
[11:41:57.942]   - Field: ‘result’
[11:41:57.942]   - Field: ‘asynchronous’
[11:41:57.942]   - Field: ‘calls’
[11:41:57.942]   - Field: ‘globals’
[11:41:57.942]   - Field: ‘stdout’
[11:41:57.942]   - Field: ‘earlySignal’
[11:41:57.942]   - Field: ‘lazy’
[11:41:57.942]   - Field: ‘state’
[11:41:57.942] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:57.943] - Launch lazy future ...
[11:41:57.943] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:57.943] Packages needed by future strategies (n = 0): <none>
[11:41:57.943] {
[11:41:57.943]     {
[11:41:57.943]         {
[11:41:57.943]             ...future.startTime <- base::Sys.time()
[11:41:57.943]             {
[11:41:57.943]                 {
[11:41:57.943]                   {
[11:41:57.943]                     {
[11:41:57.943]                       {
[11:41:57.943]                         base::local({
[11:41:57.943]                           has_future <- base::requireNamespace("future", 
[11:41:57.943]                             quietly = TRUE)
[11:41:57.943]                           if (has_future) {
[11:41:57.943]                             ns <- base::getNamespace("future")
[11:41:57.943]                             version <- ns[[".package"]][["version"]]
[11:41:57.943]                             if (is.null(version)) 
[11:41:57.943]                               version <- utils::packageVersion("future")
[11:41:57.943]                           }
[11:41:57.943]                           else {
[11:41:57.943]                             version <- NULL
[11:41:57.943]                           }
[11:41:57.943]                           if (!has_future || version < "1.8.0") {
[11:41:57.943]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:57.943]                               "", base::R.version$version.string), 
[11:41:57.943]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:57.943]                                 base::R.version$platform, 8 * 
[11:41:57.943]                                   base::.Machine$sizeof.pointer), 
[11:41:57.943]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:57.943]                                 "release", "version")], collapse = " "), 
[11:41:57.943]                               hostname = base::Sys.info()[["nodename"]])
[11:41:57.943]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:57.943]                               info)
[11:41:57.943]                             info <- base::paste(info, collapse = "; ")
[11:41:57.943]                             if (!has_future) {
[11:41:57.943]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:57.943]                                 info)
[11:41:57.943]                             }
[11:41:57.943]                             else {
[11:41:57.943]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:57.943]                                 info, version)
[11:41:57.943]                             }
[11:41:57.943]                             base::stop(msg)
[11:41:57.943]                           }
[11:41:57.943]                         })
[11:41:57.943]                       }
[11:41:57.943]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:57.943]                       base::options(mc.cores = 1L)
[11:41:57.943]                     }
[11:41:57.943]                     base::local({
[11:41:57.943]                       for (pkg in "mlr3") {
[11:41:57.943]                         base::loadNamespace(pkg)
[11:41:57.943]                         base::library(pkg, character.only = TRUE)
[11:41:57.943]                       }
[11:41:57.943]                     })
[11:41:57.943]                   }
[11:41:57.943]                   options(future.plan = NULL)
[11:41:57.943]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:57.943]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:57.943]                 }
[11:41:57.943]                 ...future.workdir <- getwd()
[11:41:57.943]             }
[11:41:57.943]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:57.943]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:57.943]         }
[11:41:57.943]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:57.943]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:57.943]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:57.943]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:57.943]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:57.943]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:57.943]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:57.943]             base::names(...future.oldOptions))
[11:41:57.943]     }
[11:41:57.943]     if (FALSE) {
[11:41:57.943]     }
[11:41:57.943]     else {
[11:41:57.943]         if (TRUE) {
[11:41:57.943]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:57.943]                 open = "w")
[11:41:57.943]         }
[11:41:57.943]         else {
[11:41:57.943]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:57.943]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:57.943]         }
[11:41:57.943]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:57.943]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:57.943]             base::sink(type = "output", split = FALSE)
[11:41:57.943]             base::close(...future.stdout)
[11:41:57.943]         }, add = TRUE)
[11:41:57.943]     }
[11:41:57.943]     ...future.frame <- base::sys.nframe()
[11:41:57.943]     ...future.conditions <- base::list()
[11:41:57.943]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:57.943]     if (FALSE) {
[11:41:57.943]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:57.943]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:57.943]     }
[11:41:57.943]     ...future.result <- base::tryCatch({
[11:41:57.943]         base::withCallingHandlers({
[11:41:57.943]             ...future.value <- base::withVisible(base::local({
[11:41:57.943]                 ...future.makeSendCondition <- local({
[11:41:57.943]                   sendCondition <- NULL
[11:41:57.943]                   function(frame = 1L) {
[11:41:57.943]                     if (is.function(sendCondition)) 
[11:41:57.943]                       return(sendCondition)
[11:41:57.943]                     ns <- getNamespace("parallel")
[11:41:57.943]                     if (exists("sendData", mode = "function", 
[11:41:57.943]                       envir = ns)) {
[11:41:57.943]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:57.943]                         envir = ns)
[11:41:57.943]                       envir <- sys.frame(frame)
[11:41:57.943]                       master <- NULL
[11:41:57.943]                       while (!identical(envir, .GlobalEnv) && 
[11:41:57.943]                         !identical(envir, emptyenv())) {
[11:41:57.943]                         if (exists("master", mode = "list", envir = envir, 
[11:41:57.943]                           inherits = FALSE)) {
[11:41:57.943]                           master <- get("master", mode = "list", 
[11:41:57.943]                             envir = envir, inherits = FALSE)
[11:41:57.943]                           if (inherits(master, c("SOCKnode", 
[11:41:57.943]                             "SOCK0node"))) {
[11:41:57.943]                             sendCondition <<- function(cond) {
[11:41:57.943]                               data <- list(type = "VALUE", value = cond, 
[11:41:57.943]                                 success = TRUE)
[11:41:57.943]                               parallel_sendData(master, data)
[11:41:57.943]                             }
[11:41:57.943]                             return(sendCondition)
[11:41:57.943]                           }
[11:41:57.943]                         }
[11:41:57.943]                         frame <- frame + 1L
[11:41:57.943]                         envir <- sys.frame(frame)
[11:41:57.943]                       }
[11:41:57.943]                     }
[11:41:57.943]                     sendCondition <<- function(cond) NULL
[11:41:57.943]                   }
[11:41:57.943]                 })
[11:41:57.943]                 withCallingHandlers({
[11:41:57.943]                   {
[11:41:57.943]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:57.943]                     if (!identical(...future.globals.maxSize.org, 
[11:41:57.943]                       ...future.globals.maxSize)) {
[11:41:57.943]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:57.943]                       on.exit(options(oopts), add = TRUE)
[11:41:57.943]                     }
[11:41:57.943]                     {
[11:41:57.943]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:57.943]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:57.943]                           envir = globalenv(), inherits = FALSE)
[11:41:57.943]                         ...future.FUN(...)
[11:41:57.943]                       }
[11:41:57.943]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:57.943]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:57.943]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:57.943]                         USE.NAMES = FALSE)
[11:41:57.943]                       do.call(mapply, args = args)
[11:41:57.943]                     }
[11:41:57.943]                   }
[11:41:57.943]                 }, immediateCondition = function(cond) {
[11:41:57.943]                   sendCondition <- ...future.makeSendCondition()
[11:41:57.943]                   sendCondition(cond)
[11:41:57.943]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:57.943]                   {
[11:41:57.943]                     inherits <- base::inherits
[11:41:57.943]                     invokeRestart <- base::invokeRestart
[11:41:57.943]                     is.null <- base::is.null
[11:41:57.943]                     muffled <- FALSE
[11:41:57.943]                     if (inherits(cond, "message")) {
[11:41:57.943]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:57.943]                       if (muffled) 
[11:41:57.943]                         invokeRestart("muffleMessage")
[11:41:57.943]                     }
[11:41:57.943]                     else if (inherits(cond, "warning")) {
[11:41:57.943]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:57.943]                       if (muffled) 
[11:41:57.943]                         invokeRestart("muffleWarning")
[11:41:57.943]                     }
[11:41:57.943]                     else if (inherits(cond, "condition")) {
[11:41:57.943]                       if (!is.null(pattern)) {
[11:41:57.943]                         computeRestarts <- base::computeRestarts
[11:41:57.943]                         grepl <- base::grepl
[11:41:57.943]                         restarts <- computeRestarts(cond)
[11:41:57.943]                         for (restart in restarts) {
[11:41:57.943]                           name <- restart$name
[11:41:57.943]                           if (is.null(name)) 
[11:41:57.943]                             next
[11:41:57.943]                           if (!grepl(pattern, name)) 
[11:41:57.943]                             next
[11:41:57.943]                           invokeRestart(restart)
[11:41:57.943]                           muffled <- TRUE
[11:41:57.943]                           break
[11:41:57.943]                         }
[11:41:57.943]                       }
[11:41:57.943]                     }
[11:41:57.943]                     invisible(muffled)
[11:41:57.943]                   }
[11:41:57.943]                   muffleCondition(cond)
[11:41:57.943]                 })
[11:41:57.943]             }))
[11:41:57.943]             future::FutureResult(value = ...future.value$value, 
[11:41:57.943]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:57.943]                   ...future.rng), globalenv = if (FALSE) 
[11:41:57.943]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:57.943]                     ...future.globalenv.names))
[11:41:57.943]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:57.943]         }, condition = base::local({
[11:41:57.943]             c <- base::c
[11:41:57.943]             inherits <- base::inherits
[11:41:57.943]             invokeRestart <- base::invokeRestart
[11:41:57.943]             length <- base::length
[11:41:57.943]             list <- base::list
[11:41:57.943]             seq.int <- base::seq.int
[11:41:57.943]             signalCondition <- base::signalCondition
[11:41:57.943]             sys.calls <- base::sys.calls
[11:41:57.943]             `[[` <- base::`[[`
[11:41:57.943]             `+` <- base::`+`
[11:41:57.943]             `<<-` <- base::`<<-`
[11:41:57.943]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:57.943]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:57.943]                   3L)]
[11:41:57.943]             }
[11:41:57.943]             function(cond) {
[11:41:57.943]                 is_error <- inherits(cond, "error")
[11:41:57.943]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:57.943]                   NULL)
[11:41:57.943]                 if (is_error) {
[11:41:57.943]                   sessionInformation <- function() {
[11:41:57.943]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:57.943]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:57.943]                       search = base::search(), system = base::Sys.info())
[11:41:57.943]                   }
[11:41:57.943]                   ...future.conditions[[length(...future.conditions) + 
[11:41:57.943]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:57.943]                     cond$call), session = sessionInformation(), 
[11:41:57.943]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:57.943]                   signalCondition(cond)
[11:41:57.943]                 }
[11:41:57.943]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:57.943]                 "immediateCondition"))) {
[11:41:57.943]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:57.943]                   ...future.conditions[[length(...future.conditions) + 
[11:41:57.943]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:57.943]                   if (TRUE && !signal) {
[11:41:57.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:57.943]                     {
[11:41:57.943]                       inherits <- base::inherits
[11:41:57.943]                       invokeRestart <- base::invokeRestart
[11:41:57.943]                       is.null <- base::is.null
[11:41:57.943]                       muffled <- FALSE
[11:41:57.943]                       if (inherits(cond, "message")) {
[11:41:57.943]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:57.943]                         if (muffled) 
[11:41:57.943]                           invokeRestart("muffleMessage")
[11:41:57.943]                       }
[11:41:57.943]                       else if (inherits(cond, "warning")) {
[11:41:57.943]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:57.943]                         if (muffled) 
[11:41:57.943]                           invokeRestart("muffleWarning")
[11:41:57.943]                       }
[11:41:57.943]                       else if (inherits(cond, "condition")) {
[11:41:57.943]                         if (!is.null(pattern)) {
[11:41:57.943]                           computeRestarts <- base::computeRestarts
[11:41:57.943]                           grepl <- base::grepl
[11:41:57.943]                           restarts <- computeRestarts(cond)
[11:41:57.943]                           for (restart in restarts) {
[11:41:57.943]                             name <- restart$name
[11:41:57.943]                             if (is.null(name)) 
[11:41:57.943]                               next
[11:41:57.943]                             if (!grepl(pattern, name)) 
[11:41:57.943]                               next
[11:41:57.943]                             invokeRestart(restart)
[11:41:57.943]                             muffled <- TRUE
[11:41:57.943]                             break
[11:41:57.943]                           }
[11:41:57.943]                         }
[11:41:57.943]                       }
[11:41:57.943]                       invisible(muffled)
[11:41:57.943]                     }
[11:41:57.943]                     muffleCondition(cond, pattern = "^muffle")
[11:41:57.943]                   }
[11:41:57.943]                 }
[11:41:57.943]                 else {
[11:41:57.943]                   if (TRUE) {
[11:41:57.943]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:57.943]                     {
[11:41:57.943]                       inherits <- base::inherits
[11:41:57.943]                       invokeRestart <- base::invokeRestart
[11:41:57.943]                       is.null <- base::is.null
[11:41:57.943]                       muffled <- FALSE
[11:41:57.943]                       if (inherits(cond, "message")) {
[11:41:57.943]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:57.943]                         if (muffled) 
[11:41:57.943]                           invokeRestart("muffleMessage")
[11:41:57.943]                       }
[11:41:57.943]                       else if (inherits(cond, "warning")) {
[11:41:57.943]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:57.943]                         if (muffled) 
[11:41:57.943]                           invokeRestart("muffleWarning")
[11:41:57.943]                       }
[11:41:57.943]                       else if (inherits(cond, "condition")) {
[11:41:57.943]                         if (!is.null(pattern)) {
[11:41:57.943]                           computeRestarts <- base::computeRestarts
[11:41:57.943]                           grepl <- base::grepl
[11:41:57.943]                           restarts <- computeRestarts(cond)
[11:41:57.943]                           for (restart in restarts) {
[11:41:57.943]                             name <- restart$name
[11:41:57.943]                             if (is.null(name)) 
[11:41:57.943]                               next
[11:41:57.943]                             if (!grepl(pattern, name)) 
[11:41:57.943]                               next
[11:41:57.943]                             invokeRestart(restart)
[11:41:57.943]                             muffled <- TRUE
[11:41:57.943]                             break
[11:41:57.943]                           }
[11:41:57.943]                         }
[11:41:57.943]                       }
[11:41:57.943]                       invisible(muffled)
[11:41:57.943]                     }
[11:41:57.943]                     muffleCondition(cond, pattern = "^muffle")
[11:41:57.943]                   }
[11:41:57.943]                 }
[11:41:57.943]             }
[11:41:57.943]         }))
[11:41:57.943]     }, error = function(ex) {
[11:41:57.943]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:57.943]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:57.943]                 ...future.rng), started = ...future.startTime, 
[11:41:57.943]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:57.943]             version = "1.8"), class = "FutureResult")
[11:41:57.943]     }, finally = {
[11:41:57.943]         if (!identical(...future.workdir, getwd())) 
[11:41:57.943]             setwd(...future.workdir)
[11:41:57.943]         {
[11:41:57.943]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:57.943]                 ...future.oldOptions$nwarnings <- NULL
[11:41:57.943]             }
[11:41:57.943]             base::options(...future.oldOptions)
[11:41:57.943]             if (.Platform$OS.type == "windows") {
[11:41:57.943]                 old_names <- names(...future.oldEnvVars)
[11:41:57.943]                 envs <- base::Sys.getenv()
[11:41:57.943]                 names <- names(envs)
[11:41:57.943]                 common <- intersect(names, old_names)
[11:41:57.943]                 added <- setdiff(names, old_names)
[11:41:57.943]                 removed <- setdiff(old_names, names)
[11:41:57.943]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:57.943]                   envs[common]]
[11:41:57.943]                 NAMES <- toupper(changed)
[11:41:57.943]                 args <- list()
[11:41:57.943]                 for (kk in seq_along(NAMES)) {
[11:41:57.943]                   name <- changed[[kk]]
[11:41:57.943]                   NAME <- NAMES[[kk]]
[11:41:57.943]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:57.943]                     next
[11:41:57.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:57.943]                 }
[11:41:57.943]                 NAMES <- toupper(added)
[11:41:57.943]                 for (kk in seq_along(NAMES)) {
[11:41:57.943]                   name <- added[[kk]]
[11:41:57.943]                   NAME <- NAMES[[kk]]
[11:41:57.943]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:57.943]                     next
[11:41:57.943]                   args[[name]] <- ""
[11:41:57.943]                 }
[11:41:57.943]                 NAMES <- toupper(removed)
[11:41:57.943]                 for (kk in seq_along(NAMES)) {
[11:41:57.943]                   name <- removed[[kk]]
[11:41:57.943]                   NAME <- NAMES[[kk]]
[11:41:57.943]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:57.943]                     next
[11:41:57.943]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:57.943]                 }
[11:41:57.943]                 if (length(args) > 0) 
[11:41:57.943]                   base::do.call(base::Sys.setenv, args = args)
[11:41:57.943]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:57.943]             }
[11:41:57.943]             else {
[11:41:57.943]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:57.943]             }
[11:41:57.943]             {
[11:41:57.943]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:57.943]                   0L) {
[11:41:57.943]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:57.943]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:57.943]                   base::options(opts)
[11:41:57.943]                 }
[11:41:57.943]                 {
[11:41:57.943]                   {
[11:41:57.943]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:57.943]                     NULL
[11:41:57.943]                   }
[11:41:57.943]                   options(future.plan = NULL)
[11:41:57.943]                   if (is.na(NA_character_)) 
[11:41:57.943]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:57.943]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:57.943]                   future::plan(list(function (..., workers = 2, 
[11:41:57.943]                     envir = parent.frame()) 
[11:41:57.943]                   strategy(..., workers = workers, envir = envir)), 
[11:41:57.943]                     .cleanup = FALSE, .init = FALSE)
[11:41:57.943]                 }
[11:41:57.943]             }
[11:41:57.943]         }
[11:41:57.943]     })
[11:41:57.943]     if (TRUE) {
[11:41:57.943]         base::sink(type = "output", split = FALSE)
[11:41:57.943]         if (TRUE) {
[11:41:57.943]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:57.943]         }
[11:41:57.943]         else {
[11:41:57.943]             ...future.result["stdout"] <- base::list(NULL)
[11:41:57.943]         }
[11:41:57.943]         base::close(...future.stdout)
[11:41:57.943]         ...future.stdout <- NULL
[11:41:57.943]     }
[11:41:57.943]     ...future.result$conditions <- ...future.conditions
[11:41:57.943]     ...future.result$finished <- base::Sys.time()
[11:41:57.943]     ...future.result
[11:41:57.943] }
[11:41:57.945] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:57.956] receiveMessageFromWorker() for ClusterFuture ...
[11:41:57.956] - Validating connection of MultisessionFuture
[11:41:57.956] - received message: FutureResult
[11:41:57.956] - Received FutureResult
[11:41:57.957] - Erased future from FutureRegistry
[11:41:57.957] result() for ClusterFuture ...
[11:41:57.957] - result already collected: FutureResult
[11:41:57.957] result() for ClusterFuture ... done
[11:41:57.957] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:57.957] result() for ClusterFuture ...
[11:41:57.957] - result already collected: FutureResult
[11:41:57.957] result() for ClusterFuture ... done
[11:41:57.957] result() for ClusterFuture ...
[11:41:57.957] - result already collected: FutureResult
[11:41:57.957] result() for ClusterFuture ... done
[11:41:57.958] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:57.958] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:58.001] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:58.004] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:58.053] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:58.053] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:58.097] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:58.097] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:58.098] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:58.098] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:58.099] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:58.099] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:58.099] MultisessionFuture started
[11:41:58.099] - Launch lazy future ... done
[11:41:58.099] run() for ‘MultisessionFuture’ ... done
[11:41:58.099] Created future:
[11:41:58.099] MultisessionFuture:
[11:41:58.099] Label: ‘future_mapply-68’
[11:41:58.099] Expression:
[11:41:58.099] {
[11:41:58.099]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:58.099]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:58.099]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:58.099]         on.exit(options(oopts), add = TRUE)
[11:41:58.099]     }
[11:41:58.099]     {
[11:41:58.099]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:58.099]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:58.099]                 inherits = FALSE)
[11:41:58.099]             ...future.FUN(...)
[11:41:58.099]         }
[11:41:58.099]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:58.099]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:58.099]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:58.099]         do.call(mapply, args = args)
[11:41:58.099]     }
[11:41:58.099] }
[11:41:58.099] Lazy evaluation: FALSE
[11:41:58.099] Asynchronous evaluation: TRUE
[11:41:58.099] Local evaluation: TRUE
[11:41:58.099] Environment: 0x560ef58e1768
[11:41:58.099] Capture standard output: TRUE
[11:41:58.099] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:58.099] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:58.099] Packages: 1 packages (‘mlr3’)
[11:41:58.099] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:58.099] Resolved: FALSE
[11:41:58.099] Value: <not collected>
[11:41:58.099] Conditions captured: <none>
[11:41:58.099] Early signaling: FALSE
[11:41:58.099] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:58.099] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:58.113] Chunk #68 of 90 ... DONE
[11:41:58.114] Chunk #69 of 90 ...
[11:41:58.114]  - seeds: [1] <seeds>
[11:41:58.114] getGlobalsAndPackages() ...
[11:41:58.114] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:58.114] Resolving globals: FALSE
[11:41:58.114] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:58.114] - packages: [1] ‘mlr3’
[11:41:58.115] getGlobalsAndPackages() ... DONE
[11:41:58.115] run() for ‘Future’ ...
[11:41:58.115] - state: ‘created’
[11:41:58.115] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:58.125] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:58.126] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:58.126]   - Field: ‘node’
[11:41:58.126]   - Field: ‘label’
[11:41:58.126]   - Field: ‘local’
[11:41:58.126]   - Field: ‘owner’
[11:41:58.126]   - Field: ‘envir’
[11:41:58.126]   - Field: ‘workers’
[11:41:58.126]   - Field: ‘packages’
[11:41:58.126]   - Field: ‘gc’
[11:41:58.126]   - Field: ‘conditions’
[11:41:58.126]   - Field: ‘persistent’
[11:41:58.126]   - Field: ‘expr’
[11:41:58.126]   - Field: ‘uuid’
[11:41:58.126]   - Field: ‘seed’
[11:41:58.127]   - Field: ‘version’
[11:41:58.127]   - Field: ‘result’
[11:41:58.127]   - Field: ‘asynchronous’
[11:41:58.127]   - Field: ‘calls’
[11:41:58.127]   - Field: ‘globals’
[11:41:58.127]   - Field: ‘stdout’
[11:41:58.127]   - Field: ‘earlySignal’
[11:41:58.127]   - Field: ‘lazy’
[11:41:58.127]   - Field: ‘state’
[11:41:58.127] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:58.127] - Launch lazy future ...
[11:41:58.127] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:58.127] Packages needed by future strategies (n = 0): <none>
[11:41:58.128] {
[11:41:58.128]     {
[11:41:58.128]         {
[11:41:58.128]             ...future.startTime <- base::Sys.time()
[11:41:58.128]             {
[11:41:58.128]                 {
[11:41:58.128]                   {
[11:41:58.128]                     {
[11:41:58.128]                       {
[11:41:58.128]                         base::local({
[11:41:58.128]                           has_future <- base::requireNamespace("future", 
[11:41:58.128]                             quietly = TRUE)
[11:41:58.128]                           if (has_future) {
[11:41:58.128]                             ns <- base::getNamespace("future")
[11:41:58.128]                             version <- ns[[".package"]][["version"]]
[11:41:58.128]                             if (is.null(version)) 
[11:41:58.128]                               version <- utils::packageVersion("future")
[11:41:58.128]                           }
[11:41:58.128]                           else {
[11:41:58.128]                             version <- NULL
[11:41:58.128]                           }
[11:41:58.128]                           if (!has_future || version < "1.8.0") {
[11:41:58.128]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:58.128]                               "", base::R.version$version.string), 
[11:41:58.128]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:58.128]                                 base::R.version$platform, 8 * 
[11:41:58.128]                                   base::.Machine$sizeof.pointer), 
[11:41:58.128]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:58.128]                                 "release", "version")], collapse = " "), 
[11:41:58.128]                               hostname = base::Sys.info()[["nodename"]])
[11:41:58.128]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:58.128]                               info)
[11:41:58.128]                             info <- base::paste(info, collapse = "; ")
[11:41:58.128]                             if (!has_future) {
[11:41:58.128]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:58.128]                                 info)
[11:41:58.128]                             }
[11:41:58.128]                             else {
[11:41:58.128]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:58.128]                                 info, version)
[11:41:58.128]                             }
[11:41:58.128]                             base::stop(msg)
[11:41:58.128]                           }
[11:41:58.128]                         })
[11:41:58.128]                       }
[11:41:58.128]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:58.128]                       base::options(mc.cores = 1L)
[11:41:58.128]                     }
[11:41:58.128]                     base::local({
[11:41:58.128]                       for (pkg in "mlr3") {
[11:41:58.128]                         base::loadNamespace(pkg)
[11:41:58.128]                         base::library(pkg, character.only = TRUE)
[11:41:58.128]                       }
[11:41:58.128]                     })
[11:41:58.128]                   }
[11:41:58.128]                   options(future.plan = NULL)
[11:41:58.128]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:58.128]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:58.128]                 }
[11:41:58.128]                 ...future.workdir <- getwd()
[11:41:58.128]             }
[11:41:58.128]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:58.128]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:58.128]         }
[11:41:58.128]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:58.128]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:58.128]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:58.128]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:58.128]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:58.128]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:58.128]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:58.128]             base::names(...future.oldOptions))
[11:41:58.128]     }
[11:41:58.128]     if (FALSE) {
[11:41:58.128]     }
[11:41:58.128]     else {
[11:41:58.128]         if (TRUE) {
[11:41:58.128]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:58.128]                 open = "w")
[11:41:58.128]         }
[11:41:58.128]         else {
[11:41:58.128]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:58.128]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:58.128]         }
[11:41:58.128]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:58.128]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:58.128]             base::sink(type = "output", split = FALSE)
[11:41:58.128]             base::close(...future.stdout)
[11:41:58.128]         }, add = TRUE)
[11:41:58.128]     }
[11:41:58.128]     ...future.frame <- base::sys.nframe()
[11:41:58.128]     ...future.conditions <- base::list()
[11:41:58.128]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:58.128]     if (FALSE) {
[11:41:58.128]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:58.128]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:58.128]     }
[11:41:58.128]     ...future.result <- base::tryCatch({
[11:41:58.128]         base::withCallingHandlers({
[11:41:58.128]             ...future.value <- base::withVisible(base::local({
[11:41:58.128]                 ...future.makeSendCondition <- local({
[11:41:58.128]                   sendCondition <- NULL
[11:41:58.128]                   function(frame = 1L) {
[11:41:58.128]                     if (is.function(sendCondition)) 
[11:41:58.128]                       return(sendCondition)
[11:41:58.128]                     ns <- getNamespace("parallel")
[11:41:58.128]                     if (exists("sendData", mode = "function", 
[11:41:58.128]                       envir = ns)) {
[11:41:58.128]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:58.128]                         envir = ns)
[11:41:58.128]                       envir <- sys.frame(frame)
[11:41:58.128]                       master <- NULL
[11:41:58.128]                       while (!identical(envir, .GlobalEnv) && 
[11:41:58.128]                         !identical(envir, emptyenv())) {
[11:41:58.128]                         if (exists("master", mode = "list", envir = envir, 
[11:41:58.128]                           inherits = FALSE)) {
[11:41:58.128]                           master <- get("master", mode = "list", 
[11:41:58.128]                             envir = envir, inherits = FALSE)
[11:41:58.128]                           if (inherits(master, c("SOCKnode", 
[11:41:58.128]                             "SOCK0node"))) {
[11:41:58.128]                             sendCondition <<- function(cond) {
[11:41:58.128]                               data <- list(type = "VALUE", value = cond, 
[11:41:58.128]                                 success = TRUE)
[11:41:58.128]                               parallel_sendData(master, data)
[11:41:58.128]                             }
[11:41:58.128]                             return(sendCondition)
[11:41:58.128]                           }
[11:41:58.128]                         }
[11:41:58.128]                         frame <- frame + 1L
[11:41:58.128]                         envir <- sys.frame(frame)
[11:41:58.128]                       }
[11:41:58.128]                     }
[11:41:58.128]                     sendCondition <<- function(cond) NULL
[11:41:58.128]                   }
[11:41:58.128]                 })
[11:41:58.128]                 withCallingHandlers({
[11:41:58.128]                   {
[11:41:58.128]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:58.128]                     if (!identical(...future.globals.maxSize.org, 
[11:41:58.128]                       ...future.globals.maxSize)) {
[11:41:58.128]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:58.128]                       on.exit(options(oopts), add = TRUE)
[11:41:58.128]                     }
[11:41:58.128]                     {
[11:41:58.128]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:58.128]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:58.128]                           envir = globalenv(), inherits = FALSE)
[11:41:58.128]                         ...future.FUN(...)
[11:41:58.128]                       }
[11:41:58.128]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:58.128]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:58.128]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:58.128]                         USE.NAMES = FALSE)
[11:41:58.128]                       do.call(mapply, args = args)
[11:41:58.128]                     }
[11:41:58.128]                   }
[11:41:58.128]                 }, immediateCondition = function(cond) {
[11:41:58.128]                   sendCondition <- ...future.makeSendCondition()
[11:41:58.128]                   sendCondition(cond)
[11:41:58.128]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:58.128]                   {
[11:41:58.128]                     inherits <- base::inherits
[11:41:58.128]                     invokeRestart <- base::invokeRestart
[11:41:58.128]                     is.null <- base::is.null
[11:41:58.128]                     muffled <- FALSE
[11:41:58.128]                     if (inherits(cond, "message")) {
[11:41:58.128]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:58.128]                       if (muffled) 
[11:41:58.128]                         invokeRestart("muffleMessage")
[11:41:58.128]                     }
[11:41:58.128]                     else if (inherits(cond, "warning")) {
[11:41:58.128]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:58.128]                       if (muffled) 
[11:41:58.128]                         invokeRestart("muffleWarning")
[11:41:58.128]                     }
[11:41:58.128]                     else if (inherits(cond, "condition")) {
[11:41:58.128]                       if (!is.null(pattern)) {
[11:41:58.128]                         computeRestarts <- base::computeRestarts
[11:41:58.128]                         grepl <- base::grepl
[11:41:58.128]                         restarts <- computeRestarts(cond)
[11:41:58.128]                         for (restart in restarts) {
[11:41:58.128]                           name <- restart$name
[11:41:58.128]                           if (is.null(name)) 
[11:41:58.128]                             next
[11:41:58.128]                           if (!grepl(pattern, name)) 
[11:41:58.128]                             next
[11:41:58.128]                           invokeRestart(restart)
[11:41:58.128]                           muffled <- TRUE
[11:41:58.128]                           break
[11:41:58.128]                         }
[11:41:58.128]                       }
[11:41:58.128]                     }
[11:41:58.128]                     invisible(muffled)
[11:41:58.128]                   }
[11:41:58.128]                   muffleCondition(cond)
[11:41:58.128]                 })
[11:41:58.128]             }))
[11:41:58.128]             future::FutureResult(value = ...future.value$value, 
[11:41:58.128]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:58.128]                   ...future.rng), globalenv = if (FALSE) 
[11:41:58.128]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:58.128]                     ...future.globalenv.names))
[11:41:58.128]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:58.128]         }, condition = base::local({
[11:41:58.128]             c <- base::c
[11:41:58.128]             inherits <- base::inherits
[11:41:58.128]             invokeRestart <- base::invokeRestart
[11:41:58.128]             length <- base::length
[11:41:58.128]             list <- base::list
[11:41:58.128]             seq.int <- base::seq.int
[11:41:58.128]             signalCondition <- base::signalCondition
[11:41:58.128]             sys.calls <- base::sys.calls
[11:41:58.128]             `[[` <- base::`[[`
[11:41:58.128]             `+` <- base::`+`
[11:41:58.128]             `<<-` <- base::`<<-`
[11:41:58.128]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:58.128]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:58.128]                   3L)]
[11:41:58.128]             }
[11:41:58.128]             function(cond) {
[11:41:58.128]                 is_error <- inherits(cond, "error")
[11:41:58.128]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:58.128]                   NULL)
[11:41:58.128]                 if (is_error) {
[11:41:58.128]                   sessionInformation <- function() {
[11:41:58.128]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:58.128]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:58.128]                       search = base::search(), system = base::Sys.info())
[11:41:58.128]                   }
[11:41:58.128]                   ...future.conditions[[length(...future.conditions) + 
[11:41:58.128]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:58.128]                     cond$call), session = sessionInformation(), 
[11:41:58.128]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:58.128]                   signalCondition(cond)
[11:41:58.128]                 }
[11:41:58.128]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:58.128]                 "immediateCondition"))) {
[11:41:58.128]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:58.128]                   ...future.conditions[[length(...future.conditions) + 
[11:41:58.128]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:58.128]                   if (TRUE && !signal) {
[11:41:58.128]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:58.128]                     {
[11:41:58.128]                       inherits <- base::inherits
[11:41:58.128]                       invokeRestart <- base::invokeRestart
[11:41:58.128]                       is.null <- base::is.null
[11:41:58.128]                       muffled <- FALSE
[11:41:58.128]                       if (inherits(cond, "message")) {
[11:41:58.128]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:58.128]                         if (muffled) 
[11:41:58.128]                           invokeRestart("muffleMessage")
[11:41:58.128]                       }
[11:41:58.128]                       else if (inherits(cond, "warning")) {
[11:41:58.128]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:58.128]                         if (muffled) 
[11:41:58.128]                           invokeRestart("muffleWarning")
[11:41:58.128]                       }
[11:41:58.128]                       else if (inherits(cond, "condition")) {
[11:41:58.128]                         if (!is.null(pattern)) {
[11:41:58.128]                           computeRestarts <- base::computeRestarts
[11:41:58.128]                           grepl <- base::grepl
[11:41:58.128]                           restarts <- computeRestarts(cond)
[11:41:58.128]                           for (restart in restarts) {
[11:41:58.128]                             name <- restart$name
[11:41:58.128]                             if (is.null(name)) 
[11:41:58.128]                               next
[11:41:58.128]                             if (!grepl(pattern, name)) 
[11:41:58.128]                               next
[11:41:58.128]                             invokeRestart(restart)
[11:41:58.128]                             muffled <- TRUE
[11:41:58.128]                             break
[11:41:58.128]                           }
[11:41:58.128]                         }
[11:41:58.128]                       }
[11:41:58.128]                       invisible(muffled)
[11:41:58.128]                     }
[11:41:58.128]                     muffleCondition(cond, pattern = "^muffle")
[11:41:58.128]                   }
[11:41:58.128]                 }
[11:41:58.128]                 else {
[11:41:58.128]                   if (TRUE) {
[11:41:58.128]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:58.128]                     {
[11:41:58.128]                       inherits <- base::inherits
[11:41:58.128]                       invokeRestart <- base::invokeRestart
[11:41:58.128]                       is.null <- base::is.null
[11:41:58.128]                       muffled <- FALSE
[11:41:58.128]                       if (inherits(cond, "message")) {
[11:41:58.128]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:58.128]                         if (muffled) 
[11:41:58.128]                           invokeRestart("muffleMessage")
[11:41:58.128]                       }
[11:41:58.128]                       else if (inherits(cond, "warning")) {
[11:41:58.128]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:58.128]                         if (muffled) 
[11:41:58.128]                           invokeRestart("muffleWarning")
[11:41:58.128]                       }
[11:41:58.128]                       else if (inherits(cond, "condition")) {
[11:41:58.128]                         if (!is.null(pattern)) {
[11:41:58.128]                           computeRestarts <- base::computeRestarts
[11:41:58.128]                           grepl <- base::grepl
[11:41:58.128]                           restarts <- computeRestarts(cond)
[11:41:58.128]                           for (restart in restarts) {
[11:41:58.128]                             name <- restart$name
[11:41:58.128]                             if (is.null(name)) 
[11:41:58.128]                               next
[11:41:58.128]                             if (!grepl(pattern, name)) 
[11:41:58.128]                               next
[11:41:58.128]                             invokeRestart(restart)
[11:41:58.128]                             muffled <- TRUE
[11:41:58.128]                             break
[11:41:58.128]                           }
[11:41:58.128]                         }
[11:41:58.128]                       }
[11:41:58.128]                       invisible(muffled)
[11:41:58.128]                     }
[11:41:58.128]                     muffleCondition(cond, pattern = "^muffle")
[11:41:58.128]                   }
[11:41:58.128]                 }
[11:41:58.128]             }
[11:41:58.128]         }))
[11:41:58.128]     }, error = function(ex) {
[11:41:58.128]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:58.128]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:58.128]                 ...future.rng), started = ...future.startTime, 
[11:41:58.128]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:58.128]             version = "1.8"), class = "FutureResult")
[11:41:58.128]     }, finally = {
[11:41:58.128]         if (!identical(...future.workdir, getwd())) 
[11:41:58.128]             setwd(...future.workdir)
[11:41:58.128]         {
[11:41:58.128]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:58.128]                 ...future.oldOptions$nwarnings <- NULL
[11:41:58.128]             }
[11:41:58.128]             base::options(...future.oldOptions)
[11:41:58.128]             if (.Platform$OS.type == "windows") {
[11:41:58.128]                 old_names <- names(...future.oldEnvVars)
[11:41:58.128]                 envs <- base::Sys.getenv()
[11:41:58.128]                 names <- names(envs)
[11:41:58.128]                 common <- intersect(names, old_names)
[11:41:58.128]                 added <- setdiff(names, old_names)
[11:41:58.128]                 removed <- setdiff(old_names, names)
[11:41:58.128]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:58.128]                   envs[common]]
[11:41:58.128]                 NAMES <- toupper(changed)
[11:41:58.128]                 args <- list()
[11:41:58.128]                 for (kk in seq_along(NAMES)) {
[11:41:58.128]                   name <- changed[[kk]]
[11:41:58.128]                   NAME <- NAMES[[kk]]
[11:41:58.128]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:58.128]                     next
[11:41:58.128]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:58.128]                 }
[11:41:58.128]                 NAMES <- toupper(added)
[11:41:58.128]                 for (kk in seq_along(NAMES)) {
[11:41:58.128]                   name <- added[[kk]]
[11:41:58.128]                   NAME <- NAMES[[kk]]
[11:41:58.128]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:58.128]                     next
[11:41:58.128]                   args[[name]] <- ""
[11:41:58.128]                 }
[11:41:58.128]                 NAMES <- toupper(removed)
[11:41:58.128]                 for (kk in seq_along(NAMES)) {
[11:41:58.128]                   name <- removed[[kk]]
[11:41:58.128]                   NAME <- NAMES[[kk]]
[11:41:58.128]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:58.128]                     next
[11:41:58.128]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:58.128]                 }
[11:41:58.128]                 if (length(args) > 0) 
[11:41:58.128]                   base::do.call(base::Sys.setenv, args = args)
[11:41:58.128]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:58.128]             }
[11:41:58.128]             else {
[11:41:58.128]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:58.128]             }
[11:41:58.128]             {
[11:41:58.128]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:58.128]                   0L) {
[11:41:58.128]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:58.128]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:58.128]                   base::options(opts)
[11:41:58.128]                 }
[11:41:58.128]                 {
[11:41:58.128]                   {
[11:41:58.128]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:58.128]                     NULL
[11:41:58.128]                   }
[11:41:58.128]                   options(future.plan = NULL)
[11:41:58.128]                   if (is.na(NA_character_)) 
[11:41:58.128]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:58.128]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:58.128]                   future::plan(list(function (..., workers = 2, 
[11:41:58.128]                     envir = parent.frame()) 
[11:41:58.128]                   strategy(..., workers = workers, envir = envir)), 
[11:41:58.128]                     .cleanup = FALSE, .init = FALSE)
[11:41:58.128]                 }
[11:41:58.128]             }
[11:41:58.128]         }
[11:41:58.128]     })
[11:41:58.128]     if (TRUE) {
[11:41:58.128]         base::sink(type = "output", split = FALSE)
[11:41:58.128]         if (TRUE) {
[11:41:58.128]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:58.128]         }
[11:41:58.128]         else {
[11:41:58.128]             ...future.result["stdout"] <- base::list(NULL)
[11:41:58.128]         }
[11:41:58.128]         base::close(...future.stdout)
[11:41:58.128]         ...future.stdout <- NULL
[11:41:58.128]     }
[11:41:58.128]     ...future.result$conditions <- ...future.conditions
[11:41:58.128]     ...future.result$finished <- base::Sys.time()
[11:41:58.128]     ...future.result
[11:41:58.128] }
[11:41:58.130] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:58.140] receiveMessageFromWorker() for ClusterFuture ...
[11:41:58.140] - Validating connection of MultisessionFuture
[11:41:58.141] - received message: FutureResult
[11:41:58.141] - Received FutureResult
[11:41:58.141] - Erased future from FutureRegistry
[11:41:58.141] result() for ClusterFuture ...
[11:41:58.141] - result already collected: FutureResult
[11:41:58.141] result() for ClusterFuture ... done
[11:41:58.141] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:58.141] result() for ClusterFuture ...
[11:41:58.141] - result already collected: FutureResult
[11:41:58.141] result() for ClusterFuture ... done
[11:41:58.141] result() for ClusterFuture ...
[11:41:58.141] - result already collected: FutureResult
[11:41:58.141] result() for ClusterFuture ... done
[11:41:58.142] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:58.142] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:58.185] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:58.188] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:58.190] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:58.190] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:58.191] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:58.192] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:58.192] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:58.192] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:58.193] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:58.193] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:58.194] MultisessionFuture started
[11:41:58.194] - Launch lazy future ... done
[11:41:58.194] run() for ‘MultisessionFuture’ ... done
[11:41:58.194] Created future:
[11:41:58.194] MultisessionFuture:
[11:41:58.194] Label: ‘future_mapply-69’
[11:41:58.194] Expression:
[11:41:58.194] {
[11:41:58.194]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:58.194]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:58.194]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:58.194]         on.exit(options(oopts), add = TRUE)
[11:41:58.194]     }
[11:41:58.194]     {
[11:41:58.194]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:58.194]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:58.194]                 inherits = FALSE)
[11:41:58.194]             ...future.FUN(...)
[11:41:58.194]         }
[11:41:58.194]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:58.194]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:58.194]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:58.194]         do.call(mapply, args = args)
[11:41:58.194]     }
[11:41:58.194] }
[11:41:58.194] Lazy evaluation: FALSE
[11:41:58.194] Asynchronous evaluation: TRUE
[11:41:58.194] Local evaluation: TRUE
[11:41:58.194] Environment: 0x560ef58e1768
[11:41:58.194] Capture standard output: TRUE
[11:41:58.194] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:58.194] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:58.194] Packages: 1 packages (‘mlr3’)
[11:41:58.194] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:58.194] Resolved: FALSE
[11:41:58.194] Value: <not collected>
[11:41:58.194] Conditions captured: <none>
[11:41:58.194] Early signaling: FALSE
[11:41:58.194] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:58.194] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:58.210] Chunk #69 of 90 ... DONE
[11:41:58.211] Chunk #70 of 90 ...
[11:41:58.211]  - seeds: [1] <seeds>
[11:41:58.211] getGlobalsAndPackages() ...
[11:41:58.211] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:58.211] Resolving globals: FALSE
[11:41:58.212] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:58.212] - packages: [1] ‘mlr3’
[11:41:58.212] getGlobalsAndPackages() ... DONE
[11:41:58.212] run() for ‘Future’ ...
[11:41:58.212] - state: ‘created’
[11:41:58.213] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:58.224] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:58.224] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:58.225]   - Field: ‘node’
[11:41:58.225]   - Field: ‘label’
[11:41:58.225]   - Field: ‘local’
[11:41:58.225]   - Field: ‘owner’
[11:41:58.225]   - Field: ‘envir’
[11:41:58.225]   - Field: ‘workers’
[11:41:58.225]   - Field: ‘packages’
[11:41:58.225]   - Field: ‘gc’
[11:41:58.225]   - Field: ‘conditions’
[11:41:58.225]   - Field: ‘persistent’
[11:41:58.225]   - Field: ‘expr’
[11:41:58.225]   - Field: ‘uuid’
[11:41:58.225]   - Field: ‘seed’
[11:41:58.225]   - Field: ‘version’
[11:41:58.225]   - Field: ‘result’
[11:41:58.226]   - Field: ‘asynchronous’
[11:41:58.226]   - Field: ‘calls’
[11:41:58.226]   - Field: ‘globals’
[11:41:58.226]   - Field: ‘stdout’
[11:41:58.226]   - Field: ‘earlySignal’
[11:41:58.226]   - Field: ‘lazy’
[11:41:58.226]   - Field: ‘state’
[11:41:58.226] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:58.226] - Launch lazy future ...
[11:41:58.226] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:58.226] Packages needed by future strategies (n = 0): <none>
[11:41:58.227] {
[11:41:58.227]     {
[11:41:58.227]         {
[11:41:58.227]             ...future.startTime <- base::Sys.time()
[11:41:58.227]             {
[11:41:58.227]                 {
[11:41:58.227]                   {
[11:41:58.227]                     {
[11:41:58.227]                       {
[11:41:58.227]                         base::local({
[11:41:58.227]                           has_future <- base::requireNamespace("future", 
[11:41:58.227]                             quietly = TRUE)
[11:41:58.227]                           if (has_future) {
[11:41:58.227]                             ns <- base::getNamespace("future")
[11:41:58.227]                             version <- ns[[".package"]][["version"]]
[11:41:58.227]                             if (is.null(version)) 
[11:41:58.227]                               version <- utils::packageVersion("future")
[11:41:58.227]                           }
[11:41:58.227]                           else {
[11:41:58.227]                             version <- NULL
[11:41:58.227]                           }
[11:41:58.227]                           if (!has_future || version < "1.8.0") {
[11:41:58.227]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:58.227]                               "", base::R.version$version.string), 
[11:41:58.227]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:58.227]                                 base::R.version$platform, 8 * 
[11:41:58.227]                                   base::.Machine$sizeof.pointer), 
[11:41:58.227]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:58.227]                                 "release", "version")], collapse = " "), 
[11:41:58.227]                               hostname = base::Sys.info()[["nodename"]])
[11:41:58.227]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:58.227]                               info)
[11:41:58.227]                             info <- base::paste(info, collapse = "; ")
[11:41:58.227]                             if (!has_future) {
[11:41:58.227]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:58.227]                                 info)
[11:41:58.227]                             }
[11:41:58.227]                             else {
[11:41:58.227]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:58.227]                                 info, version)
[11:41:58.227]                             }
[11:41:58.227]                             base::stop(msg)
[11:41:58.227]                           }
[11:41:58.227]                         })
[11:41:58.227]                       }
[11:41:58.227]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:58.227]                       base::options(mc.cores = 1L)
[11:41:58.227]                     }
[11:41:58.227]                     base::local({
[11:41:58.227]                       for (pkg in "mlr3") {
[11:41:58.227]                         base::loadNamespace(pkg)
[11:41:58.227]                         base::library(pkg, character.only = TRUE)
[11:41:58.227]                       }
[11:41:58.227]                     })
[11:41:58.227]                   }
[11:41:58.227]                   options(future.plan = NULL)
[11:41:58.227]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:58.227]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:58.227]                 }
[11:41:58.227]                 ...future.workdir <- getwd()
[11:41:58.227]             }
[11:41:58.227]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:58.227]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:58.227]         }
[11:41:58.227]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:58.227]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:58.227]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:58.227]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:58.227]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:58.227]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:58.227]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:58.227]             base::names(...future.oldOptions))
[11:41:58.227]     }
[11:41:58.227]     if (FALSE) {
[11:41:58.227]     }
[11:41:58.227]     else {
[11:41:58.227]         if (TRUE) {
[11:41:58.227]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:58.227]                 open = "w")
[11:41:58.227]         }
[11:41:58.227]         else {
[11:41:58.227]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:58.227]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:58.227]         }
[11:41:58.227]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:58.227]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:58.227]             base::sink(type = "output", split = FALSE)
[11:41:58.227]             base::close(...future.stdout)
[11:41:58.227]         }, add = TRUE)
[11:41:58.227]     }
[11:41:58.227]     ...future.frame <- base::sys.nframe()
[11:41:58.227]     ...future.conditions <- base::list()
[11:41:58.227]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:58.227]     if (FALSE) {
[11:41:58.227]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:58.227]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:58.227]     }
[11:41:58.227]     ...future.result <- base::tryCatch({
[11:41:58.227]         base::withCallingHandlers({
[11:41:58.227]             ...future.value <- base::withVisible(base::local({
[11:41:58.227]                 ...future.makeSendCondition <- local({
[11:41:58.227]                   sendCondition <- NULL
[11:41:58.227]                   function(frame = 1L) {
[11:41:58.227]                     if (is.function(sendCondition)) 
[11:41:58.227]                       return(sendCondition)
[11:41:58.227]                     ns <- getNamespace("parallel")
[11:41:58.227]                     if (exists("sendData", mode = "function", 
[11:41:58.227]                       envir = ns)) {
[11:41:58.227]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:58.227]                         envir = ns)
[11:41:58.227]                       envir <- sys.frame(frame)
[11:41:58.227]                       master <- NULL
[11:41:58.227]                       while (!identical(envir, .GlobalEnv) && 
[11:41:58.227]                         !identical(envir, emptyenv())) {
[11:41:58.227]                         if (exists("master", mode = "list", envir = envir, 
[11:41:58.227]                           inherits = FALSE)) {
[11:41:58.227]                           master <- get("master", mode = "list", 
[11:41:58.227]                             envir = envir, inherits = FALSE)
[11:41:58.227]                           if (inherits(master, c("SOCKnode", 
[11:41:58.227]                             "SOCK0node"))) {
[11:41:58.227]                             sendCondition <<- function(cond) {
[11:41:58.227]                               data <- list(type = "VALUE", value = cond, 
[11:41:58.227]                                 success = TRUE)
[11:41:58.227]                               parallel_sendData(master, data)
[11:41:58.227]                             }
[11:41:58.227]                             return(sendCondition)
[11:41:58.227]                           }
[11:41:58.227]                         }
[11:41:58.227]                         frame <- frame + 1L
[11:41:58.227]                         envir <- sys.frame(frame)
[11:41:58.227]                       }
[11:41:58.227]                     }
[11:41:58.227]                     sendCondition <<- function(cond) NULL
[11:41:58.227]                   }
[11:41:58.227]                 })
[11:41:58.227]                 withCallingHandlers({
[11:41:58.227]                   {
[11:41:58.227]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:58.227]                     if (!identical(...future.globals.maxSize.org, 
[11:41:58.227]                       ...future.globals.maxSize)) {
[11:41:58.227]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:58.227]                       on.exit(options(oopts), add = TRUE)
[11:41:58.227]                     }
[11:41:58.227]                     {
[11:41:58.227]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:58.227]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:58.227]                           envir = globalenv(), inherits = FALSE)
[11:41:58.227]                         ...future.FUN(...)
[11:41:58.227]                       }
[11:41:58.227]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:58.227]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:58.227]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:58.227]                         USE.NAMES = FALSE)
[11:41:58.227]                       do.call(mapply, args = args)
[11:41:58.227]                     }
[11:41:58.227]                   }
[11:41:58.227]                 }, immediateCondition = function(cond) {
[11:41:58.227]                   sendCondition <- ...future.makeSendCondition()
[11:41:58.227]                   sendCondition(cond)
[11:41:58.227]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:58.227]                   {
[11:41:58.227]                     inherits <- base::inherits
[11:41:58.227]                     invokeRestart <- base::invokeRestart
[11:41:58.227]                     is.null <- base::is.null
[11:41:58.227]                     muffled <- FALSE
[11:41:58.227]                     if (inherits(cond, "message")) {
[11:41:58.227]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:58.227]                       if (muffled) 
[11:41:58.227]                         invokeRestart("muffleMessage")
[11:41:58.227]                     }
[11:41:58.227]                     else if (inherits(cond, "warning")) {
[11:41:58.227]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:58.227]                       if (muffled) 
[11:41:58.227]                         invokeRestart("muffleWarning")
[11:41:58.227]                     }
[11:41:58.227]                     else if (inherits(cond, "condition")) {
[11:41:58.227]                       if (!is.null(pattern)) {
[11:41:58.227]                         computeRestarts <- base::computeRestarts
[11:41:58.227]                         grepl <- base::grepl
[11:41:58.227]                         restarts <- computeRestarts(cond)
[11:41:58.227]                         for (restart in restarts) {
[11:41:58.227]                           name <- restart$name
[11:41:58.227]                           if (is.null(name)) 
[11:41:58.227]                             next
[11:41:58.227]                           if (!grepl(pattern, name)) 
[11:41:58.227]                             next
[11:41:58.227]                           invokeRestart(restart)
[11:41:58.227]                           muffled <- TRUE
[11:41:58.227]                           break
[11:41:58.227]                         }
[11:41:58.227]                       }
[11:41:58.227]                     }
[11:41:58.227]                     invisible(muffled)
[11:41:58.227]                   }
[11:41:58.227]                   muffleCondition(cond)
[11:41:58.227]                 })
[11:41:58.227]             }))
[11:41:58.227]             future::FutureResult(value = ...future.value$value, 
[11:41:58.227]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:58.227]                   ...future.rng), globalenv = if (FALSE) 
[11:41:58.227]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:58.227]                     ...future.globalenv.names))
[11:41:58.227]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:58.227]         }, condition = base::local({
[11:41:58.227]             c <- base::c
[11:41:58.227]             inherits <- base::inherits
[11:41:58.227]             invokeRestart <- base::invokeRestart
[11:41:58.227]             length <- base::length
[11:41:58.227]             list <- base::list
[11:41:58.227]             seq.int <- base::seq.int
[11:41:58.227]             signalCondition <- base::signalCondition
[11:41:58.227]             sys.calls <- base::sys.calls
[11:41:58.227]             `[[` <- base::`[[`
[11:41:58.227]             `+` <- base::`+`
[11:41:58.227]             `<<-` <- base::`<<-`
[11:41:58.227]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:58.227]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:58.227]                   3L)]
[11:41:58.227]             }
[11:41:58.227]             function(cond) {
[11:41:58.227]                 is_error <- inherits(cond, "error")
[11:41:58.227]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:58.227]                   NULL)
[11:41:58.227]                 if (is_error) {
[11:41:58.227]                   sessionInformation <- function() {
[11:41:58.227]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:58.227]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:58.227]                       search = base::search(), system = base::Sys.info())
[11:41:58.227]                   }
[11:41:58.227]                   ...future.conditions[[length(...future.conditions) + 
[11:41:58.227]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:58.227]                     cond$call), session = sessionInformation(), 
[11:41:58.227]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:58.227]                   signalCondition(cond)
[11:41:58.227]                 }
[11:41:58.227]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:58.227]                 "immediateCondition"))) {
[11:41:58.227]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:58.227]                   ...future.conditions[[length(...future.conditions) + 
[11:41:58.227]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:58.227]                   if (TRUE && !signal) {
[11:41:58.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:58.227]                     {
[11:41:58.227]                       inherits <- base::inherits
[11:41:58.227]                       invokeRestart <- base::invokeRestart
[11:41:58.227]                       is.null <- base::is.null
[11:41:58.227]                       muffled <- FALSE
[11:41:58.227]                       if (inherits(cond, "message")) {
[11:41:58.227]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:58.227]                         if (muffled) 
[11:41:58.227]                           invokeRestart("muffleMessage")
[11:41:58.227]                       }
[11:41:58.227]                       else if (inherits(cond, "warning")) {
[11:41:58.227]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:58.227]                         if (muffled) 
[11:41:58.227]                           invokeRestart("muffleWarning")
[11:41:58.227]                       }
[11:41:58.227]                       else if (inherits(cond, "condition")) {
[11:41:58.227]                         if (!is.null(pattern)) {
[11:41:58.227]                           computeRestarts <- base::computeRestarts
[11:41:58.227]                           grepl <- base::grepl
[11:41:58.227]                           restarts <- computeRestarts(cond)
[11:41:58.227]                           for (restart in restarts) {
[11:41:58.227]                             name <- restart$name
[11:41:58.227]                             if (is.null(name)) 
[11:41:58.227]                               next
[11:41:58.227]                             if (!grepl(pattern, name)) 
[11:41:58.227]                               next
[11:41:58.227]                             invokeRestart(restart)
[11:41:58.227]                             muffled <- TRUE
[11:41:58.227]                             break
[11:41:58.227]                           }
[11:41:58.227]                         }
[11:41:58.227]                       }
[11:41:58.227]                       invisible(muffled)
[11:41:58.227]                     }
[11:41:58.227]                     muffleCondition(cond, pattern = "^muffle")
[11:41:58.227]                   }
[11:41:58.227]                 }
[11:41:58.227]                 else {
[11:41:58.227]                   if (TRUE) {
[11:41:58.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:58.227]                     {
[11:41:58.227]                       inherits <- base::inherits
[11:41:58.227]                       invokeRestart <- base::invokeRestart
[11:41:58.227]                       is.null <- base::is.null
[11:41:58.227]                       muffled <- FALSE
[11:41:58.227]                       if (inherits(cond, "message")) {
[11:41:58.227]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:58.227]                         if (muffled) 
[11:41:58.227]                           invokeRestart("muffleMessage")
[11:41:58.227]                       }
[11:41:58.227]                       else if (inherits(cond, "warning")) {
[11:41:58.227]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:58.227]                         if (muffled) 
[11:41:58.227]                           invokeRestart("muffleWarning")
[11:41:58.227]                       }
[11:41:58.227]                       else if (inherits(cond, "condition")) {
[11:41:58.227]                         if (!is.null(pattern)) {
[11:41:58.227]                           computeRestarts <- base::computeRestarts
[11:41:58.227]                           grepl <- base::grepl
[11:41:58.227]                           restarts <- computeRestarts(cond)
[11:41:58.227]                           for (restart in restarts) {
[11:41:58.227]                             name <- restart$name
[11:41:58.227]                             if (is.null(name)) 
[11:41:58.227]                               next
[11:41:58.227]                             if (!grepl(pattern, name)) 
[11:41:58.227]                               next
[11:41:58.227]                             invokeRestart(restart)
[11:41:58.227]                             muffled <- TRUE
[11:41:58.227]                             break
[11:41:58.227]                           }
[11:41:58.227]                         }
[11:41:58.227]                       }
[11:41:58.227]                       invisible(muffled)
[11:41:58.227]                     }
[11:41:58.227]                     muffleCondition(cond, pattern = "^muffle")
[11:41:58.227]                   }
[11:41:58.227]                 }
[11:41:58.227]             }
[11:41:58.227]         }))
[11:41:58.227]     }, error = function(ex) {
[11:41:58.227]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:58.227]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:58.227]                 ...future.rng), started = ...future.startTime, 
[11:41:58.227]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:58.227]             version = "1.8"), class = "FutureResult")
[11:41:58.227]     }, finally = {
[11:41:58.227]         if (!identical(...future.workdir, getwd())) 
[11:41:58.227]             setwd(...future.workdir)
[11:41:58.227]         {
[11:41:58.227]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:58.227]                 ...future.oldOptions$nwarnings <- NULL
[11:41:58.227]             }
[11:41:58.227]             base::options(...future.oldOptions)
[11:41:58.227]             if (.Platform$OS.type == "windows") {
[11:41:58.227]                 old_names <- names(...future.oldEnvVars)
[11:41:58.227]                 envs <- base::Sys.getenv()
[11:41:58.227]                 names <- names(envs)
[11:41:58.227]                 common <- intersect(names, old_names)
[11:41:58.227]                 added <- setdiff(names, old_names)
[11:41:58.227]                 removed <- setdiff(old_names, names)
[11:41:58.227]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:58.227]                   envs[common]]
[11:41:58.227]                 NAMES <- toupper(changed)
[11:41:58.227]                 args <- list()
[11:41:58.227]                 for (kk in seq_along(NAMES)) {
[11:41:58.227]                   name <- changed[[kk]]
[11:41:58.227]                   NAME <- NAMES[[kk]]
[11:41:58.227]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:58.227]                     next
[11:41:58.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:58.227]                 }
[11:41:58.227]                 NAMES <- toupper(added)
[11:41:58.227]                 for (kk in seq_along(NAMES)) {
[11:41:58.227]                   name <- added[[kk]]
[11:41:58.227]                   NAME <- NAMES[[kk]]
[11:41:58.227]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:58.227]                     next
[11:41:58.227]                   args[[name]] <- ""
[11:41:58.227]                 }
[11:41:58.227]                 NAMES <- toupper(removed)
[11:41:58.227]                 for (kk in seq_along(NAMES)) {
[11:41:58.227]                   name <- removed[[kk]]
[11:41:58.227]                   NAME <- NAMES[[kk]]
[11:41:58.227]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:58.227]                     next
[11:41:58.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:58.227]                 }
[11:41:58.227]                 if (length(args) > 0) 
[11:41:58.227]                   base::do.call(base::Sys.setenv, args = args)
[11:41:58.227]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:58.227]             }
[11:41:58.227]             else {
[11:41:58.227]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:58.227]             }
[11:41:58.227]             {
[11:41:58.227]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:58.227]                   0L) {
[11:41:58.227]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:58.227]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:58.227]                   base::options(opts)
[11:41:58.227]                 }
[11:41:58.227]                 {
[11:41:58.227]                   {
[11:41:58.227]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:58.227]                     NULL
[11:41:58.227]                   }
[11:41:58.227]                   options(future.plan = NULL)
[11:41:58.227]                   if (is.na(NA_character_)) 
[11:41:58.227]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:58.227]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:58.227]                   future::plan(list(function (..., workers = 2, 
[11:41:58.227]                     envir = parent.frame()) 
[11:41:58.227]                   strategy(..., workers = workers, envir = envir)), 
[11:41:58.227]                     .cleanup = FALSE, .init = FALSE)
[11:41:58.227]                 }
[11:41:58.227]             }
[11:41:58.227]         }
[11:41:58.227]     })
[11:41:58.227]     if (TRUE) {
[11:41:58.227]         base::sink(type = "output", split = FALSE)
[11:41:58.227]         if (TRUE) {
[11:41:58.227]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:58.227]         }
[11:41:58.227]         else {
[11:41:58.227]             ...future.result["stdout"] <- base::list(NULL)
[11:41:58.227]         }
[11:41:58.227]         base::close(...future.stdout)
[11:41:58.227]         ...future.stdout <- NULL
[11:41:58.227]     }
[11:41:58.227]     ...future.result$conditions <- ...future.conditions
[11:41:58.227]     ...future.result$finished <- base::Sys.time()
[11:41:58.227]     ...future.result
[11:41:58.227] }
[11:41:58.229] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:58.239] receiveMessageFromWorker() for ClusterFuture ...
[11:41:58.240] - Validating connection of MultisessionFuture
[11:41:58.240] - received message: FutureResult
[11:41:58.240] - Received FutureResult
[11:41:58.240] - Erased future from FutureRegistry
[11:41:58.240] result() for ClusterFuture ...
[11:41:58.240] - result already collected: FutureResult
[11:41:58.240] result() for ClusterFuture ... done
[11:41:58.240] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:58.240] result() for ClusterFuture ...
[11:41:58.240] - result already collected: FutureResult
[11:41:58.240] result() for ClusterFuture ... done
[11:41:58.241] result() for ClusterFuture ...
[11:41:58.241] - result already collected: FutureResult
[11:41:58.241] result() for ClusterFuture ... done
[11:41:58.241] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:58.242] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:58.285] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:58.294] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:58.296] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:58.297] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:58.341] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:58.342] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:58.342] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:58.342] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:58.343] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:58.343] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:58.344] MultisessionFuture started
[11:41:58.344] - Launch lazy future ... done
[11:41:58.344] run() for ‘MultisessionFuture’ ... done
[11:41:58.344] Created future:
[11:41:58.344] MultisessionFuture:
[11:41:58.344] Label: ‘future_mapply-70’
[11:41:58.344] Expression:
[11:41:58.344] {
[11:41:58.344]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:58.344]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:58.344]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:58.344]         on.exit(options(oopts), add = TRUE)
[11:41:58.344]     }
[11:41:58.344]     {
[11:41:58.344]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:58.344]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:58.344]                 inherits = FALSE)
[11:41:58.344]             ...future.FUN(...)
[11:41:58.344]         }
[11:41:58.344]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:58.344]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:58.344]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:58.344]         do.call(mapply, args = args)
[11:41:58.344]     }
[11:41:58.344] }
[11:41:58.344] Lazy evaluation: FALSE
[11:41:58.344] Asynchronous evaluation: TRUE
[11:41:58.344] Local evaluation: TRUE
[11:41:58.344] Environment: 0x560ef58e1768
[11:41:58.344] Capture standard output: TRUE
[11:41:58.344] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:58.344] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:58.344] Packages: 1 packages (‘mlr3’)
[11:41:58.344] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:58.344] Resolved: FALSE
[11:41:58.344] Value: <not collected>
[11:41:58.344] Conditions captured: <none>
[11:41:58.344] Early signaling: FALSE
[11:41:58.344] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:58.344] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:58.359] Chunk #70 of 90 ... DONE
[11:41:58.359] Chunk #71 of 90 ...
[11:41:58.359]  - seeds: [1] <seeds>
[11:41:58.359] getGlobalsAndPackages() ...
[11:41:58.359] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:58.360] Resolving globals: FALSE
[11:41:58.360] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:58.360] - packages: [1] ‘mlr3’
[11:41:58.360] getGlobalsAndPackages() ... DONE
[11:41:58.360] run() for ‘Future’ ...
[11:41:58.360] - state: ‘created’
[11:41:58.360] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:58.370] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:58.371] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:58.371]   - Field: ‘node’
[11:41:58.371]   - Field: ‘label’
[11:41:58.371]   - Field: ‘local’
[11:41:58.371]   - Field: ‘owner’
[11:41:58.371]   - Field: ‘envir’
[11:41:58.371]   - Field: ‘workers’
[11:41:58.371]   - Field: ‘packages’
[11:41:58.371]   - Field: ‘gc’
[11:41:58.371]   - Field: ‘conditions’
[11:41:58.371]   - Field: ‘persistent’
[11:41:58.371]   - Field: ‘expr’
[11:41:58.371]   - Field: ‘uuid’
[11:41:58.371]   - Field: ‘seed’
[11:41:58.371]   - Field: ‘version’
[11:41:58.371]   - Field: ‘result’
[11:41:58.371]   - Field: ‘asynchronous’
[11:41:58.371]   - Field: ‘calls’
[11:41:58.371]   - Field: ‘globals’
[11:41:58.371]   - Field: ‘stdout’
[11:41:58.372]   - Field: ‘earlySignal’
[11:41:58.372]   - Field: ‘lazy’
[11:41:58.372]   - Field: ‘state’
[11:41:58.372] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:58.372] - Launch lazy future ...
[11:41:58.372] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:58.372] Packages needed by future strategies (n = 0): <none>
[11:41:58.372] {
[11:41:58.372]     {
[11:41:58.372]         {
[11:41:58.372]             ...future.startTime <- base::Sys.time()
[11:41:58.372]             {
[11:41:58.372]                 {
[11:41:58.372]                   {
[11:41:58.372]                     {
[11:41:58.372]                       {
[11:41:58.372]                         base::local({
[11:41:58.372]                           has_future <- base::requireNamespace("future", 
[11:41:58.372]                             quietly = TRUE)
[11:41:58.372]                           if (has_future) {
[11:41:58.372]                             ns <- base::getNamespace("future")
[11:41:58.372]                             version <- ns[[".package"]][["version"]]
[11:41:58.372]                             if (is.null(version)) 
[11:41:58.372]                               version <- utils::packageVersion("future")
[11:41:58.372]                           }
[11:41:58.372]                           else {
[11:41:58.372]                             version <- NULL
[11:41:58.372]                           }
[11:41:58.372]                           if (!has_future || version < "1.8.0") {
[11:41:58.372]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:58.372]                               "", base::R.version$version.string), 
[11:41:58.372]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:58.372]                                 base::R.version$platform, 8 * 
[11:41:58.372]                                   base::.Machine$sizeof.pointer), 
[11:41:58.372]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:58.372]                                 "release", "version")], collapse = " "), 
[11:41:58.372]                               hostname = base::Sys.info()[["nodename"]])
[11:41:58.372]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:58.372]                               info)
[11:41:58.372]                             info <- base::paste(info, collapse = "; ")
[11:41:58.372]                             if (!has_future) {
[11:41:58.372]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:58.372]                                 info)
[11:41:58.372]                             }
[11:41:58.372]                             else {
[11:41:58.372]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:58.372]                                 info, version)
[11:41:58.372]                             }
[11:41:58.372]                             base::stop(msg)
[11:41:58.372]                           }
[11:41:58.372]                         })
[11:41:58.372]                       }
[11:41:58.372]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:58.372]                       base::options(mc.cores = 1L)
[11:41:58.372]                     }
[11:41:58.372]                     base::local({
[11:41:58.372]                       for (pkg in "mlr3") {
[11:41:58.372]                         base::loadNamespace(pkg)
[11:41:58.372]                         base::library(pkg, character.only = TRUE)
[11:41:58.372]                       }
[11:41:58.372]                     })
[11:41:58.372]                   }
[11:41:58.372]                   options(future.plan = NULL)
[11:41:58.372]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:58.372]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:58.372]                 }
[11:41:58.372]                 ...future.workdir <- getwd()
[11:41:58.372]             }
[11:41:58.372]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:58.372]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:58.372]         }
[11:41:58.372]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:58.372]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:58.372]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:58.372]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:58.372]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:58.372]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:58.372]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:58.372]             base::names(...future.oldOptions))
[11:41:58.372]     }
[11:41:58.372]     if (FALSE) {
[11:41:58.372]     }
[11:41:58.372]     else {
[11:41:58.372]         if (TRUE) {
[11:41:58.372]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:58.372]                 open = "w")
[11:41:58.372]         }
[11:41:58.372]         else {
[11:41:58.372]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:58.372]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:58.372]         }
[11:41:58.372]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:58.372]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:58.372]             base::sink(type = "output", split = FALSE)
[11:41:58.372]             base::close(...future.stdout)
[11:41:58.372]         }, add = TRUE)
[11:41:58.372]     }
[11:41:58.372]     ...future.frame <- base::sys.nframe()
[11:41:58.372]     ...future.conditions <- base::list()
[11:41:58.372]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:58.372]     if (FALSE) {
[11:41:58.372]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:58.372]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:58.372]     }
[11:41:58.372]     ...future.result <- base::tryCatch({
[11:41:58.372]         base::withCallingHandlers({
[11:41:58.372]             ...future.value <- base::withVisible(base::local({
[11:41:58.372]                 ...future.makeSendCondition <- local({
[11:41:58.372]                   sendCondition <- NULL
[11:41:58.372]                   function(frame = 1L) {
[11:41:58.372]                     if (is.function(sendCondition)) 
[11:41:58.372]                       return(sendCondition)
[11:41:58.372]                     ns <- getNamespace("parallel")
[11:41:58.372]                     if (exists("sendData", mode = "function", 
[11:41:58.372]                       envir = ns)) {
[11:41:58.372]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:58.372]                         envir = ns)
[11:41:58.372]                       envir <- sys.frame(frame)
[11:41:58.372]                       master <- NULL
[11:41:58.372]                       while (!identical(envir, .GlobalEnv) && 
[11:41:58.372]                         !identical(envir, emptyenv())) {
[11:41:58.372]                         if (exists("master", mode = "list", envir = envir, 
[11:41:58.372]                           inherits = FALSE)) {
[11:41:58.372]                           master <- get("master", mode = "list", 
[11:41:58.372]                             envir = envir, inherits = FALSE)
[11:41:58.372]                           if (inherits(master, c("SOCKnode", 
[11:41:58.372]                             "SOCK0node"))) {
[11:41:58.372]                             sendCondition <<- function(cond) {
[11:41:58.372]                               data <- list(type = "VALUE", value = cond, 
[11:41:58.372]                                 success = TRUE)
[11:41:58.372]                               parallel_sendData(master, data)
[11:41:58.372]                             }
[11:41:58.372]                             return(sendCondition)
[11:41:58.372]                           }
[11:41:58.372]                         }
[11:41:58.372]                         frame <- frame + 1L
[11:41:58.372]                         envir <- sys.frame(frame)
[11:41:58.372]                       }
[11:41:58.372]                     }
[11:41:58.372]                     sendCondition <<- function(cond) NULL
[11:41:58.372]                   }
[11:41:58.372]                 })
[11:41:58.372]                 withCallingHandlers({
[11:41:58.372]                   {
[11:41:58.372]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:58.372]                     if (!identical(...future.globals.maxSize.org, 
[11:41:58.372]                       ...future.globals.maxSize)) {
[11:41:58.372]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:58.372]                       on.exit(options(oopts), add = TRUE)
[11:41:58.372]                     }
[11:41:58.372]                     {
[11:41:58.372]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:58.372]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:58.372]                           envir = globalenv(), inherits = FALSE)
[11:41:58.372]                         ...future.FUN(...)
[11:41:58.372]                       }
[11:41:58.372]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:58.372]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:58.372]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:58.372]                         USE.NAMES = FALSE)
[11:41:58.372]                       do.call(mapply, args = args)
[11:41:58.372]                     }
[11:41:58.372]                   }
[11:41:58.372]                 }, immediateCondition = function(cond) {
[11:41:58.372]                   sendCondition <- ...future.makeSendCondition()
[11:41:58.372]                   sendCondition(cond)
[11:41:58.372]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:58.372]                   {
[11:41:58.372]                     inherits <- base::inherits
[11:41:58.372]                     invokeRestart <- base::invokeRestart
[11:41:58.372]                     is.null <- base::is.null
[11:41:58.372]                     muffled <- FALSE
[11:41:58.372]                     if (inherits(cond, "message")) {
[11:41:58.372]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:58.372]                       if (muffled) 
[11:41:58.372]                         invokeRestart("muffleMessage")
[11:41:58.372]                     }
[11:41:58.372]                     else if (inherits(cond, "warning")) {
[11:41:58.372]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:58.372]                       if (muffled) 
[11:41:58.372]                         invokeRestart("muffleWarning")
[11:41:58.372]                     }
[11:41:58.372]                     else if (inherits(cond, "condition")) {
[11:41:58.372]                       if (!is.null(pattern)) {
[11:41:58.372]                         computeRestarts <- base::computeRestarts
[11:41:58.372]                         grepl <- base::grepl
[11:41:58.372]                         restarts <- computeRestarts(cond)
[11:41:58.372]                         for (restart in restarts) {
[11:41:58.372]                           name <- restart$name
[11:41:58.372]                           if (is.null(name)) 
[11:41:58.372]                             next
[11:41:58.372]                           if (!grepl(pattern, name)) 
[11:41:58.372]                             next
[11:41:58.372]                           invokeRestart(restart)
[11:41:58.372]                           muffled <- TRUE
[11:41:58.372]                           break
[11:41:58.372]                         }
[11:41:58.372]                       }
[11:41:58.372]                     }
[11:41:58.372]                     invisible(muffled)
[11:41:58.372]                   }
[11:41:58.372]                   muffleCondition(cond)
[11:41:58.372]                 })
[11:41:58.372]             }))
[11:41:58.372]             future::FutureResult(value = ...future.value$value, 
[11:41:58.372]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:58.372]                   ...future.rng), globalenv = if (FALSE) 
[11:41:58.372]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:58.372]                     ...future.globalenv.names))
[11:41:58.372]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:58.372]         }, condition = base::local({
[11:41:58.372]             c <- base::c
[11:41:58.372]             inherits <- base::inherits
[11:41:58.372]             invokeRestart <- base::invokeRestart
[11:41:58.372]             length <- base::length
[11:41:58.372]             list <- base::list
[11:41:58.372]             seq.int <- base::seq.int
[11:41:58.372]             signalCondition <- base::signalCondition
[11:41:58.372]             sys.calls <- base::sys.calls
[11:41:58.372]             `[[` <- base::`[[`
[11:41:58.372]             `+` <- base::`+`
[11:41:58.372]             `<<-` <- base::`<<-`
[11:41:58.372]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:58.372]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:58.372]                   3L)]
[11:41:58.372]             }
[11:41:58.372]             function(cond) {
[11:41:58.372]                 is_error <- inherits(cond, "error")
[11:41:58.372]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:58.372]                   NULL)
[11:41:58.372]                 if (is_error) {
[11:41:58.372]                   sessionInformation <- function() {
[11:41:58.372]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:58.372]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:58.372]                       search = base::search(), system = base::Sys.info())
[11:41:58.372]                   }
[11:41:58.372]                   ...future.conditions[[length(...future.conditions) + 
[11:41:58.372]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:58.372]                     cond$call), session = sessionInformation(), 
[11:41:58.372]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:58.372]                   signalCondition(cond)
[11:41:58.372]                 }
[11:41:58.372]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:58.372]                 "immediateCondition"))) {
[11:41:58.372]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:58.372]                   ...future.conditions[[length(...future.conditions) + 
[11:41:58.372]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:58.372]                   if (TRUE && !signal) {
[11:41:58.372]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:58.372]                     {
[11:41:58.372]                       inherits <- base::inherits
[11:41:58.372]                       invokeRestart <- base::invokeRestart
[11:41:58.372]                       is.null <- base::is.null
[11:41:58.372]                       muffled <- FALSE
[11:41:58.372]                       if (inherits(cond, "message")) {
[11:41:58.372]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:58.372]                         if (muffled) 
[11:41:58.372]                           invokeRestart("muffleMessage")
[11:41:58.372]                       }
[11:41:58.372]                       else if (inherits(cond, "warning")) {
[11:41:58.372]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:58.372]                         if (muffled) 
[11:41:58.372]                           invokeRestart("muffleWarning")
[11:41:58.372]                       }
[11:41:58.372]                       else if (inherits(cond, "condition")) {
[11:41:58.372]                         if (!is.null(pattern)) {
[11:41:58.372]                           computeRestarts <- base::computeRestarts
[11:41:58.372]                           grepl <- base::grepl
[11:41:58.372]                           restarts <- computeRestarts(cond)
[11:41:58.372]                           for (restart in restarts) {
[11:41:58.372]                             name <- restart$name
[11:41:58.372]                             if (is.null(name)) 
[11:41:58.372]                               next
[11:41:58.372]                             if (!grepl(pattern, name)) 
[11:41:58.372]                               next
[11:41:58.372]                             invokeRestart(restart)
[11:41:58.372]                             muffled <- TRUE
[11:41:58.372]                             break
[11:41:58.372]                           }
[11:41:58.372]                         }
[11:41:58.372]                       }
[11:41:58.372]                       invisible(muffled)
[11:41:58.372]                     }
[11:41:58.372]                     muffleCondition(cond, pattern = "^muffle")
[11:41:58.372]                   }
[11:41:58.372]                 }
[11:41:58.372]                 else {
[11:41:58.372]                   if (TRUE) {
[11:41:58.372]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:58.372]                     {
[11:41:58.372]                       inherits <- base::inherits
[11:41:58.372]                       invokeRestart <- base::invokeRestart
[11:41:58.372]                       is.null <- base::is.null
[11:41:58.372]                       muffled <- FALSE
[11:41:58.372]                       if (inherits(cond, "message")) {
[11:41:58.372]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:58.372]                         if (muffled) 
[11:41:58.372]                           invokeRestart("muffleMessage")
[11:41:58.372]                       }
[11:41:58.372]                       else if (inherits(cond, "warning")) {
[11:41:58.372]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:58.372]                         if (muffled) 
[11:41:58.372]                           invokeRestart("muffleWarning")
[11:41:58.372]                       }
[11:41:58.372]                       else if (inherits(cond, "condition")) {
[11:41:58.372]                         if (!is.null(pattern)) {
[11:41:58.372]                           computeRestarts <- base::computeRestarts
[11:41:58.372]                           grepl <- base::grepl
[11:41:58.372]                           restarts <- computeRestarts(cond)
[11:41:58.372]                           for (restart in restarts) {
[11:41:58.372]                             name <- restart$name
[11:41:58.372]                             if (is.null(name)) 
[11:41:58.372]                               next
[11:41:58.372]                             if (!grepl(pattern, name)) 
[11:41:58.372]                               next
[11:41:58.372]                             invokeRestart(restart)
[11:41:58.372]                             muffled <- TRUE
[11:41:58.372]                             break
[11:41:58.372]                           }
[11:41:58.372]                         }
[11:41:58.372]                       }
[11:41:58.372]                       invisible(muffled)
[11:41:58.372]                     }
[11:41:58.372]                     muffleCondition(cond, pattern = "^muffle")
[11:41:58.372]                   }
[11:41:58.372]                 }
[11:41:58.372]             }
[11:41:58.372]         }))
[11:41:58.372]     }, error = function(ex) {
[11:41:58.372]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:58.372]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:58.372]                 ...future.rng), started = ...future.startTime, 
[11:41:58.372]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:58.372]             version = "1.8"), class = "FutureResult")
[11:41:58.372]     }, finally = {
[11:41:58.372]         if (!identical(...future.workdir, getwd())) 
[11:41:58.372]             setwd(...future.workdir)
[11:41:58.372]         {
[11:41:58.372]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:58.372]                 ...future.oldOptions$nwarnings <- NULL
[11:41:58.372]             }
[11:41:58.372]             base::options(...future.oldOptions)
[11:41:58.372]             if (.Platform$OS.type == "windows") {
[11:41:58.372]                 old_names <- names(...future.oldEnvVars)
[11:41:58.372]                 envs <- base::Sys.getenv()
[11:41:58.372]                 names <- names(envs)
[11:41:58.372]                 common <- intersect(names, old_names)
[11:41:58.372]                 added <- setdiff(names, old_names)
[11:41:58.372]                 removed <- setdiff(old_names, names)
[11:41:58.372]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:58.372]                   envs[common]]
[11:41:58.372]                 NAMES <- toupper(changed)
[11:41:58.372]                 args <- list()
[11:41:58.372]                 for (kk in seq_along(NAMES)) {
[11:41:58.372]                   name <- changed[[kk]]
[11:41:58.372]                   NAME <- NAMES[[kk]]
[11:41:58.372]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:58.372]                     next
[11:41:58.372]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:58.372]                 }
[11:41:58.372]                 NAMES <- toupper(added)
[11:41:58.372]                 for (kk in seq_along(NAMES)) {
[11:41:58.372]                   name <- added[[kk]]
[11:41:58.372]                   NAME <- NAMES[[kk]]
[11:41:58.372]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:58.372]                     next
[11:41:58.372]                   args[[name]] <- ""
[11:41:58.372]                 }
[11:41:58.372]                 NAMES <- toupper(removed)
[11:41:58.372]                 for (kk in seq_along(NAMES)) {
[11:41:58.372]                   name <- removed[[kk]]
[11:41:58.372]                   NAME <- NAMES[[kk]]
[11:41:58.372]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:58.372]                     next
[11:41:58.372]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:58.372]                 }
[11:41:58.372]                 if (length(args) > 0) 
[11:41:58.372]                   base::do.call(base::Sys.setenv, args = args)
[11:41:58.372]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:58.372]             }
[11:41:58.372]             else {
[11:41:58.372]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:58.372]             }
[11:41:58.372]             {
[11:41:58.372]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:58.372]                   0L) {
[11:41:58.372]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:58.372]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:58.372]                   base::options(opts)
[11:41:58.372]                 }
[11:41:58.372]                 {
[11:41:58.372]                   {
[11:41:58.372]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:58.372]                     NULL
[11:41:58.372]                   }
[11:41:58.372]                   options(future.plan = NULL)
[11:41:58.372]                   if (is.na(NA_character_)) 
[11:41:58.372]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:58.372]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:58.372]                   future::plan(list(function (..., workers = 2, 
[11:41:58.372]                     envir = parent.frame()) 
[11:41:58.372]                   strategy(..., workers = workers, envir = envir)), 
[11:41:58.372]                     .cleanup = FALSE, .init = FALSE)
[11:41:58.372]                 }
[11:41:58.372]             }
[11:41:58.372]         }
[11:41:58.372]     })
[11:41:58.372]     if (TRUE) {
[11:41:58.372]         base::sink(type = "output", split = FALSE)
[11:41:58.372]         if (TRUE) {
[11:41:58.372]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:58.372]         }
[11:41:58.372]         else {
[11:41:58.372]             ...future.result["stdout"] <- base::list(NULL)
[11:41:58.372]         }
[11:41:58.372]         base::close(...future.stdout)
[11:41:58.372]         ...future.stdout <- NULL
[11:41:58.372]     }
[11:41:58.372]     ...future.result$conditions <- ...future.conditions
[11:41:58.372]     ...future.result$finished <- base::Sys.time()
[11:41:58.372]     ...future.result
[11:41:58.372] }
[11:41:58.374] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:58.385] receiveMessageFromWorker() for ClusterFuture ...
[11:41:58.385] - Validating connection of MultisessionFuture
[11:41:58.385] - received message: FutureResult
[11:41:58.385] - Received FutureResult
[11:41:58.385] - Erased future from FutureRegistry
[11:41:58.385] result() for ClusterFuture ...
[11:41:58.385] - result already collected: FutureResult
[11:41:58.385] result() for ClusterFuture ... done
[11:41:58.385] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:58.386] result() for ClusterFuture ...
[11:41:58.386] - result already collected: FutureResult
[11:41:58.386] result() for ClusterFuture ... done
[11:41:58.386] result() for ClusterFuture ...
[11:41:58.386] - result already collected: FutureResult
[11:41:58.386] result() for ClusterFuture ... done
[11:41:58.387] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:58.387] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:58.429] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:58.432] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:58.477] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:58.478] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:58.521] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:58.521] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:58.522] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:58.522] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:58.522] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:58.522] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:58.523] MultisessionFuture started
[11:41:58.523] - Launch lazy future ... done
[11:41:58.523] run() for ‘MultisessionFuture’ ... done
[11:41:58.523] Created future:
[11:41:58.523] MultisessionFuture:
[11:41:58.523] Label: ‘future_mapply-71’
[11:41:58.523] Expression:
[11:41:58.523] {
[11:41:58.523]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:58.523]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:58.523]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:58.523]         on.exit(options(oopts), add = TRUE)
[11:41:58.523]     }
[11:41:58.523]     {
[11:41:58.523]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:58.523]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:58.523]                 inherits = FALSE)
[11:41:58.523]             ...future.FUN(...)
[11:41:58.523]         }
[11:41:58.523]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:58.523]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:58.523]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:58.523]         do.call(mapply, args = args)
[11:41:58.523]     }
[11:41:58.523] }
[11:41:58.523] Lazy evaluation: FALSE
[11:41:58.523] Asynchronous evaluation: TRUE
[11:41:58.523] Local evaluation: TRUE
[11:41:58.523] Environment: 0x560ef58e1768
[11:41:58.523] Capture standard output: TRUE
[11:41:58.523] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:58.523] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:58.523] Packages: 1 packages (‘mlr3’)
[11:41:58.523] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:58.523] Resolved: FALSE
[11:41:58.523] Value: <not collected>
[11:41:58.523] Conditions captured: <none>
[11:41:58.523] Early signaling: FALSE
[11:41:58.523] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:58.523] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:58.538] Chunk #71 of 90 ... DONE
[11:41:58.538] Chunk #72 of 90 ...
[11:41:58.538]  - seeds: [1] <seeds>
[11:41:58.538] getGlobalsAndPackages() ...
[11:41:58.539] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:58.539] Resolving globals: FALSE
[11:41:58.539] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:58.539] - packages: [1] ‘mlr3’
[11:41:58.539] getGlobalsAndPackages() ... DONE
[11:41:58.539] run() for ‘Future’ ...
[11:41:58.539] - state: ‘created’
[11:41:58.539] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:58.550] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:58.550] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:58.550]   - Field: ‘node’
[11:41:58.551]   - Field: ‘label’
[11:41:58.551]   - Field: ‘local’
[11:41:58.551]   - Field: ‘owner’
[11:41:58.551]   - Field: ‘envir’
[11:41:58.551]   - Field: ‘workers’
[11:41:58.551]   - Field: ‘packages’
[11:41:58.551]   - Field: ‘gc’
[11:41:58.551]   - Field: ‘conditions’
[11:41:58.551]   - Field: ‘persistent’
[11:41:58.551]   - Field: ‘expr’
[11:41:58.551]   - Field: ‘uuid’
[11:41:58.551]   - Field: ‘seed’
[11:41:58.551]   - Field: ‘version’
[11:41:58.551]   - Field: ‘result’
[11:41:58.551]   - Field: ‘asynchronous’
[11:41:58.551]   - Field: ‘calls’
[11:41:58.551]   - Field: ‘globals’
[11:41:58.551]   - Field: ‘stdout’
[11:41:58.551]   - Field: ‘earlySignal’
[11:41:58.551]   - Field: ‘lazy’
[11:41:58.551]   - Field: ‘state’
[11:41:58.552] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:58.552] - Launch lazy future ...
[11:41:58.552] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:58.552] Packages needed by future strategies (n = 0): <none>
[11:41:58.552] {
[11:41:58.552]     {
[11:41:58.552]         {
[11:41:58.552]             ...future.startTime <- base::Sys.time()
[11:41:58.552]             {
[11:41:58.552]                 {
[11:41:58.552]                   {
[11:41:58.552]                     {
[11:41:58.552]                       {
[11:41:58.552]                         base::local({
[11:41:58.552]                           has_future <- base::requireNamespace("future", 
[11:41:58.552]                             quietly = TRUE)
[11:41:58.552]                           if (has_future) {
[11:41:58.552]                             ns <- base::getNamespace("future")
[11:41:58.552]                             version <- ns[[".package"]][["version"]]
[11:41:58.552]                             if (is.null(version)) 
[11:41:58.552]                               version <- utils::packageVersion("future")
[11:41:58.552]                           }
[11:41:58.552]                           else {
[11:41:58.552]                             version <- NULL
[11:41:58.552]                           }
[11:41:58.552]                           if (!has_future || version < "1.8.0") {
[11:41:58.552]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:58.552]                               "", base::R.version$version.string), 
[11:41:58.552]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:58.552]                                 base::R.version$platform, 8 * 
[11:41:58.552]                                   base::.Machine$sizeof.pointer), 
[11:41:58.552]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:58.552]                                 "release", "version")], collapse = " "), 
[11:41:58.552]                               hostname = base::Sys.info()[["nodename"]])
[11:41:58.552]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:58.552]                               info)
[11:41:58.552]                             info <- base::paste(info, collapse = "; ")
[11:41:58.552]                             if (!has_future) {
[11:41:58.552]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:58.552]                                 info)
[11:41:58.552]                             }
[11:41:58.552]                             else {
[11:41:58.552]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:58.552]                                 info, version)
[11:41:58.552]                             }
[11:41:58.552]                             base::stop(msg)
[11:41:58.552]                           }
[11:41:58.552]                         })
[11:41:58.552]                       }
[11:41:58.552]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:58.552]                       base::options(mc.cores = 1L)
[11:41:58.552]                     }
[11:41:58.552]                     base::local({
[11:41:58.552]                       for (pkg in "mlr3") {
[11:41:58.552]                         base::loadNamespace(pkg)
[11:41:58.552]                         base::library(pkg, character.only = TRUE)
[11:41:58.552]                       }
[11:41:58.552]                     })
[11:41:58.552]                   }
[11:41:58.552]                   options(future.plan = NULL)
[11:41:58.552]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:58.552]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:58.552]                 }
[11:41:58.552]                 ...future.workdir <- getwd()
[11:41:58.552]             }
[11:41:58.552]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:58.552]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:58.552]         }
[11:41:58.552]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:58.552]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:58.552]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:58.552]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:58.552]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:58.552]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:58.552]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:58.552]             base::names(...future.oldOptions))
[11:41:58.552]     }
[11:41:58.552]     if (FALSE) {
[11:41:58.552]     }
[11:41:58.552]     else {
[11:41:58.552]         if (TRUE) {
[11:41:58.552]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:58.552]                 open = "w")
[11:41:58.552]         }
[11:41:58.552]         else {
[11:41:58.552]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:58.552]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:58.552]         }
[11:41:58.552]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:58.552]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:58.552]             base::sink(type = "output", split = FALSE)
[11:41:58.552]             base::close(...future.stdout)
[11:41:58.552]         }, add = TRUE)
[11:41:58.552]     }
[11:41:58.552]     ...future.frame <- base::sys.nframe()
[11:41:58.552]     ...future.conditions <- base::list()
[11:41:58.552]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:58.552]     if (FALSE) {
[11:41:58.552]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:58.552]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:58.552]     }
[11:41:58.552]     ...future.result <- base::tryCatch({
[11:41:58.552]         base::withCallingHandlers({
[11:41:58.552]             ...future.value <- base::withVisible(base::local({
[11:41:58.552]                 ...future.makeSendCondition <- local({
[11:41:58.552]                   sendCondition <- NULL
[11:41:58.552]                   function(frame = 1L) {
[11:41:58.552]                     if (is.function(sendCondition)) 
[11:41:58.552]                       return(sendCondition)
[11:41:58.552]                     ns <- getNamespace("parallel")
[11:41:58.552]                     if (exists("sendData", mode = "function", 
[11:41:58.552]                       envir = ns)) {
[11:41:58.552]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:58.552]                         envir = ns)
[11:41:58.552]                       envir <- sys.frame(frame)
[11:41:58.552]                       master <- NULL
[11:41:58.552]                       while (!identical(envir, .GlobalEnv) && 
[11:41:58.552]                         !identical(envir, emptyenv())) {
[11:41:58.552]                         if (exists("master", mode = "list", envir = envir, 
[11:41:58.552]                           inherits = FALSE)) {
[11:41:58.552]                           master <- get("master", mode = "list", 
[11:41:58.552]                             envir = envir, inherits = FALSE)
[11:41:58.552]                           if (inherits(master, c("SOCKnode", 
[11:41:58.552]                             "SOCK0node"))) {
[11:41:58.552]                             sendCondition <<- function(cond) {
[11:41:58.552]                               data <- list(type = "VALUE", value = cond, 
[11:41:58.552]                                 success = TRUE)
[11:41:58.552]                               parallel_sendData(master, data)
[11:41:58.552]                             }
[11:41:58.552]                             return(sendCondition)
[11:41:58.552]                           }
[11:41:58.552]                         }
[11:41:58.552]                         frame <- frame + 1L
[11:41:58.552]                         envir <- sys.frame(frame)
[11:41:58.552]                       }
[11:41:58.552]                     }
[11:41:58.552]                     sendCondition <<- function(cond) NULL
[11:41:58.552]                   }
[11:41:58.552]                 })
[11:41:58.552]                 withCallingHandlers({
[11:41:58.552]                   {
[11:41:58.552]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:58.552]                     if (!identical(...future.globals.maxSize.org, 
[11:41:58.552]                       ...future.globals.maxSize)) {
[11:41:58.552]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:58.552]                       on.exit(options(oopts), add = TRUE)
[11:41:58.552]                     }
[11:41:58.552]                     {
[11:41:58.552]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:58.552]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:58.552]                           envir = globalenv(), inherits = FALSE)
[11:41:58.552]                         ...future.FUN(...)
[11:41:58.552]                       }
[11:41:58.552]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:58.552]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:58.552]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:58.552]                         USE.NAMES = FALSE)
[11:41:58.552]                       do.call(mapply, args = args)
[11:41:58.552]                     }
[11:41:58.552]                   }
[11:41:58.552]                 }, immediateCondition = function(cond) {
[11:41:58.552]                   sendCondition <- ...future.makeSendCondition()
[11:41:58.552]                   sendCondition(cond)
[11:41:58.552]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:58.552]                   {
[11:41:58.552]                     inherits <- base::inherits
[11:41:58.552]                     invokeRestart <- base::invokeRestart
[11:41:58.552]                     is.null <- base::is.null
[11:41:58.552]                     muffled <- FALSE
[11:41:58.552]                     if (inherits(cond, "message")) {
[11:41:58.552]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:58.552]                       if (muffled) 
[11:41:58.552]                         invokeRestart("muffleMessage")
[11:41:58.552]                     }
[11:41:58.552]                     else if (inherits(cond, "warning")) {
[11:41:58.552]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:58.552]                       if (muffled) 
[11:41:58.552]                         invokeRestart("muffleWarning")
[11:41:58.552]                     }
[11:41:58.552]                     else if (inherits(cond, "condition")) {
[11:41:58.552]                       if (!is.null(pattern)) {
[11:41:58.552]                         computeRestarts <- base::computeRestarts
[11:41:58.552]                         grepl <- base::grepl
[11:41:58.552]                         restarts <- computeRestarts(cond)
[11:41:58.552]                         for (restart in restarts) {
[11:41:58.552]                           name <- restart$name
[11:41:58.552]                           if (is.null(name)) 
[11:41:58.552]                             next
[11:41:58.552]                           if (!grepl(pattern, name)) 
[11:41:58.552]                             next
[11:41:58.552]                           invokeRestart(restart)
[11:41:58.552]                           muffled <- TRUE
[11:41:58.552]                           break
[11:41:58.552]                         }
[11:41:58.552]                       }
[11:41:58.552]                     }
[11:41:58.552]                     invisible(muffled)
[11:41:58.552]                   }
[11:41:58.552]                   muffleCondition(cond)
[11:41:58.552]                 })
[11:41:58.552]             }))
[11:41:58.552]             future::FutureResult(value = ...future.value$value, 
[11:41:58.552]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:58.552]                   ...future.rng), globalenv = if (FALSE) 
[11:41:58.552]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:58.552]                     ...future.globalenv.names))
[11:41:58.552]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:58.552]         }, condition = base::local({
[11:41:58.552]             c <- base::c
[11:41:58.552]             inherits <- base::inherits
[11:41:58.552]             invokeRestart <- base::invokeRestart
[11:41:58.552]             length <- base::length
[11:41:58.552]             list <- base::list
[11:41:58.552]             seq.int <- base::seq.int
[11:41:58.552]             signalCondition <- base::signalCondition
[11:41:58.552]             sys.calls <- base::sys.calls
[11:41:58.552]             `[[` <- base::`[[`
[11:41:58.552]             `+` <- base::`+`
[11:41:58.552]             `<<-` <- base::`<<-`
[11:41:58.552]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:58.552]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:58.552]                   3L)]
[11:41:58.552]             }
[11:41:58.552]             function(cond) {
[11:41:58.552]                 is_error <- inherits(cond, "error")
[11:41:58.552]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:58.552]                   NULL)
[11:41:58.552]                 if (is_error) {
[11:41:58.552]                   sessionInformation <- function() {
[11:41:58.552]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:58.552]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:58.552]                       search = base::search(), system = base::Sys.info())
[11:41:58.552]                   }
[11:41:58.552]                   ...future.conditions[[length(...future.conditions) + 
[11:41:58.552]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:58.552]                     cond$call), session = sessionInformation(), 
[11:41:58.552]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:58.552]                   signalCondition(cond)
[11:41:58.552]                 }
[11:41:58.552]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:58.552]                 "immediateCondition"))) {
[11:41:58.552]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:58.552]                   ...future.conditions[[length(...future.conditions) + 
[11:41:58.552]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:58.552]                   if (TRUE && !signal) {
[11:41:58.552]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:58.552]                     {
[11:41:58.552]                       inherits <- base::inherits
[11:41:58.552]                       invokeRestart <- base::invokeRestart
[11:41:58.552]                       is.null <- base::is.null
[11:41:58.552]                       muffled <- FALSE
[11:41:58.552]                       if (inherits(cond, "message")) {
[11:41:58.552]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:58.552]                         if (muffled) 
[11:41:58.552]                           invokeRestart("muffleMessage")
[11:41:58.552]                       }
[11:41:58.552]                       else if (inherits(cond, "warning")) {
[11:41:58.552]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:58.552]                         if (muffled) 
[11:41:58.552]                           invokeRestart("muffleWarning")
[11:41:58.552]                       }
[11:41:58.552]                       else if (inherits(cond, "condition")) {
[11:41:58.552]                         if (!is.null(pattern)) {
[11:41:58.552]                           computeRestarts <- base::computeRestarts
[11:41:58.552]                           grepl <- base::grepl
[11:41:58.552]                           restarts <- computeRestarts(cond)
[11:41:58.552]                           for (restart in restarts) {
[11:41:58.552]                             name <- restart$name
[11:41:58.552]                             if (is.null(name)) 
[11:41:58.552]                               next
[11:41:58.552]                             if (!grepl(pattern, name)) 
[11:41:58.552]                               next
[11:41:58.552]                             invokeRestart(restart)
[11:41:58.552]                             muffled <- TRUE
[11:41:58.552]                             break
[11:41:58.552]                           }
[11:41:58.552]                         }
[11:41:58.552]                       }
[11:41:58.552]                       invisible(muffled)
[11:41:58.552]                     }
[11:41:58.552]                     muffleCondition(cond, pattern = "^muffle")
[11:41:58.552]                   }
[11:41:58.552]                 }
[11:41:58.552]                 else {
[11:41:58.552]                   if (TRUE) {
[11:41:58.552]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:58.552]                     {
[11:41:58.552]                       inherits <- base::inherits
[11:41:58.552]                       invokeRestart <- base::invokeRestart
[11:41:58.552]                       is.null <- base::is.null
[11:41:58.552]                       muffled <- FALSE
[11:41:58.552]                       if (inherits(cond, "message")) {
[11:41:58.552]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:58.552]                         if (muffled) 
[11:41:58.552]                           invokeRestart("muffleMessage")
[11:41:58.552]                       }
[11:41:58.552]                       else if (inherits(cond, "warning")) {
[11:41:58.552]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:58.552]                         if (muffled) 
[11:41:58.552]                           invokeRestart("muffleWarning")
[11:41:58.552]                       }
[11:41:58.552]                       else if (inherits(cond, "condition")) {
[11:41:58.552]                         if (!is.null(pattern)) {
[11:41:58.552]                           computeRestarts <- base::computeRestarts
[11:41:58.552]                           grepl <- base::grepl
[11:41:58.552]                           restarts <- computeRestarts(cond)
[11:41:58.552]                           for (restart in restarts) {
[11:41:58.552]                             name <- restart$name
[11:41:58.552]                             if (is.null(name)) 
[11:41:58.552]                               next
[11:41:58.552]                             if (!grepl(pattern, name)) 
[11:41:58.552]                               next
[11:41:58.552]                             invokeRestart(restart)
[11:41:58.552]                             muffled <- TRUE
[11:41:58.552]                             break
[11:41:58.552]                           }
[11:41:58.552]                         }
[11:41:58.552]                       }
[11:41:58.552]                       invisible(muffled)
[11:41:58.552]                     }
[11:41:58.552]                     muffleCondition(cond, pattern = "^muffle")
[11:41:58.552]                   }
[11:41:58.552]                 }
[11:41:58.552]             }
[11:41:58.552]         }))
[11:41:58.552]     }, error = function(ex) {
[11:41:58.552]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:58.552]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:58.552]                 ...future.rng), started = ...future.startTime, 
[11:41:58.552]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:58.552]             version = "1.8"), class = "FutureResult")
[11:41:58.552]     }, finally = {
[11:41:58.552]         if (!identical(...future.workdir, getwd())) 
[11:41:58.552]             setwd(...future.workdir)
[11:41:58.552]         {
[11:41:58.552]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:58.552]                 ...future.oldOptions$nwarnings <- NULL
[11:41:58.552]             }
[11:41:58.552]             base::options(...future.oldOptions)
[11:41:58.552]             if (.Platform$OS.type == "windows") {
[11:41:58.552]                 old_names <- names(...future.oldEnvVars)
[11:41:58.552]                 envs <- base::Sys.getenv()
[11:41:58.552]                 names <- names(envs)
[11:41:58.552]                 common <- intersect(names, old_names)
[11:41:58.552]                 added <- setdiff(names, old_names)
[11:41:58.552]                 removed <- setdiff(old_names, names)
[11:41:58.552]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:58.552]                   envs[common]]
[11:41:58.552]                 NAMES <- toupper(changed)
[11:41:58.552]                 args <- list()
[11:41:58.552]                 for (kk in seq_along(NAMES)) {
[11:41:58.552]                   name <- changed[[kk]]
[11:41:58.552]                   NAME <- NAMES[[kk]]
[11:41:58.552]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:58.552]                     next
[11:41:58.552]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:58.552]                 }
[11:41:58.552]                 NAMES <- toupper(added)
[11:41:58.552]                 for (kk in seq_along(NAMES)) {
[11:41:58.552]                   name <- added[[kk]]
[11:41:58.552]                   NAME <- NAMES[[kk]]
[11:41:58.552]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:58.552]                     next
[11:41:58.552]                   args[[name]] <- ""
[11:41:58.552]                 }
[11:41:58.552]                 NAMES <- toupper(removed)
[11:41:58.552]                 for (kk in seq_along(NAMES)) {
[11:41:58.552]                   name <- removed[[kk]]
[11:41:58.552]                   NAME <- NAMES[[kk]]
[11:41:58.552]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:58.552]                     next
[11:41:58.552]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:58.552]                 }
[11:41:58.552]                 if (length(args) > 0) 
[11:41:58.552]                   base::do.call(base::Sys.setenv, args = args)
[11:41:58.552]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:58.552]             }
[11:41:58.552]             else {
[11:41:58.552]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:58.552]             }
[11:41:58.552]             {
[11:41:58.552]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:58.552]                   0L) {
[11:41:58.552]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:58.552]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:58.552]                   base::options(opts)
[11:41:58.552]                 }
[11:41:58.552]                 {
[11:41:58.552]                   {
[11:41:58.552]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:58.552]                     NULL
[11:41:58.552]                   }
[11:41:58.552]                   options(future.plan = NULL)
[11:41:58.552]                   if (is.na(NA_character_)) 
[11:41:58.552]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:58.552]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:58.552]                   future::plan(list(function (..., workers = 2, 
[11:41:58.552]                     envir = parent.frame()) 
[11:41:58.552]                   strategy(..., workers = workers, envir = envir)), 
[11:41:58.552]                     .cleanup = FALSE, .init = FALSE)
[11:41:58.552]                 }
[11:41:58.552]             }
[11:41:58.552]         }
[11:41:58.552]     })
[11:41:58.552]     if (TRUE) {
[11:41:58.552]         base::sink(type = "output", split = FALSE)
[11:41:58.552]         if (TRUE) {
[11:41:58.552]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:58.552]         }
[11:41:58.552]         else {
[11:41:58.552]             ...future.result["stdout"] <- base::list(NULL)
[11:41:58.552]         }
[11:41:58.552]         base::close(...future.stdout)
[11:41:58.552]         ...future.stdout <- NULL
[11:41:58.552]     }
[11:41:58.552]     ...future.result$conditions <- ...future.conditions
[11:41:58.552]     ...future.result$finished <- base::Sys.time()
[11:41:58.552]     ...future.result
[11:41:58.552] }
[11:41:58.554] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:58.565] receiveMessageFromWorker() for ClusterFuture ...
[11:41:58.565] - Validating connection of MultisessionFuture
[11:41:58.565] - received message: FutureResult
[11:41:58.565] - Received FutureResult
[11:41:58.565] - Erased future from FutureRegistry
[11:41:58.565] result() for ClusterFuture ...
[11:41:58.565] - result already collected: FutureResult
[11:41:58.565] result() for ClusterFuture ... done
[11:41:58.565] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:58.565] result() for ClusterFuture ...
[11:41:58.566] - result already collected: FutureResult
[11:41:58.566] result() for ClusterFuture ... done
[11:41:58.566] result() for ClusterFuture ...
[11:41:58.566] - result already collected: FutureResult
[11:41:58.566] result() for ClusterFuture ... done
[11:41:58.567] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:58.567] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:58.609] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:58.612] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:58.661] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:58.661] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:58.705] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:58.705] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:58.706] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:58.706] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:58.707] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:58.707] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:58.708] MultisessionFuture started
[11:41:58.708] - Launch lazy future ... done
[11:41:58.708] run() for ‘MultisessionFuture’ ... done
[11:41:58.708] Created future:
[11:41:58.708] MultisessionFuture:
[11:41:58.708] Label: ‘future_mapply-72’
[11:41:58.708] Expression:
[11:41:58.708] {
[11:41:58.708]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:58.708]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:58.708]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:58.708]         on.exit(options(oopts), add = TRUE)
[11:41:58.708]     }
[11:41:58.708]     {
[11:41:58.708]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:58.708]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:58.708]                 inherits = FALSE)
[11:41:58.708]             ...future.FUN(...)
[11:41:58.708]         }
[11:41:58.708]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:58.708]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:58.708]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:58.708]         do.call(mapply, args = args)
[11:41:58.708]     }
[11:41:58.708] }
[11:41:58.708] Lazy evaluation: FALSE
[11:41:58.708] Asynchronous evaluation: TRUE
[11:41:58.708] Local evaluation: TRUE
[11:41:58.708] Environment: 0x560ef58e1768
[11:41:58.708] Capture standard output: TRUE
[11:41:58.708] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:58.708] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:58.708] Packages: 1 packages (‘mlr3’)
[11:41:58.708] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:58.708] Resolved: FALSE
[11:41:58.708] Value: <not collected>
[11:41:58.708] Conditions captured: <none>
[11:41:58.708] Early signaling: FALSE
[11:41:58.708] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:58.708] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:58.724] Chunk #72 of 90 ... DONE
[11:41:58.724] Chunk #73 of 90 ...
[11:41:58.724]  - seeds: [1] <seeds>
[11:41:58.724] getGlobalsAndPackages() ...
[11:41:58.725] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:58.725] Resolving globals: FALSE
[11:41:58.725] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:58.725] - packages: [1] ‘mlr3’
[11:41:58.726] getGlobalsAndPackages() ... DONE
[11:41:58.726] run() for ‘Future’ ...
[11:41:58.726] - state: ‘created’
[11:41:58.726] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:58.742] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:58.742] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:58.742]   - Field: ‘node’
[11:41:58.742]   - Field: ‘label’
[11:41:58.742]   - Field: ‘local’
[11:41:58.742]   - Field: ‘owner’
[11:41:58.742]   - Field: ‘envir’
[11:41:58.743]   - Field: ‘workers’
[11:41:58.743]   - Field: ‘packages’
[11:41:58.743]   - Field: ‘gc’
[11:41:58.743]   - Field: ‘conditions’
[11:41:58.743]   - Field: ‘persistent’
[11:41:58.743]   - Field: ‘expr’
[11:41:58.743]   - Field: ‘uuid’
[11:41:58.743]   - Field: ‘seed’
[11:41:58.743]   - Field: ‘version’
[11:41:58.743]   - Field: ‘result’
[11:41:58.743]   - Field: ‘asynchronous’
[11:41:58.744]   - Field: ‘calls’
[11:41:58.744]   - Field: ‘globals’
[11:41:58.744]   - Field: ‘stdout’
[11:41:58.744]   - Field: ‘earlySignal’
[11:41:58.744]   - Field: ‘lazy’
[11:41:58.744]   - Field: ‘state’
[11:41:58.744] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:58.744] - Launch lazy future ...
[11:41:58.745] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:58.745] Packages needed by future strategies (n = 0): <none>
[11:41:58.745] {
[11:41:58.745]     {
[11:41:58.745]         {
[11:41:58.745]             ...future.startTime <- base::Sys.time()
[11:41:58.745]             {
[11:41:58.745]                 {
[11:41:58.745]                   {
[11:41:58.745]                     {
[11:41:58.745]                       {
[11:41:58.745]                         base::local({
[11:41:58.745]                           has_future <- base::requireNamespace("future", 
[11:41:58.745]                             quietly = TRUE)
[11:41:58.745]                           if (has_future) {
[11:41:58.745]                             ns <- base::getNamespace("future")
[11:41:58.745]                             version <- ns[[".package"]][["version"]]
[11:41:58.745]                             if (is.null(version)) 
[11:41:58.745]                               version <- utils::packageVersion("future")
[11:41:58.745]                           }
[11:41:58.745]                           else {
[11:41:58.745]                             version <- NULL
[11:41:58.745]                           }
[11:41:58.745]                           if (!has_future || version < "1.8.0") {
[11:41:58.745]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:58.745]                               "", base::R.version$version.string), 
[11:41:58.745]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:58.745]                                 base::R.version$platform, 8 * 
[11:41:58.745]                                   base::.Machine$sizeof.pointer), 
[11:41:58.745]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:58.745]                                 "release", "version")], collapse = " "), 
[11:41:58.745]                               hostname = base::Sys.info()[["nodename"]])
[11:41:58.745]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:58.745]                               info)
[11:41:58.745]                             info <- base::paste(info, collapse = "; ")
[11:41:58.745]                             if (!has_future) {
[11:41:58.745]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:58.745]                                 info)
[11:41:58.745]                             }
[11:41:58.745]                             else {
[11:41:58.745]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:58.745]                                 info, version)
[11:41:58.745]                             }
[11:41:58.745]                             base::stop(msg)
[11:41:58.745]                           }
[11:41:58.745]                         })
[11:41:58.745]                       }
[11:41:58.745]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:58.745]                       base::options(mc.cores = 1L)
[11:41:58.745]                     }
[11:41:58.745]                     base::local({
[11:41:58.745]                       for (pkg in "mlr3") {
[11:41:58.745]                         base::loadNamespace(pkg)
[11:41:58.745]                         base::library(pkg, character.only = TRUE)
[11:41:58.745]                       }
[11:41:58.745]                     })
[11:41:58.745]                   }
[11:41:58.745]                   options(future.plan = NULL)
[11:41:58.745]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:58.745]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:58.745]                 }
[11:41:58.745]                 ...future.workdir <- getwd()
[11:41:58.745]             }
[11:41:58.745]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:58.745]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:58.745]         }
[11:41:58.745]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:58.745]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:58.745]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:58.745]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:58.745]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:58.745]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:58.745]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:58.745]             base::names(...future.oldOptions))
[11:41:58.745]     }
[11:41:58.745]     if (FALSE) {
[11:41:58.745]     }
[11:41:58.745]     else {
[11:41:58.745]         if (TRUE) {
[11:41:58.745]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:58.745]                 open = "w")
[11:41:58.745]         }
[11:41:58.745]         else {
[11:41:58.745]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:58.745]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:58.745]         }
[11:41:58.745]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:58.745]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:58.745]             base::sink(type = "output", split = FALSE)
[11:41:58.745]             base::close(...future.stdout)
[11:41:58.745]         }, add = TRUE)
[11:41:58.745]     }
[11:41:58.745]     ...future.frame <- base::sys.nframe()
[11:41:58.745]     ...future.conditions <- base::list()
[11:41:58.745]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:58.745]     if (FALSE) {
[11:41:58.745]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:58.745]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:58.745]     }
[11:41:58.745]     ...future.result <- base::tryCatch({
[11:41:58.745]         base::withCallingHandlers({
[11:41:58.745]             ...future.value <- base::withVisible(base::local({
[11:41:58.745]                 ...future.makeSendCondition <- local({
[11:41:58.745]                   sendCondition <- NULL
[11:41:58.745]                   function(frame = 1L) {
[11:41:58.745]                     if (is.function(sendCondition)) 
[11:41:58.745]                       return(sendCondition)
[11:41:58.745]                     ns <- getNamespace("parallel")
[11:41:58.745]                     if (exists("sendData", mode = "function", 
[11:41:58.745]                       envir = ns)) {
[11:41:58.745]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:58.745]                         envir = ns)
[11:41:58.745]                       envir <- sys.frame(frame)
[11:41:58.745]                       master <- NULL
[11:41:58.745]                       while (!identical(envir, .GlobalEnv) && 
[11:41:58.745]                         !identical(envir, emptyenv())) {
[11:41:58.745]                         if (exists("master", mode = "list", envir = envir, 
[11:41:58.745]                           inherits = FALSE)) {
[11:41:58.745]                           master <- get("master", mode = "list", 
[11:41:58.745]                             envir = envir, inherits = FALSE)
[11:41:58.745]                           if (inherits(master, c("SOCKnode", 
[11:41:58.745]                             "SOCK0node"))) {
[11:41:58.745]                             sendCondition <<- function(cond) {
[11:41:58.745]                               data <- list(type = "VALUE", value = cond, 
[11:41:58.745]                                 success = TRUE)
[11:41:58.745]                               parallel_sendData(master, data)
[11:41:58.745]                             }
[11:41:58.745]                             return(sendCondition)
[11:41:58.745]                           }
[11:41:58.745]                         }
[11:41:58.745]                         frame <- frame + 1L
[11:41:58.745]                         envir <- sys.frame(frame)
[11:41:58.745]                       }
[11:41:58.745]                     }
[11:41:58.745]                     sendCondition <<- function(cond) NULL
[11:41:58.745]                   }
[11:41:58.745]                 })
[11:41:58.745]                 withCallingHandlers({
[11:41:58.745]                   {
[11:41:58.745]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:58.745]                     if (!identical(...future.globals.maxSize.org, 
[11:41:58.745]                       ...future.globals.maxSize)) {
[11:41:58.745]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:58.745]                       on.exit(options(oopts), add = TRUE)
[11:41:58.745]                     }
[11:41:58.745]                     {
[11:41:58.745]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:58.745]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:58.745]                           envir = globalenv(), inherits = FALSE)
[11:41:58.745]                         ...future.FUN(...)
[11:41:58.745]                       }
[11:41:58.745]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:58.745]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:58.745]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:58.745]                         USE.NAMES = FALSE)
[11:41:58.745]                       do.call(mapply, args = args)
[11:41:58.745]                     }
[11:41:58.745]                   }
[11:41:58.745]                 }, immediateCondition = function(cond) {
[11:41:58.745]                   sendCondition <- ...future.makeSendCondition()
[11:41:58.745]                   sendCondition(cond)
[11:41:58.745]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:58.745]                   {
[11:41:58.745]                     inherits <- base::inherits
[11:41:58.745]                     invokeRestart <- base::invokeRestart
[11:41:58.745]                     is.null <- base::is.null
[11:41:58.745]                     muffled <- FALSE
[11:41:58.745]                     if (inherits(cond, "message")) {
[11:41:58.745]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:58.745]                       if (muffled) 
[11:41:58.745]                         invokeRestart("muffleMessage")
[11:41:58.745]                     }
[11:41:58.745]                     else if (inherits(cond, "warning")) {
[11:41:58.745]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:58.745]                       if (muffled) 
[11:41:58.745]                         invokeRestart("muffleWarning")
[11:41:58.745]                     }
[11:41:58.745]                     else if (inherits(cond, "condition")) {
[11:41:58.745]                       if (!is.null(pattern)) {
[11:41:58.745]                         computeRestarts <- base::computeRestarts
[11:41:58.745]                         grepl <- base::grepl
[11:41:58.745]                         restarts <- computeRestarts(cond)
[11:41:58.745]                         for (restart in restarts) {
[11:41:58.745]                           name <- restart$name
[11:41:58.745]                           if (is.null(name)) 
[11:41:58.745]                             next
[11:41:58.745]                           if (!grepl(pattern, name)) 
[11:41:58.745]                             next
[11:41:58.745]                           invokeRestart(restart)
[11:41:58.745]                           muffled <- TRUE
[11:41:58.745]                           break
[11:41:58.745]                         }
[11:41:58.745]                       }
[11:41:58.745]                     }
[11:41:58.745]                     invisible(muffled)
[11:41:58.745]                   }
[11:41:58.745]                   muffleCondition(cond)
[11:41:58.745]                 })
[11:41:58.745]             }))
[11:41:58.745]             future::FutureResult(value = ...future.value$value, 
[11:41:58.745]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:58.745]                   ...future.rng), globalenv = if (FALSE) 
[11:41:58.745]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:58.745]                     ...future.globalenv.names))
[11:41:58.745]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:58.745]         }, condition = base::local({
[11:41:58.745]             c <- base::c
[11:41:58.745]             inherits <- base::inherits
[11:41:58.745]             invokeRestart <- base::invokeRestart
[11:41:58.745]             length <- base::length
[11:41:58.745]             list <- base::list
[11:41:58.745]             seq.int <- base::seq.int
[11:41:58.745]             signalCondition <- base::signalCondition
[11:41:58.745]             sys.calls <- base::sys.calls
[11:41:58.745]             `[[` <- base::`[[`
[11:41:58.745]             `+` <- base::`+`
[11:41:58.745]             `<<-` <- base::`<<-`
[11:41:58.745]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:58.745]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:58.745]                   3L)]
[11:41:58.745]             }
[11:41:58.745]             function(cond) {
[11:41:58.745]                 is_error <- inherits(cond, "error")
[11:41:58.745]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:58.745]                   NULL)
[11:41:58.745]                 if (is_error) {
[11:41:58.745]                   sessionInformation <- function() {
[11:41:58.745]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:58.745]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:58.745]                       search = base::search(), system = base::Sys.info())
[11:41:58.745]                   }
[11:41:58.745]                   ...future.conditions[[length(...future.conditions) + 
[11:41:58.745]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:58.745]                     cond$call), session = sessionInformation(), 
[11:41:58.745]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:58.745]                   signalCondition(cond)
[11:41:58.745]                 }
[11:41:58.745]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:58.745]                 "immediateCondition"))) {
[11:41:58.745]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:58.745]                   ...future.conditions[[length(...future.conditions) + 
[11:41:58.745]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:58.745]                   if (TRUE && !signal) {
[11:41:58.745]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:58.745]                     {
[11:41:58.745]                       inherits <- base::inherits
[11:41:58.745]                       invokeRestart <- base::invokeRestart
[11:41:58.745]                       is.null <- base::is.null
[11:41:58.745]                       muffled <- FALSE
[11:41:58.745]                       if (inherits(cond, "message")) {
[11:41:58.745]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:58.745]                         if (muffled) 
[11:41:58.745]                           invokeRestart("muffleMessage")
[11:41:58.745]                       }
[11:41:58.745]                       else if (inherits(cond, "warning")) {
[11:41:58.745]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:58.745]                         if (muffled) 
[11:41:58.745]                           invokeRestart("muffleWarning")
[11:41:58.745]                       }
[11:41:58.745]                       else if (inherits(cond, "condition")) {
[11:41:58.745]                         if (!is.null(pattern)) {
[11:41:58.745]                           computeRestarts <- base::computeRestarts
[11:41:58.745]                           grepl <- base::grepl
[11:41:58.745]                           restarts <- computeRestarts(cond)
[11:41:58.745]                           for (restart in restarts) {
[11:41:58.745]                             name <- restart$name
[11:41:58.745]                             if (is.null(name)) 
[11:41:58.745]                               next
[11:41:58.745]                             if (!grepl(pattern, name)) 
[11:41:58.745]                               next
[11:41:58.745]                             invokeRestart(restart)
[11:41:58.745]                             muffled <- TRUE
[11:41:58.745]                             break
[11:41:58.745]                           }
[11:41:58.745]                         }
[11:41:58.745]                       }
[11:41:58.745]                       invisible(muffled)
[11:41:58.745]                     }
[11:41:58.745]                     muffleCondition(cond, pattern = "^muffle")
[11:41:58.745]                   }
[11:41:58.745]                 }
[11:41:58.745]                 else {
[11:41:58.745]                   if (TRUE) {
[11:41:58.745]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:58.745]                     {
[11:41:58.745]                       inherits <- base::inherits
[11:41:58.745]                       invokeRestart <- base::invokeRestart
[11:41:58.745]                       is.null <- base::is.null
[11:41:58.745]                       muffled <- FALSE
[11:41:58.745]                       if (inherits(cond, "message")) {
[11:41:58.745]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:58.745]                         if (muffled) 
[11:41:58.745]                           invokeRestart("muffleMessage")
[11:41:58.745]                       }
[11:41:58.745]                       else if (inherits(cond, "warning")) {
[11:41:58.745]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:58.745]                         if (muffled) 
[11:41:58.745]                           invokeRestart("muffleWarning")
[11:41:58.745]                       }
[11:41:58.745]                       else if (inherits(cond, "condition")) {
[11:41:58.745]                         if (!is.null(pattern)) {
[11:41:58.745]                           computeRestarts <- base::computeRestarts
[11:41:58.745]                           grepl <- base::grepl
[11:41:58.745]                           restarts <- computeRestarts(cond)
[11:41:58.745]                           for (restart in restarts) {
[11:41:58.745]                             name <- restart$name
[11:41:58.745]                             if (is.null(name)) 
[11:41:58.745]                               next
[11:41:58.745]                             if (!grepl(pattern, name)) 
[11:41:58.745]                               next
[11:41:58.745]                             invokeRestart(restart)
[11:41:58.745]                             muffled <- TRUE
[11:41:58.745]                             break
[11:41:58.745]                           }
[11:41:58.745]                         }
[11:41:58.745]                       }
[11:41:58.745]                       invisible(muffled)
[11:41:58.745]                     }
[11:41:58.745]                     muffleCondition(cond, pattern = "^muffle")
[11:41:58.745]                   }
[11:41:58.745]                 }
[11:41:58.745]             }
[11:41:58.745]         }))
[11:41:58.745]     }, error = function(ex) {
[11:41:58.745]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:58.745]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:58.745]                 ...future.rng), started = ...future.startTime, 
[11:41:58.745]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:58.745]             version = "1.8"), class = "FutureResult")
[11:41:58.745]     }, finally = {
[11:41:58.745]         if (!identical(...future.workdir, getwd())) 
[11:41:58.745]             setwd(...future.workdir)
[11:41:58.745]         {
[11:41:58.745]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:58.745]                 ...future.oldOptions$nwarnings <- NULL
[11:41:58.745]             }
[11:41:58.745]             base::options(...future.oldOptions)
[11:41:58.745]             if (.Platform$OS.type == "windows") {
[11:41:58.745]                 old_names <- names(...future.oldEnvVars)
[11:41:58.745]                 envs <- base::Sys.getenv()
[11:41:58.745]                 names <- names(envs)
[11:41:58.745]                 common <- intersect(names, old_names)
[11:41:58.745]                 added <- setdiff(names, old_names)
[11:41:58.745]                 removed <- setdiff(old_names, names)
[11:41:58.745]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:58.745]                   envs[common]]
[11:41:58.745]                 NAMES <- toupper(changed)
[11:41:58.745]                 args <- list()
[11:41:58.745]                 for (kk in seq_along(NAMES)) {
[11:41:58.745]                   name <- changed[[kk]]
[11:41:58.745]                   NAME <- NAMES[[kk]]
[11:41:58.745]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:58.745]                     next
[11:41:58.745]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:58.745]                 }
[11:41:58.745]                 NAMES <- toupper(added)
[11:41:58.745]                 for (kk in seq_along(NAMES)) {
[11:41:58.745]                   name <- added[[kk]]
[11:41:58.745]                   NAME <- NAMES[[kk]]
[11:41:58.745]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:58.745]                     next
[11:41:58.745]                   args[[name]] <- ""
[11:41:58.745]                 }
[11:41:58.745]                 NAMES <- toupper(removed)
[11:41:58.745]                 for (kk in seq_along(NAMES)) {
[11:41:58.745]                   name <- removed[[kk]]
[11:41:58.745]                   NAME <- NAMES[[kk]]
[11:41:58.745]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:58.745]                     next
[11:41:58.745]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:58.745]                 }
[11:41:58.745]                 if (length(args) > 0) 
[11:41:58.745]                   base::do.call(base::Sys.setenv, args = args)
[11:41:58.745]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:58.745]             }
[11:41:58.745]             else {
[11:41:58.745]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:58.745]             }
[11:41:58.745]             {
[11:41:58.745]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:58.745]                   0L) {
[11:41:58.745]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:58.745]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:58.745]                   base::options(opts)
[11:41:58.745]                 }
[11:41:58.745]                 {
[11:41:58.745]                   {
[11:41:58.745]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:58.745]                     NULL
[11:41:58.745]                   }
[11:41:58.745]                   options(future.plan = NULL)
[11:41:58.745]                   if (is.na(NA_character_)) 
[11:41:58.745]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:58.745]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:58.745]                   future::plan(list(function (..., workers = 2, 
[11:41:58.745]                     envir = parent.frame()) 
[11:41:58.745]                   strategy(..., workers = workers, envir = envir)), 
[11:41:58.745]                     .cleanup = FALSE, .init = FALSE)
[11:41:58.745]                 }
[11:41:58.745]             }
[11:41:58.745]         }
[11:41:58.745]     })
[11:41:58.745]     if (TRUE) {
[11:41:58.745]         base::sink(type = "output", split = FALSE)
[11:41:58.745]         if (TRUE) {
[11:41:58.745]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:58.745]         }
[11:41:58.745]         else {
[11:41:58.745]             ...future.result["stdout"] <- base::list(NULL)
[11:41:58.745]         }
[11:41:58.745]         base::close(...future.stdout)
[11:41:58.745]         ...future.stdout <- NULL
[11:41:58.745]     }
[11:41:58.745]     ...future.result$conditions <- ...future.conditions
[11:41:58.745]     ...future.result$finished <- base::Sys.time()
[11:41:58.745]     ...future.result
[11:41:58.745] }
[11:41:58.748] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:58.759] receiveMessageFromWorker() for ClusterFuture ...
[11:41:58.759] - Validating connection of MultisessionFuture
[11:41:58.759] - received message: FutureResult
[11:41:58.759] - Received FutureResult
[11:41:58.759] - Erased future from FutureRegistry
[11:41:58.759] result() for ClusterFuture ...
[11:41:58.759] - result already collected: FutureResult
[11:41:58.760] result() for ClusterFuture ... done
[11:41:58.760] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:58.760] result() for ClusterFuture ...
[11:41:58.760] - result already collected: FutureResult
[11:41:58.760] result() for ClusterFuture ... done
[11:41:58.760] result() for ClusterFuture ...
[11:41:58.760] - result already collected: FutureResult
[11:41:58.760] result() for ClusterFuture ... done
[11:41:58.761] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:58.761] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:58.805] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:58.809] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:58.811] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:58.811] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:58.853] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:58.854] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:58.856] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:58.857] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:58.857] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:58.857] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:58.858] MultisessionFuture started
[11:41:58.858] - Launch lazy future ... done
[11:41:58.858] run() for ‘MultisessionFuture’ ... done
[11:41:58.858] Created future:
[11:41:58.858] MultisessionFuture:
[11:41:58.858] Label: ‘future_mapply-73’
[11:41:58.858] Expression:
[11:41:58.858] {
[11:41:58.858]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:58.858]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:58.858]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:58.858]         on.exit(options(oopts), add = TRUE)
[11:41:58.858]     }
[11:41:58.858]     {
[11:41:58.858]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:58.858]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:58.858]                 inherits = FALSE)
[11:41:58.858]             ...future.FUN(...)
[11:41:58.858]         }
[11:41:58.858]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:58.858]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:58.858]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:58.858]         do.call(mapply, args = args)
[11:41:58.858]     }
[11:41:58.858] }
[11:41:58.858] Lazy evaluation: FALSE
[11:41:58.858] Asynchronous evaluation: TRUE
[11:41:58.858] Local evaluation: TRUE
[11:41:58.858] Environment: 0x560ef58e1768
[11:41:58.858] Capture standard output: TRUE
[11:41:58.858] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:58.858] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:58.858] Packages: 1 packages (‘mlr3’)
[11:41:58.858] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:58.858] Resolved: FALSE
[11:41:58.858] Value: <not collected>
[11:41:58.858] Conditions captured: <none>
[11:41:58.858] Early signaling: FALSE
[11:41:58.858] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:58.858] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:58.876] Chunk #73 of 90 ... DONE
[11:41:58.877] Chunk #74 of 90 ...
[11:41:58.877]  - seeds: [1] <seeds>
[11:41:58.877] getGlobalsAndPackages() ...
[11:41:58.877] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:58.877] Resolving globals: FALSE
[11:41:58.877] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:58.878] - packages: [1] ‘mlr3’
[11:41:58.878] getGlobalsAndPackages() ... DONE
[11:41:58.878] run() for ‘Future’ ...
[11:41:58.878] - state: ‘created’
[11:41:58.878] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:58.896] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:58.896] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:58.896]   - Field: ‘node’
[11:41:58.896]   - Field: ‘label’
[11:41:58.896]   - Field: ‘local’
[11:41:58.896]   - Field: ‘owner’
[11:41:58.896]   - Field: ‘envir’
[11:41:58.896]   - Field: ‘workers’
[11:41:58.896]   - Field: ‘packages’
[11:41:58.896]   - Field: ‘gc’
[11:41:58.896]   - Field: ‘conditions’
[11:41:58.896]   - Field: ‘persistent’
[11:41:58.896]   - Field: ‘expr’
[11:41:58.897]   - Field: ‘uuid’
[11:41:58.897]   - Field: ‘seed’
[11:41:58.897]   - Field: ‘version’
[11:41:58.897]   - Field: ‘result’
[11:41:58.897]   - Field: ‘asynchronous’
[11:41:58.897]   - Field: ‘calls’
[11:41:58.897]   - Field: ‘globals’
[11:41:58.897]   - Field: ‘stdout’
[11:41:58.897]   - Field: ‘earlySignal’
[11:41:58.897]   - Field: ‘lazy’
[11:41:58.897]   - Field: ‘state’
[11:41:58.897] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:58.897] - Launch lazy future ...
[11:41:58.897] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:58.897] Packages needed by future strategies (n = 0): <none>
[11:41:58.898] {
[11:41:58.898]     {
[11:41:58.898]         {
[11:41:58.898]             ...future.startTime <- base::Sys.time()
[11:41:58.898]             {
[11:41:58.898]                 {
[11:41:58.898]                   {
[11:41:58.898]                     {
[11:41:58.898]                       {
[11:41:58.898]                         base::local({
[11:41:58.898]                           has_future <- base::requireNamespace("future", 
[11:41:58.898]                             quietly = TRUE)
[11:41:58.898]                           if (has_future) {
[11:41:58.898]                             ns <- base::getNamespace("future")
[11:41:58.898]                             version <- ns[[".package"]][["version"]]
[11:41:58.898]                             if (is.null(version)) 
[11:41:58.898]                               version <- utils::packageVersion("future")
[11:41:58.898]                           }
[11:41:58.898]                           else {
[11:41:58.898]                             version <- NULL
[11:41:58.898]                           }
[11:41:58.898]                           if (!has_future || version < "1.8.0") {
[11:41:58.898]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:58.898]                               "", base::R.version$version.string), 
[11:41:58.898]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:58.898]                                 base::R.version$platform, 8 * 
[11:41:58.898]                                   base::.Machine$sizeof.pointer), 
[11:41:58.898]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:58.898]                                 "release", "version")], collapse = " "), 
[11:41:58.898]                               hostname = base::Sys.info()[["nodename"]])
[11:41:58.898]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:58.898]                               info)
[11:41:58.898]                             info <- base::paste(info, collapse = "; ")
[11:41:58.898]                             if (!has_future) {
[11:41:58.898]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:58.898]                                 info)
[11:41:58.898]                             }
[11:41:58.898]                             else {
[11:41:58.898]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:58.898]                                 info, version)
[11:41:58.898]                             }
[11:41:58.898]                             base::stop(msg)
[11:41:58.898]                           }
[11:41:58.898]                         })
[11:41:58.898]                       }
[11:41:58.898]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:58.898]                       base::options(mc.cores = 1L)
[11:41:58.898]                     }
[11:41:58.898]                     base::local({
[11:41:58.898]                       for (pkg in "mlr3") {
[11:41:58.898]                         base::loadNamespace(pkg)
[11:41:58.898]                         base::library(pkg, character.only = TRUE)
[11:41:58.898]                       }
[11:41:58.898]                     })
[11:41:58.898]                   }
[11:41:58.898]                   options(future.plan = NULL)
[11:41:58.898]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:58.898]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:58.898]                 }
[11:41:58.898]                 ...future.workdir <- getwd()
[11:41:58.898]             }
[11:41:58.898]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:58.898]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:58.898]         }
[11:41:58.898]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:58.898]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:58.898]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:58.898]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:58.898]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:58.898]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:58.898]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:58.898]             base::names(...future.oldOptions))
[11:41:58.898]     }
[11:41:58.898]     if (FALSE) {
[11:41:58.898]     }
[11:41:58.898]     else {
[11:41:58.898]         if (TRUE) {
[11:41:58.898]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:58.898]                 open = "w")
[11:41:58.898]         }
[11:41:58.898]         else {
[11:41:58.898]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:58.898]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:58.898]         }
[11:41:58.898]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:58.898]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:58.898]             base::sink(type = "output", split = FALSE)
[11:41:58.898]             base::close(...future.stdout)
[11:41:58.898]         }, add = TRUE)
[11:41:58.898]     }
[11:41:58.898]     ...future.frame <- base::sys.nframe()
[11:41:58.898]     ...future.conditions <- base::list()
[11:41:58.898]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:58.898]     if (FALSE) {
[11:41:58.898]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:58.898]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:58.898]     }
[11:41:58.898]     ...future.result <- base::tryCatch({
[11:41:58.898]         base::withCallingHandlers({
[11:41:58.898]             ...future.value <- base::withVisible(base::local({
[11:41:58.898]                 ...future.makeSendCondition <- local({
[11:41:58.898]                   sendCondition <- NULL
[11:41:58.898]                   function(frame = 1L) {
[11:41:58.898]                     if (is.function(sendCondition)) 
[11:41:58.898]                       return(sendCondition)
[11:41:58.898]                     ns <- getNamespace("parallel")
[11:41:58.898]                     if (exists("sendData", mode = "function", 
[11:41:58.898]                       envir = ns)) {
[11:41:58.898]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:58.898]                         envir = ns)
[11:41:58.898]                       envir <- sys.frame(frame)
[11:41:58.898]                       master <- NULL
[11:41:58.898]                       while (!identical(envir, .GlobalEnv) && 
[11:41:58.898]                         !identical(envir, emptyenv())) {
[11:41:58.898]                         if (exists("master", mode = "list", envir = envir, 
[11:41:58.898]                           inherits = FALSE)) {
[11:41:58.898]                           master <- get("master", mode = "list", 
[11:41:58.898]                             envir = envir, inherits = FALSE)
[11:41:58.898]                           if (inherits(master, c("SOCKnode", 
[11:41:58.898]                             "SOCK0node"))) {
[11:41:58.898]                             sendCondition <<- function(cond) {
[11:41:58.898]                               data <- list(type = "VALUE", value = cond, 
[11:41:58.898]                                 success = TRUE)
[11:41:58.898]                               parallel_sendData(master, data)
[11:41:58.898]                             }
[11:41:58.898]                             return(sendCondition)
[11:41:58.898]                           }
[11:41:58.898]                         }
[11:41:58.898]                         frame <- frame + 1L
[11:41:58.898]                         envir <- sys.frame(frame)
[11:41:58.898]                       }
[11:41:58.898]                     }
[11:41:58.898]                     sendCondition <<- function(cond) NULL
[11:41:58.898]                   }
[11:41:58.898]                 })
[11:41:58.898]                 withCallingHandlers({
[11:41:58.898]                   {
[11:41:58.898]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:58.898]                     if (!identical(...future.globals.maxSize.org, 
[11:41:58.898]                       ...future.globals.maxSize)) {
[11:41:58.898]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:58.898]                       on.exit(options(oopts), add = TRUE)
[11:41:58.898]                     }
[11:41:58.898]                     {
[11:41:58.898]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:58.898]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:58.898]                           envir = globalenv(), inherits = FALSE)
[11:41:58.898]                         ...future.FUN(...)
[11:41:58.898]                       }
[11:41:58.898]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:58.898]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:58.898]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:58.898]                         USE.NAMES = FALSE)
[11:41:58.898]                       do.call(mapply, args = args)
[11:41:58.898]                     }
[11:41:58.898]                   }
[11:41:58.898]                 }, immediateCondition = function(cond) {
[11:41:58.898]                   sendCondition <- ...future.makeSendCondition()
[11:41:58.898]                   sendCondition(cond)
[11:41:58.898]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:58.898]                   {
[11:41:58.898]                     inherits <- base::inherits
[11:41:58.898]                     invokeRestart <- base::invokeRestart
[11:41:58.898]                     is.null <- base::is.null
[11:41:58.898]                     muffled <- FALSE
[11:41:58.898]                     if (inherits(cond, "message")) {
[11:41:58.898]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:58.898]                       if (muffled) 
[11:41:58.898]                         invokeRestart("muffleMessage")
[11:41:58.898]                     }
[11:41:58.898]                     else if (inherits(cond, "warning")) {
[11:41:58.898]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:58.898]                       if (muffled) 
[11:41:58.898]                         invokeRestart("muffleWarning")
[11:41:58.898]                     }
[11:41:58.898]                     else if (inherits(cond, "condition")) {
[11:41:58.898]                       if (!is.null(pattern)) {
[11:41:58.898]                         computeRestarts <- base::computeRestarts
[11:41:58.898]                         grepl <- base::grepl
[11:41:58.898]                         restarts <- computeRestarts(cond)
[11:41:58.898]                         for (restart in restarts) {
[11:41:58.898]                           name <- restart$name
[11:41:58.898]                           if (is.null(name)) 
[11:41:58.898]                             next
[11:41:58.898]                           if (!grepl(pattern, name)) 
[11:41:58.898]                             next
[11:41:58.898]                           invokeRestart(restart)
[11:41:58.898]                           muffled <- TRUE
[11:41:58.898]                           break
[11:41:58.898]                         }
[11:41:58.898]                       }
[11:41:58.898]                     }
[11:41:58.898]                     invisible(muffled)
[11:41:58.898]                   }
[11:41:58.898]                   muffleCondition(cond)
[11:41:58.898]                 })
[11:41:58.898]             }))
[11:41:58.898]             future::FutureResult(value = ...future.value$value, 
[11:41:58.898]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:58.898]                   ...future.rng), globalenv = if (FALSE) 
[11:41:58.898]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:58.898]                     ...future.globalenv.names))
[11:41:58.898]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:58.898]         }, condition = base::local({
[11:41:58.898]             c <- base::c
[11:41:58.898]             inherits <- base::inherits
[11:41:58.898]             invokeRestart <- base::invokeRestart
[11:41:58.898]             length <- base::length
[11:41:58.898]             list <- base::list
[11:41:58.898]             seq.int <- base::seq.int
[11:41:58.898]             signalCondition <- base::signalCondition
[11:41:58.898]             sys.calls <- base::sys.calls
[11:41:58.898]             `[[` <- base::`[[`
[11:41:58.898]             `+` <- base::`+`
[11:41:58.898]             `<<-` <- base::`<<-`
[11:41:58.898]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:58.898]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:58.898]                   3L)]
[11:41:58.898]             }
[11:41:58.898]             function(cond) {
[11:41:58.898]                 is_error <- inherits(cond, "error")
[11:41:58.898]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:58.898]                   NULL)
[11:41:58.898]                 if (is_error) {
[11:41:58.898]                   sessionInformation <- function() {
[11:41:58.898]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:58.898]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:58.898]                       search = base::search(), system = base::Sys.info())
[11:41:58.898]                   }
[11:41:58.898]                   ...future.conditions[[length(...future.conditions) + 
[11:41:58.898]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:58.898]                     cond$call), session = sessionInformation(), 
[11:41:58.898]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:58.898]                   signalCondition(cond)
[11:41:58.898]                 }
[11:41:58.898]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:58.898]                 "immediateCondition"))) {
[11:41:58.898]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:58.898]                   ...future.conditions[[length(...future.conditions) + 
[11:41:58.898]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:58.898]                   if (TRUE && !signal) {
[11:41:58.898]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:58.898]                     {
[11:41:58.898]                       inherits <- base::inherits
[11:41:58.898]                       invokeRestart <- base::invokeRestart
[11:41:58.898]                       is.null <- base::is.null
[11:41:58.898]                       muffled <- FALSE
[11:41:58.898]                       if (inherits(cond, "message")) {
[11:41:58.898]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:58.898]                         if (muffled) 
[11:41:58.898]                           invokeRestart("muffleMessage")
[11:41:58.898]                       }
[11:41:58.898]                       else if (inherits(cond, "warning")) {
[11:41:58.898]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:58.898]                         if (muffled) 
[11:41:58.898]                           invokeRestart("muffleWarning")
[11:41:58.898]                       }
[11:41:58.898]                       else if (inherits(cond, "condition")) {
[11:41:58.898]                         if (!is.null(pattern)) {
[11:41:58.898]                           computeRestarts <- base::computeRestarts
[11:41:58.898]                           grepl <- base::grepl
[11:41:58.898]                           restarts <- computeRestarts(cond)
[11:41:58.898]                           for (restart in restarts) {
[11:41:58.898]                             name <- restart$name
[11:41:58.898]                             if (is.null(name)) 
[11:41:58.898]                               next
[11:41:58.898]                             if (!grepl(pattern, name)) 
[11:41:58.898]                               next
[11:41:58.898]                             invokeRestart(restart)
[11:41:58.898]                             muffled <- TRUE
[11:41:58.898]                             break
[11:41:58.898]                           }
[11:41:58.898]                         }
[11:41:58.898]                       }
[11:41:58.898]                       invisible(muffled)
[11:41:58.898]                     }
[11:41:58.898]                     muffleCondition(cond, pattern = "^muffle")
[11:41:58.898]                   }
[11:41:58.898]                 }
[11:41:58.898]                 else {
[11:41:58.898]                   if (TRUE) {
[11:41:58.898]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:58.898]                     {
[11:41:58.898]                       inherits <- base::inherits
[11:41:58.898]                       invokeRestart <- base::invokeRestart
[11:41:58.898]                       is.null <- base::is.null
[11:41:58.898]                       muffled <- FALSE
[11:41:58.898]                       if (inherits(cond, "message")) {
[11:41:58.898]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:58.898]                         if (muffled) 
[11:41:58.898]                           invokeRestart("muffleMessage")
[11:41:58.898]                       }
[11:41:58.898]                       else if (inherits(cond, "warning")) {
[11:41:58.898]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:58.898]                         if (muffled) 
[11:41:58.898]                           invokeRestart("muffleWarning")
[11:41:58.898]                       }
[11:41:58.898]                       else if (inherits(cond, "condition")) {
[11:41:58.898]                         if (!is.null(pattern)) {
[11:41:58.898]                           computeRestarts <- base::computeRestarts
[11:41:58.898]                           grepl <- base::grepl
[11:41:58.898]                           restarts <- computeRestarts(cond)
[11:41:58.898]                           for (restart in restarts) {
[11:41:58.898]                             name <- restart$name
[11:41:58.898]                             if (is.null(name)) 
[11:41:58.898]                               next
[11:41:58.898]                             if (!grepl(pattern, name)) 
[11:41:58.898]                               next
[11:41:58.898]                             invokeRestart(restart)
[11:41:58.898]                             muffled <- TRUE
[11:41:58.898]                             break
[11:41:58.898]                           }
[11:41:58.898]                         }
[11:41:58.898]                       }
[11:41:58.898]                       invisible(muffled)
[11:41:58.898]                     }
[11:41:58.898]                     muffleCondition(cond, pattern = "^muffle")
[11:41:58.898]                   }
[11:41:58.898]                 }
[11:41:58.898]             }
[11:41:58.898]         }))
[11:41:58.898]     }, error = function(ex) {
[11:41:58.898]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:58.898]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:58.898]                 ...future.rng), started = ...future.startTime, 
[11:41:58.898]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:58.898]             version = "1.8"), class = "FutureResult")
[11:41:58.898]     }, finally = {
[11:41:58.898]         if (!identical(...future.workdir, getwd())) 
[11:41:58.898]             setwd(...future.workdir)
[11:41:58.898]         {
[11:41:58.898]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:58.898]                 ...future.oldOptions$nwarnings <- NULL
[11:41:58.898]             }
[11:41:58.898]             base::options(...future.oldOptions)
[11:41:58.898]             if (.Platform$OS.type == "windows") {
[11:41:58.898]                 old_names <- names(...future.oldEnvVars)
[11:41:58.898]                 envs <- base::Sys.getenv()
[11:41:58.898]                 names <- names(envs)
[11:41:58.898]                 common <- intersect(names, old_names)
[11:41:58.898]                 added <- setdiff(names, old_names)
[11:41:58.898]                 removed <- setdiff(old_names, names)
[11:41:58.898]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:58.898]                   envs[common]]
[11:41:58.898]                 NAMES <- toupper(changed)
[11:41:58.898]                 args <- list()
[11:41:58.898]                 for (kk in seq_along(NAMES)) {
[11:41:58.898]                   name <- changed[[kk]]
[11:41:58.898]                   NAME <- NAMES[[kk]]
[11:41:58.898]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:58.898]                     next
[11:41:58.898]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:58.898]                 }
[11:41:58.898]                 NAMES <- toupper(added)
[11:41:58.898]                 for (kk in seq_along(NAMES)) {
[11:41:58.898]                   name <- added[[kk]]
[11:41:58.898]                   NAME <- NAMES[[kk]]
[11:41:58.898]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:58.898]                     next
[11:41:58.898]                   args[[name]] <- ""
[11:41:58.898]                 }
[11:41:58.898]                 NAMES <- toupper(removed)
[11:41:58.898]                 for (kk in seq_along(NAMES)) {
[11:41:58.898]                   name <- removed[[kk]]
[11:41:58.898]                   NAME <- NAMES[[kk]]
[11:41:58.898]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:58.898]                     next
[11:41:58.898]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:58.898]                 }
[11:41:58.898]                 if (length(args) > 0) 
[11:41:58.898]                   base::do.call(base::Sys.setenv, args = args)
[11:41:58.898]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:58.898]             }
[11:41:58.898]             else {
[11:41:58.898]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:58.898]             }
[11:41:58.898]             {
[11:41:58.898]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:58.898]                   0L) {
[11:41:58.898]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:58.898]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:58.898]                   base::options(opts)
[11:41:58.898]                 }
[11:41:58.898]                 {
[11:41:58.898]                   {
[11:41:58.898]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:58.898]                     NULL
[11:41:58.898]                   }
[11:41:58.898]                   options(future.plan = NULL)
[11:41:58.898]                   if (is.na(NA_character_)) 
[11:41:58.898]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:58.898]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:58.898]                   future::plan(list(function (..., workers = 2, 
[11:41:58.898]                     envir = parent.frame()) 
[11:41:58.898]                   strategy(..., workers = workers, envir = envir)), 
[11:41:58.898]                     .cleanup = FALSE, .init = FALSE)
[11:41:58.898]                 }
[11:41:58.898]             }
[11:41:58.898]         }
[11:41:58.898]     })
[11:41:58.898]     if (TRUE) {
[11:41:58.898]         base::sink(type = "output", split = FALSE)
[11:41:58.898]         if (TRUE) {
[11:41:58.898]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:58.898]         }
[11:41:58.898]         else {
[11:41:58.898]             ...future.result["stdout"] <- base::list(NULL)
[11:41:58.898]         }
[11:41:58.898]         base::close(...future.stdout)
[11:41:58.898]         ...future.stdout <- NULL
[11:41:58.898]     }
[11:41:58.898]     ...future.result$conditions <- ...future.conditions
[11:41:58.898]     ...future.result$finished <- base::Sys.time()
[11:41:58.898]     ...future.result
[11:41:58.898] }
[11:41:58.900] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:58.910] receiveMessageFromWorker() for ClusterFuture ...
[11:41:58.911] - Validating connection of MultisessionFuture
[11:41:58.911] - received message: FutureResult
[11:41:58.911] - Received FutureResult
[11:41:58.911] - Erased future from FutureRegistry
[11:41:58.911] result() for ClusterFuture ...
[11:41:58.911] - result already collected: FutureResult
[11:41:58.911] result() for ClusterFuture ... done
[11:41:58.911] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:58.911] result() for ClusterFuture ...
[11:41:58.911] - result already collected: FutureResult
[11:41:58.911] result() for ClusterFuture ... done
[11:41:58.912] result() for ClusterFuture ...
[11:41:58.912] - result already collected: FutureResult
[11:41:58.912] result() for ClusterFuture ... done
[11:41:58.912] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:58.913] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:58.957] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:58.961] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:59.005] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:59.006] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:59.049] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:59.050] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:59.050] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:59.050] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:59.051] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:59.051] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:59.051] MultisessionFuture started
[11:41:59.051] - Launch lazy future ... done
[11:41:59.052] run() for ‘MultisessionFuture’ ... done
[11:41:59.052] Created future:
[11:41:59.052] MultisessionFuture:
[11:41:59.052] Label: ‘future_mapply-74’
[11:41:59.052] Expression:
[11:41:59.052] {
[11:41:59.052]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:59.052]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:59.052]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:59.052]         on.exit(options(oopts), add = TRUE)
[11:41:59.052]     }
[11:41:59.052]     {
[11:41:59.052]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:59.052]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:59.052]                 inherits = FALSE)
[11:41:59.052]             ...future.FUN(...)
[11:41:59.052]         }
[11:41:59.052]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:59.052]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:59.052]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:59.052]         do.call(mapply, args = args)
[11:41:59.052]     }
[11:41:59.052] }
[11:41:59.052] Lazy evaluation: FALSE
[11:41:59.052] Asynchronous evaluation: TRUE
[11:41:59.052] Local evaluation: TRUE
[11:41:59.052] Environment: 0x560ef58e1768
[11:41:59.052] Capture standard output: TRUE
[11:41:59.052] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:59.052] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:59.052] Packages: 1 packages (‘mlr3’)
[11:41:59.052] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:59.052] Resolved: FALSE
[11:41:59.052] Value: <not collected>
[11:41:59.052] Conditions captured: <none>
[11:41:59.052] Early signaling: FALSE
[11:41:59.052] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:59.052] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:59.069] Chunk #74 of 90 ... DONE
[11:41:59.070] Chunk #75 of 90 ...
[11:41:59.070]  - seeds: [1] <seeds>
[11:41:59.070] getGlobalsAndPackages() ...
[11:41:59.070] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:59.070] Resolving globals: FALSE
[11:41:59.071] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:59.071] - packages: [1] ‘mlr3’
[11:41:59.071] getGlobalsAndPackages() ... DONE
[11:41:59.071] run() for ‘Future’ ...
[11:41:59.072] - state: ‘created’
[11:41:59.072] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:59.083] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:59.083] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:59.083]   - Field: ‘node’
[11:41:59.083]   - Field: ‘label’
[11:41:59.083]   - Field: ‘local’
[11:41:59.083]   - Field: ‘owner’
[11:41:59.083]   - Field: ‘envir’
[11:41:59.083]   - Field: ‘workers’
[11:41:59.083]   - Field: ‘packages’
[11:41:59.083]   - Field: ‘gc’
[11:41:59.083]   - Field: ‘conditions’
[11:41:59.083]   - Field: ‘persistent’
[11:41:59.083]   - Field: ‘expr’
[11:41:59.084]   - Field: ‘uuid’
[11:41:59.084]   - Field: ‘seed’
[11:41:59.084]   - Field: ‘version’
[11:41:59.084]   - Field: ‘result’
[11:41:59.084]   - Field: ‘asynchronous’
[11:41:59.084]   - Field: ‘calls’
[11:41:59.084]   - Field: ‘globals’
[11:41:59.084]   - Field: ‘stdout’
[11:41:59.084]   - Field: ‘earlySignal’
[11:41:59.084]   - Field: ‘lazy’
[11:41:59.084]   - Field: ‘state’
[11:41:59.085] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:59.085] - Launch lazy future ...
[11:41:59.085] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:59.085] Packages needed by future strategies (n = 0): <none>
[11:41:59.085] {
[11:41:59.085]     {
[11:41:59.085]         {
[11:41:59.085]             ...future.startTime <- base::Sys.time()
[11:41:59.085]             {
[11:41:59.085]                 {
[11:41:59.085]                   {
[11:41:59.085]                     {
[11:41:59.085]                       {
[11:41:59.085]                         base::local({
[11:41:59.085]                           has_future <- base::requireNamespace("future", 
[11:41:59.085]                             quietly = TRUE)
[11:41:59.085]                           if (has_future) {
[11:41:59.085]                             ns <- base::getNamespace("future")
[11:41:59.085]                             version <- ns[[".package"]][["version"]]
[11:41:59.085]                             if (is.null(version)) 
[11:41:59.085]                               version <- utils::packageVersion("future")
[11:41:59.085]                           }
[11:41:59.085]                           else {
[11:41:59.085]                             version <- NULL
[11:41:59.085]                           }
[11:41:59.085]                           if (!has_future || version < "1.8.0") {
[11:41:59.085]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:59.085]                               "", base::R.version$version.string), 
[11:41:59.085]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:59.085]                                 base::R.version$platform, 8 * 
[11:41:59.085]                                   base::.Machine$sizeof.pointer), 
[11:41:59.085]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:59.085]                                 "release", "version")], collapse = " "), 
[11:41:59.085]                               hostname = base::Sys.info()[["nodename"]])
[11:41:59.085]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:59.085]                               info)
[11:41:59.085]                             info <- base::paste(info, collapse = "; ")
[11:41:59.085]                             if (!has_future) {
[11:41:59.085]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:59.085]                                 info)
[11:41:59.085]                             }
[11:41:59.085]                             else {
[11:41:59.085]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:59.085]                                 info, version)
[11:41:59.085]                             }
[11:41:59.085]                             base::stop(msg)
[11:41:59.085]                           }
[11:41:59.085]                         })
[11:41:59.085]                       }
[11:41:59.085]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:59.085]                       base::options(mc.cores = 1L)
[11:41:59.085]                     }
[11:41:59.085]                     base::local({
[11:41:59.085]                       for (pkg in "mlr3") {
[11:41:59.085]                         base::loadNamespace(pkg)
[11:41:59.085]                         base::library(pkg, character.only = TRUE)
[11:41:59.085]                       }
[11:41:59.085]                     })
[11:41:59.085]                   }
[11:41:59.085]                   options(future.plan = NULL)
[11:41:59.085]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:59.085]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:59.085]                 }
[11:41:59.085]                 ...future.workdir <- getwd()
[11:41:59.085]             }
[11:41:59.085]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:59.085]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:59.085]         }
[11:41:59.085]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:59.085]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:59.085]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:59.085]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:59.085]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:59.085]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:59.085]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:59.085]             base::names(...future.oldOptions))
[11:41:59.085]     }
[11:41:59.085]     if (FALSE) {
[11:41:59.085]     }
[11:41:59.085]     else {
[11:41:59.085]         if (TRUE) {
[11:41:59.085]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:59.085]                 open = "w")
[11:41:59.085]         }
[11:41:59.085]         else {
[11:41:59.085]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:59.085]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:59.085]         }
[11:41:59.085]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:59.085]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:59.085]             base::sink(type = "output", split = FALSE)
[11:41:59.085]             base::close(...future.stdout)
[11:41:59.085]         }, add = TRUE)
[11:41:59.085]     }
[11:41:59.085]     ...future.frame <- base::sys.nframe()
[11:41:59.085]     ...future.conditions <- base::list()
[11:41:59.085]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:59.085]     if (FALSE) {
[11:41:59.085]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:59.085]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:59.085]     }
[11:41:59.085]     ...future.result <- base::tryCatch({
[11:41:59.085]         base::withCallingHandlers({
[11:41:59.085]             ...future.value <- base::withVisible(base::local({
[11:41:59.085]                 ...future.makeSendCondition <- local({
[11:41:59.085]                   sendCondition <- NULL
[11:41:59.085]                   function(frame = 1L) {
[11:41:59.085]                     if (is.function(sendCondition)) 
[11:41:59.085]                       return(sendCondition)
[11:41:59.085]                     ns <- getNamespace("parallel")
[11:41:59.085]                     if (exists("sendData", mode = "function", 
[11:41:59.085]                       envir = ns)) {
[11:41:59.085]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:59.085]                         envir = ns)
[11:41:59.085]                       envir <- sys.frame(frame)
[11:41:59.085]                       master <- NULL
[11:41:59.085]                       while (!identical(envir, .GlobalEnv) && 
[11:41:59.085]                         !identical(envir, emptyenv())) {
[11:41:59.085]                         if (exists("master", mode = "list", envir = envir, 
[11:41:59.085]                           inherits = FALSE)) {
[11:41:59.085]                           master <- get("master", mode = "list", 
[11:41:59.085]                             envir = envir, inherits = FALSE)
[11:41:59.085]                           if (inherits(master, c("SOCKnode", 
[11:41:59.085]                             "SOCK0node"))) {
[11:41:59.085]                             sendCondition <<- function(cond) {
[11:41:59.085]                               data <- list(type = "VALUE", value = cond, 
[11:41:59.085]                                 success = TRUE)
[11:41:59.085]                               parallel_sendData(master, data)
[11:41:59.085]                             }
[11:41:59.085]                             return(sendCondition)
[11:41:59.085]                           }
[11:41:59.085]                         }
[11:41:59.085]                         frame <- frame + 1L
[11:41:59.085]                         envir <- sys.frame(frame)
[11:41:59.085]                       }
[11:41:59.085]                     }
[11:41:59.085]                     sendCondition <<- function(cond) NULL
[11:41:59.085]                   }
[11:41:59.085]                 })
[11:41:59.085]                 withCallingHandlers({
[11:41:59.085]                   {
[11:41:59.085]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:59.085]                     if (!identical(...future.globals.maxSize.org, 
[11:41:59.085]                       ...future.globals.maxSize)) {
[11:41:59.085]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:59.085]                       on.exit(options(oopts), add = TRUE)
[11:41:59.085]                     }
[11:41:59.085]                     {
[11:41:59.085]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:59.085]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:59.085]                           envir = globalenv(), inherits = FALSE)
[11:41:59.085]                         ...future.FUN(...)
[11:41:59.085]                       }
[11:41:59.085]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:59.085]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:59.085]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:59.085]                         USE.NAMES = FALSE)
[11:41:59.085]                       do.call(mapply, args = args)
[11:41:59.085]                     }
[11:41:59.085]                   }
[11:41:59.085]                 }, immediateCondition = function(cond) {
[11:41:59.085]                   sendCondition <- ...future.makeSendCondition()
[11:41:59.085]                   sendCondition(cond)
[11:41:59.085]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:59.085]                   {
[11:41:59.085]                     inherits <- base::inherits
[11:41:59.085]                     invokeRestart <- base::invokeRestart
[11:41:59.085]                     is.null <- base::is.null
[11:41:59.085]                     muffled <- FALSE
[11:41:59.085]                     if (inherits(cond, "message")) {
[11:41:59.085]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:59.085]                       if (muffled) 
[11:41:59.085]                         invokeRestart("muffleMessage")
[11:41:59.085]                     }
[11:41:59.085]                     else if (inherits(cond, "warning")) {
[11:41:59.085]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:59.085]                       if (muffled) 
[11:41:59.085]                         invokeRestart("muffleWarning")
[11:41:59.085]                     }
[11:41:59.085]                     else if (inherits(cond, "condition")) {
[11:41:59.085]                       if (!is.null(pattern)) {
[11:41:59.085]                         computeRestarts <- base::computeRestarts
[11:41:59.085]                         grepl <- base::grepl
[11:41:59.085]                         restarts <- computeRestarts(cond)
[11:41:59.085]                         for (restart in restarts) {
[11:41:59.085]                           name <- restart$name
[11:41:59.085]                           if (is.null(name)) 
[11:41:59.085]                             next
[11:41:59.085]                           if (!grepl(pattern, name)) 
[11:41:59.085]                             next
[11:41:59.085]                           invokeRestart(restart)
[11:41:59.085]                           muffled <- TRUE
[11:41:59.085]                           break
[11:41:59.085]                         }
[11:41:59.085]                       }
[11:41:59.085]                     }
[11:41:59.085]                     invisible(muffled)
[11:41:59.085]                   }
[11:41:59.085]                   muffleCondition(cond)
[11:41:59.085]                 })
[11:41:59.085]             }))
[11:41:59.085]             future::FutureResult(value = ...future.value$value, 
[11:41:59.085]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:59.085]                   ...future.rng), globalenv = if (FALSE) 
[11:41:59.085]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:59.085]                     ...future.globalenv.names))
[11:41:59.085]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:59.085]         }, condition = base::local({
[11:41:59.085]             c <- base::c
[11:41:59.085]             inherits <- base::inherits
[11:41:59.085]             invokeRestart <- base::invokeRestart
[11:41:59.085]             length <- base::length
[11:41:59.085]             list <- base::list
[11:41:59.085]             seq.int <- base::seq.int
[11:41:59.085]             signalCondition <- base::signalCondition
[11:41:59.085]             sys.calls <- base::sys.calls
[11:41:59.085]             `[[` <- base::`[[`
[11:41:59.085]             `+` <- base::`+`
[11:41:59.085]             `<<-` <- base::`<<-`
[11:41:59.085]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:59.085]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:59.085]                   3L)]
[11:41:59.085]             }
[11:41:59.085]             function(cond) {
[11:41:59.085]                 is_error <- inherits(cond, "error")
[11:41:59.085]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:59.085]                   NULL)
[11:41:59.085]                 if (is_error) {
[11:41:59.085]                   sessionInformation <- function() {
[11:41:59.085]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:59.085]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:59.085]                       search = base::search(), system = base::Sys.info())
[11:41:59.085]                   }
[11:41:59.085]                   ...future.conditions[[length(...future.conditions) + 
[11:41:59.085]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:59.085]                     cond$call), session = sessionInformation(), 
[11:41:59.085]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:59.085]                   signalCondition(cond)
[11:41:59.085]                 }
[11:41:59.085]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:59.085]                 "immediateCondition"))) {
[11:41:59.085]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:59.085]                   ...future.conditions[[length(...future.conditions) + 
[11:41:59.085]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:59.085]                   if (TRUE && !signal) {
[11:41:59.085]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:59.085]                     {
[11:41:59.085]                       inherits <- base::inherits
[11:41:59.085]                       invokeRestart <- base::invokeRestart
[11:41:59.085]                       is.null <- base::is.null
[11:41:59.085]                       muffled <- FALSE
[11:41:59.085]                       if (inherits(cond, "message")) {
[11:41:59.085]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:59.085]                         if (muffled) 
[11:41:59.085]                           invokeRestart("muffleMessage")
[11:41:59.085]                       }
[11:41:59.085]                       else if (inherits(cond, "warning")) {
[11:41:59.085]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:59.085]                         if (muffled) 
[11:41:59.085]                           invokeRestart("muffleWarning")
[11:41:59.085]                       }
[11:41:59.085]                       else if (inherits(cond, "condition")) {
[11:41:59.085]                         if (!is.null(pattern)) {
[11:41:59.085]                           computeRestarts <- base::computeRestarts
[11:41:59.085]                           grepl <- base::grepl
[11:41:59.085]                           restarts <- computeRestarts(cond)
[11:41:59.085]                           for (restart in restarts) {
[11:41:59.085]                             name <- restart$name
[11:41:59.085]                             if (is.null(name)) 
[11:41:59.085]                               next
[11:41:59.085]                             if (!grepl(pattern, name)) 
[11:41:59.085]                               next
[11:41:59.085]                             invokeRestart(restart)
[11:41:59.085]                             muffled <- TRUE
[11:41:59.085]                             break
[11:41:59.085]                           }
[11:41:59.085]                         }
[11:41:59.085]                       }
[11:41:59.085]                       invisible(muffled)
[11:41:59.085]                     }
[11:41:59.085]                     muffleCondition(cond, pattern = "^muffle")
[11:41:59.085]                   }
[11:41:59.085]                 }
[11:41:59.085]                 else {
[11:41:59.085]                   if (TRUE) {
[11:41:59.085]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:59.085]                     {
[11:41:59.085]                       inherits <- base::inherits
[11:41:59.085]                       invokeRestart <- base::invokeRestart
[11:41:59.085]                       is.null <- base::is.null
[11:41:59.085]                       muffled <- FALSE
[11:41:59.085]                       if (inherits(cond, "message")) {
[11:41:59.085]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:59.085]                         if (muffled) 
[11:41:59.085]                           invokeRestart("muffleMessage")
[11:41:59.085]                       }
[11:41:59.085]                       else if (inherits(cond, "warning")) {
[11:41:59.085]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:59.085]                         if (muffled) 
[11:41:59.085]                           invokeRestart("muffleWarning")
[11:41:59.085]                       }
[11:41:59.085]                       else if (inherits(cond, "condition")) {
[11:41:59.085]                         if (!is.null(pattern)) {
[11:41:59.085]                           computeRestarts <- base::computeRestarts
[11:41:59.085]                           grepl <- base::grepl
[11:41:59.085]                           restarts <- computeRestarts(cond)
[11:41:59.085]                           for (restart in restarts) {
[11:41:59.085]                             name <- restart$name
[11:41:59.085]                             if (is.null(name)) 
[11:41:59.085]                               next
[11:41:59.085]                             if (!grepl(pattern, name)) 
[11:41:59.085]                               next
[11:41:59.085]                             invokeRestart(restart)
[11:41:59.085]                             muffled <- TRUE
[11:41:59.085]                             break
[11:41:59.085]                           }
[11:41:59.085]                         }
[11:41:59.085]                       }
[11:41:59.085]                       invisible(muffled)
[11:41:59.085]                     }
[11:41:59.085]                     muffleCondition(cond, pattern = "^muffle")
[11:41:59.085]                   }
[11:41:59.085]                 }
[11:41:59.085]             }
[11:41:59.085]         }))
[11:41:59.085]     }, error = function(ex) {
[11:41:59.085]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:59.085]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:59.085]                 ...future.rng), started = ...future.startTime, 
[11:41:59.085]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:59.085]             version = "1.8"), class = "FutureResult")
[11:41:59.085]     }, finally = {
[11:41:59.085]         if (!identical(...future.workdir, getwd())) 
[11:41:59.085]             setwd(...future.workdir)
[11:41:59.085]         {
[11:41:59.085]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:59.085]                 ...future.oldOptions$nwarnings <- NULL
[11:41:59.085]             }
[11:41:59.085]             base::options(...future.oldOptions)
[11:41:59.085]             if (.Platform$OS.type == "windows") {
[11:41:59.085]                 old_names <- names(...future.oldEnvVars)
[11:41:59.085]                 envs <- base::Sys.getenv()
[11:41:59.085]                 names <- names(envs)
[11:41:59.085]                 common <- intersect(names, old_names)
[11:41:59.085]                 added <- setdiff(names, old_names)
[11:41:59.085]                 removed <- setdiff(old_names, names)
[11:41:59.085]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:59.085]                   envs[common]]
[11:41:59.085]                 NAMES <- toupper(changed)
[11:41:59.085]                 args <- list()
[11:41:59.085]                 for (kk in seq_along(NAMES)) {
[11:41:59.085]                   name <- changed[[kk]]
[11:41:59.085]                   NAME <- NAMES[[kk]]
[11:41:59.085]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:59.085]                     next
[11:41:59.085]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:59.085]                 }
[11:41:59.085]                 NAMES <- toupper(added)
[11:41:59.085]                 for (kk in seq_along(NAMES)) {
[11:41:59.085]                   name <- added[[kk]]
[11:41:59.085]                   NAME <- NAMES[[kk]]
[11:41:59.085]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:59.085]                     next
[11:41:59.085]                   args[[name]] <- ""
[11:41:59.085]                 }
[11:41:59.085]                 NAMES <- toupper(removed)
[11:41:59.085]                 for (kk in seq_along(NAMES)) {
[11:41:59.085]                   name <- removed[[kk]]
[11:41:59.085]                   NAME <- NAMES[[kk]]
[11:41:59.085]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:59.085]                     next
[11:41:59.085]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:59.085]                 }
[11:41:59.085]                 if (length(args) > 0) 
[11:41:59.085]                   base::do.call(base::Sys.setenv, args = args)
[11:41:59.085]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:59.085]             }
[11:41:59.085]             else {
[11:41:59.085]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:59.085]             }
[11:41:59.085]             {
[11:41:59.085]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:59.085]                   0L) {
[11:41:59.085]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:59.085]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:59.085]                   base::options(opts)
[11:41:59.085]                 }
[11:41:59.085]                 {
[11:41:59.085]                   {
[11:41:59.085]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:59.085]                     NULL
[11:41:59.085]                   }
[11:41:59.085]                   options(future.plan = NULL)
[11:41:59.085]                   if (is.na(NA_character_)) 
[11:41:59.085]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:59.085]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:59.085]                   future::plan(list(function (..., workers = 2, 
[11:41:59.085]                     envir = parent.frame()) 
[11:41:59.085]                   strategy(..., workers = workers, envir = envir)), 
[11:41:59.085]                     .cleanup = FALSE, .init = FALSE)
[11:41:59.085]                 }
[11:41:59.085]             }
[11:41:59.085]         }
[11:41:59.085]     })
[11:41:59.085]     if (TRUE) {
[11:41:59.085]         base::sink(type = "output", split = FALSE)
[11:41:59.085]         if (TRUE) {
[11:41:59.085]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:59.085]         }
[11:41:59.085]         else {
[11:41:59.085]             ...future.result["stdout"] <- base::list(NULL)
[11:41:59.085]         }
[11:41:59.085]         base::close(...future.stdout)
[11:41:59.085]         ...future.stdout <- NULL
[11:41:59.085]     }
[11:41:59.085]     ...future.result$conditions <- ...future.conditions
[11:41:59.085]     ...future.result$finished <- base::Sys.time()
[11:41:59.085]     ...future.result
[11:41:59.085] }
[11:41:59.087] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:59.098] receiveMessageFromWorker() for ClusterFuture ...
[11:41:59.098] - Validating connection of MultisessionFuture
[11:41:59.099] - received message: FutureResult
[11:41:59.099] - Received FutureResult
[11:41:59.099] - Erased future from FutureRegistry
[11:41:59.099] result() for ClusterFuture ...
[11:41:59.099] - result already collected: FutureResult
[11:41:59.099] result() for ClusterFuture ... done
[11:41:59.099] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:59.099] result() for ClusterFuture ...
[11:41:59.099] - result already collected: FutureResult
[11:41:59.100] result() for ClusterFuture ... done
[11:41:59.100] result() for ClusterFuture ...
[11:41:59.100] - result already collected: FutureResult
[11:41:59.100] result() for ClusterFuture ... done
[11:41:59.100] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:59.101] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:59.145] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:59.149] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:59.152] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:59.152] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:59.197] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:59.197] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:59.198] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:59.198] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:59.198] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:59.198] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:59.199] MultisessionFuture started
[11:41:59.199] - Launch lazy future ... done
[11:41:59.199] run() for ‘MultisessionFuture’ ... done
[11:41:59.199] Created future:
[11:41:59.199] MultisessionFuture:
[11:41:59.199] Label: ‘future_mapply-75’
[11:41:59.199] Expression:
[11:41:59.199] {
[11:41:59.199]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:59.199]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:59.199]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:59.199]         on.exit(options(oopts), add = TRUE)
[11:41:59.199]     }
[11:41:59.199]     {
[11:41:59.199]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:59.199]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:59.199]                 inherits = FALSE)
[11:41:59.199]             ...future.FUN(...)
[11:41:59.199]         }
[11:41:59.199]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:59.199]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:59.199]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:59.199]         do.call(mapply, args = args)
[11:41:59.199]     }
[11:41:59.199] }
[11:41:59.199] Lazy evaluation: FALSE
[11:41:59.199] Asynchronous evaluation: TRUE
[11:41:59.199] Local evaluation: TRUE
[11:41:59.199] Environment: 0x560ef58e1768
[11:41:59.199] Capture standard output: TRUE
[11:41:59.199] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:59.199] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:59.199] Packages: 1 packages (‘mlr3’)
[11:41:59.199] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:59.199] Resolved: FALSE
[11:41:59.199] Value: <not collected>
[11:41:59.199] Conditions captured: <none>
[11:41:59.199] Early signaling: FALSE
[11:41:59.199] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:59.199] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:59.214] Chunk #75 of 90 ... DONE
[11:41:59.214] Chunk #76 of 90 ...
[11:41:59.214]  - seeds: [1] <seeds>
[11:41:59.214] getGlobalsAndPackages() ...
[11:41:59.214] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:59.214] Resolving globals: FALSE
[11:41:59.215] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:59.215] - packages: [1] ‘mlr3’
[11:41:59.215] getGlobalsAndPackages() ... DONE
[11:41:59.215] run() for ‘Future’ ...
[11:41:59.215] - state: ‘created’
[11:41:59.215] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:59.226] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:59.226] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:59.227]   - Field: ‘node’
[11:41:59.227]   - Field: ‘label’
[11:41:59.227]   - Field: ‘local’
[11:41:59.227]   - Field: ‘owner’
[11:41:59.227]   - Field: ‘envir’
[11:41:59.227]   - Field: ‘workers’
[11:41:59.227]   - Field: ‘packages’
[11:41:59.227]   - Field: ‘gc’
[11:41:59.227]   - Field: ‘conditions’
[11:41:59.227]   - Field: ‘persistent’
[11:41:59.227]   - Field: ‘expr’
[11:41:59.227]   - Field: ‘uuid’
[11:41:59.227]   - Field: ‘seed’
[11:41:59.227]   - Field: ‘version’
[11:41:59.227]   - Field: ‘result’
[11:41:59.227]   - Field: ‘asynchronous’
[11:41:59.227]   - Field: ‘calls’
[11:41:59.227]   - Field: ‘globals’
[11:41:59.227]   - Field: ‘stdout’
[11:41:59.228]   - Field: ‘earlySignal’
[11:41:59.228]   - Field: ‘lazy’
[11:41:59.228]   - Field: ‘state’
[11:41:59.228] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:59.228] - Launch lazy future ...
[11:41:59.228] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:59.228] Packages needed by future strategies (n = 0): <none>
[11:41:59.228] {
[11:41:59.228]     {
[11:41:59.228]         {
[11:41:59.228]             ...future.startTime <- base::Sys.time()
[11:41:59.228]             {
[11:41:59.228]                 {
[11:41:59.228]                   {
[11:41:59.228]                     {
[11:41:59.228]                       {
[11:41:59.228]                         base::local({
[11:41:59.228]                           has_future <- base::requireNamespace("future", 
[11:41:59.228]                             quietly = TRUE)
[11:41:59.228]                           if (has_future) {
[11:41:59.228]                             ns <- base::getNamespace("future")
[11:41:59.228]                             version <- ns[[".package"]][["version"]]
[11:41:59.228]                             if (is.null(version)) 
[11:41:59.228]                               version <- utils::packageVersion("future")
[11:41:59.228]                           }
[11:41:59.228]                           else {
[11:41:59.228]                             version <- NULL
[11:41:59.228]                           }
[11:41:59.228]                           if (!has_future || version < "1.8.0") {
[11:41:59.228]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:59.228]                               "", base::R.version$version.string), 
[11:41:59.228]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:59.228]                                 base::R.version$platform, 8 * 
[11:41:59.228]                                   base::.Machine$sizeof.pointer), 
[11:41:59.228]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:59.228]                                 "release", "version")], collapse = " "), 
[11:41:59.228]                               hostname = base::Sys.info()[["nodename"]])
[11:41:59.228]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:59.228]                               info)
[11:41:59.228]                             info <- base::paste(info, collapse = "; ")
[11:41:59.228]                             if (!has_future) {
[11:41:59.228]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:59.228]                                 info)
[11:41:59.228]                             }
[11:41:59.228]                             else {
[11:41:59.228]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:59.228]                                 info, version)
[11:41:59.228]                             }
[11:41:59.228]                             base::stop(msg)
[11:41:59.228]                           }
[11:41:59.228]                         })
[11:41:59.228]                       }
[11:41:59.228]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:59.228]                       base::options(mc.cores = 1L)
[11:41:59.228]                     }
[11:41:59.228]                     base::local({
[11:41:59.228]                       for (pkg in "mlr3") {
[11:41:59.228]                         base::loadNamespace(pkg)
[11:41:59.228]                         base::library(pkg, character.only = TRUE)
[11:41:59.228]                       }
[11:41:59.228]                     })
[11:41:59.228]                   }
[11:41:59.228]                   options(future.plan = NULL)
[11:41:59.228]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:59.228]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:59.228]                 }
[11:41:59.228]                 ...future.workdir <- getwd()
[11:41:59.228]             }
[11:41:59.228]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:59.228]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:59.228]         }
[11:41:59.228]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:59.228]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:59.228]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:59.228]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:59.228]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:59.228]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:59.228]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:59.228]             base::names(...future.oldOptions))
[11:41:59.228]     }
[11:41:59.228]     if (FALSE) {
[11:41:59.228]     }
[11:41:59.228]     else {
[11:41:59.228]         if (TRUE) {
[11:41:59.228]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:59.228]                 open = "w")
[11:41:59.228]         }
[11:41:59.228]         else {
[11:41:59.228]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:59.228]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:59.228]         }
[11:41:59.228]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:59.228]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:59.228]             base::sink(type = "output", split = FALSE)
[11:41:59.228]             base::close(...future.stdout)
[11:41:59.228]         }, add = TRUE)
[11:41:59.228]     }
[11:41:59.228]     ...future.frame <- base::sys.nframe()
[11:41:59.228]     ...future.conditions <- base::list()
[11:41:59.228]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:59.228]     if (FALSE) {
[11:41:59.228]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:59.228]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:59.228]     }
[11:41:59.228]     ...future.result <- base::tryCatch({
[11:41:59.228]         base::withCallingHandlers({
[11:41:59.228]             ...future.value <- base::withVisible(base::local({
[11:41:59.228]                 ...future.makeSendCondition <- local({
[11:41:59.228]                   sendCondition <- NULL
[11:41:59.228]                   function(frame = 1L) {
[11:41:59.228]                     if (is.function(sendCondition)) 
[11:41:59.228]                       return(sendCondition)
[11:41:59.228]                     ns <- getNamespace("parallel")
[11:41:59.228]                     if (exists("sendData", mode = "function", 
[11:41:59.228]                       envir = ns)) {
[11:41:59.228]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:59.228]                         envir = ns)
[11:41:59.228]                       envir <- sys.frame(frame)
[11:41:59.228]                       master <- NULL
[11:41:59.228]                       while (!identical(envir, .GlobalEnv) && 
[11:41:59.228]                         !identical(envir, emptyenv())) {
[11:41:59.228]                         if (exists("master", mode = "list", envir = envir, 
[11:41:59.228]                           inherits = FALSE)) {
[11:41:59.228]                           master <- get("master", mode = "list", 
[11:41:59.228]                             envir = envir, inherits = FALSE)
[11:41:59.228]                           if (inherits(master, c("SOCKnode", 
[11:41:59.228]                             "SOCK0node"))) {
[11:41:59.228]                             sendCondition <<- function(cond) {
[11:41:59.228]                               data <- list(type = "VALUE", value = cond, 
[11:41:59.228]                                 success = TRUE)
[11:41:59.228]                               parallel_sendData(master, data)
[11:41:59.228]                             }
[11:41:59.228]                             return(sendCondition)
[11:41:59.228]                           }
[11:41:59.228]                         }
[11:41:59.228]                         frame <- frame + 1L
[11:41:59.228]                         envir <- sys.frame(frame)
[11:41:59.228]                       }
[11:41:59.228]                     }
[11:41:59.228]                     sendCondition <<- function(cond) NULL
[11:41:59.228]                   }
[11:41:59.228]                 })
[11:41:59.228]                 withCallingHandlers({
[11:41:59.228]                   {
[11:41:59.228]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:59.228]                     if (!identical(...future.globals.maxSize.org, 
[11:41:59.228]                       ...future.globals.maxSize)) {
[11:41:59.228]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:59.228]                       on.exit(options(oopts), add = TRUE)
[11:41:59.228]                     }
[11:41:59.228]                     {
[11:41:59.228]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:59.228]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:59.228]                           envir = globalenv(), inherits = FALSE)
[11:41:59.228]                         ...future.FUN(...)
[11:41:59.228]                       }
[11:41:59.228]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:59.228]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:59.228]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:59.228]                         USE.NAMES = FALSE)
[11:41:59.228]                       do.call(mapply, args = args)
[11:41:59.228]                     }
[11:41:59.228]                   }
[11:41:59.228]                 }, immediateCondition = function(cond) {
[11:41:59.228]                   sendCondition <- ...future.makeSendCondition()
[11:41:59.228]                   sendCondition(cond)
[11:41:59.228]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:59.228]                   {
[11:41:59.228]                     inherits <- base::inherits
[11:41:59.228]                     invokeRestart <- base::invokeRestart
[11:41:59.228]                     is.null <- base::is.null
[11:41:59.228]                     muffled <- FALSE
[11:41:59.228]                     if (inherits(cond, "message")) {
[11:41:59.228]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:59.228]                       if (muffled) 
[11:41:59.228]                         invokeRestart("muffleMessage")
[11:41:59.228]                     }
[11:41:59.228]                     else if (inherits(cond, "warning")) {
[11:41:59.228]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:59.228]                       if (muffled) 
[11:41:59.228]                         invokeRestart("muffleWarning")
[11:41:59.228]                     }
[11:41:59.228]                     else if (inherits(cond, "condition")) {
[11:41:59.228]                       if (!is.null(pattern)) {
[11:41:59.228]                         computeRestarts <- base::computeRestarts
[11:41:59.228]                         grepl <- base::grepl
[11:41:59.228]                         restarts <- computeRestarts(cond)
[11:41:59.228]                         for (restart in restarts) {
[11:41:59.228]                           name <- restart$name
[11:41:59.228]                           if (is.null(name)) 
[11:41:59.228]                             next
[11:41:59.228]                           if (!grepl(pattern, name)) 
[11:41:59.228]                             next
[11:41:59.228]                           invokeRestart(restart)
[11:41:59.228]                           muffled <- TRUE
[11:41:59.228]                           break
[11:41:59.228]                         }
[11:41:59.228]                       }
[11:41:59.228]                     }
[11:41:59.228]                     invisible(muffled)
[11:41:59.228]                   }
[11:41:59.228]                   muffleCondition(cond)
[11:41:59.228]                 })
[11:41:59.228]             }))
[11:41:59.228]             future::FutureResult(value = ...future.value$value, 
[11:41:59.228]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:59.228]                   ...future.rng), globalenv = if (FALSE) 
[11:41:59.228]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:59.228]                     ...future.globalenv.names))
[11:41:59.228]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:59.228]         }, condition = base::local({
[11:41:59.228]             c <- base::c
[11:41:59.228]             inherits <- base::inherits
[11:41:59.228]             invokeRestart <- base::invokeRestart
[11:41:59.228]             length <- base::length
[11:41:59.228]             list <- base::list
[11:41:59.228]             seq.int <- base::seq.int
[11:41:59.228]             signalCondition <- base::signalCondition
[11:41:59.228]             sys.calls <- base::sys.calls
[11:41:59.228]             `[[` <- base::`[[`
[11:41:59.228]             `+` <- base::`+`
[11:41:59.228]             `<<-` <- base::`<<-`
[11:41:59.228]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:59.228]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:59.228]                   3L)]
[11:41:59.228]             }
[11:41:59.228]             function(cond) {
[11:41:59.228]                 is_error <- inherits(cond, "error")
[11:41:59.228]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:59.228]                   NULL)
[11:41:59.228]                 if (is_error) {
[11:41:59.228]                   sessionInformation <- function() {
[11:41:59.228]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:59.228]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:59.228]                       search = base::search(), system = base::Sys.info())
[11:41:59.228]                   }
[11:41:59.228]                   ...future.conditions[[length(...future.conditions) + 
[11:41:59.228]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:59.228]                     cond$call), session = sessionInformation(), 
[11:41:59.228]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:59.228]                   signalCondition(cond)
[11:41:59.228]                 }
[11:41:59.228]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:59.228]                 "immediateCondition"))) {
[11:41:59.228]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:59.228]                   ...future.conditions[[length(...future.conditions) + 
[11:41:59.228]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:59.228]                   if (TRUE && !signal) {
[11:41:59.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:59.228]                     {
[11:41:59.228]                       inherits <- base::inherits
[11:41:59.228]                       invokeRestart <- base::invokeRestart
[11:41:59.228]                       is.null <- base::is.null
[11:41:59.228]                       muffled <- FALSE
[11:41:59.228]                       if (inherits(cond, "message")) {
[11:41:59.228]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:59.228]                         if (muffled) 
[11:41:59.228]                           invokeRestart("muffleMessage")
[11:41:59.228]                       }
[11:41:59.228]                       else if (inherits(cond, "warning")) {
[11:41:59.228]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:59.228]                         if (muffled) 
[11:41:59.228]                           invokeRestart("muffleWarning")
[11:41:59.228]                       }
[11:41:59.228]                       else if (inherits(cond, "condition")) {
[11:41:59.228]                         if (!is.null(pattern)) {
[11:41:59.228]                           computeRestarts <- base::computeRestarts
[11:41:59.228]                           grepl <- base::grepl
[11:41:59.228]                           restarts <- computeRestarts(cond)
[11:41:59.228]                           for (restart in restarts) {
[11:41:59.228]                             name <- restart$name
[11:41:59.228]                             if (is.null(name)) 
[11:41:59.228]                               next
[11:41:59.228]                             if (!grepl(pattern, name)) 
[11:41:59.228]                               next
[11:41:59.228]                             invokeRestart(restart)
[11:41:59.228]                             muffled <- TRUE
[11:41:59.228]                             break
[11:41:59.228]                           }
[11:41:59.228]                         }
[11:41:59.228]                       }
[11:41:59.228]                       invisible(muffled)
[11:41:59.228]                     }
[11:41:59.228]                     muffleCondition(cond, pattern = "^muffle")
[11:41:59.228]                   }
[11:41:59.228]                 }
[11:41:59.228]                 else {
[11:41:59.228]                   if (TRUE) {
[11:41:59.228]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:59.228]                     {
[11:41:59.228]                       inherits <- base::inherits
[11:41:59.228]                       invokeRestart <- base::invokeRestart
[11:41:59.228]                       is.null <- base::is.null
[11:41:59.228]                       muffled <- FALSE
[11:41:59.228]                       if (inherits(cond, "message")) {
[11:41:59.228]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:59.228]                         if (muffled) 
[11:41:59.228]                           invokeRestart("muffleMessage")
[11:41:59.228]                       }
[11:41:59.228]                       else if (inherits(cond, "warning")) {
[11:41:59.228]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:59.228]                         if (muffled) 
[11:41:59.228]                           invokeRestart("muffleWarning")
[11:41:59.228]                       }
[11:41:59.228]                       else if (inherits(cond, "condition")) {
[11:41:59.228]                         if (!is.null(pattern)) {
[11:41:59.228]                           computeRestarts <- base::computeRestarts
[11:41:59.228]                           grepl <- base::grepl
[11:41:59.228]                           restarts <- computeRestarts(cond)
[11:41:59.228]                           for (restart in restarts) {
[11:41:59.228]                             name <- restart$name
[11:41:59.228]                             if (is.null(name)) 
[11:41:59.228]                               next
[11:41:59.228]                             if (!grepl(pattern, name)) 
[11:41:59.228]                               next
[11:41:59.228]                             invokeRestart(restart)
[11:41:59.228]                             muffled <- TRUE
[11:41:59.228]                             break
[11:41:59.228]                           }
[11:41:59.228]                         }
[11:41:59.228]                       }
[11:41:59.228]                       invisible(muffled)
[11:41:59.228]                     }
[11:41:59.228]                     muffleCondition(cond, pattern = "^muffle")
[11:41:59.228]                   }
[11:41:59.228]                 }
[11:41:59.228]             }
[11:41:59.228]         }))
[11:41:59.228]     }, error = function(ex) {
[11:41:59.228]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:59.228]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:59.228]                 ...future.rng), started = ...future.startTime, 
[11:41:59.228]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:59.228]             version = "1.8"), class = "FutureResult")
[11:41:59.228]     }, finally = {
[11:41:59.228]         if (!identical(...future.workdir, getwd())) 
[11:41:59.228]             setwd(...future.workdir)
[11:41:59.228]         {
[11:41:59.228]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:59.228]                 ...future.oldOptions$nwarnings <- NULL
[11:41:59.228]             }
[11:41:59.228]             base::options(...future.oldOptions)
[11:41:59.228]             if (.Platform$OS.type == "windows") {
[11:41:59.228]                 old_names <- names(...future.oldEnvVars)
[11:41:59.228]                 envs <- base::Sys.getenv()
[11:41:59.228]                 names <- names(envs)
[11:41:59.228]                 common <- intersect(names, old_names)
[11:41:59.228]                 added <- setdiff(names, old_names)
[11:41:59.228]                 removed <- setdiff(old_names, names)
[11:41:59.228]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:59.228]                   envs[common]]
[11:41:59.228]                 NAMES <- toupper(changed)
[11:41:59.228]                 args <- list()
[11:41:59.228]                 for (kk in seq_along(NAMES)) {
[11:41:59.228]                   name <- changed[[kk]]
[11:41:59.228]                   NAME <- NAMES[[kk]]
[11:41:59.228]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:59.228]                     next
[11:41:59.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:59.228]                 }
[11:41:59.228]                 NAMES <- toupper(added)
[11:41:59.228]                 for (kk in seq_along(NAMES)) {
[11:41:59.228]                   name <- added[[kk]]
[11:41:59.228]                   NAME <- NAMES[[kk]]
[11:41:59.228]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:59.228]                     next
[11:41:59.228]                   args[[name]] <- ""
[11:41:59.228]                 }
[11:41:59.228]                 NAMES <- toupper(removed)
[11:41:59.228]                 for (kk in seq_along(NAMES)) {
[11:41:59.228]                   name <- removed[[kk]]
[11:41:59.228]                   NAME <- NAMES[[kk]]
[11:41:59.228]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:59.228]                     next
[11:41:59.228]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:59.228]                 }
[11:41:59.228]                 if (length(args) > 0) 
[11:41:59.228]                   base::do.call(base::Sys.setenv, args = args)
[11:41:59.228]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:59.228]             }
[11:41:59.228]             else {
[11:41:59.228]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:59.228]             }
[11:41:59.228]             {
[11:41:59.228]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:59.228]                   0L) {
[11:41:59.228]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:59.228]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:59.228]                   base::options(opts)
[11:41:59.228]                 }
[11:41:59.228]                 {
[11:41:59.228]                   {
[11:41:59.228]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:59.228]                     NULL
[11:41:59.228]                   }
[11:41:59.228]                   options(future.plan = NULL)
[11:41:59.228]                   if (is.na(NA_character_)) 
[11:41:59.228]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:59.228]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:59.228]                   future::plan(list(function (..., workers = 2, 
[11:41:59.228]                     envir = parent.frame()) 
[11:41:59.228]                   strategy(..., workers = workers, envir = envir)), 
[11:41:59.228]                     .cleanup = FALSE, .init = FALSE)
[11:41:59.228]                 }
[11:41:59.228]             }
[11:41:59.228]         }
[11:41:59.228]     })
[11:41:59.228]     if (TRUE) {
[11:41:59.228]         base::sink(type = "output", split = FALSE)
[11:41:59.228]         if (TRUE) {
[11:41:59.228]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:59.228]         }
[11:41:59.228]         else {
[11:41:59.228]             ...future.result["stdout"] <- base::list(NULL)
[11:41:59.228]         }
[11:41:59.228]         base::close(...future.stdout)
[11:41:59.228]         ...future.stdout <- NULL
[11:41:59.228]     }
[11:41:59.228]     ...future.result$conditions <- ...future.conditions
[11:41:59.228]     ...future.result$finished <- base::Sys.time()
[11:41:59.228]     ...future.result
[11:41:59.228] }
[11:41:59.231] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:59.241] receiveMessageFromWorker() for ClusterFuture ...
[11:41:59.242] - Validating connection of MultisessionFuture
[11:41:59.242] - received message: FutureResult
[11:41:59.242] - Received FutureResult
[11:41:59.242] - Erased future from FutureRegistry
[11:41:59.242] result() for ClusterFuture ...
[11:41:59.242] - result already collected: FutureResult
[11:41:59.242] result() for ClusterFuture ... done
[11:41:59.242] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:59.242] result() for ClusterFuture ...
[11:41:59.242] - result already collected: FutureResult
[11:41:59.242] result() for ClusterFuture ... done
[11:41:59.242] result() for ClusterFuture ...
[11:41:59.243] - result already collected: FutureResult
[11:41:59.243] result() for ClusterFuture ... done
[11:41:59.243] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:59.243] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:59.289] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:59.295] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:59.337] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:59.338] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:59.381] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:59.382] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:59.382] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:59.382] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:59.383] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:59.383] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:59.384] MultisessionFuture started
[11:41:59.384] - Launch lazy future ... done
[11:41:59.384] run() for ‘MultisessionFuture’ ... done
[11:41:59.384] Created future:
[11:41:59.384] MultisessionFuture:
[11:41:59.384] Label: ‘future_mapply-76’
[11:41:59.384] Expression:
[11:41:59.384] {
[11:41:59.384]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:59.384]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:59.384]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:59.384]         on.exit(options(oopts), add = TRUE)
[11:41:59.384]     }
[11:41:59.384]     {
[11:41:59.384]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:59.384]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:59.384]                 inherits = FALSE)
[11:41:59.384]             ...future.FUN(...)
[11:41:59.384]         }
[11:41:59.384]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:59.384]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:59.384]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:59.384]         do.call(mapply, args = args)
[11:41:59.384]     }
[11:41:59.384] }
[11:41:59.384] Lazy evaluation: FALSE
[11:41:59.384] Asynchronous evaluation: TRUE
[11:41:59.384] Local evaluation: TRUE
[11:41:59.384] Environment: 0x560ef58e1768
[11:41:59.384] Capture standard output: TRUE
[11:41:59.384] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:59.384] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:59.384] Packages: 1 packages (‘mlr3’)
[11:41:59.384] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:59.384] Resolved: FALSE
[11:41:59.384] Value: <not collected>
[11:41:59.384] Conditions captured: <none>
[11:41:59.384] Early signaling: FALSE
[11:41:59.384] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:59.384] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:59.401] Chunk #76 of 90 ... DONE
[11:41:59.401] Chunk #77 of 90 ...
[11:41:59.402]  - seeds: [1] <seeds>
[11:41:59.402] getGlobalsAndPackages() ...
[11:41:59.402] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:59.402] Resolving globals: FALSE
[11:41:59.402] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:59.403] - packages: [1] ‘mlr3’
[11:41:59.403] getGlobalsAndPackages() ... DONE
[11:41:59.403] run() for ‘Future’ ...
[11:41:59.403] - state: ‘created’
[11:41:59.403] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:59.416] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:59.416] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:59.417]   - Field: ‘node’
[11:41:59.417]   - Field: ‘label’
[11:41:59.417]   - Field: ‘local’
[11:41:59.417]   - Field: ‘owner’
[11:41:59.417]   - Field: ‘envir’
[11:41:59.417]   - Field: ‘workers’
[11:41:59.417]   - Field: ‘packages’
[11:41:59.417]   - Field: ‘gc’
[11:41:59.417]   - Field: ‘conditions’
[11:41:59.417]   - Field: ‘persistent’
[11:41:59.417]   - Field: ‘expr’
[11:41:59.417]   - Field: ‘uuid’
[11:41:59.417]   - Field: ‘seed’
[11:41:59.417]   - Field: ‘version’
[11:41:59.418]   - Field: ‘result’
[11:41:59.418]   - Field: ‘asynchronous’
[11:41:59.421]   - Field: ‘calls’
[11:41:59.422]   - Field: ‘globals’
[11:41:59.422]   - Field: ‘stdout’
[11:41:59.422]   - Field: ‘earlySignal’
[11:41:59.422]   - Field: ‘lazy’
[11:41:59.422]   - Field: ‘state’
[11:41:59.422] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:59.422] - Launch lazy future ...
[11:41:59.423] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:59.423] Packages needed by future strategies (n = 0): <none>
[11:41:59.423] {
[11:41:59.423]     {
[11:41:59.423]         {
[11:41:59.423]             ...future.startTime <- base::Sys.time()
[11:41:59.423]             {
[11:41:59.423]                 {
[11:41:59.423]                   {
[11:41:59.423]                     {
[11:41:59.423]                       {
[11:41:59.423]                         base::local({
[11:41:59.423]                           has_future <- base::requireNamespace("future", 
[11:41:59.423]                             quietly = TRUE)
[11:41:59.423]                           if (has_future) {
[11:41:59.423]                             ns <- base::getNamespace("future")
[11:41:59.423]                             version <- ns[[".package"]][["version"]]
[11:41:59.423]                             if (is.null(version)) 
[11:41:59.423]                               version <- utils::packageVersion("future")
[11:41:59.423]                           }
[11:41:59.423]                           else {
[11:41:59.423]                             version <- NULL
[11:41:59.423]                           }
[11:41:59.423]                           if (!has_future || version < "1.8.0") {
[11:41:59.423]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:59.423]                               "", base::R.version$version.string), 
[11:41:59.423]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:59.423]                                 base::R.version$platform, 8 * 
[11:41:59.423]                                   base::.Machine$sizeof.pointer), 
[11:41:59.423]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:59.423]                                 "release", "version")], collapse = " "), 
[11:41:59.423]                               hostname = base::Sys.info()[["nodename"]])
[11:41:59.423]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:59.423]                               info)
[11:41:59.423]                             info <- base::paste(info, collapse = "; ")
[11:41:59.423]                             if (!has_future) {
[11:41:59.423]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:59.423]                                 info)
[11:41:59.423]                             }
[11:41:59.423]                             else {
[11:41:59.423]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:59.423]                                 info, version)
[11:41:59.423]                             }
[11:41:59.423]                             base::stop(msg)
[11:41:59.423]                           }
[11:41:59.423]                         })
[11:41:59.423]                       }
[11:41:59.423]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:59.423]                       base::options(mc.cores = 1L)
[11:41:59.423]                     }
[11:41:59.423]                     base::local({
[11:41:59.423]                       for (pkg in "mlr3") {
[11:41:59.423]                         base::loadNamespace(pkg)
[11:41:59.423]                         base::library(pkg, character.only = TRUE)
[11:41:59.423]                       }
[11:41:59.423]                     })
[11:41:59.423]                   }
[11:41:59.423]                   options(future.plan = NULL)
[11:41:59.423]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:59.423]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:59.423]                 }
[11:41:59.423]                 ...future.workdir <- getwd()
[11:41:59.423]             }
[11:41:59.423]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:59.423]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:59.423]         }
[11:41:59.423]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:59.423]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:59.423]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:59.423]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:59.423]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:59.423]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:59.423]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:59.423]             base::names(...future.oldOptions))
[11:41:59.423]     }
[11:41:59.423]     if (FALSE) {
[11:41:59.423]     }
[11:41:59.423]     else {
[11:41:59.423]         if (TRUE) {
[11:41:59.423]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:59.423]                 open = "w")
[11:41:59.423]         }
[11:41:59.423]         else {
[11:41:59.423]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:59.423]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:59.423]         }
[11:41:59.423]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:59.423]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:59.423]             base::sink(type = "output", split = FALSE)
[11:41:59.423]             base::close(...future.stdout)
[11:41:59.423]         }, add = TRUE)
[11:41:59.423]     }
[11:41:59.423]     ...future.frame <- base::sys.nframe()
[11:41:59.423]     ...future.conditions <- base::list()
[11:41:59.423]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:59.423]     if (FALSE) {
[11:41:59.423]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:59.423]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:59.423]     }
[11:41:59.423]     ...future.result <- base::tryCatch({
[11:41:59.423]         base::withCallingHandlers({
[11:41:59.423]             ...future.value <- base::withVisible(base::local({
[11:41:59.423]                 ...future.makeSendCondition <- local({
[11:41:59.423]                   sendCondition <- NULL
[11:41:59.423]                   function(frame = 1L) {
[11:41:59.423]                     if (is.function(sendCondition)) 
[11:41:59.423]                       return(sendCondition)
[11:41:59.423]                     ns <- getNamespace("parallel")
[11:41:59.423]                     if (exists("sendData", mode = "function", 
[11:41:59.423]                       envir = ns)) {
[11:41:59.423]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:59.423]                         envir = ns)
[11:41:59.423]                       envir <- sys.frame(frame)
[11:41:59.423]                       master <- NULL
[11:41:59.423]                       while (!identical(envir, .GlobalEnv) && 
[11:41:59.423]                         !identical(envir, emptyenv())) {
[11:41:59.423]                         if (exists("master", mode = "list", envir = envir, 
[11:41:59.423]                           inherits = FALSE)) {
[11:41:59.423]                           master <- get("master", mode = "list", 
[11:41:59.423]                             envir = envir, inherits = FALSE)
[11:41:59.423]                           if (inherits(master, c("SOCKnode", 
[11:41:59.423]                             "SOCK0node"))) {
[11:41:59.423]                             sendCondition <<- function(cond) {
[11:41:59.423]                               data <- list(type = "VALUE", value = cond, 
[11:41:59.423]                                 success = TRUE)
[11:41:59.423]                               parallel_sendData(master, data)
[11:41:59.423]                             }
[11:41:59.423]                             return(sendCondition)
[11:41:59.423]                           }
[11:41:59.423]                         }
[11:41:59.423]                         frame <- frame + 1L
[11:41:59.423]                         envir <- sys.frame(frame)
[11:41:59.423]                       }
[11:41:59.423]                     }
[11:41:59.423]                     sendCondition <<- function(cond) NULL
[11:41:59.423]                   }
[11:41:59.423]                 })
[11:41:59.423]                 withCallingHandlers({
[11:41:59.423]                   {
[11:41:59.423]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:59.423]                     if (!identical(...future.globals.maxSize.org, 
[11:41:59.423]                       ...future.globals.maxSize)) {
[11:41:59.423]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:59.423]                       on.exit(options(oopts), add = TRUE)
[11:41:59.423]                     }
[11:41:59.423]                     {
[11:41:59.423]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:59.423]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:59.423]                           envir = globalenv(), inherits = FALSE)
[11:41:59.423]                         ...future.FUN(...)
[11:41:59.423]                       }
[11:41:59.423]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:59.423]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:59.423]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:59.423]                         USE.NAMES = FALSE)
[11:41:59.423]                       do.call(mapply, args = args)
[11:41:59.423]                     }
[11:41:59.423]                   }
[11:41:59.423]                 }, immediateCondition = function(cond) {
[11:41:59.423]                   sendCondition <- ...future.makeSendCondition()
[11:41:59.423]                   sendCondition(cond)
[11:41:59.423]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:59.423]                   {
[11:41:59.423]                     inherits <- base::inherits
[11:41:59.423]                     invokeRestart <- base::invokeRestart
[11:41:59.423]                     is.null <- base::is.null
[11:41:59.423]                     muffled <- FALSE
[11:41:59.423]                     if (inherits(cond, "message")) {
[11:41:59.423]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:59.423]                       if (muffled) 
[11:41:59.423]                         invokeRestart("muffleMessage")
[11:41:59.423]                     }
[11:41:59.423]                     else if (inherits(cond, "warning")) {
[11:41:59.423]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:59.423]                       if (muffled) 
[11:41:59.423]                         invokeRestart("muffleWarning")
[11:41:59.423]                     }
[11:41:59.423]                     else if (inherits(cond, "condition")) {
[11:41:59.423]                       if (!is.null(pattern)) {
[11:41:59.423]                         computeRestarts <- base::computeRestarts
[11:41:59.423]                         grepl <- base::grepl
[11:41:59.423]                         restarts <- computeRestarts(cond)
[11:41:59.423]                         for (restart in restarts) {
[11:41:59.423]                           name <- restart$name
[11:41:59.423]                           if (is.null(name)) 
[11:41:59.423]                             next
[11:41:59.423]                           if (!grepl(pattern, name)) 
[11:41:59.423]                             next
[11:41:59.423]                           invokeRestart(restart)
[11:41:59.423]                           muffled <- TRUE
[11:41:59.423]                           break
[11:41:59.423]                         }
[11:41:59.423]                       }
[11:41:59.423]                     }
[11:41:59.423]                     invisible(muffled)
[11:41:59.423]                   }
[11:41:59.423]                   muffleCondition(cond)
[11:41:59.423]                 })
[11:41:59.423]             }))
[11:41:59.423]             future::FutureResult(value = ...future.value$value, 
[11:41:59.423]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:59.423]                   ...future.rng), globalenv = if (FALSE) 
[11:41:59.423]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:59.423]                     ...future.globalenv.names))
[11:41:59.423]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:59.423]         }, condition = base::local({
[11:41:59.423]             c <- base::c
[11:41:59.423]             inherits <- base::inherits
[11:41:59.423]             invokeRestart <- base::invokeRestart
[11:41:59.423]             length <- base::length
[11:41:59.423]             list <- base::list
[11:41:59.423]             seq.int <- base::seq.int
[11:41:59.423]             signalCondition <- base::signalCondition
[11:41:59.423]             sys.calls <- base::sys.calls
[11:41:59.423]             `[[` <- base::`[[`
[11:41:59.423]             `+` <- base::`+`
[11:41:59.423]             `<<-` <- base::`<<-`
[11:41:59.423]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:59.423]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:59.423]                   3L)]
[11:41:59.423]             }
[11:41:59.423]             function(cond) {
[11:41:59.423]                 is_error <- inherits(cond, "error")
[11:41:59.423]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:59.423]                   NULL)
[11:41:59.423]                 if (is_error) {
[11:41:59.423]                   sessionInformation <- function() {
[11:41:59.423]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:59.423]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:59.423]                       search = base::search(), system = base::Sys.info())
[11:41:59.423]                   }
[11:41:59.423]                   ...future.conditions[[length(...future.conditions) + 
[11:41:59.423]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:59.423]                     cond$call), session = sessionInformation(), 
[11:41:59.423]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:59.423]                   signalCondition(cond)
[11:41:59.423]                 }
[11:41:59.423]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:59.423]                 "immediateCondition"))) {
[11:41:59.423]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:59.423]                   ...future.conditions[[length(...future.conditions) + 
[11:41:59.423]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:59.423]                   if (TRUE && !signal) {
[11:41:59.423]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:59.423]                     {
[11:41:59.423]                       inherits <- base::inherits
[11:41:59.423]                       invokeRestart <- base::invokeRestart
[11:41:59.423]                       is.null <- base::is.null
[11:41:59.423]                       muffled <- FALSE
[11:41:59.423]                       if (inherits(cond, "message")) {
[11:41:59.423]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:59.423]                         if (muffled) 
[11:41:59.423]                           invokeRestart("muffleMessage")
[11:41:59.423]                       }
[11:41:59.423]                       else if (inherits(cond, "warning")) {
[11:41:59.423]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:59.423]                         if (muffled) 
[11:41:59.423]                           invokeRestart("muffleWarning")
[11:41:59.423]                       }
[11:41:59.423]                       else if (inherits(cond, "condition")) {
[11:41:59.423]                         if (!is.null(pattern)) {
[11:41:59.423]                           computeRestarts <- base::computeRestarts
[11:41:59.423]                           grepl <- base::grepl
[11:41:59.423]                           restarts <- computeRestarts(cond)
[11:41:59.423]                           for (restart in restarts) {
[11:41:59.423]                             name <- restart$name
[11:41:59.423]                             if (is.null(name)) 
[11:41:59.423]                               next
[11:41:59.423]                             if (!grepl(pattern, name)) 
[11:41:59.423]                               next
[11:41:59.423]                             invokeRestart(restart)
[11:41:59.423]                             muffled <- TRUE
[11:41:59.423]                             break
[11:41:59.423]                           }
[11:41:59.423]                         }
[11:41:59.423]                       }
[11:41:59.423]                       invisible(muffled)
[11:41:59.423]                     }
[11:41:59.423]                     muffleCondition(cond, pattern = "^muffle")
[11:41:59.423]                   }
[11:41:59.423]                 }
[11:41:59.423]                 else {
[11:41:59.423]                   if (TRUE) {
[11:41:59.423]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:59.423]                     {
[11:41:59.423]                       inherits <- base::inherits
[11:41:59.423]                       invokeRestart <- base::invokeRestart
[11:41:59.423]                       is.null <- base::is.null
[11:41:59.423]                       muffled <- FALSE
[11:41:59.423]                       if (inherits(cond, "message")) {
[11:41:59.423]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:59.423]                         if (muffled) 
[11:41:59.423]                           invokeRestart("muffleMessage")
[11:41:59.423]                       }
[11:41:59.423]                       else if (inherits(cond, "warning")) {
[11:41:59.423]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:59.423]                         if (muffled) 
[11:41:59.423]                           invokeRestart("muffleWarning")
[11:41:59.423]                       }
[11:41:59.423]                       else if (inherits(cond, "condition")) {
[11:41:59.423]                         if (!is.null(pattern)) {
[11:41:59.423]                           computeRestarts <- base::computeRestarts
[11:41:59.423]                           grepl <- base::grepl
[11:41:59.423]                           restarts <- computeRestarts(cond)
[11:41:59.423]                           for (restart in restarts) {
[11:41:59.423]                             name <- restart$name
[11:41:59.423]                             if (is.null(name)) 
[11:41:59.423]                               next
[11:41:59.423]                             if (!grepl(pattern, name)) 
[11:41:59.423]                               next
[11:41:59.423]                             invokeRestart(restart)
[11:41:59.423]                             muffled <- TRUE
[11:41:59.423]                             break
[11:41:59.423]                           }
[11:41:59.423]                         }
[11:41:59.423]                       }
[11:41:59.423]                       invisible(muffled)
[11:41:59.423]                     }
[11:41:59.423]                     muffleCondition(cond, pattern = "^muffle")
[11:41:59.423]                   }
[11:41:59.423]                 }
[11:41:59.423]             }
[11:41:59.423]         }))
[11:41:59.423]     }, error = function(ex) {
[11:41:59.423]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:59.423]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:59.423]                 ...future.rng), started = ...future.startTime, 
[11:41:59.423]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:59.423]             version = "1.8"), class = "FutureResult")
[11:41:59.423]     }, finally = {
[11:41:59.423]         if (!identical(...future.workdir, getwd())) 
[11:41:59.423]             setwd(...future.workdir)
[11:41:59.423]         {
[11:41:59.423]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:59.423]                 ...future.oldOptions$nwarnings <- NULL
[11:41:59.423]             }
[11:41:59.423]             base::options(...future.oldOptions)
[11:41:59.423]             if (.Platform$OS.type == "windows") {
[11:41:59.423]                 old_names <- names(...future.oldEnvVars)
[11:41:59.423]                 envs <- base::Sys.getenv()
[11:41:59.423]                 names <- names(envs)
[11:41:59.423]                 common <- intersect(names, old_names)
[11:41:59.423]                 added <- setdiff(names, old_names)
[11:41:59.423]                 removed <- setdiff(old_names, names)
[11:41:59.423]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:59.423]                   envs[common]]
[11:41:59.423]                 NAMES <- toupper(changed)
[11:41:59.423]                 args <- list()
[11:41:59.423]                 for (kk in seq_along(NAMES)) {
[11:41:59.423]                   name <- changed[[kk]]
[11:41:59.423]                   NAME <- NAMES[[kk]]
[11:41:59.423]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:59.423]                     next
[11:41:59.423]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:59.423]                 }
[11:41:59.423]                 NAMES <- toupper(added)
[11:41:59.423]                 for (kk in seq_along(NAMES)) {
[11:41:59.423]                   name <- added[[kk]]
[11:41:59.423]                   NAME <- NAMES[[kk]]
[11:41:59.423]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:59.423]                     next
[11:41:59.423]                   args[[name]] <- ""
[11:41:59.423]                 }
[11:41:59.423]                 NAMES <- toupper(removed)
[11:41:59.423]                 for (kk in seq_along(NAMES)) {
[11:41:59.423]                   name <- removed[[kk]]
[11:41:59.423]                   NAME <- NAMES[[kk]]
[11:41:59.423]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:59.423]                     next
[11:41:59.423]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:59.423]                 }
[11:41:59.423]                 if (length(args) > 0) 
[11:41:59.423]                   base::do.call(base::Sys.setenv, args = args)
[11:41:59.423]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:59.423]             }
[11:41:59.423]             else {
[11:41:59.423]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:59.423]             }
[11:41:59.423]             {
[11:41:59.423]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:59.423]                   0L) {
[11:41:59.423]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:59.423]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:59.423]                   base::options(opts)
[11:41:59.423]                 }
[11:41:59.423]                 {
[11:41:59.423]                   {
[11:41:59.423]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:59.423]                     NULL
[11:41:59.423]                   }
[11:41:59.423]                   options(future.plan = NULL)
[11:41:59.423]                   if (is.na(NA_character_)) 
[11:41:59.423]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:59.423]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:59.423]                   future::plan(list(function (..., workers = 2, 
[11:41:59.423]                     envir = parent.frame()) 
[11:41:59.423]                   strategy(..., workers = workers, envir = envir)), 
[11:41:59.423]                     .cleanup = FALSE, .init = FALSE)
[11:41:59.423]                 }
[11:41:59.423]             }
[11:41:59.423]         }
[11:41:59.423]     })
[11:41:59.423]     if (TRUE) {
[11:41:59.423]         base::sink(type = "output", split = FALSE)
[11:41:59.423]         if (TRUE) {
[11:41:59.423]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:59.423]         }
[11:41:59.423]         else {
[11:41:59.423]             ...future.result["stdout"] <- base::list(NULL)
[11:41:59.423]         }
[11:41:59.423]         base::close(...future.stdout)
[11:41:59.423]         ...future.stdout <- NULL
[11:41:59.423]     }
[11:41:59.423]     ...future.result$conditions <- ...future.conditions
[11:41:59.423]     ...future.result$finished <- base::Sys.time()
[11:41:59.423]     ...future.result
[11:41:59.423] }
[11:41:59.426] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:59.437] receiveMessageFromWorker() for ClusterFuture ...
[11:41:59.437] - Validating connection of MultisessionFuture
[11:41:59.438] - received message: FutureResult
[11:41:59.438] - Received FutureResult
[11:41:59.438] - Erased future from FutureRegistry
[11:41:59.438] result() for ClusterFuture ...
[11:41:59.439] - result already collected: FutureResult
[11:41:59.439] result() for ClusterFuture ... done
[11:41:59.439] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:59.439] result() for ClusterFuture ...
[11:41:59.439] - result already collected: FutureResult
[11:41:59.439] result() for ClusterFuture ... done
[11:41:59.439] result() for ClusterFuture ...
[11:41:59.439] - result already collected: FutureResult
[11:41:59.440] result() for ClusterFuture ... done
[11:41:59.441] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:59.441] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:59.485] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:59.490] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:59.533] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:59.533] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:59.577] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:59.578] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:59.578] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:59.578] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:59.579] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:59.579] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:59.580] MultisessionFuture started
[11:41:59.580] - Launch lazy future ... done
[11:41:59.580] run() for ‘MultisessionFuture’ ... done
[11:41:59.580] Created future:
[11:41:59.580] MultisessionFuture:
[11:41:59.580] Label: ‘future_mapply-77’
[11:41:59.580] Expression:
[11:41:59.580] {
[11:41:59.580]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:59.580]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:59.580]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:59.580]         on.exit(options(oopts), add = TRUE)
[11:41:59.580]     }
[11:41:59.580]     {
[11:41:59.580]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:59.580]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:59.580]                 inherits = FALSE)
[11:41:59.580]             ...future.FUN(...)
[11:41:59.580]         }
[11:41:59.580]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:59.580]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:59.580]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:59.580]         do.call(mapply, args = args)
[11:41:59.580]     }
[11:41:59.580] }
[11:41:59.580] Lazy evaluation: FALSE
[11:41:59.580] Asynchronous evaluation: TRUE
[11:41:59.580] Local evaluation: TRUE
[11:41:59.580] Environment: 0x560ef58e1768
[11:41:59.580] Capture standard output: TRUE
[11:41:59.580] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:59.580] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:59.580] Packages: 1 packages (‘mlr3’)
[11:41:59.580] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:59.580] Resolved: FALSE
[11:41:59.580] Value: <not collected>
[11:41:59.580] Conditions captured: <none>
[11:41:59.580] Early signaling: FALSE
[11:41:59.580] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:59.580] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:59.597] Chunk #77 of 90 ... DONE
[11:41:59.597] Chunk #78 of 90 ...
[11:41:59.597]  - seeds: [1] <seeds>
[11:41:59.597] getGlobalsAndPackages() ...
[11:41:59.597] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:59.597] Resolving globals: FALSE
[11:41:59.598] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:59.598] - packages: [1] ‘mlr3’
[11:41:59.598] getGlobalsAndPackages() ... DONE
[11:41:59.598] run() for ‘Future’ ...
[11:41:59.599] - state: ‘created’
[11:41:59.599] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:59.613] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:59.613] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:59.613]   - Field: ‘node’
[11:41:59.613]   - Field: ‘label’
[11:41:59.613]   - Field: ‘local’
[11:41:59.613]   - Field: ‘owner’
[11:41:59.613]   - Field: ‘envir’
[11:41:59.613]   - Field: ‘workers’
[11:41:59.613]   - Field: ‘packages’
[11:41:59.614]   - Field: ‘gc’
[11:41:59.614]   - Field: ‘conditions’
[11:41:59.614]   - Field: ‘persistent’
[11:41:59.614]   - Field: ‘expr’
[11:41:59.614]   - Field: ‘uuid’
[11:41:59.614]   - Field: ‘seed’
[11:41:59.614]   - Field: ‘version’
[11:41:59.614]   - Field: ‘result’
[11:41:59.614]   - Field: ‘asynchronous’
[11:41:59.614]   - Field: ‘calls’
[11:41:59.614]   - Field: ‘globals’
[11:41:59.614]   - Field: ‘stdout’
[11:41:59.614]   - Field: ‘earlySignal’
[11:41:59.614]   - Field: ‘lazy’
[11:41:59.614]   - Field: ‘state’
[11:41:59.614] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:59.614] - Launch lazy future ...
[11:41:59.615] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:59.615] Packages needed by future strategies (n = 0): <none>
[11:41:59.615] {
[11:41:59.615]     {
[11:41:59.615]         {
[11:41:59.615]             ...future.startTime <- base::Sys.time()
[11:41:59.615]             {
[11:41:59.615]                 {
[11:41:59.615]                   {
[11:41:59.615]                     {
[11:41:59.615]                       {
[11:41:59.615]                         base::local({
[11:41:59.615]                           has_future <- base::requireNamespace("future", 
[11:41:59.615]                             quietly = TRUE)
[11:41:59.615]                           if (has_future) {
[11:41:59.615]                             ns <- base::getNamespace("future")
[11:41:59.615]                             version <- ns[[".package"]][["version"]]
[11:41:59.615]                             if (is.null(version)) 
[11:41:59.615]                               version <- utils::packageVersion("future")
[11:41:59.615]                           }
[11:41:59.615]                           else {
[11:41:59.615]                             version <- NULL
[11:41:59.615]                           }
[11:41:59.615]                           if (!has_future || version < "1.8.0") {
[11:41:59.615]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:59.615]                               "", base::R.version$version.string), 
[11:41:59.615]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:59.615]                                 base::R.version$platform, 8 * 
[11:41:59.615]                                   base::.Machine$sizeof.pointer), 
[11:41:59.615]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:59.615]                                 "release", "version")], collapse = " "), 
[11:41:59.615]                               hostname = base::Sys.info()[["nodename"]])
[11:41:59.615]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:59.615]                               info)
[11:41:59.615]                             info <- base::paste(info, collapse = "; ")
[11:41:59.615]                             if (!has_future) {
[11:41:59.615]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:59.615]                                 info)
[11:41:59.615]                             }
[11:41:59.615]                             else {
[11:41:59.615]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:59.615]                                 info, version)
[11:41:59.615]                             }
[11:41:59.615]                             base::stop(msg)
[11:41:59.615]                           }
[11:41:59.615]                         })
[11:41:59.615]                       }
[11:41:59.615]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:59.615]                       base::options(mc.cores = 1L)
[11:41:59.615]                     }
[11:41:59.615]                     base::local({
[11:41:59.615]                       for (pkg in "mlr3") {
[11:41:59.615]                         base::loadNamespace(pkg)
[11:41:59.615]                         base::library(pkg, character.only = TRUE)
[11:41:59.615]                       }
[11:41:59.615]                     })
[11:41:59.615]                   }
[11:41:59.615]                   options(future.plan = NULL)
[11:41:59.615]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:59.615]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:59.615]                 }
[11:41:59.615]                 ...future.workdir <- getwd()
[11:41:59.615]             }
[11:41:59.615]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:59.615]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:59.615]         }
[11:41:59.615]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:59.615]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:59.615]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:59.615]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:59.615]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:59.615]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:59.615]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:59.615]             base::names(...future.oldOptions))
[11:41:59.615]     }
[11:41:59.615]     if (FALSE) {
[11:41:59.615]     }
[11:41:59.615]     else {
[11:41:59.615]         if (TRUE) {
[11:41:59.615]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:59.615]                 open = "w")
[11:41:59.615]         }
[11:41:59.615]         else {
[11:41:59.615]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:59.615]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:59.615]         }
[11:41:59.615]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:59.615]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:59.615]             base::sink(type = "output", split = FALSE)
[11:41:59.615]             base::close(...future.stdout)
[11:41:59.615]         }, add = TRUE)
[11:41:59.615]     }
[11:41:59.615]     ...future.frame <- base::sys.nframe()
[11:41:59.615]     ...future.conditions <- base::list()
[11:41:59.615]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:59.615]     if (FALSE) {
[11:41:59.615]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:59.615]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:59.615]     }
[11:41:59.615]     ...future.result <- base::tryCatch({
[11:41:59.615]         base::withCallingHandlers({
[11:41:59.615]             ...future.value <- base::withVisible(base::local({
[11:41:59.615]                 ...future.makeSendCondition <- local({
[11:41:59.615]                   sendCondition <- NULL
[11:41:59.615]                   function(frame = 1L) {
[11:41:59.615]                     if (is.function(sendCondition)) 
[11:41:59.615]                       return(sendCondition)
[11:41:59.615]                     ns <- getNamespace("parallel")
[11:41:59.615]                     if (exists("sendData", mode = "function", 
[11:41:59.615]                       envir = ns)) {
[11:41:59.615]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:59.615]                         envir = ns)
[11:41:59.615]                       envir <- sys.frame(frame)
[11:41:59.615]                       master <- NULL
[11:41:59.615]                       while (!identical(envir, .GlobalEnv) && 
[11:41:59.615]                         !identical(envir, emptyenv())) {
[11:41:59.615]                         if (exists("master", mode = "list", envir = envir, 
[11:41:59.615]                           inherits = FALSE)) {
[11:41:59.615]                           master <- get("master", mode = "list", 
[11:41:59.615]                             envir = envir, inherits = FALSE)
[11:41:59.615]                           if (inherits(master, c("SOCKnode", 
[11:41:59.615]                             "SOCK0node"))) {
[11:41:59.615]                             sendCondition <<- function(cond) {
[11:41:59.615]                               data <- list(type = "VALUE", value = cond, 
[11:41:59.615]                                 success = TRUE)
[11:41:59.615]                               parallel_sendData(master, data)
[11:41:59.615]                             }
[11:41:59.615]                             return(sendCondition)
[11:41:59.615]                           }
[11:41:59.615]                         }
[11:41:59.615]                         frame <- frame + 1L
[11:41:59.615]                         envir <- sys.frame(frame)
[11:41:59.615]                       }
[11:41:59.615]                     }
[11:41:59.615]                     sendCondition <<- function(cond) NULL
[11:41:59.615]                   }
[11:41:59.615]                 })
[11:41:59.615]                 withCallingHandlers({
[11:41:59.615]                   {
[11:41:59.615]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:59.615]                     if (!identical(...future.globals.maxSize.org, 
[11:41:59.615]                       ...future.globals.maxSize)) {
[11:41:59.615]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:59.615]                       on.exit(options(oopts), add = TRUE)
[11:41:59.615]                     }
[11:41:59.615]                     {
[11:41:59.615]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:59.615]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:59.615]                           envir = globalenv(), inherits = FALSE)
[11:41:59.615]                         ...future.FUN(...)
[11:41:59.615]                       }
[11:41:59.615]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:59.615]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:59.615]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:59.615]                         USE.NAMES = FALSE)
[11:41:59.615]                       do.call(mapply, args = args)
[11:41:59.615]                     }
[11:41:59.615]                   }
[11:41:59.615]                 }, immediateCondition = function(cond) {
[11:41:59.615]                   sendCondition <- ...future.makeSendCondition()
[11:41:59.615]                   sendCondition(cond)
[11:41:59.615]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:59.615]                   {
[11:41:59.615]                     inherits <- base::inherits
[11:41:59.615]                     invokeRestart <- base::invokeRestart
[11:41:59.615]                     is.null <- base::is.null
[11:41:59.615]                     muffled <- FALSE
[11:41:59.615]                     if (inherits(cond, "message")) {
[11:41:59.615]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:59.615]                       if (muffled) 
[11:41:59.615]                         invokeRestart("muffleMessage")
[11:41:59.615]                     }
[11:41:59.615]                     else if (inherits(cond, "warning")) {
[11:41:59.615]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:59.615]                       if (muffled) 
[11:41:59.615]                         invokeRestart("muffleWarning")
[11:41:59.615]                     }
[11:41:59.615]                     else if (inherits(cond, "condition")) {
[11:41:59.615]                       if (!is.null(pattern)) {
[11:41:59.615]                         computeRestarts <- base::computeRestarts
[11:41:59.615]                         grepl <- base::grepl
[11:41:59.615]                         restarts <- computeRestarts(cond)
[11:41:59.615]                         for (restart in restarts) {
[11:41:59.615]                           name <- restart$name
[11:41:59.615]                           if (is.null(name)) 
[11:41:59.615]                             next
[11:41:59.615]                           if (!grepl(pattern, name)) 
[11:41:59.615]                             next
[11:41:59.615]                           invokeRestart(restart)
[11:41:59.615]                           muffled <- TRUE
[11:41:59.615]                           break
[11:41:59.615]                         }
[11:41:59.615]                       }
[11:41:59.615]                     }
[11:41:59.615]                     invisible(muffled)
[11:41:59.615]                   }
[11:41:59.615]                   muffleCondition(cond)
[11:41:59.615]                 })
[11:41:59.615]             }))
[11:41:59.615]             future::FutureResult(value = ...future.value$value, 
[11:41:59.615]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:59.615]                   ...future.rng), globalenv = if (FALSE) 
[11:41:59.615]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:59.615]                     ...future.globalenv.names))
[11:41:59.615]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:59.615]         }, condition = base::local({
[11:41:59.615]             c <- base::c
[11:41:59.615]             inherits <- base::inherits
[11:41:59.615]             invokeRestart <- base::invokeRestart
[11:41:59.615]             length <- base::length
[11:41:59.615]             list <- base::list
[11:41:59.615]             seq.int <- base::seq.int
[11:41:59.615]             signalCondition <- base::signalCondition
[11:41:59.615]             sys.calls <- base::sys.calls
[11:41:59.615]             `[[` <- base::`[[`
[11:41:59.615]             `+` <- base::`+`
[11:41:59.615]             `<<-` <- base::`<<-`
[11:41:59.615]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:59.615]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:59.615]                   3L)]
[11:41:59.615]             }
[11:41:59.615]             function(cond) {
[11:41:59.615]                 is_error <- inherits(cond, "error")
[11:41:59.615]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:59.615]                   NULL)
[11:41:59.615]                 if (is_error) {
[11:41:59.615]                   sessionInformation <- function() {
[11:41:59.615]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:59.615]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:59.615]                       search = base::search(), system = base::Sys.info())
[11:41:59.615]                   }
[11:41:59.615]                   ...future.conditions[[length(...future.conditions) + 
[11:41:59.615]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:59.615]                     cond$call), session = sessionInformation(), 
[11:41:59.615]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:59.615]                   signalCondition(cond)
[11:41:59.615]                 }
[11:41:59.615]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:59.615]                 "immediateCondition"))) {
[11:41:59.615]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:59.615]                   ...future.conditions[[length(...future.conditions) + 
[11:41:59.615]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:59.615]                   if (TRUE && !signal) {
[11:41:59.615]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:59.615]                     {
[11:41:59.615]                       inherits <- base::inherits
[11:41:59.615]                       invokeRestart <- base::invokeRestart
[11:41:59.615]                       is.null <- base::is.null
[11:41:59.615]                       muffled <- FALSE
[11:41:59.615]                       if (inherits(cond, "message")) {
[11:41:59.615]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:59.615]                         if (muffled) 
[11:41:59.615]                           invokeRestart("muffleMessage")
[11:41:59.615]                       }
[11:41:59.615]                       else if (inherits(cond, "warning")) {
[11:41:59.615]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:59.615]                         if (muffled) 
[11:41:59.615]                           invokeRestart("muffleWarning")
[11:41:59.615]                       }
[11:41:59.615]                       else if (inherits(cond, "condition")) {
[11:41:59.615]                         if (!is.null(pattern)) {
[11:41:59.615]                           computeRestarts <- base::computeRestarts
[11:41:59.615]                           grepl <- base::grepl
[11:41:59.615]                           restarts <- computeRestarts(cond)
[11:41:59.615]                           for (restart in restarts) {
[11:41:59.615]                             name <- restart$name
[11:41:59.615]                             if (is.null(name)) 
[11:41:59.615]                               next
[11:41:59.615]                             if (!grepl(pattern, name)) 
[11:41:59.615]                               next
[11:41:59.615]                             invokeRestart(restart)
[11:41:59.615]                             muffled <- TRUE
[11:41:59.615]                             break
[11:41:59.615]                           }
[11:41:59.615]                         }
[11:41:59.615]                       }
[11:41:59.615]                       invisible(muffled)
[11:41:59.615]                     }
[11:41:59.615]                     muffleCondition(cond, pattern = "^muffle")
[11:41:59.615]                   }
[11:41:59.615]                 }
[11:41:59.615]                 else {
[11:41:59.615]                   if (TRUE) {
[11:41:59.615]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:59.615]                     {
[11:41:59.615]                       inherits <- base::inherits
[11:41:59.615]                       invokeRestart <- base::invokeRestart
[11:41:59.615]                       is.null <- base::is.null
[11:41:59.615]                       muffled <- FALSE
[11:41:59.615]                       if (inherits(cond, "message")) {
[11:41:59.615]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:59.615]                         if (muffled) 
[11:41:59.615]                           invokeRestart("muffleMessage")
[11:41:59.615]                       }
[11:41:59.615]                       else if (inherits(cond, "warning")) {
[11:41:59.615]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:59.615]                         if (muffled) 
[11:41:59.615]                           invokeRestart("muffleWarning")
[11:41:59.615]                       }
[11:41:59.615]                       else if (inherits(cond, "condition")) {
[11:41:59.615]                         if (!is.null(pattern)) {
[11:41:59.615]                           computeRestarts <- base::computeRestarts
[11:41:59.615]                           grepl <- base::grepl
[11:41:59.615]                           restarts <- computeRestarts(cond)
[11:41:59.615]                           for (restart in restarts) {
[11:41:59.615]                             name <- restart$name
[11:41:59.615]                             if (is.null(name)) 
[11:41:59.615]                               next
[11:41:59.615]                             if (!grepl(pattern, name)) 
[11:41:59.615]                               next
[11:41:59.615]                             invokeRestart(restart)
[11:41:59.615]                             muffled <- TRUE
[11:41:59.615]                             break
[11:41:59.615]                           }
[11:41:59.615]                         }
[11:41:59.615]                       }
[11:41:59.615]                       invisible(muffled)
[11:41:59.615]                     }
[11:41:59.615]                     muffleCondition(cond, pattern = "^muffle")
[11:41:59.615]                   }
[11:41:59.615]                 }
[11:41:59.615]             }
[11:41:59.615]         }))
[11:41:59.615]     }, error = function(ex) {
[11:41:59.615]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:59.615]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:59.615]                 ...future.rng), started = ...future.startTime, 
[11:41:59.615]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:59.615]             version = "1.8"), class = "FutureResult")
[11:41:59.615]     }, finally = {
[11:41:59.615]         if (!identical(...future.workdir, getwd())) 
[11:41:59.615]             setwd(...future.workdir)
[11:41:59.615]         {
[11:41:59.615]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:59.615]                 ...future.oldOptions$nwarnings <- NULL
[11:41:59.615]             }
[11:41:59.615]             base::options(...future.oldOptions)
[11:41:59.615]             if (.Platform$OS.type == "windows") {
[11:41:59.615]                 old_names <- names(...future.oldEnvVars)
[11:41:59.615]                 envs <- base::Sys.getenv()
[11:41:59.615]                 names <- names(envs)
[11:41:59.615]                 common <- intersect(names, old_names)
[11:41:59.615]                 added <- setdiff(names, old_names)
[11:41:59.615]                 removed <- setdiff(old_names, names)
[11:41:59.615]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:59.615]                   envs[common]]
[11:41:59.615]                 NAMES <- toupper(changed)
[11:41:59.615]                 args <- list()
[11:41:59.615]                 for (kk in seq_along(NAMES)) {
[11:41:59.615]                   name <- changed[[kk]]
[11:41:59.615]                   NAME <- NAMES[[kk]]
[11:41:59.615]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:59.615]                     next
[11:41:59.615]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:59.615]                 }
[11:41:59.615]                 NAMES <- toupper(added)
[11:41:59.615]                 for (kk in seq_along(NAMES)) {
[11:41:59.615]                   name <- added[[kk]]
[11:41:59.615]                   NAME <- NAMES[[kk]]
[11:41:59.615]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:59.615]                     next
[11:41:59.615]                   args[[name]] <- ""
[11:41:59.615]                 }
[11:41:59.615]                 NAMES <- toupper(removed)
[11:41:59.615]                 for (kk in seq_along(NAMES)) {
[11:41:59.615]                   name <- removed[[kk]]
[11:41:59.615]                   NAME <- NAMES[[kk]]
[11:41:59.615]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:59.615]                     next
[11:41:59.615]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:59.615]                 }
[11:41:59.615]                 if (length(args) > 0) 
[11:41:59.615]                   base::do.call(base::Sys.setenv, args = args)
[11:41:59.615]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:59.615]             }
[11:41:59.615]             else {
[11:41:59.615]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:59.615]             }
[11:41:59.615]             {
[11:41:59.615]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:59.615]                   0L) {
[11:41:59.615]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:59.615]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:59.615]                   base::options(opts)
[11:41:59.615]                 }
[11:41:59.615]                 {
[11:41:59.615]                   {
[11:41:59.615]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:59.615]                     NULL
[11:41:59.615]                   }
[11:41:59.615]                   options(future.plan = NULL)
[11:41:59.615]                   if (is.na(NA_character_)) 
[11:41:59.615]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:59.615]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:59.615]                   future::plan(list(function (..., workers = 2, 
[11:41:59.615]                     envir = parent.frame()) 
[11:41:59.615]                   strategy(..., workers = workers, envir = envir)), 
[11:41:59.615]                     .cleanup = FALSE, .init = FALSE)
[11:41:59.615]                 }
[11:41:59.615]             }
[11:41:59.615]         }
[11:41:59.615]     })
[11:41:59.615]     if (TRUE) {
[11:41:59.615]         base::sink(type = "output", split = FALSE)
[11:41:59.615]         if (TRUE) {
[11:41:59.615]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:59.615]         }
[11:41:59.615]         else {
[11:41:59.615]             ...future.result["stdout"] <- base::list(NULL)
[11:41:59.615]         }
[11:41:59.615]         base::close(...future.stdout)
[11:41:59.615]         ...future.stdout <- NULL
[11:41:59.615]     }
[11:41:59.615]     ...future.result$conditions <- ...future.conditions
[11:41:59.615]     ...future.result$finished <- base::Sys.time()
[11:41:59.615]     ...future.result
[11:41:59.615] }
[11:41:59.617] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:59.628] receiveMessageFromWorker() for ClusterFuture ...
[11:41:59.628] - Validating connection of MultisessionFuture
[11:41:59.629] - received message: FutureResult
[11:41:59.629] - Received FutureResult
[11:41:59.629] - Erased future from FutureRegistry
[11:41:59.629] result() for ClusterFuture ...
[11:41:59.629] - result already collected: FutureResult
[11:41:59.629] result() for ClusterFuture ... done
[11:41:59.629] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:59.630] result() for ClusterFuture ...
[11:41:59.630] - result already collected: FutureResult
[11:41:59.630] result() for ClusterFuture ... done
[11:41:59.630] result() for ClusterFuture ...
[11:41:59.630] - result already collected: FutureResult
[11:41:59.630] result() for ClusterFuture ... done
[11:41:59.631] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:41:59.631] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:41:59.673] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:41:59.679] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:41:59.729] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:41:59.730] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:41:59.773] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:41:59.774] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:41:59.774] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:41:59.774] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:41:59.775] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:41:59.775] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:41:59.775] MultisessionFuture started
[11:41:59.775] - Launch lazy future ... done
[11:41:59.776] run() for ‘MultisessionFuture’ ... done
[11:41:59.776] Created future:
[11:41:59.776] MultisessionFuture:
[11:41:59.776] Label: ‘future_mapply-78’
[11:41:59.776] Expression:
[11:41:59.776] {
[11:41:59.776]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:59.776]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:59.776]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:59.776]         on.exit(options(oopts), add = TRUE)
[11:41:59.776]     }
[11:41:59.776]     {
[11:41:59.776]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:59.776]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:59.776]                 inherits = FALSE)
[11:41:59.776]             ...future.FUN(...)
[11:41:59.776]         }
[11:41:59.776]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:59.776]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:59.776]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:59.776]         do.call(mapply, args = args)
[11:41:59.776]     }
[11:41:59.776] }
[11:41:59.776] Lazy evaluation: FALSE
[11:41:59.776] Asynchronous evaluation: TRUE
[11:41:59.776] Local evaluation: TRUE
[11:41:59.776] Environment: 0x560ef58e1768
[11:41:59.776] Capture standard output: TRUE
[11:41:59.776] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:59.776] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:59.776] Packages: 1 packages (‘mlr3’)
[11:41:59.776] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:59.776] Resolved: FALSE
[11:41:59.776] Value: <not collected>
[11:41:59.776] Conditions captured: <none>
[11:41:59.776] Early signaling: FALSE
[11:41:59.776] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:59.776] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:59.792] Chunk #78 of 90 ... DONE
[11:41:59.792] Chunk #79 of 90 ...
[11:41:59.792]  - seeds: [1] <seeds>
[11:41:59.792] getGlobalsAndPackages() ...
[11:41:59.792] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:59.792] Resolving globals: FALSE
[11:41:59.793] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:59.793] - packages: [1] ‘mlr3’
[11:41:59.793] getGlobalsAndPackages() ... DONE
[11:41:59.793] run() for ‘Future’ ...
[11:41:59.793] - state: ‘created’
[11:41:59.793] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:59.803] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:59.803] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:41:59.804]   - Field: ‘node’
[11:41:59.804]   - Field: ‘label’
[11:41:59.804]   - Field: ‘local’
[11:41:59.804]   - Field: ‘owner’
[11:41:59.804]   - Field: ‘envir’
[11:41:59.804]   - Field: ‘workers’
[11:41:59.804]   - Field: ‘packages’
[11:41:59.804]   - Field: ‘gc’
[11:41:59.804]   - Field: ‘conditions’
[11:41:59.804]   - Field: ‘persistent’
[11:41:59.804]   - Field: ‘expr’
[11:41:59.804]   - Field: ‘uuid’
[11:41:59.804]   - Field: ‘seed’
[11:41:59.804]   - Field: ‘version’
[11:41:59.804]   - Field: ‘result’
[11:41:59.804]   - Field: ‘asynchronous’
[11:41:59.804]   - Field: ‘calls’
[11:41:59.805]   - Field: ‘globals’
[11:41:59.805]   - Field: ‘stdout’
[11:41:59.805]   - Field: ‘earlySignal’
[11:41:59.805]   - Field: ‘lazy’
[11:41:59.805]   - Field: ‘state’
[11:41:59.805] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:41:59.805] - Launch lazy future ...
[11:41:59.805] Packages needed by the future expression (n = 1): ‘mlr3’
[11:41:59.805] Packages needed by future strategies (n = 0): <none>
[11:41:59.806] {
[11:41:59.806]     {
[11:41:59.806]         {
[11:41:59.806]             ...future.startTime <- base::Sys.time()
[11:41:59.806]             {
[11:41:59.806]                 {
[11:41:59.806]                   {
[11:41:59.806]                     {
[11:41:59.806]                       {
[11:41:59.806]                         base::local({
[11:41:59.806]                           has_future <- base::requireNamespace("future", 
[11:41:59.806]                             quietly = TRUE)
[11:41:59.806]                           if (has_future) {
[11:41:59.806]                             ns <- base::getNamespace("future")
[11:41:59.806]                             version <- ns[[".package"]][["version"]]
[11:41:59.806]                             if (is.null(version)) 
[11:41:59.806]                               version <- utils::packageVersion("future")
[11:41:59.806]                           }
[11:41:59.806]                           else {
[11:41:59.806]                             version <- NULL
[11:41:59.806]                           }
[11:41:59.806]                           if (!has_future || version < "1.8.0") {
[11:41:59.806]                             info <- base::c(r_version = base::gsub("R version ", 
[11:41:59.806]                               "", base::R.version$version.string), 
[11:41:59.806]                               platform = base::sprintf("%s (%s-bit)", 
[11:41:59.806]                                 base::R.version$platform, 8 * 
[11:41:59.806]                                   base::.Machine$sizeof.pointer), 
[11:41:59.806]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:41:59.806]                                 "release", "version")], collapse = " "), 
[11:41:59.806]                               hostname = base::Sys.info()[["nodename"]])
[11:41:59.806]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:41:59.806]                               info)
[11:41:59.806]                             info <- base::paste(info, collapse = "; ")
[11:41:59.806]                             if (!has_future) {
[11:41:59.806]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:41:59.806]                                 info)
[11:41:59.806]                             }
[11:41:59.806]                             else {
[11:41:59.806]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:41:59.806]                                 info, version)
[11:41:59.806]                             }
[11:41:59.806]                             base::stop(msg)
[11:41:59.806]                           }
[11:41:59.806]                         })
[11:41:59.806]                       }
[11:41:59.806]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:41:59.806]                       base::options(mc.cores = 1L)
[11:41:59.806]                     }
[11:41:59.806]                     base::local({
[11:41:59.806]                       for (pkg in "mlr3") {
[11:41:59.806]                         base::loadNamespace(pkg)
[11:41:59.806]                         base::library(pkg, character.only = TRUE)
[11:41:59.806]                       }
[11:41:59.806]                     })
[11:41:59.806]                   }
[11:41:59.806]                   options(future.plan = NULL)
[11:41:59.806]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:41:59.806]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:41:59.806]                 }
[11:41:59.806]                 ...future.workdir <- getwd()
[11:41:59.806]             }
[11:41:59.806]             ...future.oldOptions <- base::as.list(base::.Options)
[11:41:59.806]             ...future.oldEnvVars <- base::Sys.getenv()
[11:41:59.806]         }
[11:41:59.806]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:41:59.806]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:41:59.806]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:41:59.806]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:41:59.806]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:41:59.806]             future.stdout.windows.reencode = NULL, width = 400L)
[11:41:59.806]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:41:59.806]             base::names(...future.oldOptions))
[11:41:59.806]     }
[11:41:59.806]     if (FALSE) {
[11:41:59.806]     }
[11:41:59.806]     else {
[11:41:59.806]         if (TRUE) {
[11:41:59.806]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:41:59.806]                 open = "w")
[11:41:59.806]         }
[11:41:59.806]         else {
[11:41:59.806]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:41:59.806]                 windows = "NUL", "/dev/null"), open = "w")
[11:41:59.806]         }
[11:41:59.806]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:41:59.806]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:41:59.806]             base::sink(type = "output", split = FALSE)
[11:41:59.806]             base::close(...future.stdout)
[11:41:59.806]         }, add = TRUE)
[11:41:59.806]     }
[11:41:59.806]     ...future.frame <- base::sys.nframe()
[11:41:59.806]     ...future.conditions <- base::list()
[11:41:59.806]     ...future.rng <- base::globalenv()$.Random.seed
[11:41:59.806]     if (FALSE) {
[11:41:59.806]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:41:59.806]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:41:59.806]     }
[11:41:59.806]     ...future.result <- base::tryCatch({
[11:41:59.806]         base::withCallingHandlers({
[11:41:59.806]             ...future.value <- base::withVisible(base::local({
[11:41:59.806]                 ...future.makeSendCondition <- local({
[11:41:59.806]                   sendCondition <- NULL
[11:41:59.806]                   function(frame = 1L) {
[11:41:59.806]                     if (is.function(sendCondition)) 
[11:41:59.806]                       return(sendCondition)
[11:41:59.806]                     ns <- getNamespace("parallel")
[11:41:59.806]                     if (exists("sendData", mode = "function", 
[11:41:59.806]                       envir = ns)) {
[11:41:59.806]                       parallel_sendData <- get("sendData", mode = "function", 
[11:41:59.806]                         envir = ns)
[11:41:59.806]                       envir <- sys.frame(frame)
[11:41:59.806]                       master <- NULL
[11:41:59.806]                       while (!identical(envir, .GlobalEnv) && 
[11:41:59.806]                         !identical(envir, emptyenv())) {
[11:41:59.806]                         if (exists("master", mode = "list", envir = envir, 
[11:41:59.806]                           inherits = FALSE)) {
[11:41:59.806]                           master <- get("master", mode = "list", 
[11:41:59.806]                             envir = envir, inherits = FALSE)
[11:41:59.806]                           if (inherits(master, c("SOCKnode", 
[11:41:59.806]                             "SOCK0node"))) {
[11:41:59.806]                             sendCondition <<- function(cond) {
[11:41:59.806]                               data <- list(type = "VALUE", value = cond, 
[11:41:59.806]                                 success = TRUE)
[11:41:59.806]                               parallel_sendData(master, data)
[11:41:59.806]                             }
[11:41:59.806]                             return(sendCondition)
[11:41:59.806]                           }
[11:41:59.806]                         }
[11:41:59.806]                         frame <- frame + 1L
[11:41:59.806]                         envir <- sys.frame(frame)
[11:41:59.806]                       }
[11:41:59.806]                     }
[11:41:59.806]                     sendCondition <<- function(cond) NULL
[11:41:59.806]                   }
[11:41:59.806]                 })
[11:41:59.806]                 withCallingHandlers({
[11:41:59.806]                   {
[11:41:59.806]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:59.806]                     if (!identical(...future.globals.maxSize.org, 
[11:41:59.806]                       ...future.globals.maxSize)) {
[11:41:59.806]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:59.806]                       on.exit(options(oopts), add = TRUE)
[11:41:59.806]                     }
[11:41:59.806]                     {
[11:41:59.806]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:59.806]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:41:59.806]                           envir = globalenv(), inherits = FALSE)
[11:41:59.806]                         ...future.FUN(...)
[11:41:59.806]                       }
[11:41:59.806]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:59.806]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:59.806]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:41:59.806]                         USE.NAMES = FALSE)
[11:41:59.806]                       do.call(mapply, args = args)
[11:41:59.806]                     }
[11:41:59.806]                   }
[11:41:59.806]                 }, immediateCondition = function(cond) {
[11:41:59.806]                   sendCondition <- ...future.makeSendCondition()
[11:41:59.806]                   sendCondition(cond)
[11:41:59.806]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:59.806]                   {
[11:41:59.806]                     inherits <- base::inherits
[11:41:59.806]                     invokeRestart <- base::invokeRestart
[11:41:59.806]                     is.null <- base::is.null
[11:41:59.806]                     muffled <- FALSE
[11:41:59.806]                     if (inherits(cond, "message")) {
[11:41:59.806]                       muffled <- grepl(pattern, "muffleMessage")
[11:41:59.806]                       if (muffled) 
[11:41:59.806]                         invokeRestart("muffleMessage")
[11:41:59.806]                     }
[11:41:59.806]                     else if (inherits(cond, "warning")) {
[11:41:59.806]                       muffled <- grepl(pattern, "muffleWarning")
[11:41:59.806]                       if (muffled) 
[11:41:59.806]                         invokeRestart("muffleWarning")
[11:41:59.806]                     }
[11:41:59.806]                     else if (inherits(cond, "condition")) {
[11:41:59.806]                       if (!is.null(pattern)) {
[11:41:59.806]                         computeRestarts <- base::computeRestarts
[11:41:59.806]                         grepl <- base::grepl
[11:41:59.806]                         restarts <- computeRestarts(cond)
[11:41:59.806]                         for (restart in restarts) {
[11:41:59.806]                           name <- restart$name
[11:41:59.806]                           if (is.null(name)) 
[11:41:59.806]                             next
[11:41:59.806]                           if (!grepl(pattern, name)) 
[11:41:59.806]                             next
[11:41:59.806]                           invokeRestart(restart)
[11:41:59.806]                           muffled <- TRUE
[11:41:59.806]                           break
[11:41:59.806]                         }
[11:41:59.806]                       }
[11:41:59.806]                     }
[11:41:59.806]                     invisible(muffled)
[11:41:59.806]                   }
[11:41:59.806]                   muffleCondition(cond)
[11:41:59.806]                 })
[11:41:59.806]             }))
[11:41:59.806]             future::FutureResult(value = ...future.value$value, 
[11:41:59.806]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:59.806]                   ...future.rng), globalenv = if (FALSE) 
[11:41:59.806]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:41:59.806]                     ...future.globalenv.names))
[11:41:59.806]                 else NULL, started = ...future.startTime, version = "1.8")
[11:41:59.806]         }, condition = base::local({
[11:41:59.806]             c <- base::c
[11:41:59.806]             inherits <- base::inherits
[11:41:59.806]             invokeRestart <- base::invokeRestart
[11:41:59.806]             length <- base::length
[11:41:59.806]             list <- base::list
[11:41:59.806]             seq.int <- base::seq.int
[11:41:59.806]             signalCondition <- base::signalCondition
[11:41:59.806]             sys.calls <- base::sys.calls
[11:41:59.806]             `[[` <- base::`[[`
[11:41:59.806]             `+` <- base::`+`
[11:41:59.806]             `<<-` <- base::`<<-`
[11:41:59.806]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:41:59.806]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:41:59.806]                   3L)]
[11:41:59.806]             }
[11:41:59.806]             function(cond) {
[11:41:59.806]                 is_error <- inherits(cond, "error")
[11:41:59.806]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:41:59.806]                   NULL)
[11:41:59.806]                 if (is_error) {
[11:41:59.806]                   sessionInformation <- function() {
[11:41:59.806]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:41:59.806]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:41:59.806]                       search = base::search(), system = base::Sys.info())
[11:41:59.806]                   }
[11:41:59.806]                   ...future.conditions[[length(...future.conditions) + 
[11:41:59.806]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:41:59.806]                     cond$call), session = sessionInformation(), 
[11:41:59.806]                     timestamp = base::Sys.time(), signaled = 0L)
[11:41:59.806]                   signalCondition(cond)
[11:41:59.806]                 }
[11:41:59.806]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:41:59.806]                 "immediateCondition"))) {
[11:41:59.806]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:41:59.806]                   ...future.conditions[[length(...future.conditions) + 
[11:41:59.806]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:41:59.806]                   if (TRUE && !signal) {
[11:41:59.806]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:59.806]                     {
[11:41:59.806]                       inherits <- base::inherits
[11:41:59.806]                       invokeRestart <- base::invokeRestart
[11:41:59.806]                       is.null <- base::is.null
[11:41:59.806]                       muffled <- FALSE
[11:41:59.806]                       if (inherits(cond, "message")) {
[11:41:59.806]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:59.806]                         if (muffled) 
[11:41:59.806]                           invokeRestart("muffleMessage")
[11:41:59.806]                       }
[11:41:59.806]                       else if (inherits(cond, "warning")) {
[11:41:59.806]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:59.806]                         if (muffled) 
[11:41:59.806]                           invokeRestart("muffleWarning")
[11:41:59.806]                       }
[11:41:59.806]                       else if (inherits(cond, "condition")) {
[11:41:59.806]                         if (!is.null(pattern)) {
[11:41:59.806]                           computeRestarts <- base::computeRestarts
[11:41:59.806]                           grepl <- base::grepl
[11:41:59.806]                           restarts <- computeRestarts(cond)
[11:41:59.806]                           for (restart in restarts) {
[11:41:59.806]                             name <- restart$name
[11:41:59.806]                             if (is.null(name)) 
[11:41:59.806]                               next
[11:41:59.806]                             if (!grepl(pattern, name)) 
[11:41:59.806]                               next
[11:41:59.806]                             invokeRestart(restart)
[11:41:59.806]                             muffled <- TRUE
[11:41:59.806]                             break
[11:41:59.806]                           }
[11:41:59.806]                         }
[11:41:59.806]                       }
[11:41:59.806]                       invisible(muffled)
[11:41:59.806]                     }
[11:41:59.806]                     muffleCondition(cond, pattern = "^muffle")
[11:41:59.806]                   }
[11:41:59.806]                 }
[11:41:59.806]                 else {
[11:41:59.806]                   if (TRUE) {
[11:41:59.806]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:41:59.806]                     {
[11:41:59.806]                       inherits <- base::inherits
[11:41:59.806]                       invokeRestart <- base::invokeRestart
[11:41:59.806]                       is.null <- base::is.null
[11:41:59.806]                       muffled <- FALSE
[11:41:59.806]                       if (inherits(cond, "message")) {
[11:41:59.806]                         muffled <- grepl(pattern, "muffleMessage")
[11:41:59.806]                         if (muffled) 
[11:41:59.806]                           invokeRestart("muffleMessage")
[11:41:59.806]                       }
[11:41:59.806]                       else if (inherits(cond, "warning")) {
[11:41:59.806]                         muffled <- grepl(pattern, "muffleWarning")
[11:41:59.806]                         if (muffled) 
[11:41:59.806]                           invokeRestart("muffleWarning")
[11:41:59.806]                       }
[11:41:59.806]                       else if (inherits(cond, "condition")) {
[11:41:59.806]                         if (!is.null(pattern)) {
[11:41:59.806]                           computeRestarts <- base::computeRestarts
[11:41:59.806]                           grepl <- base::grepl
[11:41:59.806]                           restarts <- computeRestarts(cond)
[11:41:59.806]                           for (restart in restarts) {
[11:41:59.806]                             name <- restart$name
[11:41:59.806]                             if (is.null(name)) 
[11:41:59.806]                               next
[11:41:59.806]                             if (!grepl(pattern, name)) 
[11:41:59.806]                               next
[11:41:59.806]                             invokeRestart(restart)
[11:41:59.806]                             muffled <- TRUE
[11:41:59.806]                             break
[11:41:59.806]                           }
[11:41:59.806]                         }
[11:41:59.806]                       }
[11:41:59.806]                       invisible(muffled)
[11:41:59.806]                     }
[11:41:59.806]                     muffleCondition(cond, pattern = "^muffle")
[11:41:59.806]                   }
[11:41:59.806]                 }
[11:41:59.806]             }
[11:41:59.806]         }))
[11:41:59.806]     }, error = function(ex) {
[11:41:59.806]         base::structure(base::list(value = NULL, visible = NULL, 
[11:41:59.806]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:41:59.806]                 ...future.rng), started = ...future.startTime, 
[11:41:59.806]             finished = Sys.time(), session_uuid = NA_character_, 
[11:41:59.806]             version = "1.8"), class = "FutureResult")
[11:41:59.806]     }, finally = {
[11:41:59.806]         if (!identical(...future.workdir, getwd())) 
[11:41:59.806]             setwd(...future.workdir)
[11:41:59.806]         {
[11:41:59.806]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:41:59.806]                 ...future.oldOptions$nwarnings <- NULL
[11:41:59.806]             }
[11:41:59.806]             base::options(...future.oldOptions)
[11:41:59.806]             if (.Platform$OS.type == "windows") {
[11:41:59.806]                 old_names <- names(...future.oldEnvVars)
[11:41:59.806]                 envs <- base::Sys.getenv()
[11:41:59.806]                 names <- names(envs)
[11:41:59.806]                 common <- intersect(names, old_names)
[11:41:59.806]                 added <- setdiff(names, old_names)
[11:41:59.806]                 removed <- setdiff(old_names, names)
[11:41:59.806]                 changed <- common[...future.oldEnvVars[common] != 
[11:41:59.806]                   envs[common]]
[11:41:59.806]                 NAMES <- toupper(changed)
[11:41:59.806]                 args <- list()
[11:41:59.806]                 for (kk in seq_along(NAMES)) {
[11:41:59.806]                   name <- changed[[kk]]
[11:41:59.806]                   NAME <- NAMES[[kk]]
[11:41:59.806]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:59.806]                     next
[11:41:59.806]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:59.806]                 }
[11:41:59.806]                 NAMES <- toupper(added)
[11:41:59.806]                 for (kk in seq_along(NAMES)) {
[11:41:59.806]                   name <- added[[kk]]
[11:41:59.806]                   NAME <- NAMES[[kk]]
[11:41:59.806]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:59.806]                     next
[11:41:59.806]                   args[[name]] <- ""
[11:41:59.806]                 }
[11:41:59.806]                 NAMES <- toupper(removed)
[11:41:59.806]                 for (kk in seq_along(NAMES)) {
[11:41:59.806]                   name <- removed[[kk]]
[11:41:59.806]                   NAME <- NAMES[[kk]]
[11:41:59.806]                   if (name != NAME && is.element(NAME, old_names)) 
[11:41:59.806]                     next
[11:41:59.806]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:41:59.806]                 }
[11:41:59.806]                 if (length(args) > 0) 
[11:41:59.806]                   base::do.call(base::Sys.setenv, args = args)
[11:41:59.806]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:41:59.806]             }
[11:41:59.806]             else {
[11:41:59.806]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:41:59.806]             }
[11:41:59.806]             {
[11:41:59.806]                 if (base::length(...future.futureOptionsAdded) > 
[11:41:59.806]                   0L) {
[11:41:59.806]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:41:59.806]                   base::names(opts) <- ...future.futureOptionsAdded
[11:41:59.806]                   base::options(opts)
[11:41:59.806]                 }
[11:41:59.806]                 {
[11:41:59.806]                   {
[11:41:59.806]                     base::options(mc.cores = ...future.mc.cores.old)
[11:41:59.806]                     NULL
[11:41:59.806]                   }
[11:41:59.806]                   options(future.plan = NULL)
[11:41:59.806]                   if (is.na(NA_character_)) 
[11:41:59.806]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:41:59.806]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:41:59.806]                   future::plan(list(function (..., workers = 2, 
[11:41:59.806]                     envir = parent.frame()) 
[11:41:59.806]                   strategy(..., workers = workers, envir = envir)), 
[11:41:59.806]                     .cleanup = FALSE, .init = FALSE)
[11:41:59.806]                 }
[11:41:59.806]             }
[11:41:59.806]         }
[11:41:59.806]     })
[11:41:59.806]     if (TRUE) {
[11:41:59.806]         base::sink(type = "output", split = FALSE)
[11:41:59.806]         if (TRUE) {
[11:41:59.806]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:41:59.806]         }
[11:41:59.806]         else {
[11:41:59.806]             ...future.result["stdout"] <- base::list(NULL)
[11:41:59.806]         }
[11:41:59.806]         base::close(...future.stdout)
[11:41:59.806]         ...future.stdout <- NULL
[11:41:59.806]     }
[11:41:59.806]     ...future.result$conditions <- ...future.conditions
[11:41:59.806]     ...future.result$finished <- base::Sys.time()
[11:41:59.806]     ...future.result
[11:41:59.806] }
[11:41:59.807] Poll #1 (0): usedNodes() = 2, workers = 2
[11:41:59.818] receiveMessageFromWorker() for ClusterFuture ...
[11:41:59.819] - Validating connection of MultisessionFuture
[11:41:59.819] - received message: FutureResult
[11:41:59.819] - Received FutureResult
[11:41:59.819] - Erased future from FutureRegistry
[11:41:59.819] result() for ClusterFuture ...
[11:41:59.820] - result already collected: FutureResult
[11:41:59.820] result() for ClusterFuture ... done
[11:41:59.820] receiveMessageFromWorker() for ClusterFuture ... done
[11:41:59.820] result() for ClusterFuture ...
[11:41:59.820] - result already collected: FutureResult
[11:41:59.820] result() for ClusterFuture ... done
[11:41:59.820] result() for ClusterFuture ...
[11:41:59.820] - result already collected: FutureResult
[11:41:59.820] result() for ClusterFuture ... done
[11:41:59.821] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:41:59.822] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:41:59.865] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:41:59.870] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:41:59.917] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:41:59.917] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:41:59.961] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:41:59.962] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:41:59.962] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:41:59.962] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:41:59.963] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:41:59.963] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:41:59.964] MultisessionFuture started
[11:41:59.964] - Launch lazy future ... done
[11:41:59.964] run() for ‘MultisessionFuture’ ... done
[11:41:59.964] Created future:
[11:41:59.964] MultisessionFuture:
[11:41:59.964] Label: ‘future_mapply-79’
[11:41:59.964] Expression:
[11:41:59.964] {
[11:41:59.964]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:41:59.964]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:41:59.964]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:41:59.964]         on.exit(options(oopts), add = TRUE)
[11:41:59.964]     }
[11:41:59.964]     {
[11:41:59.964]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:41:59.964]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:41:59.964]                 inherits = FALSE)
[11:41:59.964]             ...future.FUN(...)
[11:41:59.964]         }
[11:41:59.964]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:41:59.964]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:41:59.964]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:41:59.964]         do.call(mapply, args = args)
[11:41:59.964]     }
[11:41:59.964] }
[11:41:59.964] Lazy evaluation: FALSE
[11:41:59.964] Asynchronous evaluation: TRUE
[11:41:59.964] Local evaluation: TRUE
[11:41:59.964] Environment: 0x560ef58e1768
[11:41:59.964] Capture standard output: TRUE
[11:41:59.964] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:41:59.964] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:41:59.964] Packages: 1 packages (‘mlr3’)
[11:41:59.964] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:41:59.964] Resolved: FALSE
[11:41:59.964] Value: <not collected>
[11:41:59.964] Conditions captured: <none>
[11:41:59.964] Early signaling: FALSE
[11:41:59.964] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:41:59.964] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:59.981] Chunk #79 of 90 ... DONE
[11:41:59.981] Chunk #80 of 90 ...
[11:41:59.981]  - seeds: [1] <seeds>
[11:41:59.981] getGlobalsAndPackages() ...
[11:41:59.981] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:59.981] Resolving globals: FALSE
[11:41:59.982] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:41:59.982] - packages: [1] ‘mlr3’
[11:41:59.982] getGlobalsAndPackages() ... DONE
[11:41:59.983] run() for ‘Future’ ...
[11:41:59.983] - state: ‘created’
[11:41:59.983] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:41:59.999] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:41:59.999] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:42:00.000]   - Field: ‘node’
[11:42:00.000]   - Field: ‘label’
[11:42:00.000]   - Field: ‘local’
[11:42:00.000]   - Field: ‘owner’
[11:42:00.000]   - Field: ‘envir’
[11:42:00.000]   - Field: ‘workers’
[11:42:00.000]   - Field: ‘packages’
[11:42:00.000]   - Field: ‘gc’
[11:42:00.000]   - Field: ‘conditions’
[11:42:00.000]   - Field: ‘persistent’
[11:42:00.000]   - Field: ‘expr’
[11:42:00.000]   - Field: ‘uuid’
[11:42:00.000]   - Field: ‘seed’
[11:42:00.000]   - Field: ‘version’
[11:42:00.000]   - Field: ‘result’
[11:42:00.000]   - Field: ‘asynchronous’
[11:42:00.000]   - Field: ‘calls’
[11:42:00.000]   - Field: ‘globals’
[11:42:00.000]   - Field: ‘stdout’
[11:42:00.001]   - Field: ‘earlySignal’
[11:42:00.001]   - Field: ‘lazy’
[11:42:00.001]   - Field: ‘state’
[11:42:00.001] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:42:00.001] - Launch lazy future ...
[11:42:00.001] Packages needed by the future expression (n = 1): ‘mlr3’
[11:42:00.001] Packages needed by future strategies (n = 0): <none>
[11:42:00.001] {
[11:42:00.001]     {
[11:42:00.001]         {
[11:42:00.001]             ...future.startTime <- base::Sys.time()
[11:42:00.001]             {
[11:42:00.001]                 {
[11:42:00.001]                   {
[11:42:00.001]                     {
[11:42:00.001]                       {
[11:42:00.001]                         base::local({
[11:42:00.001]                           has_future <- base::requireNamespace("future", 
[11:42:00.001]                             quietly = TRUE)
[11:42:00.001]                           if (has_future) {
[11:42:00.001]                             ns <- base::getNamespace("future")
[11:42:00.001]                             version <- ns[[".package"]][["version"]]
[11:42:00.001]                             if (is.null(version)) 
[11:42:00.001]                               version <- utils::packageVersion("future")
[11:42:00.001]                           }
[11:42:00.001]                           else {
[11:42:00.001]                             version <- NULL
[11:42:00.001]                           }
[11:42:00.001]                           if (!has_future || version < "1.8.0") {
[11:42:00.001]                             info <- base::c(r_version = base::gsub("R version ", 
[11:42:00.001]                               "", base::R.version$version.string), 
[11:42:00.001]                               platform = base::sprintf("%s (%s-bit)", 
[11:42:00.001]                                 base::R.version$platform, 8 * 
[11:42:00.001]                                   base::.Machine$sizeof.pointer), 
[11:42:00.001]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:42:00.001]                                 "release", "version")], collapse = " "), 
[11:42:00.001]                               hostname = base::Sys.info()[["nodename"]])
[11:42:00.001]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:42:00.001]                               info)
[11:42:00.001]                             info <- base::paste(info, collapse = "; ")
[11:42:00.001]                             if (!has_future) {
[11:42:00.001]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:42:00.001]                                 info)
[11:42:00.001]                             }
[11:42:00.001]                             else {
[11:42:00.001]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:42:00.001]                                 info, version)
[11:42:00.001]                             }
[11:42:00.001]                             base::stop(msg)
[11:42:00.001]                           }
[11:42:00.001]                         })
[11:42:00.001]                       }
[11:42:00.001]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:42:00.001]                       base::options(mc.cores = 1L)
[11:42:00.001]                     }
[11:42:00.001]                     base::local({
[11:42:00.001]                       for (pkg in "mlr3") {
[11:42:00.001]                         base::loadNamespace(pkg)
[11:42:00.001]                         base::library(pkg, character.only = TRUE)
[11:42:00.001]                       }
[11:42:00.001]                     })
[11:42:00.001]                   }
[11:42:00.001]                   options(future.plan = NULL)
[11:42:00.001]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:42:00.001]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:42:00.001]                 }
[11:42:00.001]                 ...future.workdir <- getwd()
[11:42:00.001]             }
[11:42:00.001]             ...future.oldOptions <- base::as.list(base::.Options)
[11:42:00.001]             ...future.oldEnvVars <- base::Sys.getenv()
[11:42:00.001]         }
[11:42:00.001]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:42:00.001]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:42:00.001]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:42:00.001]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:42:00.001]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:42:00.001]             future.stdout.windows.reencode = NULL, width = 400L)
[11:42:00.001]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:42:00.001]             base::names(...future.oldOptions))
[11:42:00.001]     }
[11:42:00.001]     if (FALSE) {
[11:42:00.001]     }
[11:42:00.001]     else {
[11:42:00.001]         if (TRUE) {
[11:42:00.001]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:42:00.001]                 open = "w")
[11:42:00.001]         }
[11:42:00.001]         else {
[11:42:00.001]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:42:00.001]                 windows = "NUL", "/dev/null"), open = "w")
[11:42:00.001]         }
[11:42:00.001]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:42:00.001]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:42:00.001]             base::sink(type = "output", split = FALSE)
[11:42:00.001]             base::close(...future.stdout)
[11:42:00.001]         }, add = TRUE)
[11:42:00.001]     }
[11:42:00.001]     ...future.frame <- base::sys.nframe()
[11:42:00.001]     ...future.conditions <- base::list()
[11:42:00.001]     ...future.rng <- base::globalenv()$.Random.seed
[11:42:00.001]     if (FALSE) {
[11:42:00.001]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:42:00.001]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:42:00.001]     }
[11:42:00.001]     ...future.result <- base::tryCatch({
[11:42:00.001]         base::withCallingHandlers({
[11:42:00.001]             ...future.value <- base::withVisible(base::local({
[11:42:00.001]                 ...future.makeSendCondition <- local({
[11:42:00.001]                   sendCondition <- NULL
[11:42:00.001]                   function(frame = 1L) {
[11:42:00.001]                     if (is.function(sendCondition)) 
[11:42:00.001]                       return(sendCondition)
[11:42:00.001]                     ns <- getNamespace("parallel")
[11:42:00.001]                     if (exists("sendData", mode = "function", 
[11:42:00.001]                       envir = ns)) {
[11:42:00.001]                       parallel_sendData <- get("sendData", mode = "function", 
[11:42:00.001]                         envir = ns)
[11:42:00.001]                       envir <- sys.frame(frame)
[11:42:00.001]                       master <- NULL
[11:42:00.001]                       while (!identical(envir, .GlobalEnv) && 
[11:42:00.001]                         !identical(envir, emptyenv())) {
[11:42:00.001]                         if (exists("master", mode = "list", envir = envir, 
[11:42:00.001]                           inherits = FALSE)) {
[11:42:00.001]                           master <- get("master", mode = "list", 
[11:42:00.001]                             envir = envir, inherits = FALSE)
[11:42:00.001]                           if (inherits(master, c("SOCKnode", 
[11:42:00.001]                             "SOCK0node"))) {
[11:42:00.001]                             sendCondition <<- function(cond) {
[11:42:00.001]                               data <- list(type = "VALUE", value = cond, 
[11:42:00.001]                                 success = TRUE)
[11:42:00.001]                               parallel_sendData(master, data)
[11:42:00.001]                             }
[11:42:00.001]                             return(sendCondition)
[11:42:00.001]                           }
[11:42:00.001]                         }
[11:42:00.001]                         frame <- frame + 1L
[11:42:00.001]                         envir <- sys.frame(frame)
[11:42:00.001]                       }
[11:42:00.001]                     }
[11:42:00.001]                     sendCondition <<- function(cond) NULL
[11:42:00.001]                   }
[11:42:00.001]                 })
[11:42:00.001]                 withCallingHandlers({
[11:42:00.001]                   {
[11:42:00.001]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:42:00.001]                     if (!identical(...future.globals.maxSize.org, 
[11:42:00.001]                       ...future.globals.maxSize)) {
[11:42:00.001]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:42:00.001]                       on.exit(options(oopts), add = TRUE)
[11:42:00.001]                     }
[11:42:00.001]                     {
[11:42:00.001]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:42:00.001]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:42:00.001]                           envir = globalenv(), inherits = FALSE)
[11:42:00.001]                         ...future.FUN(...)
[11:42:00.001]                       }
[11:42:00.001]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:42:00.001]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:42:00.001]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:42:00.001]                         USE.NAMES = FALSE)
[11:42:00.001]                       do.call(mapply, args = args)
[11:42:00.001]                     }
[11:42:00.001]                   }
[11:42:00.001]                 }, immediateCondition = function(cond) {
[11:42:00.001]                   sendCondition <- ...future.makeSendCondition()
[11:42:00.001]                   sendCondition(cond)
[11:42:00.001]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:00.001]                   {
[11:42:00.001]                     inherits <- base::inherits
[11:42:00.001]                     invokeRestart <- base::invokeRestart
[11:42:00.001]                     is.null <- base::is.null
[11:42:00.001]                     muffled <- FALSE
[11:42:00.001]                     if (inherits(cond, "message")) {
[11:42:00.001]                       muffled <- grepl(pattern, "muffleMessage")
[11:42:00.001]                       if (muffled) 
[11:42:00.001]                         invokeRestart("muffleMessage")
[11:42:00.001]                     }
[11:42:00.001]                     else if (inherits(cond, "warning")) {
[11:42:00.001]                       muffled <- grepl(pattern, "muffleWarning")
[11:42:00.001]                       if (muffled) 
[11:42:00.001]                         invokeRestart("muffleWarning")
[11:42:00.001]                     }
[11:42:00.001]                     else if (inherits(cond, "condition")) {
[11:42:00.001]                       if (!is.null(pattern)) {
[11:42:00.001]                         computeRestarts <- base::computeRestarts
[11:42:00.001]                         grepl <- base::grepl
[11:42:00.001]                         restarts <- computeRestarts(cond)
[11:42:00.001]                         for (restart in restarts) {
[11:42:00.001]                           name <- restart$name
[11:42:00.001]                           if (is.null(name)) 
[11:42:00.001]                             next
[11:42:00.001]                           if (!grepl(pattern, name)) 
[11:42:00.001]                             next
[11:42:00.001]                           invokeRestart(restart)
[11:42:00.001]                           muffled <- TRUE
[11:42:00.001]                           break
[11:42:00.001]                         }
[11:42:00.001]                       }
[11:42:00.001]                     }
[11:42:00.001]                     invisible(muffled)
[11:42:00.001]                   }
[11:42:00.001]                   muffleCondition(cond)
[11:42:00.001]                 })
[11:42:00.001]             }))
[11:42:00.001]             future::FutureResult(value = ...future.value$value, 
[11:42:00.001]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:42:00.001]                   ...future.rng), globalenv = if (FALSE) 
[11:42:00.001]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:42:00.001]                     ...future.globalenv.names))
[11:42:00.001]                 else NULL, started = ...future.startTime, version = "1.8")
[11:42:00.001]         }, condition = base::local({
[11:42:00.001]             c <- base::c
[11:42:00.001]             inherits <- base::inherits
[11:42:00.001]             invokeRestart <- base::invokeRestart
[11:42:00.001]             length <- base::length
[11:42:00.001]             list <- base::list
[11:42:00.001]             seq.int <- base::seq.int
[11:42:00.001]             signalCondition <- base::signalCondition
[11:42:00.001]             sys.calls <- base::sys.calls
[11:42:00.001]             `[[` <- base::`[[`
[11:42:00.001]             `+` <- base::`+`
[11:42:00.001]             `<<-` <- base::`<<-`
[11:42:00.001]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:42:00.001]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:42:00.001]                   3L)]
[11:42:00.001]             }
[11:42:00.001]             function(cond) {
[11:42:00.001]                 is_error <- inherits(cond, "error")
[11:42:00.001]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:42:00.001]                   NULL)
[11:42:00.001]                 if (is_error) {
[11:42:00.001]                   sessionInformation <- function() {
[11:42:00.001]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:42:00.001]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:42:00.001]                       search = base::search(), system = base::Sys.info())
[11:42:00.001]                   }
[11:42:00.001]                   ...future.conditions[[length(...future.conditions) + 
[11:42:00.001]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:42:00.001]                     cond$call), session = sessionInformation(), 
[11:42:00.001]                     timestamp = base::Sys.time(), signaled = 0L)
[11:42:00.001]                   signalCondition(cond)
[11:42:00.001]                 }
[11:42:00.001]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:42:00.001]                 "immediateCondition"))) {
[11:42:00.001]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:42:00.001]                   ...future.conditions[[length(...future.conditions) + 
[11:42:00.001]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:42:00.001]                   if (TRUE && !signal) {
[11:42:00.001]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:00.001]                     {
[11:42:00.001]                       inherits <- base::inherits
[11:42:00.001]                       invokeRestart <- base::invokeRestart
[11:42:00.001]                       is.null <- base::is.null
[11:42:00.001]                       muffled <- FALSE
[11:42:00.001]                       if (inherits(cond, "message")) {
[11:42:00.001]                         muffled <- grepl(pattern, "muffleMessage")
[11:42:00.001]                         if (muffled) 
[11:42:00.001]                           invokeRestart("muffleMessage")
[11:42:00.001]                       }
[11:42:00.001]                       else if (inherits(cond, "warning")) {
[11:42:00.001]                         muffled <- grepl(pattern, "muffleWarning")
[11:42:00.001]                         if (muffled) 
[11:42:00.001]                           invokeRestart("muffleWarning")
[11:42:00.001]                       }
[11:42:00.001]                       else if (inherits(cond, "condition")) {
[11:42:00.001]                         if (!is.null(pattern)) {
[11:42:00.001]                           computeRestarts <- base::computeRestarts
[11:42:00.001]                           grepl <- base::grepl
[11:42:00.001]                           restarts <- computeRestarts(cond)
[11:42:00.001]                           for (restart in restarts) {
[11:42:00.001]                             name <- restart$name
[11:42:00.001]                             if (is.null(name)) 
[11:42:00.001]                               next
[11:42:00.001]                             if (!grepl(pattern, name)) 
[11:42:00.001]                               next
[11:42:00.001]                             invokeRestart(restart)
[11:42:00.001]                             muffled <- TRUE
[11:42:00.001]                             break
[11:42:00.001]                           }
[11:42:00.001]                         }
[11:42:00.001]                       }
[11:42:00.001]                       invisible(muffled)
[11:42:00.001]                     }
[11:42:00.001]                     muffleCondition(cond, pattern = "^muffle")
[11:42:00.001]                   }
[11:42:00.001]                 }
[11:42:00.001]                 else {
[11:42:00.001]                   if (TRUE) {
[11:42:00.001]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:00.001]                     {
[11:42:00.001]                       inherits <- base::inherits
[11:42:00.001]                       invokeRestart <- base::invokeRestart
[11:42:00.001]                       is.null <- base::is.null
[11:42:00.001]                       muffled <- FALSE
[11:42:00.001]                       if (inherits(cond, "message")) {
[11:42:00.001]                         muffled <- grepl(pattern, "muffleMessage")
[11:42:00.001]                         if (muffled) 
[11:42:00.001]                           invokeRestart("muffleMessage")
[11:42:00.001]                       }
[11:42:00.001]                       else if (inherits(cond, "warning")) {
[11:42:00.001]                         muffled <- grepl(pattern, "muffleWarning")
[11:42:00.001]                         if (muffled) 
[11:42:00.001]                           invokeRestart("muffleWarning")
[11:42:00.001]                       }
[11:42:00.001]                       else if (inherits(cond, "condition")) {
[11:42:00.001]                         if (!is.null(pattern)) {
[11:42:00.001]                           computeRestarts <- base::computeRestarts
[11:42:00.001]                           grepl <- base::grepl
[11:42:00.001]                           restarts <- computeRestarts(cond)
[11:42:00.001]                           for (restart in restarts) {
[11:42:00.001]                             name <- restart$name
[11:42:00.001]                             if (is.null(name)) 
[11:42:00.001]                               next
[11:42:00.001]                             if (!grepl(pattern, name)) 
[11:42:00.001]                               next
[11:42:00.001]                             invokeRestart(restart)
[11:42:00.001]                             muffled <- TRUE
[11:42:00.001]                             break
[11:42:00.001]                           }
[11:42:00.001]                         }
[11:42:00.001]                       }
[11:42:00.001]                       invisible(muffled)
[11:42:00.001]                     }
[11:42:00.001]                     muffleCondition(cond, pattern = "^muffle")
[11:42:00.001]                   }
[11:42:00.001]                 }
[11:42:00.001]             }
[11:42:00.001]         }))
[11:42:00.001]     }, error = function(ex) {
[11:42:00.001]         base::structure(base::list(value = NULL, visible = NULL, 
[11:42:00.001]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:42:00.001]                 ...future.rng), started = ...future.startTime, 
[11:42:00.001]             finished = Sys.time(), session_uuid = NA_character_, 
[11:42:00.001]             version = "1.8"), class = "FutureResult")
[11:42:00.001]     }, finally = {
[11:42:00.001]         if (!identical(...future.workdir, getwd())) 
[11:42:00.001]             setwd(...future.workdir)
[11:42:00.001]         {
[11:42:00.001]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:42:00.001]                 ...future.oldOptions$nwarnings <- NULL
[11:42:00.001]             }
[11:42:00.001]             base::options(...future.oldOptions)
[11:42:00.001]             if (.Platform$OS.type == "windows") {
[11:42:00.001]                 old_names <- names(...future.oldEnvVars)
[11:42:00.001]                 envs <- base::Sys.getenv()
[11:42:00.001]                 names <- names(envs)
[11:42:00.001]                 common <- intersect(names, old_names)
[11:42:00.001]                 added <- setdiff(names, old_names)
[11:42:00.001]                 removed <- setdiff(old_names, names)
[11:42:00.001]                 changed <- common[...future.oldEnvVars[common] != 
[11:42:00.001]                   envs[common]]
[11:42:00.001]                 NAMES <- toupper(changed)
[11:42:00.001]                 args <- list()
[11:42:00.001]                 for (kk in seq_along(NAMES)) {
[11:42:00.001]                   name <- changed[[kk]]
[11:42:00.001]                   NAME <- NAMES[[kk]]
[11:42:00.001]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:00.001]                     next
[11:42:00.001]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:42:00.001]                 }
[11:42:00.001]                 NAMES <- toupper(added)
[11:42:00.001]                 for (kk in seq_along(NAMES)) {
[11:42:00.001]                   name <- added[[kk]]
[11:42:00.001]                   NAME <- NAMES[[kk]]
[11:42:00.001]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:00.001]                     next
[11:42:00.001]                   args[[name]] <- ""
[11:42:00.001]                 }
[11:42:00.001]                 NAMES <- toupper(removed)
[11:42:00.001]                 for (kk in seq_along(NAMES)) {
[11:42:00.001]                   name <- removed[[kk]]
[11:42:00.001]                   NAME <- NAMES[[kk]]
[11:42:00.001]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:00.001]                     next
[11:42:00.001]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:42:00.001]                 }
[11:42:00.001]                 if (length(args) > 0) 
[11:42:00.001]                   base::do.call(base::Sys.setenv, args = args)
[11:42:00.001]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:42:00.001]             }
[11:42:00.001]             else {
[11:42:00.001]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:42:00.001]             }
[11:42:00.001]             {
[11:42:00.001]                 if (base::length(...future.futureOptionsAdded) > 
[11:42:00.001]                   0L) {
[11:42:00.001]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:42:00.001]                   base::names(opts) <- ...future.futureOptionsAdded
[11:42:00.001]                   base::options(opts)
[11:42:00.001]                 }
[11:42:00.001]                 {
[11:42:00.001]                   {
[11:42:00.001]                     base::options(mc.cores = ...future.mc.cores.old)
[11:42:00.001]                     NULL
[11:42:00.001]                   }
[11:42:00.001]                   options(future.plan = NULL)
[11:42:00.001]                   if (is.na(NA_character_)) 
[11:42:00.001]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:42:00.001]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:42:00.001]                   future::plan(list(function (..., workers = 2, 
[11:42:00.001]                     envir = parent.frame()) 
[11:42:00.001]                   strategy(..., workers = workers, envir = envir)), 
[11:42:00.001]                     .cleanup = FALSE, .init = FALSE)
[11:42:00.001]                 }
[11:42:00.001]             }
[11:42:00.001]         }
[11:42:00.001]     })
[11:42:00.001]     if (TRUE) {
[11:42:00.001]         base::sink(type = "output", split = FALSE)
[11:42:00.001]         if (TRUE) {
[11:42:00.001]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:42:00.001]         }
[11:42:00.001]         else {
[11:42:00.001]             ...future.result["stdout"] <- base::list(NULL)
[11:42:00.001]         }
[11:42:00.001]         base::close(...future.stdout)
[11:42:00.001]         ...future.stdout <- NULL
[11:42:00.001]     }
[11:42:00.001]     ...future.result$conditions <- ...future.conditions
[11:42:00.001]     ...future.result$finished <- base::Sys.time()
[11:42:00.001]     ...future.result
[11:42:00.001] }
[11:42:00.003] Poll #1 (0): usedNodes() = 2, workers = 2
[11:42:00.014] receiveMessageFromWorker() for ClusterFuture ...
[11:42:00.014] - Validating connection of MultisessionFuture
[11:42:00.015] - received message: FutureResult
[11:42:00.015] - Received FutureResult
[11:42:00.015] - Erased future from FutureRegistry
[11:42:00.015] result() for ClusterFuture ...
[11:42:00.015] - result already collected: FutureResult
[11:42:00.015] result() for ClusterFuture ... done
[11:42:00.015] receiveMessageFromWorker() for ClusterFuture ... done
[11:42:00.015] result() for ClusterFuture ...
[11:42:00.015] - result already collected: FutureResult
[11:42:00.015] result() for ClusterFuture ... done
[11:42:00.016] result() for ClusterFuture ...
[11:42:00.016] - result already collected: FutureResult
[11:42:00.016] result() for ClusterFuture ... done
[11:42:00.016] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:42:00.017] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:42:00.061] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:42:00.069] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:42:00.070] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:42:00.071] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:42:00.113] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:42:00.114] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:42:00.114] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:42:00.114] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:42:00.115] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:42:00.115] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:42:00.115] MultisessionFuture started
[11:42:00.115] - Launch lazy future ... done
[11:42:00.115] run() for ‘MultisessionFuture’ ... done
[11:42:00.116] Created future:
[11:42:00.116] MultisessionFuture:
[11:42:00.116] Label: ‘future_mapply-80’
[11:42:00.116] Expression:
[11:42:00.116] {
[11:42:00.116]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:42:00.116]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:42:00.116]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:42:00.116]         on.exit(options(oopts), add = TRUE)
[11:42:00.116]     }
[11:42:00.116]     {
[11:42:00.116]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:42:00.116]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:42:00.116]                 inherits = FALSE)
[11:42:00.116]             ...future.FUN(...)
[11:42:00.116]         }
[11:42:00.116]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:42:00.116]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:42:00.116]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:42:00.116]         do.call(mapply, args = args)
[11:42:00.116]     }
[11:42:00.116] }
[11:42:00.116] Lazy evaluation: FALSE
[11:42:00.116] Asynchronous evaluation: TRUE
[11:42:00.116] Local evaluation: TRUE
[11:42:00.116] Environment: 0x560ef58e1768
[11:42:00.116] Capture standard output: TRUE
[11:42:00.116] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:42:00.116] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:42:00.116] Packages: 1 packages (‘mlr3’)
[11:42:00.116] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:42:00.116] Resolved: FALSE
[11:42:00.116] Value: <not collected>
[11:42:00.116] Conditions captured: <none>
[11:42:00.116] Early signaling: FALSE
[11:42:00.116] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:42:00.116] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:42:00.130] Chunk #80 of 90 ... DONE
[11:42:00.130] Chunk #81 of 90 ...
[11:42:00.130]  - seeds: [1] <seeds>
[11:42:00.130] getGlobalsAndPackages() ...
[11:42:00.131] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:42:00.131] Resolving globals: FALSE
[11:42:00.131] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:42:00.131] - packages: [1] ‘mlr3’
[11:42:00.131] getGlobalsAndPackages() ... DONE
[11:42:00.131] run() for ‘Future’ ...
[11:42:00.131] - state: ‘created’
[11:42:00.132] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:42:00.142] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:42:00.142] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:42:00.142]   - Field: ‘node’
[11:42:00.142]   - Field: ‘label’
[11:42:00.143]   - Field: ‘local’
[11:42:00.143]   - Field: ‘owner’
[11:42:00.143]   - Field: ‘envir’
[11:42:00.143]   - Field: ‘workers’
[11:42:00.143]   - Field: ‘packages’
[11:42:00.143]   - Field: ‘gc’
[11:42:00.143]   - Field: ‘conditions’
[11:42:00.143]   - Field: ‘persistent’
[11:42:00.143]   - Field: ‘expr’
[11:42:00.143]   - Field: ‘uuid’
[11:42:00.143]   - Field: ‘seed’
[11:42:00.143]   - Field: ‘version’
[11:42:00.143]   - Field: ‘result’
[11:42:00.143]   - Field: ‘asynchronous’
[11:42:00.143]   - Field: ‘calls’
[11:42:00.143]   - Field: ‘globals’
[11:42:00.143]   - Field: ‘stdout’
[11:42:00.143]   - Field: ‘earlySignal’
[11:42:00.143]   - Field: ‘lazy’
[11:42:00.143]   - Field: ‘state’
[11:42:00.144] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:42:00.144] - Launch lazy future ...
[11:42:00.144] Packages needed by the future expression (n = 1): ‘mlr3’
[11:42:00.144] Packages needed by future strategies (n = 0): <none>
[11:42:00.144] {
[11:42:00.144]     {
[11:42:00.144]         {
[11:42:00.144]             ...future.startTime <- base::Sys.time()
[11:42:00.144]             {
[11:42:00.144]                 {
[11:42:00.144]                   {
[11:42:00.144]                     {
[11:42:00.144]                       {
[11:42:00.144]                         base::local({
[11:42:00.144]                           has_future <- base::requireNamespace("future", 
[11:42:00.144]                             quietly = TRUE)
[11:42:00.144]                           if (has_future) {
[11:42:00.144]                             ns <- base::getNamespace("future")
[11:42:00.144]                             version <- ns[[".package"]][["version"]]
[11:42:00.144]                             if (is.null(version)) 
[11:42:00.144]                               version <- utils::packageVersion("future")
[11:42:00.144]                           }
[11:42:00.144]                           else {
[11:42:00.144]                             version <- NULL
[11:42:00.144]                           }
[11:42:00.144]                           if (!has_future || version < "1.8.0") {
[11:42:00.144]                             info <- base::c(r_version = base::gsub("R version ", 
[11:42:00.144]                               "", base::R.version$version.string), 
[11:42:00.144]                               platform = base::sprintf("%s (%s-bit)", 
[11:42:00.144]                                 base::R.version$platform, 8 * 
[11:42:00.144]                                   base::.Machine$sizeof.pointer), 
[11:42:00.144]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:42:00.144]                                 "release", "version")], collapse = " "), 
[11:42:00.144]                               hostname = base::Sys.info()[["nodename"]])
[11:42:00.144]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:42:00.144]                               info)
[11:42:00.144]                             info <- base::paste(info, collapse = "; ")
[11:42:00.144]                             if (!has_future) {
[11:42:00.144]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:42:00.144]                                 info)
[11:42:00.144]                             }
[11:42:00.144]                             else {
[11:42:00.144]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:42:00.144]                                 info, version)
[11:42:00.144]                             }
[11:42:00.144]                             base::stop(msg)
[11:42:00.144]                           }
[11:42:00.144]                         })
[11:42:00.144]                       }
[11:42:00.144]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:42:00.144]                       base::options(mc.cores = 1L)
[11:42:00.144]                     }
[11:42:00.144]                     base::local({
[11:42:00.144]                       for (pkg in "mlr3") {
[11:42:00.144]                         base::loadNamespace(pkg)
[11:42:00.144]                         base::library(pkg, character.only = TRUE)
[11:42:00.144]                       }
[11:42:00.144]                     })
[11:42:00.144]                   }
[11:42:00.144]                   options(future.plan = NULL)
[11:42:00.144]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:42:00.144]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:42:00.144]                 }
[11:42:00.144]                 ...future.workdir <- getwd()
[11:42:00.144]             }
[11:42:00.144]             ...future.oldOptions <- base::as.list(base::.Options)
[11:42:00.144]             ...future.oldEnvVars <- base::Sys.getenv()
[11:42:00.144]         }
[11:42:00.144]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:42:00.144]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:42:00.144]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:42:00.144]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:42:00.144]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:42:00.144]             future.stdout.windows.reencode = NULL, width = 400L)
[11:42:00.144]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:42:00.144]             base::names(...future.oldOptions))
[11:42:00.144]     }
[11:42:00.144]     if (FALSE) {
[11:42:00.144]     }
[11:42:00.144]     else {
[11:42:00.144]         if (TRUE) {
[11:42:00.144]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:42:00.144]                 open = "w")
[11:42:00.144]         }
[11:42:00.144]         else {
[11:42:00.144]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:42:00.144]                 windows = "NUL", "/dev/null"), open = "w")
[11:42:00.144]         }
[11:42:00.144]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:42:00.144]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:42:00.144]             base::sink(type = "output", split = FALSE)
[11:42:00.144]             base::close(...future.stdout)
[11:42:00.144]         }, add = TRUE)
[11:42:00.144]     }
[11:42:00.144]     ...future.frame <- base::sys.nframe()
[11:42:00.144]     ...future.conditions <- base::list()
[11:42:00.144]     ...future.rng <- base::globalenv()$.Random.seed
[11:42:00.144]     if (FALSE) {
[11:42:00.144]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:42:00.144]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:42:00.144]     }
[11:42:00.144]     ...future.result <- base::tryCatch({
[11:42:00.144]         base::withCallingHandlers({
[11:42:00.144]             ...future.value <- base::withVisible(base::local({
[11:42:00.144]                 ...future.makeSendCondition <- local({
[11:42:00.144]                   sendCondition <- NULL
[11:42:00.144]                   function(frame = 1L) {
[11:42:00.144]                     if (is.function(sendCondition)) 
[11:42:00.144]                       return(sendCondition)
[11:42:00.144]                     ns <- getNamespace("parallel")
[11:42:00.144]                     if (exists("sendData", mode = "function", 
[11:42:00.144]                       envir = ns)) {
[11:42:00.144]                       parallel_sendData <- get("sendData", mode = "function", 
[11:42:00.144]                         envir = ns)
[11:42:00.144]                       envir <- sys.frame(frame)
[11:42:00.144]                       master <- NULL
[11:42:00.144]                       while (!identical(envir, .GlobalEnv) && 
[11:42:00.144]                         !identical(envir, emptyenv())) {
[11:42:00.144]                         if (exists("master", mode = "list", envir = envir, 
[11:42:00.144]                           inherits = FALSE)) {
[11:42:00.144]                           master <- get("master", mode = "list", 
[11:42:00.144]                             envir = envir, inherits = FALSE)
[11:42:00.144]                           if (inherits(master, c("SOCKnode", 
[11:42:00.144]                             "SOCK0node"))) {
[11:42:00.144]                             sendCondition <<- function(cond) {
[11:42:00.144]                               data <- list(type = "VALUE", value = cond, 
[11:42:00.144]                                 success = TRUE)
[11:42:00.144]                               parallel_sendData(master, data)
[11:42:00.144]                             }
[11:42:00.144]                             return(sendCondition)
[11:42:00.144]                           }
[11:42:00.144]                         }
[11:42:00.144]                         frame <- frame + 1L
[11:42:00.144]                         envir <- sys.frame(frame)
[11:42:00.144]                       }
[11:42:00.144]                     }
[11:42:00.144]                     sendCondition <<- function(cond) NULL
[11:42:00.144]                   }
[11:42:00.144]                 })
[11:42:00.144]                 withCallingHandlers({
[11:42:00.144]                   {
[11:42:00.144]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:42:00.144]                     if (!identical(...future.globals.maxSize.org, 
[11:42:00.144]                       ...future.globals.maxSize)) {
[11:42:00.144]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:42:00.144]                       on.exit(options(oopts), add = TRUE)
[11:42:00.144]                     }
[11:42:00.144]                     {
[11:42:00.144]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:42:00.144]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:42:00.144]                           envir = globalenv(), inherits = FALSE)
[11:42:00.144]                         ...future.FUN(...)
[11:42:00.144]                       }
[11:42:00.144]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:42:00.144]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:42:00.144]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:42:00.144]                         USE.NAMES = FALSE)
[11:42:00.144]                       do.call(mapply, args = args)
[11:42:00.144]                     }
[11:42:00.144]                   }
[11:42:00.144]                 }, immediateCondition = function(cond) {
[11:42:00.144]                   sendCondition <- ...future.makeSendCondition()
[11:42:00.144]                   sendCondition(cond)
[11:42:00.144]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:00.144]                   {
[11:42:00.144]                     inherits <- base::inherits
[11:42:00.144]                     invokeRestart <- base::invokeRestart
[11:42:00.144]                     is.null <- base::is.null
[11:42:00.144]                     muffled <- FALSE
[11:42:00.144]                     if (inherits(cond, "message")) {
[11:42:00.144]                       muffled <- grepl(pattern, "muffleMessage")
[11:42:00.144]                       if (muffled) 
[11:42:00.144]                         invokeRestart("muffleMessage")
[11:42:00.144]                     }
[11:42:00.144]                     else if (inherits(cond, "warning")) {
[11:42:00.144]                       muffled <- grepl(pattern, "muffleWarning")
[11:42:00.144]                       if (muffled) 
[11:42:00.144]                         invokeRestart("muffleWarning")
[11:42:00.144]                     }
[11:42:00.144]                     else if (inherits(cond, "condition")) {
[11:42:00.144]                       if (!is.null(pattern)) {
[11:42:00.144]                         computeRestarts <- base::computeRestarts
[11:42:00.144]                         grepl <- base::grepl
[11:42:00.144]                         restarts <- computeRestarts(cond)
[11:42:00.144]                         for (restart in restarts) {
[11:42:00.144]                           name <- restart$name
[11:42:00.144]                           if (is.null(name)) 
[11:42:00.144]                             next
[11:42:00.144]                           if (!grepl(pattern, name)) 
[11:42:00.144]                             next
[11:42:00.144]                           invokeRestart(restart)
[11:42:00.144]                           muffled <- TRUE
[11:42:00.144]                           break
[11:42:00.144]                         }
[11:42:00.144]                       }
[11:42:00.144]                     }
[11:42:00.144]                     invisible(muffled)
[11:42:00.144]                   }
[11:42:00.144]                   muffleCondition(cond)
[11:42:00.144]                 })
[11:42:00.144]             }))
[11:42:00.144]             future::FutureResult(value = ...future.value$value, 
[11:42:00.144]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:42:00.144]                   ...future.rng), globalenv = if (FALSE) 
[11:42:00.144]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:42:00.144]                     ...future.globalenv.names))
[11:42:00.144]                 else NULL, started = ...future.startTime, version = "1.8")
[11:42:00.144]         }, condition = base::local({
[11:42:00.144]             c <- base::c
[11:42:00.144]             inherits <- base::inherits
[11:42:00.144]             invokeRestart <- base::invokeRestart
[11:42:00.144]             length <- base::length
[11:42:00.144]             list <- base::list
[11:42:00.144]             seq.int <- base::seq.int
[11:42:00.144]             signalCondition <- base::signalCondition
[11:42:00.144]             sys.calls <- base::sys.calls
[11:42:00.144]             `[[` <- base::`[[`
[11:42:00.144]             `+` <- base::`+`
[11:42:00.144]             `<<-` <- base::`<<-`
[11:42:00.144]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:42:00.144]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:42:00.144]                   3L)]
[11:42:00.144]             }
[11:42:00.144]             function(cond) {
[11:42:00.144]                 is_error <- inherits(cond, "error")
[11:42:00.144]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:42:00.144]                   NULL)
[11:42:00.144]                 if (is_error) {
[11:42:00.144]                   sessionInformation <- function() {
[11:42:00.144]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:42:00.144]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:42:00.144]                       search = base::search(), system = base::Sys.info())
[11:42:00.144]                   }
[11:42:00.144]                   ...future.conditions[[length(...future.conditions) + 
[11:42:00.144]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:42:00.144]                     cond$call), session = sessionInformation(), 
[11:42:00.144]                     timestamp = base::Sys.time(), signaled = 0L)
[11:42:00.144]                   signalCondition(cond)
[11:42:00.144]                 }
[11:42:00.144]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:42:00.144]                 "immediateCondition"))) {
[11:42:00.144]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:42:00.144]                   ...future.conditions[[length(...future.conditions) + 
[11:42:00.144]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:42:00.144]                   if (TRUE && !signal) {
[11:42:00.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:00.144]                     {
[11:42:00.144]                       inherits <- base::inherits
[11:42:00.144]                       invokeRestart <- base::invokeRestart
[11:42:00.144]                       is.null <- base::is.null
[11:42:00.144]                       muffled <- FALSE
[11:42:00.144]                       if (inherits(cond, "message")) {
[11:42:00.144]                         muffled <- grepl(pattern, "muffleMessage")
[11:42:00.144]                         if (muffled) 
[11:42:00.144]                           invokeRestart("muffleMessage")
[11:42:00.144]                       }
[11:42:00.144]                       else if (inherits(cond, "warning")) {
[11:42:00.144]                         muffled <- grepl(pattern, "muffleWarning")
[11:42:00.144]                         if (muffled) 
[11:42:00.144]                           invokeRestart("muffleWarning")
[11:42:00.144]                       }
[11:42:00.144]                       else if (inherits(cond, "condition")) {
[11:42:00.144]                         if (!is.null(pattern)) {
[11:42:00.144]                           computeRestarts <- base::computeRestarts
[11:42:00.144]                           grepl <- base::grepl
[11:42:00.144]                           restarts <- computeRestarts(cond)
[11:42:00.144]                           for (restart in restarts) {
[11:42:00.144]                             name <- restart$name
[11:42:00.144]                             if (is.null(name)) 
[11:42:00.144]                               next
[11:42:00.144]                             if (!grepl(pattern, name)) 
[11:42:00.144]                               next
[11:42:00.144]                             invokeRestart(restart)
[11:42:00.144]                             muffled <- TRUE
[11:42:00.144]                             break
[11:42:00.144]                           }
[11:42:00.144]                         }
[11:42:00.144]                       }
[11:42:00.144]                       invisible(muffled)
[11:42:00.144]                     }
[11:42:00.144]                     muffleCondition(cond, pattern = "^muffle")
[11:42:00.144]                   }
[11:42:00.144]                 }
[11:42:00.144]                 else {
[11:42:00.144]                   if (TRUE) {
[11:42:00.144]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:00.144]                     {
[11:42:00.144]                       inherits <- base::inherits
[11:42:00.144]                       invokeRestart <- base::invokeRestart
[11:42:00.144]                       is.null <- base::is.null
[11:42:00.144]                       muffled <- FALSE
[11:42:00.144]                       if (inherits(cond, "message")) {
[11:42:00.144]                         muffled <- grepl(pattern, "muffleMessage")
[11:42:00.144]                         if (muffled) 
[11:42:00.144]                           invokeRestart("muffleMessage")
[11:42:00.144]                       }
[11:42:00.144]                       else if (inherits(cond, "warning")) {
[11:42:00.144]                         muffled <- grepl(pattern, "muffleWarning")
[11:42:00.144]                         if (muffled) 
[11:42:00.144]                           invokeRestart("muffleWarning")
[11:42:00.144]                       }
[11:42:00.144]                       else if (inherits(cond, "condition")) {
[11:42:00.144]                         if (!is.null(pattern)) {
[11:42:00.144]                           computeRestarts <- base::computeRestarts
[11:42:00.144]                           grepl <- base::grepl
[11:42:00.144]                           restarts <- computeRestarts(cond)
[11:42:00.144]                           for (restart in restarts) {
[11:42:00.144]                             name <- restart$name
[11:42:00.144]                             if (is.null(name)) 
[11:42:00.144]                               next
[11:42:00.144]                             if (!grepl(pattern, name)) 
[11:42:00.144]                               next
[11:42:00.144]                             invokeRestart(restart)
[11:42:00.144]                             muffled <- TRUE
[11:42:00.144]                             break
[11:42:00.144]                           }
[11:42:00.144]                         }
[11:42:00.144]                       }
[11:42:00.144]                       invisible(muffled)
[11:42:00.144]                     }
[11:42:00.144]                     muffleCondition(cond, pattern = "^muffle")
[11:42:00.144]                   }
[11:42:00.144]                 }
[11:42:00.144]             }
[11:42:00.144]         }))
[11:42:00.144]     }, error = function(ex) {
[11:42:00.144]         base::structure(base::list(value = NULL, visible = NULL, 
[11:42:00.144]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:42:00.144]                 ...future.rng), started = ...future.startTime, 
[11:42:00.144]             finished = Sys.time(), session_uuid = NA_character_, 
[11:42:00.144]             version = "1.8"), class = "FutureResult")
[11:42:00.144]     }, finally = {
[11:42:00.144]         if (!identical(...future.workdir, getwd())) 
[11:42:00.144]             setwd(...future.workdir)
[11:42:00.144]         {
[11:42:00.144]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:42:00.144]                 ...future.oldOptions$nwarnings <- NULL
[11:42:00.144]             }
[11:42:00.144]             base::options(...future.oldOptions)
[11:42:00.144]             if (.Platform$OS.type == "windows") {
[11:42:00.144]                 old_names <- names(...future.oldEnvVars)
[11:42:00.144]                 envs <- base::Sys.getenv()
[11:42:00.144]                 names <- names(envs)
[11:42:00.144]                 common <- intersect(names, old_names)
[11:42:00.144]                 added <- setdiff(names, old_names)
[11:42:00.144]                 removed <- setdiff(old_names, names)
[11:42:00.144]                 changed <- common[...future.oldEnvVars[common] != 
[11:42:00.144]                   envs[common]]
[11:42:00.144]                 NAMES <- toupper(changed)
[11:42:00.144]                 args <- list()
[11:42:00.144]                 for (kk in seq_along(NAMES)) {
[11:42:00.144]                   name <- changed[[kk]]
[11:42:00.144]                   NAME <- NAMES[[kk]]
[11:42:00.144]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:00.144]                     next
[11:42:00.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:42:00.144]                 }
[11:42:00.144]                 NAMES <- toupper(added)
[11:42:00.144]                 for (kk in seq_along(NAMES)) {
[11:42:00.144]                   name <- added[[kk]]
[11:42:00.144]                   NAME <- NAMES[[kk]]
[11:42:00.144]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:00.144]                     next
[11:42:00.144]                   args[[name]] <- ""
[11:42:00.144]                 }
[11:42:00.144]                 NAMES <- toupper(removed)
[11:42:00.144]                 for (kk in seq_along(NAMES)) {
[11:42:00.144]                   name <- removed[[kk]]
[11:42:00.144]                   NAME <- NAMES[[kk]]
[11:42:00.144]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:00.144]                     next
[11:42:00.144]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:42:00.144]                 }
[11:42:00.144]                 if (length(args) > 0) 
[11:42:00.144]                   base::do.call(base::Sys.setenv, args = args)
[11:42:00.144]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:42:00.144]             }
[11:42:00.144]             else {
[11:42:00.144]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:42:00.144]             }
[11:42:00.144]             {
[11:42:00.144]                 if (base::length(...future.futureOptionsAdded) > 
[11:42:00.144]                   0L) {
[11:42:00.144]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:42:00.144]                   base::names(opts) <- ...future.futureOptionsAdded
[11:42:00.144]                   base::options(opts)
[11:42:00.144]                 }
[11:42:00.144]                 {
[11:42:00.144]                   {
[11:42:00.144]                     base::options(mc.cores = ...future.mc.cores.old)
[11:42:00.144]                     NULL
[11:42:00.144]                   }
[11:42:00.144]                   options(future.plan = NULL)
[11:42:00.144]                   if (is.na(NA_character_)) 
[11:42:00.144]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:42:00.144]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:42:00.144]                   future::plan(list(function (..., workers = 2, 
[11:42:00.144]                     envir = parent.frame()) 
[11:42:00.144]                   strategy(..., workers = workers, envir = envir)), 
[11:42:00.144]                     .cleanup = FALSE, .init = FALSE)
[11:42:00.144]                 }
[11:42:00.144]             }
[11:42:00.144]         }
[11:42:00.144]     })
[11:42:00.144]     if (TRUE) {
[11:42:00.144]         base::sink(type = "output", split = FALSE)
[11:42:00.144]         if (TRUE) {
[11:42:00.144]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:42:00.144]         }
[11:42:00.144]         else {
[11:42:00.144]             ...future.result["stdout"] <- base::list(NULL)
[11:42:00.144]         }
[11:42:00.144]         base::close(...future.stdout)
[11:42:00.144]         ...future.stdout <- NULL
[11:42:00.144]     }
[11:42:00.144]     ...future.result$conditions <- ...future.conditions
[11:42:00.144]     ...future.result$finished <- base::Sys.time()
[11:42:00.144]     ...future.result
[11:42:00.144] }
[11:42:00.146] Poll #1 (0): usedNodes() = 2, workers = 2
[11:42:00.157] receiveMessageFromWorker() for ClusterFuture ...
[11:42:00.157] - Validating connection of MultisessionFuture
[11:42:00.157] - received message: FutureResult
[11:42:00.158] - Received FutureResult
[11:42:00.158] - Erased future from FutureRegistry
[11:42:00.158] result() for ClusterFuture ...
[11:42:00.158] - result already collected: FutureResult
[11:42:00.158] result() for ClusterFuture ... done
[11:42:00.158] receiveMessageFromWorker() for ClusterFuture ... done
[11:42:00.158] result() for ClusterFuture ...
[11:42:00.158] - result already collected: FutureResult
[11:42:00.158] result() for ClusterFuture ... done
[11:42:00.158] result() for ClusterFuture ...
[11:42:00.158] - result already collected: FutureResult
[11:42:00.158] result() for ClusterFuture ... done
[11:42:00.159] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:42:00.159] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:42:00.201] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:42:00.206] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:42:00.249] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:42:00.250] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:42:00.293] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:42:00.294] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:42:00.295] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:42:00.295] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:42:00.296] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:42:00.296] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:42:00.297] MultisessionFuture started
[11:42:00.297] - Launch lazy future ... done
[11:42:00.297] run() for ‘MultisessionFuture’ ... done
[11:42:00.297] Created future:
[11:42:00.297] MultisessionFuture:
[11:42:00.297] Label: ‘future_mapply-81’
[11:42:00.297] Expression:
[11:42:00.297] {
[11:42:00.297]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:42:00.297]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:42:00.297]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:42:00.297]         on.exit(options(oopts), add = TRUE)
[11:42:00.297]     }
[11:42:00.297]     {
[11:42:00.297]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:42:00.297]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:42:00.297]                 inherits = FALSE)
[11:42:00.297]             ...future.FUN(...)
[11:42:00.297]         }
[11:42:00.297]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:42:00.297]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:42:00.297]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:42:00.297]         do.call(mapply, args = args)
[11:42:00.297]     }
[11:42:00.297] }
[11:42:00.297] Lazy evaluation: FALSE
[11:42:00.297] Asynchronous evaluation: TRUE
[11:42:00.297] Local evaluation: TRUE
[11:42:00.297] Environment: 0x560ef58e1768
[11:42:00.297] Capture standard output: TRUE
[11:42:00.297] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:42:00.297] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:42:00.297] Packages: 1 packages (‘mlr3’)
[11:42:00.297] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:42:00.297] Resolved: FALSE
[11:42:00.297] Value: <not collected>
[11:42:00.297] Conditions captured: <none>
[11:42:00.297] Early signaling: FALSE
[11:42:00.297] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:42:00.297] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:42:00.313] Chunk #81 of 90 ... DONE
[11:42:00.314] Chunk #82 of 90 ...
[11:42:00.314]  - seeds: [1] <seeds>
[11:42:00.314] getGlobalsAndPackages() ...
[11:42:00.314] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:42:00.314] Resolving globals: FALSE
[11:42:00.314] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:42:00.314] - packages: [1] ‘mlr3’
[11:42:00.315] getGlobalsAndPackages() ... DONE
[11:42:00.315] run() for ‘Future’ ...
[11:42:00.315] - state: ‘created’
[11:42:00.315] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:42:00.326] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:42:00.326] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:42:00.327]   - Field: ‘node’
[11:42:00.327]   - Field: ‘label’
[11:42:00.327]   - Field: ‘local’
[11:42:00.327]   - Field: ‘owner’
[11:42:00.327]   - Field: ‘envir’
[11:42:00.327]   - Field: ‘workers’
[11:42:00.327]   - Field: ‘packages’
[11:42:00.327]   - Field: ‘gc’
[11:42:00.327]   - Field: ‘conditions’
[11:42:00.327]   - Field: ‘persistent’
[11:42:00.327]   - Field: ‘expr’
[11:42:00.327]   - Field: ‘uuid’
[11:42:00.327]   - Field: ‘seed’
[11:42:00.327]   - Field: ‘version’
[11:42:00.327]   - Field: ‘result’
[11:42:00.327]   - Field: ‘asynchronous’
[11:42:00.327]   - Field: ‘calls’
[11:42:00.327]   - Field: ‘globals’
[11:42:00.327]   - Field: ‘stdout’
[11:42:00.327]   - Field: ‘earlySignal’
[11:42:00.327]   - Field: ‘lazy’
[11:42:00.328]   - Field: ‘state’
[11:42:00.328] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:42:00.328] - Launch lazy future ...
[11:42:00.328] Packages needed by the future expression (n = 1): ‘mlr3’
[11:42:00.328] Packages needed by future strategies (n = 0): <none>
[11:42:00.328] {
[11:42:00.328]     {
[11:42:00.328]         {
[11:42:00.328]             ...future.startTime <- base::Sys.time()
[11:42:00.328]             {
[11:42:00.328]                 {
[11:42:00.328]                   {
[11:42:00.328]                     {
[11:42:00.328]                       {
[11:42:00.328]                         base::local({
[11:42:00.328]                           has_future <- base::requireNamespace("future", 
[11:42:00.328]                             quietly = TRUE)
[11:42:00.328]                           if (has_future) {
[11:42:00.328]                             ns <- base::getNamespace("future")
[11:42:00.328]                             version <- ns[[".package"]][["version"]]
[11:42:00.328]                             if (is.null(version)) 
[11:42:00.328]                               version <- utils::packageVersion("future")
[11:42:00.328]                           }
[11:42:00.328]                           else {
[11:42:00.328]                             version <- NULL
[11:42:00.328]                           }
[11:42:00.328]                           if (!has_future || version < "1.8.0") {
[11:42:00.328]                             info <- base::c(r_version = base::gsub("R version ", 
[11:42:00.328]                               "", base::R.version$version.string), 
[11:42:00.328]                               platform = base::sprintf("%s (%s-bit)", 
[11:42:00.328]                                 base::R.version$platform, 8 * 
[11:42:00.328]                                   base::.Machine$sizeof.pointer), 
[11:42:00.328]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:42:00.328]                                 "release", "version")], collapse = " "), 
[11:42:00.328]                               hostname = base::Sys.info()[["nodename"]])
[11:42:00.328]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:42:00.328]                               info)
[11:42:00.328]                             info <- base::paste(info, collapse = "; ")
[11:42:00.328]                             if (!has_future) {
[11:42:00.328]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:42:00.328]                                 info)
[11:42:00.328]                             }
[11:42:00.328]                             else {
[11:42:00.328]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:42:00.328]                                 info, version)
[11:42:00.328]                             }
[11:42:00.328]                             base::stop(msg)
[11:42:00.328]                           }
[11:42:00.328]                         })
[11:42:00.328]                       }
[11:42:00.328]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:42:00.328]                       base::options(mc.cores = 1L)
[11:42:00.328]                     }
[11:42:00.328]                     base::local({
[11:42:00.328]                       for (pkg in "mlr3") {
[11:42:00.328]                         base::loadNamespace(pkg)
[11:42:00.328]                         base::library(pkg, character.only = TRUE)
[11:42:00.328]                       }
[11:42:00.328]                     })
[11:42:00.328]                   }
[11:42:00.328]                   options(future.plan = NULL)
[11:42:00.328]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:42:00.328]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:42:00.328]                 }
[11:42:00.328]                 ...future.workdir <- getwd()
[11:42:00.328]             }
[11:42:00.328]             ...future.oldOptions <- base::as.list(base::.Options)
[11:42:00.328]             ...future.oldEnvVars <- base::Sys.getenv()
[11:42:00.328]         }
[11:42:00.328]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:42:00.328]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:42:00.328]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:42:00.328]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:42:00.328]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:42:00.328]             future.stdout.windows.reencode = NULL, width = 400L)
[11:42:00.328]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:42:00.328]             base::names(...future.oldOptions))
[11:42:00.328]     }
[11:42:00.328]     if (FALSE) {
[11:42:00.328]     }
[11:42:00.328]     else {
[11:42:00.328]         if (TRUE) {
[11:42:00.328]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:42:00.328]                 open = "w")
[11:42:00.328]         }
[11:42:00.328]         else {
[11:42:00.328]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:42:00.328]                 windows = "NUL", "/dev/null"), open = "w")
[11:42:00.328]         }
[11:42:00.328]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:42:00.328]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:42:00.328]             base::sink(type = "output", split = FALSE)
[11:42:00.328]             base::close(...future.stdout)
[11:42:00.328]         }, add = TRUE)
[11:42:00.328]     }
[11:42:00.328]     ...future.frame <- base::sys.nframe()
[11:42:00.328]     ...future.conditions <- base::list()
[11:42:00.328]     ...future.rng <- base::globalenv()$.Random.seed
[11:42:00.328]     if (FALSE) {
[11:42:00.328]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:42:00.328]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:42:00.328]     }
[11:42:00.328]     ...future.result <- base::tryCatch({
[11:42:00.328]         base::withCallingHandlers({
[11:42:00.328]             ...future.value <- base::withVisible(base::local({
[11:42:00.328]                 ...future.makeSendCondition <- local({
[11:42:00.328]                   sendCondition <- NULL
[11:42:00.328]                   function(frame = 1L) {
[11:42:00.328]                     if (is.function(sendCondition)) 
[11:42:00.328]                       return(sendCondition)
[11:42:00.328]                     ns <- getNamespace("parallel")
[11:42:00.328]                     if (exists("sendData", mode = "function", 
[11:42:00.328]                       envir = ns)) {
[11:42:00.328]                       parallel_sendData <- get("sendData", mode = "function", 
[11:42:00.328]                         envir = ns)
[11:42:00.328]                       envir <- sys.frame(frame)
[11:42:00.328]                       master <- NULL
[11:42:00.328]                       while (!identical(envir, .GlobalEnv) && 
[11:42:00.328]                         !identical(envir, emptyenv())) {
[11:42:00.328]                         if (exists("master", mode = "list", envir = envir, 
[11:42:00.328]                           inherits = FALSE)) {
[11:42:00.328]                           master <- get("master", mode = "list", 
[11:42:00.328]                             envir = envir, inherits = FALSE)
[11:42:00.328]                           if (inherits(master, c("SOCKnode", 
[11:42:00.328]                             "SOCK0node"))) {
[11:42:00.328]                             sendCondition <<- function(cond) {
[11:42:00.328]                               data <- list(type = "VALUE", value = cond, 
[11:42:00.328]                                 success = TRUE)
[11:42:00.328]                               parallel_sendData(master, data)
[11:42:00.328]                             }
[11:42:00.328]                             return(sendCondition)
[11:42:00.328]                           }
[11:42:00.328]                         }
[11:42:00.328]                         frame <- frame + 1L
[11:42:00.328]                         envir <- sys.frame(frame)
[11:42:00.328]                       }
[11:42:00.328]                     }
[11:42:00.328]                     sendCondition <<- function(cond) NULL
[11:42:00.328]                   }
[11:42:00.328]                 })
[11:42:00.328]                 withCallingHandlers({
[11:42:00.328]                   {
[11:42:00.328]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:42:00.328]                     if (!identical(...future.globals.maxSize.org, 
[11:42:00.328]                       ...future.globals.maxSize)) {
[11:42:00.328]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:42:00.328]                       on.exit(options(oopts), add = TRUE)
[11:42:00.328]                     }
[11:42:00.328]                     {
[11:42:00.328]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:42:00.328]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:42:00.328]                           envir = globalenv(), inherits = FALSE)
[11:42:00.328]                         ...future.FUN(...)
[11:42:00.328]                       }
[11:42:00.328]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:42:00.328]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:42:00.328]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:42:00.328]                         USE.NAMES = FALSE)
[11:42:00.328]                       do.call(mapply, args = args)
[11:42:00.328]                     }
[11:42:00.328]                   }
[11:42:00.328]                 }, immediateCondition = function(cond) {
[11:42:00.328]                   sendCondition <- ...future.makeSendCondition()
[11:42:00.328]                   sendCondition(cond)
[11:42:00.328]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:00.328]                   {
[11:42:00.328]                     inherits <- base::inherits
[11:42:00.328]                     invokeRestart <- base::invokeRestart
[11:42:00.328]                     is.null <- base::is.null
[11:42:00.328]                     muffled <- FALSE
[11:42:00.328]                     if (inherits(cond, "message")) {
[11:42:00.328]                       muffled <- grepl(pattern, "muffleMessage")
[11:42:00.328]                       if (muffled) 
[11:42:00.328]                         invokeRestart("muffleMessage")
[11:42:00.328]                     }
[11:42:00.328]                     else if (inherits(cond, "warning")) {
[11:42:00.328]                       muffled <- grepl(pattern, "muffleWarning")
[11:42:00.328]                       if (muffled) 
[11:42:00.328]                         invokeRestart("muffleWarning")
[11:42:00.328]                     }
[11:42:00.328]                     else if (inherits(cond, "condition")) {
[11:42:00.328]                       if (!is.null(pattern)) {
[11:42:00.328]                         computeRestarts <- base::computeRestarts
[11:42:00.328]                         grepl <- base::grepl
[11:42:00.328]                         restarts <- computeRestarts(cond)
[11:42:00.328]                         for (restart in restarts) {
[11:42:00.328]                           name <- restart$name
[11:42:00.328]                           if (is.null(name)) 
[11:42:00.328]                             next
[11:42:00.328]                           if (!grepl(pattern, name)) 
[11:42:00.328]                             next
[11:42:00.328]                           invokeRestart(restart)
[11:42:00.328]                           muffled <- TRUE
[11:42:00.328]                           break
[11:42:00.328]                         }
[11:42:00.328]                       }
[11:42:00.328]                     }
[11:42:00.328]                     invisible(muffled)
[11:42:00.328]                   }
[11:42:00.328]                   muffleCondition(cond)
[11:42:00.328]                 })
[11:42:00.328]             }))
[11:42:00.328]             future::FutureResult(value = ...future.value$value, 
[11:42:00.328]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:42:00.328]                   ...future.rng), globalenv = if (FALSE) 
[11:42:00.328]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:42:00.328]                     ...future.globalenv.names))
[11:42:00.328]                 else NULL, started = ...future.startTime, version = "1.8")
[11:42:00.328]         }, condition = base::local({
[11:42:00.328]             c <- base::c
[11:42:00.328]             inherits <- base::inherits
[11:42:00.328]             invokeRestart <- base::invokeRestart
[11:42:00.328]             length <- base::length
[11:42:00.328]             list <- base::list
[11:42:00.328]             seq.int <- base::seq.int
[11:42:00.328]             signalCondition <- base::signalCondition
[11:42:00.328]             sys.calls <- base::sys.calls
[11:42:00.328]             `[[` <- base::`[[`
[11:42:00.328]             `+` <- base::`+`
[11:42:00.328]             `<<-` <- base::`<<-`
[11:42:00.328]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:42:00.328]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:42:00.328]                   3L)]
[11:42:00.328]             }
[11:42:00.328]             function(cond) {
[11:42:00.328]                 is_error <- inherits(cond, "error")
[11:42:00.328]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:42:00.328]                   NULL)
[11:42:00.328]                 if (is_error) {
[11:42:00.328]                   sessionInformation <- function() {
[11:42:00.328]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:42:00.328]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:42:00.328]                       search = base::search(), system = base::Sys.info())
[11:42:00.328]                   }
[11:42:00.328]                   ...future.conditions[[length(...future.conditions) + 
[11:42:00.328]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:42:00.328]                     cond$call), session = sessionInformation(), 
[11:42:00.328]                     timestamp = base::Sys.time(), signaled = 0L)
[11:42:00.328]                   signalCondition(cond)
[11:42:00.328]                 }
[11:42:00.328]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:42:00.328]                 "immediateCondition"))) {
[11:42:00.328]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:42:00.328]                   ...future.conditions[[length(...future.conditions) + 
[11:42:00.328]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:42:00.328]                   if (TRUE && !signal) {
[11:42:00.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:00.328]                     {
[11:42:00.328]                       inherits <- base::inherits
[11:42:00.328]                       invokeRestart <- base::invokeRestart
[11:42:00.328]                       is.null <- base::is.null
[11:42:00.328]                       muffled <- FALSE
[11:42:00.328]                       if (inherits(cond, "message")) {
[11:42:00.328]                         muffled <- grepl(pattern, "muffleMessage")
[11:42:00.328]                         if (muffled) 
[11:42:00.328]                           invokeRestart("muffleMessage")
[11:42:00.328]                       }
[11:42:00.328]                       else if (inherits(cond, "warning")) {
[11:42:00.328]                         muffled <- grepl(pattern, "muffleWarning")
[11:42:00.328]                         if (muffled) 
[11:42:00.328]                           invokeRestart("muffleWarning")
[11:42:00.328]                       }
[11:42:00.328]                       else if (inherits(cond, "condition")) {
[11:42:00.328]                         if (!is.null(pattern)) {
[11:42:00.328]                           computeRestarts <- base::computeRestarts
[11:42:00.328]                           grepl <- base::grepl
[11:42:00.328]                           restarts <- computeRestarts(cond)
[11:42:00.328]                           for (restart in restarts) {
[11:42:00.328]                             name <- restart$name
[11:42:00.328]                             if (is.null(name)) 
[11:42:00.328]                               next
[11:42:00.328]                             if (!grepl(pattern, name)) 
[11:42:00.328]                               next
[11:42:00.328]                             invokeRestart(restart)
[11:42:00.328]                             muffled <- TRUE
[11:42:00.328]                             break
[11:42:00.328]                           }
[11:42:00.328]                         }
[11:42:00.328]                       }
[11:42:00.328]                       invisible(muffled)
[11:42:00.328]                     }
[11:42:00.328]                     muffleCondition(cond, pattern = "^muffle")
[11:42:00.328]                   }
[11:42:00.328]                 }
[11:42:00.328]                 else {
[11:42:00.328]                   if (TRUE) {
[11:42:00.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:00.328]                     {
[11:42:00.328]                       inherits <- base::inherits
[11:42:00.328]                       invokeRestart <- base::invokeRestart
[11:42:00.328]                       is.null <- base::is.null
[11:42:00.328]                       muffled <- FALSE
[11:42:00.328]                       if (inherits(cond, "message")) {
[11:42:00.328]                         muffled <- grepl(pattern, "muffleMessage")
[11:42:00.328]                         if (muffled) 
[11:42:00.328]                           invokeRestart("muffleMessage")
[11:42:00.328]                       }
[11:42:00.328]                       else if (inherits(cond, "warning")) {
[11:42:00.328]                         muffled <- grepl(pattern, "muffleWarning")
[11:42:00.328]                         if (muffled) 
[11:42:00.328]                           invokeRestart("muffleWarning")
[11:42:00.328]                       }
[11:42:00.328]                       else if (inherits(cond, "condition")) {
[11:42:00.328]                         if (!is.null(pattern)) {
[11:42:00.328]                           computeRestarts <- base::computeRestarts
[11:42:00.328]                           grepl <- base::grepl
[11:42:00.328]                           restarts <- computeRestarts(cond)
[11:42:00.328]                           for (restart in restarts) {
[11:42:00.328]                             name <- restart$name
[11:42:00.328]                             if (is.null(name)) 
[11:42:00.328]                               next
[11:42:00.328]                             if (!grepl(pattern, name)) 
[11:42:00.328]                               next
[11:42:00.328]                             invokeRestart(restart)
[11:42:00.328]                             muffled <- TRUE
[11:42:00.328]                             break
[11:42:00.328]                           }
[11:42:00.328]                         }
[11:42:00.328]                       }
[11:42:00.328]                       invisible(muffled)
[11:42:00.328]                     }
[11:42:00.328]                     muffleCondition(cond, pattern = "^muffle")
[11:42:00.328]                   }
[11:42:00.328]                 }
[11:42:00.328]             }
[11:42:00.328]         }))
[11:42:00.328]     }, error = function(ex) {
[11:42:00.328]         base::structure(base::list(value = NULL, visible = NULL, 
[11:42:00.328]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:42:00.328]                 ...future.rng), started = ...future.startTime, 
[11:42:00.328]             finished = Sys.time(), session_uuid = NA_character_, 
[11:42:00.328]             version = "1.8"), class = "FutureResult")
[11:42:00.328]     }, finally = {
[11:42:00.328]         if (!identical(...future.workdir, getwd())) 
[11:42:00.328]             setwd(...future.workdir)
[11:42:00.328]         {
[11:42:00.328]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:42:00.328]                 ...future.oldOptions$nwarnings <- NULL
[11:42:00.328]             }
[11:42:00.328]             base::options(...future.oldOptions)
[11:42:00.328]             if (.Platform$OS.type == "windows") {
[11:42:00.328]                 old_names <- names(...future.oldEnvVars)
[11:42:00.328]                 envs <- base::Sys.getenv()
[11:42:00.328]                 names <- names(envs)
[11:42:00.328]                 common <- intersect(names, old_names)
[11:42:00.328]                 added <- setdiff(names, old_names)
[11:42:00.328]                 removed <- setdiff(old_names, names)
[11:42:00.328]                 changed <- common[...future.oldEnvVars[common] != 
[11:42:00.328]                   envs[common]]
[11:42:00.328]                 NAMES <- toupper(changed)
[11:42:00.328]                 args <- list()
[11:42:00.328]                 for (kk in seq_along(NAMES)) {
[11:42:00.328]                   name <- changed[[kk]]
[11:42:00.328]                   NAME <- NAMES[[kk]]
[11:42:00.328]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:00.328]                     next
[11:42:00.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:42:00.328]                 }
[11:42:00.328]                 NAMES <- toupper(added)
[11:42:00.328]                 for (kk in seq_along(NAMES)) {
[11:42:00.328]                   name <- added[[kk]]
[11:42:00.328]                   NAME <- NAMES[[kk]]
[11:42:00.328]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:00.328]                     next
[11:42:00.328]                   args[[name]] <- ""
[11:42:00.328]                 }
[11:42:00.328]                 NAMES <- toupper(removed)
[11:42:00.328]                 for (kk in seq_along(NAMES)) {
[11:42:00.328]                   name <- removed[[kk]]
[11:42:00.328]                   NAME <- NAMES[[kk]]
[11:42:00.328]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:00.328]                     next
[11:42:00.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:42:00.328]                 }
[11:42:00.328]                 if (length(args) > 0) 
[11:42:00.328]                   base::do.call(base::Sys.setenv, args = args)
[11:42:00.328]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:42:00.328]             }
[11:42:00.328]             else {
[11:42:00.328]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:42:00.328]             }
[11:42:00.328]             {
[11:42:00.328]                 if (base::length(...future.futureOptionsAdded) > 
[11:42:00.328]                   0L) {
[11:42:00.328]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:42:00.328]                   base::names(opts) <- ...future.futureOptionsAdded
[11:42:00.328]                   base::options(opts)
[11:42:00.328]                 }
[11:42:00.328]                 {
[11:42:00.328]                   {
[11:42:00.328]                     base::options(mc.cores = ...future.mc.cores.old)
[11:42:00.328]                     NULL
[11:42:00.328]                   }
[11:42:00.328]                   options(future.plan = NULL)
[11:42:00.328]                   if (is.na(NA_character_)) 
[11:42:00.328]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:42:00.328]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:42:00.328]                   future::plan(list(function (..., workers = 2, 
[11:42:00.328]                     envir = parent.frame()) 
[11:42:00.328]                   strategy(..., workers = workers, envir = envir)), 
[11:42:00.328]                     .cleanup = FALSE, .init = FALSE)
[11:42:00.328]                 }
[11:42:00.328]             }
[11:42:00.328]         }
[11:42:00.328]     })
[11:42:00.328]     if (TRUE) {
[11:42:00.328]         base::sink(type = "output", split = FALSE)
[11:42:00.328]         if (TRUE) {
[11:42:00.328]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:42:00.328]         }
[11:42:00.328]         else {
[11:42:00.328]             ...future.result["stdout"] <- base::list(NULL)
[11:42:00.328]         }
[11:42:00.328]         base::close(...future.stdout)
[11:42:00.328]         ...future.stdout <- NULL
[11:42:00.328]     }
[11:42:00.328]     ...future.result$conditions <- ...future.conditions
[11:42:00.328]     ...future.result$finished <- base::Sys.time()
[11:42:00.328]     ...future.result
[11:42:00.328] }
[11:42:00.331] Poll #1 (0): usedNodes() = 2, workers = 2
[11:42:00.341] receiveMessageFromWorker() for ClusterFuture ...
[11:42:00.341] - Validating connection of MultisessionFuture
[11:42:00.342] - received message: FutureResult
[11:42:00.342] - Received FutureResult
[11:42:00.342] - Erased future from FutureRegistry
[11:42:00.342] result() for ClusterFuture ...
[11:42:00.342] - result already collected: FutureResult
[11:42:00.342] result() for ClusterFuture ... done
[11:42:00.342] receiveMessageFromWorker() for ClusterFuture ... done
[11:42:00.342] result() for ClusterFuture ...
[11:42:00.342] - result already collected: FutureResult
[11:42:00.342] result() for ClusterFuture ... done
[11:42:00.342] result() for ClusterFuture ...
[11:42:00.342] - result already collected: FutureResult
[11:42:00.342] result() for ClusterFuture ... done
[11:42:00.343] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:42:00.343] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:42:00.389] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:42:00.392] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:42:00.437] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:42:00.438] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:42:00.481] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:42:00.482] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:42:00.482] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:42:00.482] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:42:00.482] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:42:00.483] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:42:00.483] MultisessionFuture started
[11:42:00.483] - Launch lazy future ... done
[11:42:00.483] run() for ‘MultisessionFuture’ ... done
[11:42:00.483] Created future:
[11:42:00.483] MultisessionFuture:
[11:42:00.483] Label: ‘future_mapply-82’
[11:42:00.483] Expression:
[11:42:00.483] {
[11:42:00.483]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:42:00.483]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:42:00.483]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:42:00.483]         on.exit(options(oopts), add = TRUE)
[11:42:00.483]     }
[11:42:00.483]     {
[11:42:00.483]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:42:00.483]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:42:00.483]                 inherits = FALSE)
[11:42:00.483]             ...future.FUN(...)
[11:42:00.483]         }
[11:42:00.483]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:42:00.483]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:42:00.483]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:42:00.483]         do.call(mapply, args = args)
[11:42:00.483]     }
[11:42:00.483] }
[11:42:00.483] Lazy evaluation: FALSE
[11:42:00.483] Asynchronous evaluation: TRUE
[11:42:00.483] Local evaluation: TRUE
[11:42:00.483] Environment: 0x560ef58e1768
[11:42:00.483] Capture standard output: TRUE
[11:42:00.483] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:42:00.483] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:42:00.483] Packages: 1 packages (‘mlr3’)
[11:42:00.483] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:42:00.483] Resolved: FALSE
[11:42:00.483] Value: <not collected>
[11:42:00.483] Conditions captured: <none>
[11:42:00.483] Early signaling: FALSE
[11:42:00.483] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:42:00.483] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:42:00.497] Chunk #82 of 90 ... DONE
[11:42:00.497] Chunk #83 of 90 ...
[11:42:00.497]  - seeds: [1] <seeds>
[11:42:00.497] getGlobalsAndPackages() ...
[11:42:00.498] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:42:00.498] Resolving globals: FALSE
[11:42:00.498] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:42:00.498] - packages: [1] ‘mlr3’
[11:42:00.498] getGlobalsAndPackages() ... DONE
[11:42:00.498] run() for ‘Future’ ...
[11:42:00.498] - state: ‘created’
[11:42:00.499] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:42:00.508] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:42:00.509] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:42:00.509]   - Field: ‘node’
[11:42:00.509]   - Field: ‘label’
[11:42:00.509]   - Field: ‘local’
[11:42:00.509]   - Field: ‘owner’
[11:42:00.509]   - Field: ‘envir’
[11:42:00.509]   - Field: ‘workers’
[11:42:00.509]   - Field: ‘packages’
[11:42:00.509]   - Field: ‘gc’
[11:42:00.509]   - Field: ‘conditions’
[11:42:00.509]   - Field: ‘persistent’
[11:42:00.509]   - Field: ‘expr’
[11:42:00.509]   - Field: ‘uuid’
[11:42:00.510]   - Field: ‘seed’
[11:42:00.510]   - Field: ‘version’
[11:42:00.510]   - Field: ‘result’
[11:42:00.510]   - Field: ‘asynchronous’
[11:42:00.510]   - Field: ‘calls’
[11:42:00.510]   - Field: ‘globals’
[11:42:00.510]   - Field: ‘stdout’
[11:42:00.510]   - Field: ‘earlySignal’
[11:42:00.510]   - Field: ‘lazy’
[11:42:00.510]   - Field: ‘state’
[11:42:00.510] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:42:00.510] - Launch lazy future ...
[11:42:00.510] Packages needed by the future expression (n = 1): ‘mlr3’
[11:42:00.510] Packages needed by future strategies (n = 0): <none>
[11:42:00.511] {
[11:42:00.511]     {
[11:42:00.511]         {
[11:42:00.511]             ...future.startTime <- base::Sys.time()
[11:42:00.511]             {
[11:42:00.511]                 {
[11:42:00.511]                   {
[11:42:00.511]                     {
[11:42:00.511]                       {
[11:42:00.511]                         base::local({
[11:42:00.511]                           has_future <- base::requireNamespace("future", 
[11:42:00.511]                             quietly = TRUE)
[11:42:00.511]                           if (has_future) {
[11:42:00.511]                             ns <- base::getNamespace("future")
[11:42:00.511]                             version <- ns[[".package"]][["version"]]
[11:42:00.511]                             if (is.null(version)) 
[11:42:00.511]                               version <- utils::packageVersion("future")
[11:42:00.511]                           }
[11:42:00.511]                           else {
[11:42:00.511]                             version <- NULL
[11:42:00.511]                           }
[11:42:00.511]                           if (!has_future || version < "1.8.0") {
[11:42:00.511]                             info <- base::c(r_version = base::gsub("R version ", 
[11:42:00.511]                               "", base::R.version$version.string), 
[11:42:00.511]                               platform = base::sprintf("%s (%s-bit)", 
[11:42:00.511]                                 base::R.version$platform, 8 * 
[11:42:00.511]                                   base::.Machine$sizeof.pointer), 
[11:42:00.511]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:42:00.511]                                 "release", "version")], collapse = " "), 
[11:42:00.511]                               hostname = base::Sys.info()[["nodename"]])
[11:42:00.511]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:42:00.511]                               info)
[11:42:00.511]                             info <- base::paste(info, collapse = "; ")
[11:42:00.511]                             if (!has_future) {
[11:42:00.511]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:42:00.511]                                 info)
[11:42:00.511]                             }
[11:42:00.511]                             else {
[11:42:00.511]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:42:00.511]                                 info, version)
[11:42:00.511]                             }
[11:42:00.511]                             base::stop(msg)
[11:42:00.511]                           }
[11:42:00.511]                         })
[11:42:00.511]                       }
[11:42:00.511]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:42:00.511]                       base::options(mc.cores = 1L)
[11:42:00.511]                     }
[11:42:00.511]                     base::local({
[11:42:00.511]                       for (pkg in "mlr3") {
[11:42:00.511]                         base::loadNamespace(pkg)
[11:42:00.511]                         base::library(pkg, character.only = TRUE)
[11:42:00.511]                       }
[11:42:00.511]                     })
[11:42:00.511]                   }
[11:42:00.511]                   options(future.plan = NULL)
[11:42:00.511]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:42:00.511]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:42:00.511]                 }
[11:42:00.511]                 ...future.workdir <- getwd()
[11:42:00.511]             }
[11:42:00.511]             ...future.oldOptions <- base::as.list(base::.Options)
[11:42:00.511]             ...future.oldEnvVars <- base::Sys.getenv()
[11:42:00.511]         }
[11:42:00.511]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:42:00.511]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:42:00.511]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:42:00.511]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:42:00.511]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:42:00.511]             future.stdout.windows.reencode = NULL, width = 400L)
[11:42:00.511]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:42:00.511]             base::names(...future.oldOptions))
[11:42:00.511]     }
[11:42:00.511]     if (FALSE) {
[11:42:00.511]     }
[11:42:00.511]     else {
[11:42:00.511]         if (TRUE) {
[11:42:00.511]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:42:00.511]                 open = "w")
[11:42:00.511]         }
[11:42:00.511]         else {
[11:42:00.511]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:42:00.511]                 windows = "NUL", "/dev/null"), open = "w")
[11:42:00.511]         }
[11:42:00.511]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:42:00.511]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:42:00.511]             base::sink(type = "output", split = FALSE)
[11:42:00.511]             base::close(...future.stdout)
[11:42:00.511]         }, add = TRUE)
[11:42:00.511]     }
[11:42:00.511]     ...future.frame <- base::sys.nframe()
[11:42:00.511]     ...future.conditions <- base::list()
[11:42:00.511]     ...future.rng <- base::globalenv()$.Random.seed
[11:42:00.511]     if (FALSE) {
[11:42:00.511]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:42:00.511]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:42:00.511]     }
[11:42:00.511]     ...future.result <- base::tryCatch({
[11:42:00.511]         base::withCallingHandlers({
[11:42:00.511]             ...future.value <- base::withVisible(base::local({
[11:42:00.511]                 ...future.makeSendCondition <- local({
[11:42:00.511]                   sendCondition <- NULL
[11:42:00.511]                   function(frame = 1L) {
[11:42:00.511]                     if (is.function(sendCondition)) 
[11:42:00.511]                       return(sendCondition)
[11:42:00.511]                     ns <- getNamespace("parallel")
[11:42:00.511]                     if (exists("sendData", mode = "function", 
[11:42:00.511]                       envir = ns)) {
[11:42:00.511]                       parallel_sendData <- get("sendData", mode = "function", 
[11:42:00.511]                         envir = ns)
[11:42:00.511]                       envir <- sys.frame(frame)
[11:42:00.511]                       master <- NULL
[11:42:00.511]                       while (!identical(envir, .GlobalEnv) && 
[11:42:00.511]                         !identical(envir, emptyenv())) {
[11:42:00.511]                         if (exists("master", mode = "list", envir = envir, 
[11:42:00.511]                           inherits = FALSE)) {
[11:42:00.511]                           master <- get("master", mode = "list", 
[11:42:00.511]                             envir = envir, inherits = FALSE)
[11:42:00.511]                           if (inherits(master, c("SOCKnode", 
[11:42:00.511]                             "SOCK0node"))) {
[11:42:00.511]                             sendCondition <<- function(cond) {
[11:42:00.511]                               data <- list(type = "VALUE", value = cond, 
[11:42:00.511]                                 success = TRUE)
[11:42:00.511]                               parallel_sendData(master, data)
[11:42:00.511]                             }
[11:42:00.511]                             return(sendCondition)
[11:42:00.511]                           }
[11:42:00.511]                         }
[11:42:00.511]                         frame <- frame + 1L
[11:42:00.511]                         envir <- sys.frame(frame)
[11:42:00.511]                       }
[11:42:00.511]                     }
[11:42:00.511]                     sendCondition <<- function(cond) NULL
[11:42:00.511]                   }
[11:42:00.511]                 })
[11:42:00.511]                 withCallingHandlers({
[11:42:00.511]                   {
[11:42:00.511]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:42:00.511]                     if (!identical(...future.globals.maxSize.org, 
[11:42:00.511]                       ...future.globals.maxSize)) {
[11:42:00.511]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:42:00.511]                       on.exit(options(oopts), add = TRUE)
[11:42:00.511]                     }
[11:42:00.511]                     {
[11:42:00.511]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:42:00.511]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:42:00.511]                           envir = globalenv(), inherits = FALSE)
[11:42:00.511]                         ...future.FUN(...)
[11:42:00.511]                       }
[11:42:00.511]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:42:00.511]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:42:00.511]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:42:00.511]                         USE.NAMES = FALSE)
[11:42:00.511]                       do.call(mapply, args = args)
[11:42:00.511]                     }
[11:42:00.511]                   }
[11:42:00.511]                 }, immediateCondition = function(cond) {
[11:42:00.511]                   sendCondition <- ...future.makeSendCondition()
[11:42:00.511]                   sendCondition(cond)
[11:42:00.511]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:00.511]                   {
[11:42:00.511]                     inherits <- base::inherits
[11:42:00.511]                     invokeRestart <- base::invokeRestart
[11:42:00.511]                     is.null <- base::is.null
[11:42:00.511]                     muffled <- FALSE
[11:42:00.511]                     if (inherits(cond, "message")) {
[11:42:00.511]                       muffled <- grepl(pattern, "muffleMessage")
[11:42:00.511]                       if (muffled) 
[11:42:00.511]                         invokeRestart("muffleMessage")
[11:42:00.511]                     }
[11:42:00.511]                     else if (inherits(cond, "warning")) {
[11:42:00.511]                       muffled <- grepl(pattern, "muffleWarning")
[11:42:00.511]                       if (muffled) 
[11:42:00.511]                         invokeRestart("muffleWarning")
[11:42:00.511]                     }
[11:42:00.511]                     else if (inherits(cond, "condition")) {
[11:42:00.511]                       if (!is.null(pattern)) {
[11:42:00.511]                         computeRestarts <- base::computeRestarts
[11:42:00.511]                         grepl <- base::grepl
[11:42:00.511]                         restarts <- computeRestarts(cond)
[11:42:00.511]                         for (restart in restarts) {
[11:42:00.511]                           name <- restart$name
[11:42:00.511]                           if (is.null(name)) 
[11:42:00.511]                             next
[11:42:00.511]                           if (!grepl(pattern, name)) 
[11:42:00.511]                             next
[11:42:00.511]                           invokeRestart(restart)
[11:42:00.511]                           muffled <- TRUE
[11:42:00.511]                           break
[11:42:00.511]                         }
[11:42:00.511]                       }
[11:42:00.511]                     }
[11:42:00.511]                     invisible(muffled)
[11:42:00.511]                   }
[11:42:00.511]                   muffleCondition(cond)
[11:42:00.511]                 })
[11:42:00.511]             }))
[11:42:00.511]             future::FutureResult(value = ...future.value$value, 
[11:42:00.511]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:42:00.511]                   ...future.rng), globalenv = if (FALSE) 
[11:42:00.511]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:42:00.511]                     ...future.globalenv.names))
[11:42:00.511]                 else NULL, started = ...future.startTime, version = "1.8")
[11:42:00.511]         }, condition = base::local({
[11:42:00.511]             c <- base::c
[11:42:00.511]             inherits <- base::inherits
[11:42:00.511]             invokeRestart <- base::invokeRestart
[11:42:00.511]             length <- base::length
[11:42:00.511]             list <- base::list
[11:42:00.511]             seq.int <- base::seq.int
[11:42:00.511]             signalCondition <- base::signalCondition
[11:42:00.511]             sys.calls <- base::sys.calls
[11:42:00.511]             `[[` <- base::`[[`
[11:42:00.511]             `+` <- base::`+`
[11:42:00.511]             `<<-` <- base::`<<-`
[11:42:00.511]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:42:00.511]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:42:00.511]                   3L)]
[11:42:00.511]             }
[11:42:00.511]             function(cond) {
[11:42:00.511]                 is_error <- inherits(cond, "error")
[11:42:00.511]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:42:00.511]                   NULL)
[11:42:00.511]                 if (is_error) {
[11:42:00.511]                   sessionInformation <- function() {
[11:42:00.511]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:42:00.511]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:42:00.511]                       search = base::search(), system = base::Sys.info())
[11:42:00.511]                   }
[11:42:00.511]                   ...future.conditions[[length(...future.conditions) + 
[11:42:00.511]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:42:00.511]                     cond$call), session = sessionInformation(), 
[11:42:00.511]                     timestamp = base::Sys.time(), signaled = 0L)
[11:42:00.511]                   signalCondition(cond)
[11:42:00.511]                 }
[11:42:00.511]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:42:00.511]                 "immediateCondition"))) {
[11:42:00.511]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:42:00.511]                   ...future.conditions[[length(...future.conditions) + 
[11:42:00.511]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:42:00.511]                   if (TRUE && !signal) {
[11:42:00.511]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:00.511]                     {
[11:42:00.511]                       inherits <- base::inherits
[11:42:00.511]                       invokeRestart <- base::invokeRestart
[11:42:00.511]                       is.null <- base::is.null
[11:42:00.511]                       muffled <- FALSE
[11:42:00.511]                       if (inherits(cond, "message")) {
[11:42:00.511]                         muffled <- grepl(pattern, "muffleMessage")
[11:42:00.511]                         if (muffled) 
[11:42:00.511]                           invokeRestart("muffleMessage")
[11:42:00.511]                       }
[11:42:00.511]                       else if (inherits(cond, "warning")) {
[11:42:00.511]                         muffled <- grepl(pattern, "muffleWarning")
[11:42:00.511]                         if (muffled) 
[11:42:00.511]                           invokeRestart("muffleWarning")
[11:42:00.511]                       }
[11:42:00.511]                       else if (inherits(cond, "condition")) {
[11:42:00.511]                         if (!is.null(pattern)) {
[11:42:00.511]                           computeRestarts <- base::computeRestarts
[11:42:00.511]                           grepl <- base::grepl
[11:42:00.511]                           restarts <- computeRestarts(cond)
[11:42:00.511]                           for (restart in restarts) {
[11:42:00.511]                             name <- restart$name
[11:42:00.511]                             if (is.null(name)) 
[11:42:00.511]                               next
[11:42:00.511]                             if (!grepl(pattern, name)) 
[11:42:00.511]                               next
[11:42:00.511]                             invokeRestart(restart)
[11:42:00.511]                             muffled <- TRUE
[11:42:00.511]                             break
[11:42:00.511]                           }
[11:42:00.511]                         }
[11:42:00.511]                       }
[11:42:00.511]                       invisible(muffled)
[11:42:00.511]                     }
[11:42:00.511]                     muffleCondition(cond, pattern = "^muffle")
[11:42:00.511]                   }
[11:42:00.511]                 }
[11:42:00.511]                 else {
[11:42:00.511]                   if (TRUE) {
[11:42:00.511]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:00.511]                     {
[11:42:00.511]                       inherits <- base::inherits
[11:42:00.511]                       invokeRestart <- base::invokeRestart
[11:42:00.511]                       is.null <- base::is.null
[11:42:00.511]                       muffled <- FALSE
[11:42:00.511]                       if (inherits(cond, "message")) {
[11:42:00.511]                         muffled <- grepl(pattern, "muffleMessage")
[11:42:00.511]                         if (muffled) 
[11:42:00.511]                           invokeRestart("muffleMessage")
[11:42:00.511]                       }
[11:42:00.511]                       else if (inherits(cond, "warning")) {
[11:42:00.511]                         muffled <- grepl(pattern, "muffleWarning")
[11:42:00.511]                         if (muffled) 
[11:42:00.511]                           invokeRestart("muffleWarning")
[11:42:00.511]                       }
[11:42:00.511]                       else if (inherits(cond, "condition")) {
[11:42:00.511]                         if (!is.null(pattern)) {
[11:42:00.511]                           computeRestarts <- base::computeRestarts
[11:42:00.511]                           grepl <- base::grepl
[11:42:00.511]                           restarts <- computeRestarts(cond)
[11:42:00.511]                           for (restart in restarts) {
[11:42:00.511]                             name <- restart$name
[11:42:00.511]                             if (is.null(name)) 
[11:42:00.511]                               next
[11:42:00.511]                             if (!grepl(pattern, name)) 
[11:42:00.511]                               next
[11:42:00.511]                             invokeRestart(restart)
[11:42:00.511]                             muffled <- TRUE
[11:42:00.511]                             break
[11:42:00.511]                           }
[11:42:00.511]                         }
[11:42:00.511]                       }
[11:42:00.511]                       invisible(muffled)
[11:42:00.511]                     }
[11:42:00.511]                     muffleCondition(cond, pattern = "^muffle")
[11:42:00.511]                   }
[11:42:00.511]                 }
[11:42:00.511]             }
[11:42:00.511]         }))
[11:42:00.511]     }, error = function(ex) {
[11:42:00.511]         base::structure(base::list(value = NULL, visible = NULL, 
[11:42:00.511]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:42:00.511]                 ...future.rng), started = ...future.startTime, 
[11:42:00.511]             finished = Sys.time(), session_uuid = NA_character_, 
[11:42:00.511]             version = "1.8"), class = "FutureResult")
[11:42:00.511]     }, finally = {
[11:42:00.511]         if (!identical(...future.workdir, getwd())) 
[11:42:00.511]             setwd(...future.workdir)
[11:42:00.511]         {
[11:42:00.511]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:42:00.511]                 ...future.oldOptions$nwarnings <- NULL
[11:42:00.511]             }
[11:42:00.511]             base::options(...future.oldOptions)
[11:42:00.511]             if (.Platform$OS.type == "windows") {
[11:42:00.511]                 old_names <- names(...future.oldEnvVars)
[11:42:00.511]                 envs <- base::Sys.getenv()
[11:42:00.511]                 names <- names(envs)
[11:42:00.511]                 common <- intersect(names, old_names)
[11:42:00.511]                 added <- setdiff(names, old_names)
[11:42:00.511]                 removed <- setdiff(old_names, names)
[11:42:00.511]                 changed <- common[...future.oldEnvVars[common] != 
[11:42:00.511]                   envs[common]]
[11:42:00.511]                 NAMES <- toupper(changed)
[11:42:00.511]                 args <- list()
[11:42:00.511]                 for (kk in seq_along(NAMES)) {
[11:42:00.511]                   name <- changed[[kk]]
[11:42:00.511]                   NAME <- NAMES[[kk]]
[11:42:00.511]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:00.511]                     next
[11:42:00.511]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:42:00.511]                 }
[11:42:00.511]                 NAMES <- toupper(added)
[11:42:00.511]                 for (kk in seq_along(NAMES)) {
[11:42:00.511]                   name <- added[[kk]]
[11:42:00.511]                   NAME <- NAMES[[kk]]
[11:42:00.511]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:00.511]                     next
[11:42:00.511]                   args[[name]] <- ""
[11:42:00.511]                 }
[11:42:00.511]                 NAMES <- toupper(removed)
[11:42:00.511]                 for (kk in seq_along(NAMES)) {
[11:42:00.511]                   name <- removed[[kk]]
[11:42:00.511]                   NAME <- NAMES[[kk]]
[11:42:00.511]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:00.511]                     next
[11:42:00.511]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:42:00.511]                 }
[11:42:00.511]                 if (length(args) > 0) 
[11:42:00.511]                   base::do.call(base::Sys.setenv, args = args)
[11:42:00.511]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:42:00.511]             }
[11:42:00.511]             else {
[11:42:00.511]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:42:00.511]             }
[11:42:00.511]             {
[11:42:00.511]                 if (base::length(...future.futureOptionsAdded) > 
[11:42:00.511]                   0L) {
[11:42:00.511]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:42:00.511]                   base::names(opts) <- ...future.futureOptionsAdded
[11:42:00.511]                   base::options(opts)
[11:42:00.511]                 }
[11:42:00.511]                 {
[11:42:00.511]                   {
[11:42:00.511]                     base::options(mc.cores = ...future.mc.cores.old)
[11:42:00.511]                     NULL
[11:42:00.511]                   }
[11:42:00.511]                   options(future.plan = NULL)
[11:42:00.511]                   if (is.na(NA_character_)) 
[11:42:00.511]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:42:00.511]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:42:00.511]                   future::plan(list(function (..., workers = 2, 
[11:42:00.511]                     envir = parent.frame()) 
[11:42:00.511]                   strategy(..., workers = workers, envir = envir)), 
[11:42:00.511]                     .cleanup = FALSE, .init = FALSE)
[11:42:00.511]                 }
[11:42:00.511]             }
[11:42:00.511]         }
[11:42:00.511]     })
[11:42:00.511]     if (TRUE) {
[11:42:00.511]         base::sink(type = "output", split = FALSE)
[11:42:00.511]         if (TRUE) {
[11:42:00.511]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:42:00.511]         }
[11:42:00.511]         else {
[11:42:00.511]             ...future.result["stdout"] <- base::list(NULL)
[11:42:00.511]         }
[11:42:00.511]         base::close(...future.stdout)
[11:42:00.511]         ...future.stdout <- NULL
[11:42:00.511]     }
[11:42:00.511]     ...future.result$conditions <- ...future.conditions
[11:42:00.511]     ...future.result$finished <- base::Sys.time()
[11:42:00.511]     ...future.result
[11:42:00.511] }
[11:42:00.513] Poll #1 (0): usedNodes() = 2, workers = 2
[11:42:00.523] receiveMessageFromWorker() for ClusterFuture ...
[11:42:00.524] - Validating connection of MultisessionFuture
[11:42:00.524] - received message: FutureResult
[11:42:00.524] - Received FutureResult
[11:42:00.524] - Erased future from FutureRegistry
[11:42:00.524] result() for ClusterFuture ...
[11:42:00.524] - result already collected: FutureResult
[11:42:00.524] result() for ClusterFuture ... done
[11:42:00.524] receiveMessageFromWorker() for ClusterFuture ... done
[11:42:00.524] result() for ClusterFuture ...
[11:42:00.524] - result already collected: FutureResult
[11:42:00.525] result() for ClusterFuture ... done
[11:42:00.525] result() for ClusterFuture ...
[11:42:00.525] - result already collected: FutureResult
[11:42:00.525] result() for ClusterFuture ... done
[11:42:00.526] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:42:00.526] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:42:00.569] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:42:00.574] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:42:00.577] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:42:00.577] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:42:00.622] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:42:00.623] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:42:00.624] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:42:00.624] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:42:00.624] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:42:00.624] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:42:00.625] MultisessionFuture started
[11:42:00.625] - Launch lazy future ... done
[11:42:00.626] run() for ‘MultisessionFuture’ ... done
[11:42:00.626] Created future:
[11:42:00.626] MultisessionFuture:
[11:42:00.626] Label: ‘future_mapply-83’
[11:42:00.626] Expression:
[11:42:00.626] {
[11:42:00.626]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:42:00.626]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:42:00.626]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:42:00.626]         on.exit(options(oopts), add = TRUE)
[11:42:00.626]     }
[11:42:00.626]     {
[11:42:00.626]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:42:00.626]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:42:00.626]                 inherits = FALSE)
[11:42:00.626]             ...future.FUN(...)
[11:42:00.626]         }
[11:42:00.626]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:42:00.626]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:42:00.626]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:42:00.626]         do.call(mapply, args = args)
[11:42:00.626]     }
[11:42:00.626] }
[11:42:00.626] Lazy evaluation: FALSE
[11:42:00.626] Asynchronous evaluation: TRUE
[11:42:00.626] Local evaluation: TRUE
[11:42:00.626] Environment: 0x560ef58e1768
[11:42:00.626] Capture standard output: TRUE
[11:42:00.626] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:42:00.626] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:42:00.626] Packages: 1 packages (‘mlr3’)
[11:42:00.626] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:42:00.626] Resolved: FALSE
[11:42:00.626] Value: <not collected>
[11:42:00.626] Conditions captured: <none>
[11:42:00.626] Early signaling: FALSE
[11:42:00.626] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:42:00.626] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:42:00.645] Chunk #83 of 90 ... DONE
[11:42:00.645] Chunk #84 of 90 ...
[11:42:00.645]  - seeds: [1] <seeds>
[11:42:00.646] getGlobalsAndPackages() ...
[11:42:00.646] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:42:00.646] Resolving globals: FALSE
[11:42:00.646] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:42:00.646] - packages: [1] ‘mlr3’
[11:42:00.646] getGlobalsAndPackages() ... DONE
[11:42:00.647] run() for ‘Future’ ...
[11:42:00.647] - state: ‘created’
[11:42:00.647] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:42:00.660] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:42:00.661] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:42:00.661]   - Field: ‘node’
[11:42:00.661]   - Field: ‘label’
[11:42:00.661]   - Field: ‘local’
[11:42:00.661]   - Field: ‘owner’
[11:42:00.661]   - Field: ‘envir’
[11:42:00.661]   - Field: ‘workers’
[11:42:00.661]   - Field: ‘packages’
[11:42:00.661]   - Field: ‘gc’
[11:42:00.661]   - Field: ‘conditions’
[11:42:00.661]   - Field: ‘persistent’
[11:42:00.661]   - Field: ‘expr’
[11:42:00.661]   - Field: ‘uuid’
[11:42:00.661]   - Field: ‘seed’
[11:42:00.661]   - Field: ‘version’
[11:42:00.661]   - Field: ‘result’
[11:42:00.661]   - Field: ‘asynchronous’
[11:42:00.662]   - Field: ‘calls’
[11:42:00.662]   - Field: ‘globals’
[11:42:00.662]   - Field: ‘stdout’
[11:42:00.662]   - Field: ‘earlySignal’
[11:42:00.662]   - Field: ‘lazy’
[11:42:00.662]   - Field: ‘state’
[11:42:00.662] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:42:00.662] - Launch lazy future ...
[11:42:00.662] Packages needed by the future expression (n = 1): ‘mlr3’
[11:42:00.662] Packages needed by future strategies (n = 0): <none>
[11:42:00.662] {
[11:42:00.662]     {
[11:42:00.662]         {
[11:42:00.662]             ...future.startTime <- base::Sys.time()
[11:42:00.662]             {
[11:42:00.662]                 {
[11:42:00.662]                   {
[11:42:00.662]                     {
[11:42:00.662]                       {
[11:42:00.662]                         base::local({
[11:42:00.662]                           has_future <- base::requireNamespace("future", 
[11:42:00.662]                             quietly = TRUE)
[11:42:00.662]                           if (has_future) {
[11:42:00.662]                             ns <- base::getNamespace("future")
[11:42:00.662]                             version <- ns[[".package"]][["version"]]
[11:42:00.662]                             if (is.null(version)) 
[11:42:00.662]                               version <- utils::packageVersion("future")
[11:42:00.662]                           }
[11:42:00.662]                           else {
[11:42:00.662]                             version <- NULL
[11:42:00.662]                           }
[11:42:00.662]                           if (!has_future || version < "1.8.0") {
[11:42:00.662]                             info <- base::c(r_version = base::gsub("R version ", 
[11:42:00.662]                               "", base::R.version$version.string), 
[11:42:00.662]                               platform = base::sprintf("%s (%s-bit)", 
[11:42:00.662]                                 base::R.version$platform, 8 * 
[11:42:00.662]                                   base::.Machine$sizeof.pointer), 
[11:42:00.662]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:42:00.662]                                 "release", "version")], collapse = " "), 
[11:42:00.662]                               hostname = base::Sys.info()[["nodename"]])
[11:42:00.662]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:42:00.662]                               info)
[11:42:00.662]                             info <- base::paste(info, collapse = "; ")
[11:42:00.662]                             if (!has_future) {
[11:42:00.662]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:42:00.662]                                 info)
[11:42:00.662]                             }
[11:42:00.662]                             else {
[11:42:00.662]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:42:00.662]                                 info, version)
[11:42:00.662]                             }
[11:42:00.662]                             base::stop(msg)
[11:42:00.662]                           }
[11:42:00.662]                         })
[11:42:00.662]                       }
[11:42:00.662]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:42:00.662]                       base::options(mc.cores = 1L)
[11:42:00.662]                     }
[11:42:00.662]                     base::local({
[11:42:00.662]                       for (pkg in "mlr3") {
[11:42:00.662]                         base::loadNamespace(pkg)
[11:42:00.662]                         base::library(pkg, character.only = TRUE)
[11:42:00.662]                       }
[11:42:00.662]                     })
[11:42:00.662]                   }
[11:42:00.662]                   options(future.plan = NULL)
[11:42:00.662]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:42:00.662]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:42:00.662]                 }
[11:42:00.662]                 ...future.workdir <- getwd()
[11:42:00.662]             }
[11:42:00.662]             ...future.oldOptions <- base::as.list(base::.Options)
[11:42:00.662]             ...future.oldEnvVars <- base::Sys.getenv()
[11:42:00.662]         }
[11:42:00.662]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:42:00.662]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:42:00.662]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:42:00.662]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:42:00.662]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:42:00.662]             future.stdout.windows.reencode = NULL, width = 400L)
[11:42:00.662]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:42:00.662]             base::names(...future.oldOptions))
[11:42:00.662]     }
[11:42:00.662]     if (FALSE) {
[11:42:00.662]     }
[11:42:00.662]     else {
[11:42:00.662]         if (TRUE) {
[11:42:00.662]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:42:00.662]                 open = "w")
[11:42:00.662]         }
[11:42:00.662]         else {
[11:42:00.662]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:42:00.662]                 windows = "NUL", "/dev/null"), open = "w")
[11:42:00.662]         }
[11:42:00.662]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:42:00.662]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:42:00.662]             base::sink(type = "output", split = FALSE)
[11:42:00.662]             base::close(...future.stdout)
[11:42:00.662]         }, add = TRUE)
[11:42:00.662]     }
[11:42:00.662]     ...future.frame <- base::sys.nframe()
[11:42:00.662]     ...future.conditions <- base::list()
[11:42:00.662]     ...future.rng <- base::globalenv()$.Random.seed
[11:42:00.662]     if (FALSE) {
[11:42:00.662]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:42:00.662]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:42:00.662]     }
[11:42:00.662]     ...future.result <- base::tryCatch({
[11:42:00.662]         base::withCallingHandlers({
[11:42:00.662]             ...future.value <- base::withVisible(base::local({
[11:42:00.662]                 ...future.makeSendCondition <- local({
[11:42:00.662]                   sendCondition <- NULL
[11:42:00.662]                   function(frame = 1L) {
[11:42:00.662]                     if (is.function(sendCondition)) 
[11:42:00.662]                       return(sendCondition)
[11:42:00.662]                     ns <- getNamespace("parallel")
[11:42:00.662]                     if (exists("sendData", mode = "function", 
[11:42:00.662]                       envir = ns)) {
[11:42:00.662]                       parallel_sendData <- get("sendData", mode = "function", 
[11:42:00.662]                         envir = ns)
[11:42:00.662]                       envir <- sys.frame(frame)
[11:42:00.662]                       master <- NULL
[11:42:00.662]                       while (!identical(envir, .GlobalEnv) && 
[11:42:00.662]                         !identical(envir, emptyenv())) {
[11:42:00.662]                         if (exists("master", mode = "list", envir = envir, 
[11:42:00.662]                           inherits = FALSE)) {
[11:42:00.662]                           master <- get("master", mode = "list", 
[11:42:00.662]                             envir = envir, inherits = FALSE)
[11:42:00.662]                           if (inherits(master, c("SOCKnode", 
[11:42:00.662]                             "SOCK0node"))) {
[11:42:00.662]                             sendCondition <<- function(cond) {
[11:42:00.662]                               data <- list(type = "VALUE", value = cond, 
[11:42:00.662]                                 success = TRUE)
[11:42:00.662]                               parallel_sendData(master, data)
[11:42:00.662]                             }
[11:42:00.662]                             return(sendCondition)
[11:42:00.662]                           }
[11:42:00.662]                         }
[11:42:00.662]                         frame <- frame + 1L
[11:42:00.662]                         envir <- sys.frame(frame)
[11:42:00.662]                       }
[11:42:00.662]                     }
[11:42:00.662]                     sendCondition <<- function(cond) NULL
[11:42:00.662]                   }
[11:42:00.662]                 })
[11:42:00.662]                 withCallingHandlers({
[11:42:00.662]                   {
[11:42:00.662]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:42:00.662]                     if (!identical(...future.globals.maxSize.org, 
[11:42:00.662]                       ...future.globals.maxSize)) {
[11:42:00.662]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:42:00.662]                       on.exit(options(oopts), add = TRUE)
[11:42:00.662]                     }
[11:42:00.662]                     {
[11:42:00.662]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:42:00.662]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:42:00.662]                           envir = globalenv(), inherits = FALSE)
[11:42:00.662]                         ...future.FUN(...)
[11:42:00.662]                       }
[11:42:00.662]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:42:00.662]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:42:00.662]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:42:00.662]                         USE.NAMES = FALSE)
[11:42:00.662]                       do.call(mapply, args = args)
[11:42:00.662]                     }
[11:42:00.662]                   }
[11:42:00.662]                 }, immediateCondition = function(cond) {
[11:42:00.662]                   sendCondition <- ...future.makeSendCondition()
[11:42:00.662]                   sendCondition(cond)
[11:42:00.662]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:00.662]                   {
[11:42:00.662]                     inherits <- base::inherits
[11:42:00.662]                     invokeRestart <- base::invokeRestart
[11:42:00.662]                     is.null <- base::is.null
[11:42:00.662]                     muffled <- FALSE
[11:42:00.662]                     if (inherits(cond, "message")) {
[11:42:00.662]                       muffled <- grepl(pattern, "muffleMessage")
[11:42:00.662]                       if (muffled) 
[11:42:00.662]                         invokeRestart("muffleMessage")
[11:42:00.662]                     }
[11:42:00.662]                     else if (inherits(cond, "warning")) {
[11:42:00.662]                       muffled <- grepl(pattern, "muffleWarning")
[11:42:00.662]                       if (muffled) 
[11:42:00.662]                         invokeRestart("muffleWarning")
[11:42:00.662]                     }
[11:42:00.662]                     else if (inherits(cond, "condition")) {
[11:42:00.662]                       if (!is.null(pattern)) {
[11:42:00.662]                         computeRestarts <- base::computeRestarts
[11:42:00.662]                         grepl <- base::grepl
[11:42:00.662]                         restarts <- computeRestarts(cond)
[11:42:00.662]                         for (restart in restarts) {
[11:42:00.662]                           name <- restart$name
[11:42:00.662]                           if (is.null(name)) 
[11:42:00.662]                             next
[11:42:00.662]                           if (!grepl(pattern, name)) 
[11:42:00.662]                             next
[11:42:00.662]                           invokeRestart(restart)
[11:42:00.662]                           muffled <- TRUE
[11:42:00.662]                           break
[11:42:00.662]                         }
[11:42:00.662]                       }
[11:42:00.662]                     }
[11:42:00.662]                     invisible(muffled)
[11:42:00.662]                   }
[11:42:00.662]                   muffleCondition(cond)
[11:42:00.662]                 })
[11:42:00.662]             }))
[11:42:00.662]             future::FutureResult(value = ...future.value$value, 
[11:42:00.662]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:42:00.662]                   ...future.rng), globalenv = if (FALSE) 
[11:42:00.662]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:42:00.662]                     ...future.globalenv.names))
[11:42:00.662]                 else NULL, started = ...future.startTime, version = "1.8")
[11:42:00.662]         }, condition = base::local({
[11:42:00.662]             c <- base::c
[11:42:00.662]             inherits <- base::inherits
[11:42:00.662]             invokeRestart <- base::invokeRestart
[11:42:00.662]             length <- base::length
[11:42:00.662]             list <- base::list
[11:42:00.662]             seq.int <- base::seq.int
[11:42:00.662]             signalCondition <- base::signalCondition
[11:42:00.662]             sys.calls <- base::sys.calls
[11:42:00.662]             `[[` <- base::`[[`
[11:42:00.662]             `+` <- base::`+`
[11:42:00.662]             `<<-` <- base::`<<-`
[11:42:00.662]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:42:00.662]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:42:00.662]                   3L)]
[11:42:00.662]             }
[11:42:00.662]             function(cond) {
[11:42:00.662]                 is_error <- inherits(cond, "error")
[11:42:00.662]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:42:00.662]                   NULL)
[11:42:00.662]                 if (is_error) {
[11:42:00.662]                   sessionInformation <- function() {
[11:42:00.662]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:42:00.662]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:42:00.662]                       search = base::search(), system = base::Sys.info())
[11:42:00.662]                   }
[11:42:00.662]                   ...future.conditions[[length(...future.conditions) + 
[11:42:00.662]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:42:00.662]                     cond$call), session = sessionInformation(), 
[11:42:00.662]                     timestamp = base::Sys.time(), signaled = 0L)
[11:42:00.662]                   signalCondition(cond)
[11:42:00.662]                 }
[11:42:00.662]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:42:00.662]                 "immediateCondition"))) {
[11:42:00.662]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:42:00.662]                   ...future.conditions[[length(...future.conditions) + 
[11:42:00.662]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:42:00.662]                   if (TRUE && !signal) {
[11:42:00.662]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:00.662]                     {
[11:42:00.662]                       inherits <- base::inherits
[11:42:00.662]                       invokeRestart <- base::invokeRestart
[11:42:00.662]                       is.null <- base::is.null
[11:42:00.662]                       muffled <- FALSE
[11:42:00.662]                       if (inherits(cond, "message")) {
[11:42:00.662]                         muffled <- grepl(pattern, "muffleMessage")
[11:42:00.662]                         if (muffled) 
[11:42:00.662]                           invokeRestart("muffleMessage")
[11:42:00.662]                       }
[11:42:00.662]                       else if (inherits(cond, "warning")) {
[11:42:00.662]                         muffled <- grepl(pattern, "muffleWarning")
[11:42:00.662]                         if (muffled) 
[11:42:00.662]                           invokeRestart("muffleWarning")
[11:42:00.662]                       }
[11:42:00.662]                       else if (inherits(cond, "condition")) {
[11:42:00.662]                         if (!is.null(pattern)) {
[11:42:00.662]                           computeRestarts <- base::computeRestarts
[11:42:00.662]                           grepl <- base::grepl
[11:42:00.662]                           restarts <- computeRestarts(cond)
[11:42:00.662]                           for (restart in restarts) {
[11:42:00.662]                             name <- restart$name
[11:42:00.662]                             if (is.null(name)) 
[11:42:00.662]                               next
[11:42:00.662]                             if (!grepl(pattern, name)) 
[11:42:00.662]                               next
[11:42:00.662]                             invokeRestart(restart)
[11:42:00.662]                             muffled <- TRUE
[11:42:00.662]                             break
[11:42:00.662]                           }
[11:42:00.662]                         }
[11:42:00.662]                       }
[11:42:00.662]                       invisible(muffled)
[11:42:00.662]                     }
[11:42:00.662]                     muffleCondition(cond, pattern = "^muffle")
[11:42:00.662]                   }
[11:42:00.662]                 }
[11:42:00.662]                 else {
[11:42:00.662]                   if (TRUE) {
[11:42:00.662]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:00.662]                     {
[11:42:00.662]                       inherits <- base::inherits
[11:42:00.662]                       invokeRestart <- base::invokeRestart
[11:42:00.662]                       is.null <- base::is.null
[11:42:00.662]                       muffled <- FALSE
[11:42:00.662]                       if (inherits(cond, "message")) {
[11:42:00.662]                         muffled <- grepl(pattern, "muffleMessage")
[11:42:00.662]                         if (muffled) 
[11:42:00.662]                           invokeRestart("muffleMessage")
[11:42:00.662]                       }
[11:42:00.662]                       else if (inherits(cond, "warning")) {
[11:42:00.662]                         muffled <- grepl(pattern, "muffleWarning")
[11:42:00.662]                         if (muffled) 
[11:42:00.662]                           invokeRestart("muffleWarning")
[11:42:00.662]                       }
[11:42:00.662]                       else if (inherits(cond, "condition")) {
[11:42:00.662]                         if (!is.null(pattern)) {
[11:42:00.662]                           computeRestarts <- base::computeRestarts
[11:42:00.662]                           grepl <- base::grepl
[11:42:00.662]                           restarts <- computeRestarts(cond)
[11:42:00.662]                           for (restart in restarts) {
[11:42:00.662]                             name <- restart$name
[11:42:00.662]                             if (is.null(name)) 
[11:42:00.662]                               next
[11:42:00.662]                             if (!grepl(pattern, name)) 
[11:42:00.662]                               next
[11:42:00.662]                             invokeRestart(restart)
[11:42:00.662]                             muffled <- TRUE
[11:42:00.662]                             break
[11:42:00.662]                           }
[11:42:00.662]                         }
[11:42:00.662]                       }
[11:42:00.662]                       invisible(muffled)
[11:42:00.662]                     }
[11:42:00.662]                     muffleCondition(cond, pattern = "^muffle")
[11:42:00.662]                   }
[11:42:00.662]                 }
[11:42:00.662]             }
[11:42:00.662]         }))
[11:42:00.662]     }, error = function(ex) {
[11:42:00.662]         base::structure(base::list(value = NULL, visible = NULL, 
[11:42:00.662]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:42:00.662]                 ...future.rng), started = ...future.startTime, 
[11:42:00.662]             finished = Sys.time(), session_uuid = NA_character_, 
[11:42:00.662]             version = "1.8"), class = "FutureResult")
[11:42:00.662]     }, finally = {
[11:42:00.662]         if (!identical(...future.workdir, getwd())) 
[11:42:00.662]             setwd(...future.workdir)
[11:42:00.662]         {
[11:42:00.662]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:42:00.662]                 ...future.oldOptions$nwarnings <- NULL
[11:42:00.662]             }
[11:42:00.662]             base::options(...future.oldOptions)
[11:42:00.662]             if (.Platform$OS.type == "windows") {
[11:42:00.662]                 old_names <- names(...future.oldEnvVars)
[11:42:00.662]                 envs <- base::Sys.getenv()
[11:42:00.662]                 names <- names(envs)
[11:42:00.662]                 common <- intersect(names, old_names)
[11:42:00.662]                 added <- setdiff(names, old_names)
[11:42:00.662]                 removed <- setdiff(old_names, names)
[11:42:00.662]                 changed <- common[...future.oldEnvVars[common] != 
[11:42:00.662]                   envs[common]]
[11:42:00.662]                 NAMES <- toupper(changed)
[11:42:00.662]                 args <- list()
[11:42:00.662]                 for (kk in seq_along(NAMES)) {
[11:42:00.662]                   name <- changed[[kk]]
[11:42:00.662]                   NAME <- NAMES[[kk]]
[11:42:00.662]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:00.662]                     next
[11:42:00.662]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:42:00.662]                 }
[11:42:00.662]                 NAMES <- toupper(added)
[11:42:00.662]                 for (kk in seq_along(NAMES)) {
[11:42:00.662]                   name <- added[[kk]]
[11:42:00.662]                   NAME <- NAMES[[kk]]
[11:42:00.662]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:00.662]                     next
[11:42:00.662]                   args[[name]] <- ""
[11:42:00.662]                 }
[11:42:00.662]                 NAMES <- toupper(removed)
[11:42:00.662]                 for (kk in seq_along(NAMES)) {
[11:42:00.662]                   name <- removed[[kk]]
[11:42:00.662]                   NAME <- NAMES[[kk]]
[11:42:00.662]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:00.662]                     next
[11:42:00.662]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:42:00.662]                 }
[11:42:00.662]                 if (length(args) > 0) 
[11:42:00.662]                   base::do.call(base::Sys.setenv, args = args)
[11:42:00.662]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:42:00.662]             }
[11:42:00.662]             else {
[11:42:00.662]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:42:00.662]             }
[11:42:00.662]             {
[11:42:00.662]                 if (base::length(...future.futureOptionsAdded) > 
[11:42:00.662]                   0L) {
[11:42:00.662]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:42:00.662]                   base::names(opts) <- ...future.futureOptionsAdded
[11:42:00.662]                   base::options(opts)
[11:42:00.662]                 }
[11:42:00.662]                 {
[11:42:00.662]                   {
[11:42:00.662]                     base::options(mc.cores = ...future.mc.cores.old)
[11:42:00.662]                     NULL
[11:42:00.662]                   }
[11:42:00.662]                   options(future.plan = NULL)
[11:42:00.662]                   if (is.na(NA_character_)) 
[11:42:00.662]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:42:00.662]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:42:00.662]                   future::plan(list(function (..., workers = 2, 
[11:42:00.662]                     envir = parent.frame()) 
[11:42:00.662]                   strategy(..., workers = workers, envir = envir)), 
[11:42:00.662]                     .cleanup = FALSE, .init = FALSE)
[11:42:00.662]                 }
[11:42:00.662]             }
[11:42:00.662]         }
[11:42:00.662]     })
[11:42:00.662]     if (TRUE) {
[11:42:00.662]         base::sink(type = "output", split = FALSE)
[11:42:00.662]         if (TRUE) {
[11:42:00.662]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:42:00.662]         }
[11:42:00.662]         else {
[11:42:00.662]             ...future.result["stdout"] <- base::list(NULL)
[11:42:00.662]         }
[11:42:00.662]         base::close(...future.stdout)
[11:42:00.662]         ...future.stdout <- NULL
[11:42:00.662]     }
[11:42:00.662]     ...future.result$conditions <- ...future.conditions
[11:42:00.662]     ...future.result$finished <- base::Sys.time()
[11:42:00.662]     ...future.result
[11:42:00.662] }
[11:42:00.664] Poll #1 (0): usedNodes() = 2, workers = 2
[11:42:00.675] receiveMessageFromWorker() for ClusterFuture ...
[11:42:00.675] - Validating connection of MultisessionFuture
[11:42:00.676] - received message: FutureResult
[11:42:00.676] - Received FutureResult
[11:42:00.676] - Erased future from FutureRegistry
[11:42:00.676] result() for ClusterFuture ...
[11:42:00.676] - result already collected: FutureResult
[11:42:00.676] result() for ClusterFuture ... done
[11:42:00.676] receiveMessageFromWorker() for ClusterFuture ... done
[11:42:00.676] result() for ClusterFuture ...
[11:42:00.677] - result already collected: FutureResult
[11:42:00.677] result() for ClusterFuture ... done
[11:42:00.677] result() for ClusterFuture ...
[11:42:00.677] - result already collected: FutureResult
[11:42:00.677] result() for ClusterFuture ... done
[11:42:00.678] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:42:00.678] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:42:00.726] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:42:00.732] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:42:00.778] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:42:00.779] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:42:00.827] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:42:00.828] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:42:00.829] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:42:00.830] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:42:00.832] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:42:00.832] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:42:00.834] MultisessionFuture started
[11:42:00.834] - Launch lazy future ... done
[11:42:00.834] run() for ‘MultisessionFuture’ ... done
[11:42:00.834] Created future:
[11:42:00.835] MultisessionFuture:
[11:42:00.835] Label: ‘future_mapply-84’
[11:42:00.835] Expression:
[11:42:00.835] {
[11:42:00.835]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:42:00.835]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:42:00.835]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:42:00.835]         on.exit(options(oopts), add = TRUE)
[11:42:00.835]     }
[11:42:00.835]     {
[11:42:00.835]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:42:00.835]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:42:00.835]                 inherits = FALSE)
[11:42:00.835]             ...future.FUN(...)
[11:42:00.835]         }
[11:42:00.835]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:42:00.835]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:42:00.835]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:42:00.835]         do.call(mapply, args = args)
[11:42:00.835]     }
[11:42:00.835] }
[11:42:00.835] Lazy evaluation: FALSE
[11:42:00.835] Asynchronous evaluation: TRUE
[11:42:00.835] Local evaluation: TRUE
[11:42:00.835] Environment: 0x560ef58e1768
[11:42:00.835] Capture standard output: TRUE
[11:42:00.835] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:42:00.835] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:42:00.835] Packages: 1 packages (‘mlr3’)
[11:42:00.835] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:42:00.835] Resolved: FALSE
[11:42:00.835] Value: <not collected>
[11:42:00.835] Conditions captured: <none>
[11:42:00.835] Early signaling: FALSE
[11:42:00.835] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:42:00.835] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:42:00.854] Chunk #84 of 90 ... DONE
[11:42:00.854] Chunk #85 of 90 ...
[11:42:00.855]  - seeds: [1] <seeds>
[11:42:00.855] getGlobalsAndPackages() ...
[11:42:00.855] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:42:00.855] Resolving globals: FALSE
[11:42:00.856] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:42:00.857] - packages: [1] ‘mlr3’
[11:42:00.857] getGlobalsAndPackages() ... DONE
[11:42:00.857] run() for ‘Future’ ...
[11:42:00.858] - state: ‘created’
[11:42:00.858] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:42:00.872] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:42:00.872] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:42:00.872]   - Field: ‘node’
[11:42:00.872]   - Field: ‘label’
[11:42:00.873]   - Field: ‘local’
[11:42:00.873]   - Field: ‘owner’
[11:42:00.873]   - Field: ‘envir’
[11:42:00.873]   - Field: ‘workers’
[11:42:00.873]   - Field: ‘packages’
[11:42:00.873]   - Field: ‘gc’
[11:42:00.873]   - Field: ‘conditions’
[11:42:00.873]   - Field: ‘persistent’
[11:42:00.873]   - Field: ‘expr’
[11:42:00.873]   - Field: ‘uuid’
[11:42:00.873]   - Field: ‘seed’
[11:42:00.873]   - Field: ‘version’
[11:42:00.873]   - Field: ‘result’
[11:42:00.873]   - Field: ‘asynchronous’
[11:42:00.873]   - Field: ‘calls’
[11:42:00.873]   - Field: ‘globals’
[11:42:00.873]   - Field: ‘stdout’
[11:42:00.873]   - Field: ‘earlySignal’
[11:42:00.873]   - Field: ‘lazy’
[11:42:00.874]   - Field: ‘state’
[11:42:00.874] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:42:00.874] - Launch lazy future ...
[11:42:00.874] Packages needed by the future expression (n = 1): ‘mlr3’
[11:42:00.874] Packages needed by future strategies (n = 0): <none>
[11:42:00.874] {
[11:42:00.874]     {
[11:42:00.874]         {
[11:42:00.874]             ...future.startTime <- base::Sys.time()
[11:42:00.874]             {
[11:42:00.874]                 {
[11:42:00.874]                   {
[11:42:00.874]                     {
[11:42:00.874]                       {
[11:42:00.874]                         base::local({
[11:42:00.874]                           has_future <- base::requireNamespace("future", 
[11:42:00.874]                             quietly = TRUE)
[11:42:00.874]                           if (has_future) {
[11:42:00.874]                             ns <- base::getNamespace("future")
[11:42:00.874]                             version <- ns[[".package"]][["version"]]
[11:42:00.874]                             if (is.null(version)) 
[11:42:00.874]                               version <- utils::packageVersion("future")
[11:42:00.874]                           }
[11:42:00.874]                           else {
[11:42:00.874]                             version <- NULL
[11:42:00.874]                           }
[11:42:00.874]                           if (!has_future || version < "1.8.0") {
[11:42:00.874]                             info <- base::c(r_version = base::gsub("R version ", 
[11:42:00.874]                               "", base::R.version$version.string), 
[11:42:00.874]                               platform = base::sprintf("%s (%s-bit)", 
[11:42:00.874]                                 base::R.version$platform, 8 * 
[11:42:00.874]                                   base::.Machine$sizeof.pointer), 
[11:42:00.874]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:42:00.874]                                 "release", "version")], collapse = " "), 
[11:42:00.874]                               hostname = base::Sys.info()[["nodename"]])
[11:42:00.874]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:42:00.874]                               info)
[11:42:00.874]                             info <- base::paste(info, collapse = "; ")
[11:42:00.874]                             if (!has_future) {
[11:42:00.874]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:42:00.874]                                 info)
[11:42:00.874]                             }
[11:42:00.874]                             else {
[11:42:00.874]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:42:00.874]                                 info, version)
[11:42:00.874]                             }
[11:42:00.874]                             base::stop(msg)
[11:42:00.874]                           }
[11:42:00.874]                         })
[11:42:00.874]                       }
[11:42:00.874]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:42:00.874]                       base::options(mc.cores = 1L)
[11:42:00.874]                     }
[11:42:00.874]                     base::local({
[11:42:00.874]                       for (pkg in "mlr3") {
[11:42:00.874]                         base::loadNamespace(pkg)
[11:42:00.874]                         base::library(pkg, character.only = TRUE)
[11:42:00.874]                       }
[11:42:00.874]                     })
[11:42:00.874]                   }
[11:42:00.874]                   options(future.plan = NULL)
[11:42:00.874]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:42:00.874]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:42:00.874]                 }
[11:42:00.874]                 ...future.workdir <- getwd()
[11:42:00.874]             }
[11:42:00.874]             ...future.oldOptions <- base::as.list(base::.Options)
[11:42:00.874]             ...future.oldEnvVars <- base::Sys.getenv()
[11:42:00.874]         }
[11:42:00.874]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:42:00.874]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:42:00.874]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:42:00.874]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:42:00.874]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:42:00.874]             future.stdout.windows.reencode = NULL, width = 400L)
[11:42:00.874]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:42:00.874]             base::names(...future.oldOptions))
[11:42:00.874]     }
[11:42:00.874]     if (FALSE) {
[11:42:00.874]     }
[11:42:00.874]     else {
[11:42:00.874]         if (TRUE) {
[11:42:00.874]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:42:00.874]                 open = "w")
[11:42:00.874]         }
[11:42:00.874]         else {
[11:42:00.874]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:42:00.874]                 windows = "NUL", "/dev/null"), open = "w")
[11:42:00.874]         }
[11:42:00.874]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:42:00.874]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:42:00.874]             base::sink(type = "output", split = FALSE)
[11:42:00.874]             base::close(...future.stdout)
[11:42:00.874]         }, add = TRUE)
[11:42:00.874]     }
[11:42:00.874]     ...future.frame <- base::sys.nframe()
[11:42:00.874]     ...future.conditions <- base::list()
[11:42:00.874]     ...future.rng <- base::globalenv()$.Random.seed
[11:42:00.874]     if (FALSE) {
[11:42:00.874]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:42:00.874]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:42:00.874]     }
[11:42:00.874]     ...future.result <- base::tryCatch({
[11:42:00.874]         base::withCallingHandlers({
[11:42:00.874]             ...future.value <- base::withVisible(base::local({
[11:42:00.874]                 ...future.makeSendCondition <- local({
[11:42:00.874]                   sendCondition <- NULL
[11:42:00.874]                   function(frame = 1L) {
[11:42:00.874]                     if (is.function(sendCondition)) 
[11:42:00.874]                       return(sendCondition)
[11:42:00.874]                     ns <- getNamespace("parallel")
[11:42:00.874]                     if (exists("sendData", mode = "function", 
[11:42:00.874]                       envir = ns)) {
[11:42:00.874]                       parallel_sendData <- get("sendData", mode = "function", 
[11:42:00.874]                         envir = ns)
[11:42:00.874]                       envir <- sys.frame(frame)
[11:42:00.874]                       master <- NULL
[11:42:00.874]                       while (!identical(envir, .GlobalEnv) && 
[11:42:00.874]                         !identical(envir, emptyenv())) {
[11:42:00.874]                         if (exists("master", mode = "list", envir = envir, 
[11:42:00.874]                           inherits = FALSE)) {
[11:42:00.874]                           master <- get("master", mode = "list", 
[11:42:00.874]                             envir = envir, inherits = FALSE)
[11:42:00.874]                           if (inherits(master, c("SOCKnode", 
[11:42:00.874]                             "SOCK0node"))) {
[11:42:00.874]                             sendCondition <<- function(cond) {
[11:42:00.874]                               data <- list(type = "VALUE", value = cond, 
[11:42:00.874]                                 success = TRUE)
[11:42:00.874]                               parallel_sendData(master, data)
[11:42:00.874]                             }
[11:42:00.874]                             return(sendCondition)
[11:42:00.874]                           }
[11:42:00.874]                         }
[11:42:00.874]                         frame <- frame + 1L
[11:42:00.874]                         envir <- sys.frame(frame)
[11:42:00.874]                       }
[11:42:00.874]                     }
[11:42:00.874]                     sendCondition <<- function(cond) NULL
[11:42:00.874]                   }
[11:42:00.874]                 })
[11:42:00.874]                 withCallingHandlers({
[11:42:00.874]                   {
[11:42:00.874]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:42:00.874]                     if (!identical(...future.globals.maxSize.org, 
[11:42:00.874]                       ...future.globals.maxSize)) {
[11:42:00.874]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:42:00.874]                       on.exit(options(oopts), add = TRUE)
[11:42:00.874]                     }
[11:42:00.874]                     {
[11:42:00.874]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:42:00.874]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:42:00.874]                           envir = globalenv(), inherits = FALSE)
[11:42:00.874]                         ...future.FUN(...)
[11:42:00.874]                       }
[11:42:00.874]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:42:00.874]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:42:00.874]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:42:00.874]                         USE.NAMES = FALSE)
[11:42:00.874]                       do.call(mapply, args = args)
[11:42:00.874]                     }
[11:42:00.874]                   }
[11:42:00.874]                 }, immediateCondition = function(cond) {
[11:42:00.874]                   sendCondition <- ...future.makeSendCondition()
[11:42:00.874]                   sendCondition(cond)
[11:42:00.874]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:00.874]                   {
[11:42:00.874]                     inherits <- base::inherits
[11:42:00.874]                     invokeRestart <- base::invokeRestart
[11:42:00.874]                     is.null <- base::is.null
[11:42:00.874]                     muffled <- FALSE
[11:42:00.874]                     if (inherits(cond, "message")) {
[11:42:00.874]                       muffled <- grepl(pattern, "muffleMessage")
[11:42:00.874]                       if (muffled) 
[11:42:00.874]                         invokeRestart("muffleMessage")
[11:42:00.874]                     }
[11:42:00.874]                     else if (inherits(cond, "warning")) {
[11:42:00.874]                       muffled <- grepl(pattern, "muffleWarning")
[11:42:00.874]                       if (muffled) 
[11:42:00.874]                         invokeRestart("muffleWarning")
[11:42:00.874]                     }
[11:42:00.874]                     else if (inherits(cond, "condition")) {
[11:42:00.874]                       if (!is.null(pattern)) {
[11:42:00.874]                         computeRestarts <- base::computeRestarts
[11:42:00.874]                         grepl <- base::grepl
[11:42:00.874]                         restarts <- computeRestarts(cond)
[11:42:00.874]                         for (restart in restarts) {
[11:42:00.874]                           name <- restart$name
[11:42:00.874]                           if (is.null(name)) 
[11:42:00.874]                             next
[11:42:00.874]                           if (!grepl(pattern, name)) 
[11:42:00.874]                             next
[11:42:00.874]                           invokeRestart(restart)
[11:42:00.874]                           muffled <- TRUE
[11:42:00.874]                           break
[11:42:00.874]                         }
[11:42:00.874]                       }
[11:42:00.874]                     }
[11:42:00.874]                     invisible(muffled)
[11:42:00.874]                   }
[11:42:00.874]                   muffleCondition(cond)
[11:42:00.874]                 })
[11:42:00.874]             }))
[11:42:00.874]             future::FutureResult(value = ...future.value$value, 
[11:42:00.874]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:42:00.874]                   ...future.rng), globalenv = if (FALSE) 
[11:42:00.874]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:42:00.874]                     ...future.globalenv.names))
[11:42:00.874]                 else NULL, started = ...future.startTime, version = "1.8")
[11:42:00.874]         }, condition = base::local({
[11:42:00.874]             c <- base::c
[11:42:00.874]             inherits <- base::inherits
[11:42:00.874]             invokeRestart <- base::invokeRestart
[11:42:00.874]             length <- base::length
[11:42:00.874]             list <- base::list
[11:42:00.874]             seq.int <- base::seq.int
[11:42:00.874]             signalCondition <- base::signalCondition
[11:42:00.874]             sys.calls <- base::sys.calls
[11:42:00.874]             `[[` <- base::`[[`
[11:42:00.874]             `+` <- base::`+`
[11:42:00.874]             `<<-` <- base::`<<-`
[11:42:00.874]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:42:00.874]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:42:00.874]                   3L)]
[11:42:00.874]             }
[11:42:00.874]             function(cond) {
[11:42:00.874]                 is_error <- inherits(cond, "error")
[11:42:00.874]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:42:00.874]                   NULL)
[11:42:00.874]                 if (is_error) {
[11:42:00.874]                   sessionInformation <- function() {
[11:42:00.874]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:42:00.874]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:42:00.874]                       search = base::search(), system = base::Sys.info())
[11:42:00.874]                   }
[11:42:00.874]                   ...future.conditions[[length(...future.conditions) + 
[11:42:00.874]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:42:00.874]                     cond$call), session = sessionInformation(), 
[11:42:00.874]                     timestamp = base::Sys.time(), signaled = 0L)
[11:42:00.874]                   signalCondition(cond)
[11:42:00.874]                 }
[11:42:00.874]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:42:00.874]                 "immediateCondition"))) {
[11:42:00.874]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:42:00.874]                   ...future.conditions[[length(...future.conditions) + 
[11:42:00.874]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:42:00.874]                   if (TRUE && !signal) {
[11:42:00.874]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:00.874]                     {
[11:42:00.874]                       inherits <- base::inherits
[11:42:00.874]                       invokeRestart <- base::invokeRestart
[11:42:00.874]                       is.null <- base::is.null
[11:42:00.874]                       muffled <- FALSE
[11:42:00.874]                       if (inherits(cond, "message")) {
[11:42:00.874]                         muffled <- grepl(pattern, "muffleMessage")
[11:42:00.874]                         if (muffled) 
[11:42:00.874]                           invokeRestart("muffleMessage")
[11:42:00.874]                       }
[11:42:00.874]                       else if (inherits(cond, "warning")) {
[11:42:00.874]                         muffled <- grepl(pattern, "muffleWarning")
[11:42:00.874]                         if (muffled) 
[11:42:00.874]                           invokeRestart("muffleWarning")
[11:42:00.874]                       }
[11:42:00.874]                       else if (inherits(cond, "condition")) {
[11:42:00.874]                         if (!is.null(pattern)) {
[11:42:00.874]                           computeRestarts <- base::computeRestarts
[11:42:00.874]                           grepl <- base::grepl
[11:42:00.874]                           restarts <- computeRestarts(cond)
[11:42:00.874]                           for (restart in restarts) {
[11:42:00.874]                             name <- restart$name
[11:42:00.874]                             if (is.null(name)) 
[11:42:00.874]                               next
[11:42:00.874]                             if (!grepl(pattern, name)) 
[11:42:00.874]                               next
[11:42:00.874]                             invokeRestart(restart)
[11:42:00.874]                             muffled <- TRUE
[11:42:00.874]                             break
[11:42:00.874]                           }
[11:42:00.874]                         }
[11:42:00.874]                       }
[11:42:00.874]                       invisible(muffled)
[11:42:00.874]                     }
[11:42:00.874]                     muffleCondition(cond, pattern = "^muffle")
[11:42:00.874]                   }
[11:42:00.874]                 }
[11:42:00.874]                 else {
[11:42:00.874]                   if (TRUE) {
[11:42:00.874]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:00.874]                     {
[11:42:00.874]                       inherits <- base::inherits
[11:42:00.874]                       invokeRestart <- base::invokeRestart
[11:42:00.874]                       is.null <- base::is.null
[11:42:00.874]                       muffled <- FALSE
[11:42:00.874]                       if (inherits(cond, "message")) {
[11:42:00.874]                         muffled <- grepl(pattern, "muffleMessage")
[11:42:00.874]                         if (muffled) 
[11:42:00.874]                           invokeRestart("muffleMessage")
[11:42:00.874]                       }
[11:42:00.874]                       else if (inherits(cond, "warning")) {
[11:42:00.874]                         muffled <- grepl(pattern, "muffleWarning")
[11:42:00.874]                         if (muffled) 
[11:42:00.874]                           invokeRestart("muffleWarning")
[11:42:00.874]                       }
[11:42:00.874]                       else if (inherits(cond, "condition")) {
[11:42:00.874]                         if (!is.null(pattern)) {
[11:42:00.874]                           computeRestarts <- base::computeRestarts
[11:42:00.874]                           grepl <- base::grepl
[11:42:00.874]                           restarts <- computeRestarts(cond)
[11:42:00.874]                           for (restart in restarts) {
[11:42:00.874]                             name <- restart$name
[11:42:00.874]                             if (is.null(name)) 
[11:42:00.874]                               next
[11:42:00.874]                             if (!grepl(pattern, name)) 
[11:42:00.874]                               next
[11:42:00.874]                             invokeRestart(restart)
[11:42:00.874]                             muffled <- TRUE
[11:42:00.874]                             break
[11:42:00.874]                           }
[11:42:00.874]                         }
[11:42:00.874]                       }
[11:42:00.874]                       invisible(muffled)
[11:42:00.874]                     }
[11:42:00.874]                     muffleCondition(cond, pattern = "^muffle")
[11:42:00.874]                   }
[11:42:00.874]                 }
[11:42:00.874]             }
[11:42:00.874]         }))
[11:42:00.874]     }, error = function(ex) {
[11:42:00.874]         base::structure(base::list(value = NULL, visible = NULL, 
[11:42:00.874]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:42:00.874]                 ...future.rng), started = ...future.startTime, 
[11:42:00.874]             finished = Sys.time(), session_uuid = NA_character_, 
[11:42:00.874]             version = "1.8"), class = "FutureResult")
[11:42:00.874]     }, finally = {
[11:42:00.874]         if (!identical(...future.workdir, getwd())) 
[11:42:00.874]             setwd(...future.workdir)
[11:42:00.874]         {
[11:42:00.874]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:42:00.874]                 ...future.oldOptions$nwarnings <- NULL
[11:42:00.874]             }
[11:42:00.874]             base::options(...future.oldOptions)
[11:42:00.874]             if (.Platform$OS.type == "windows") {
[11:42:00.874]                 old_names <- names(...future.oldEnvVars)
[11:42:00.874]                 envs <- base::Sys.getenv()
[11:42:00.874]                 names <- names(envs)
[11:42:00.874]                 common <- intersect(names, old_names)
[11:42:00.874]                 added <- setdiff(names, old_names)
[11:42:00.874]                 removed <- setdiff(old_names, names)
[11:42:00.874]                 changed <- common[...future.oldEnvVars[common] != 
[11:42:00.874]                   envs[common]]
[11:42:00.874]                 NAMES <- toupper(changed)
[11:42:00.874]                 args <- list()
[11:42:00.874]                 for (kk in seq_along(NAMES)) {
[11:42:00.874]                   name <- changed[[kk]]
[11:42:00.874]                   NAME <- NAMES[[kk]]
[11:42:00.874]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:00.874]                     next
[11:42:00.874]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:42:00.874]                 }
[11:42:00.874]                 NAMES <- toupper(added)
[11:42:00.874]                 for (kk in seq_along(NAMES)) {
[11:42:00.874]                   name <- added[[kk]]
[11:42:00.874]                   NAME <- NAMES[[kk]]
[11:42:00.874]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:00.874]                     next
[11:42:00.874]                   args[[name]] <- ""
[11:42:00.874]                 }
[11:42:00.874]                 NAMES <- toupper(removed)
[11:42:00.874]                 for (kk in seq_along(NAMES)) {
[11:42:00.874]                   name <- removed[[kk]]
[11:42:00.874]                   NAME <- NAMES[[kk]]
[11:42:00.874]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:00.874]                     next
[11:42:00.874]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:42:00.874]                 }
[11:42:00.874]                 if (length(args) > 0) 
[11:42:00.874]                   base::do.call(base::Sys.setenv, args = args)
[11:42:00.874]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:42:00.874]             }
[11:42:00.874]             else {
[11:42:00.874]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:42:00.874]             }
[11:42:00.874]             {
[11:42:00.874]                 if (base::length(...future.futureOptionsAdded) > 
[11:42:00.874]                   0L) {
[11:42:00.874]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:42:00.874]                   base::names(opts) <- ...future.futureOptionsAdded
[11:42:00.874]                   base::options(opts)
[11:42:00.874]                 }
[11:42:00.874]                 {
[11:42:00.874]                   {
[11:42:00.874]                     base::options(mc.cores = ...future.mc.cores.old)
[11:42:00.874]                     NULL
[11:42:00.874]                   }
[11:42:00.874]                   options(future.plan = NULL)
[11:42:00.874]                   if (is.na(NA_character_)) 
[11:42:00.874]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:42:00.874]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:42:00.874]                   future::plan(list(function (..., workers = 2, 
[11:42:00.874]                     envir = parent.frame()) 
[11:42:00.874]                   strategy(..., workers = workers, envir = envir)), 
[11:42:00.874]                     .cleanup = FALSE, .init = FALSE)
[11:42:00.874]                 }
[11:42:00.874]             }
[11:42:00.874]         }
[11:42:00.874]     })
[11:42:00.874]     if (TRUE) {
[11:42:00.874]         base::sink(type = "output", split = FALSE)
[11:42:00.874]         if (TRUE) {
[11:42:00.874]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:42:00.874]         }
[11:42:00.874]         else {
[11:42:00.874]             ...future.result["stdout"] <- base::list(NULL)
[11:42:00.874]         }
[11:42:00.874]         base::close(...future.stdout)
[11:42:00.874]         ...future.stdout <- NULL
[11:42:00.874]     }
[11:42:00.874]     ...future.result$conditions <- ...future.conditions
[11:42:00.874]     ...future.result$finished <- base::Sys.time()
[11:42:00.874]     ...future.result
[11:42:00.874] }
[11:42:00.876] Poll #1 (0): usedNodes() = 2, workers = 2
[11:42:00.887] receiveMessageFromWorker() for ClusterFuture ...
[11:42:00.887] - Validating connection of MultisessionFuture
[11:42:00.887] - received message: FutureResult
[11:42:00.887] - Received FutureResult
[11:42:00.887] - Erased future from FutureRegistry
[11:42:00.888] result() for ClusterFuture ...
[11:42:00.888] - result already collected: FutureResult
[11:42:00.888] result() for ClusterFuture ... done
[11:42:00.888] receiveMessageFromWorker() for ClusterFuture ... done
[11:42:00.888] result() for ClusterFuture ...
[11:42:00.888] - result already collected: FutureResult
[11:42:00.888] result() for ClusterFuture ... done
[11:42:00.888] result() for ClusterFuture ...
[11:42:00.888] - result already collected: FutureResult
[11:42:00.888] result() for ClusterFuture ... done
[11:42:00.889] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:42:00.889] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:42:00.933] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:42:00.936] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:42:00.981] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:42:00.981] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:42:01.025] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:42:01.026] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:42:01.026] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:42:01.026] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:42:01.027] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:42:01.027] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:42:01.027] MultisessionFuture started
[11:42:01.027] - Launch lazy future ... done
[11:42:01.027] run() for ‘MultisessionFuture’ ... done
[11:42:01.027] Created future:
[11:42:01.027] MultisessionFuture:
[11:42:01.027] Label: ‘future_mapply-85’
[11:42:01.027] Expression:
[11:42:01.027] {
[11:42:01.027]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:42:01.027]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:42:01.027]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:42:01.027]         on.exit(options(oopts), add = TRUE)
[11:42:01.027]     }
[11:42:01.027]     {
[11:42:01.027]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:42:01.027]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:42:01.027]                 inherits = FALSE)
[11:42:01.027]             ...future.FUN(...)
[11:42:01.027]         }
[11:42:01.027]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:42:01.027]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:42:01.027]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:42:01.027]         do.call(mapply, args = args)
[11:42:01.027]     }
[11:42:01.027] }
[11:42:01.027] Lazy evaluation: FALSE
[11:42:01.027] Asynchronous evaluation: TRUE
[11:42:01.027] Local evaluation: TRUE
[11:42:01.027] Environment: 0x560ef58e1768
[11:42:01.027] Capture standard output: TRUE
[11:42:01.027] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:42:01.027] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:42:01.027] Packages: 1 packages (‘mlr3’)
[11:42:01.027] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:42:01.027] Resolved: FALSE
[11:42:01.027] Value: <not collected>
[11:42:01.027] Conditions captured: <none>
[11:42:01.027] Early signaling: FALSE
[11:42:01.027] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:42:01.027] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:42:01.041] Chunk #85 of 90 ... DONE
[11:42:01.041] Chunk #86 of 90 ...
[11:42:01.041]  - seeds: [1] <seeds>
[11:42:01.042] getGlobalsAndPackages() ...
[11:42:01.042] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:42:01.042] Resolving globals: FALSE
[11:42:01.042] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:42:01.042] - packages: [1] ‘mlr3’
[11:42:01.042] getGlobalsAndPackages() ... DONE
[11:42:01.042] run() for ‘Future’ ...
[11:42:01.042] - state: ‘created’
[11:42:01.042] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:42:01.051] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:42:01.051] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:42:01.051]   - Field: ‘node’
[11:42:01.051]   - Field: ‘label’
[11:42:01.052]   - Field: ‘local’
[11:42:01.052]   - Field: ‘owner’
[11:42:01.052]   - Field: ‘envir’
[11:42:01.052]   - Field: ‘workers’
[11:42:01.052]   - Field: ‘packages’
[11:42:01.052]   - Field: ‘gc’
[11:42:01.052]   - Field: ‘conditions’
[11:42:01.052]   - Field: ‘persistent’
[11:42:01.052]   - Field: ‘expr’
[11:42:01.052]   - Field: ‘uuid’
[11:42:01.052]   - Field: ‘seed’
[11:42:01.052]   - Field: ‘version’
[11:42:01.052]   - Field: ‘result’
[11:42:01.052]   - Field: ‘asynchronous’
[11:42:01.052]   - Field: ‘calls’
[11:42:01.052]   - Field: ‘globals’
[11:42:01.052]   - Field: ‘stdout’
[11:42:01.052]   - Field: ‘earlySignal’
[11:42:01.052]   - Field: ‘lazy’
[11:42:01.052]   - Field: ‘state’
[11:42:01.052] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:42:01.053] - Launch lazy future ...
[11:42:01.053] Packages needed by the future expression (n = 1): ‘mlr3’
[11:42:01.053] Packages needed by future strategies (n = 0): <none>
[11:42:01.053] {
[11:42:01.053]     {
[11:42:01.053]         {
[11:42:01.053]             ...future.startTime <- base::Sys.time()
[11:42:01.053]             {
[11:42:01.053]                 {
[11:42:01.053]                   {
[11:42:01.053]                     {
[11:42:01.053]                       {
[11:42:01.053]                         base::local({
[11:42:01.053]                           has_future <- base::requireNamespace("future", 
[11:42:01.053]                             quietly = TRUE)
[11:42:01.053]                           if (has_future) {
[11:42:01.053]                             ns <- base::getNamespace("future")
[11:42:01.053]                             version <- ns[[".package"]][["version"]]
[11:42:01.053]                             if (is.null(version)) 
[11:42:01.053]                               version <- utils::packageVersion("future")
[11:42:01.053]                           }
[11:42:01.053]                           else {
[11:42:01.053]                             version <- NULL
[11:42:01.053]                           }
[11:42:01.053]                           if (!has_future || version < "1.8.0") {
[11:42:01.053]                             info <- base::c(r_version = base::gsub("R version ", 
[11:42:01.053]                               "", base::R.version$version.string), 
[11:42:01.053]                               platform = base::sprintf("%s (%s-bit)", 
[11:42:01.053]                                 base::R.version$platform, 8 * 
[11:42:01.053]                                   base::.Machine$sizeof.pointer), 
[11:42:01.053]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:42:01.053]                                 "release", "version")], collapse = " "), 
[11:42:01.053]                               hostname = base::Sys.info()[["nodename"]])
[11:42:01.053]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:42:01.053]                               info)
[11:42:01.053]                             info <- base::paste(info, collapse = "; ")
[11:42:01.053]                             if (!has_future) {
[11:42:01.053]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:42:01.053]                                 info)
[11:42:01.053]                             }
[11:42:01.053]                             else {
[11:42:01.053]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:42:01.053]                                 info, version)
[11:42:01.053]                             }
[11:42:01.053]                             base::stop(msg)
[11:42:01.053]                           }
[11:42:01.053]                         })
[11:42:01.053]                       }
[11:42:01.053]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:42:01.053]                       base::options(mc.cores = 1L)
[11:42:01.053]                     }
[11:42:01.053]                     base::local({
[11:42:01.053]                       for (pkg in "mlr3") {
[11:42:01.053]                         base::loadNamespace(pkg)
[11:42:01.053]                         base::library(pkg, character.only = TRUE)
[11:42:01.053]                       }
[11:42:01.053]                     })
[11:42:01.053]                   }
[11:42:01.053]                   options(future.plan = NULL)
[11:42:01.053]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:42:01.053]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:42:01.053]                 }
[11:42:01.053]                 ...future.workdir <- getwd()
[11:42:01.053]             }
[11:42:01.053]             ...future.oldOptions <- base::as.list(base::.Options)
[11:42:01.053]             ...future.oldEnvVars <- base::Sys.getenv()
[11:42:01.053]         }
[11:42:01.053]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:42:01.053]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:42:01.053]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:42:01.053]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:42:01.053]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:42:01.053]             future.stdout.windows.reencode = NULL, width = 400L)
[11:42:01.053]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:42:01.053]             base::names(...future.oldOptions))
[11:42:01.053]     }
[11:42:01.053]     if (FALSE) {
[11:42:01.053]     }
[11:42:01.053]     else {
[11:42:01.053]         if (TRUE) {
[11:42:01.053]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:42:01.053]                 open = "w")
[11:42:01.053]         }
[11:42:01.053]         else {
[11:42:01.053]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:42:01.053]                 windows = "NUL", "/dev/null"), open = "w")
[11:42:01.053]         }
[11:42:01.053]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:42:01.053]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:42:01.053]             base::sink(type = "output", split = FALSE)
[11:42:01.053]             base::close(...future.stdout)
[11:42:01.053]         }, add = TRUE)
[11:42:01.053]     }
[11:42:01.053]     ...future.frame <- base::sys.nframe()
[11:42:01.053]     ...future.conditions <- base::list()
[11:42:01.053]     ...future.rng <- base::globalenv()$.Random.seed
[11:42:01.053]     if (FALSE) {
[11:42:01.053]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:42:01.053]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:42:01.053]     }
[11:42:01.053]     ...future.result <- base::tryCatch({
[11:42:01.053]         base::withCallingHandlers({
[11:42:01.053]             ...future.value <- base::withVisible(base::local({
[11:42:01.053]                 ...future.makeSendCondition <- local({
[11:42:01.053]                   sendCondition <- NULL
[11:42:01.053]                   function(frame = 1L) {
[11:42:01.053]                     if (is.function(sendCondition)) 
[11:42:01.053]                       return(sendCondition)
[11:42:01.053]                     ns <- getNamespace("parallel")
[11:42:01.053]                     if (exists("sendData", mode = "function", 
[11:42:01.053]                       envir = ns)) {
[11:42:01.053]                       parallel_sendData <- get("sendData", mode = "function", 
[11:42:01.053]                         envir = ns)
[11:42:01.053]                       envir <- sys.frame(frame)
[11:42:01.053]                       master <- NULL
[11:42:01.053]                       while (!identical(envir, .GlobalEnv) && 
[11:42:01.053]                         !identical(envir, emptyenv())) {
[11:42:01.053]                         if (exists("master", mode = "list", envir = envir, 
[11:42:01.053]                           inherits = FALSE)) {
[11:42:01.053]                           master <- get("master", mode = "list", 
[11:42:01.053]                             envir = envir, inherits = FALSE)
[11:42:01.053]                           if (inherits(master, c("SOCKnode", 
[11:42:01.053]                             "SOCK0node"))) {
[11:42:01.053]                             sendCondition <<- function(cond) {
[11:42:01.053]                               data <- list(type = "VALUE", value = cond, 
[11:42:01.053]                                 success = TRUE)
[11:42:01.053]                               parallel_sendData(master, data)
[11:42:01.053]                             }
[11:42:01.053]                             return(sendCondition)
[11:42:01.053]                           }
[11:42:01.053]                         }
[11:42:01.053]                         frame <- frame + 1L
[11:42:01.053]                         envir <- sys.frame(frame)
[11:42:01.053]                       }
[11:42:01.053]                     }
[11:42:01.053]                     sendCondition <<- function(cond) NULL
[11:42:01.053]                   }
[11:42:01.053]                 })
[11:42:01.053]                 withCallingHandlers({
[11:42:01.053]                   {
[11:42:01.053]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:42:01.053]                     if (!identical(...future.globals.maxSize.org, 
[11:42:01.053]                       ...future.globals.maxSize)) {
[11:42:01.053]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:42:01.053]                       on.exit(options(oopts), add = TRUE)
[11:42:01.053]                     }
[11:42:01.053]                     {
[11:42:01.053]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:42:01.053]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:42:01.053]                           envir = globalenv(), inherits = FALSE)
[11:42:01.053]                         ...future.FUN(...)
[11:42:01.053]                       }
[11:42:01.053]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:42:01.053]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:42:01.053]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:42:01.053]                         USE.NAMES = FALSE)
[11:42:01.053]                       do.call(mapply, args = args)
[11:42:01.053]                     }
[11:42:01.053]                   }
[11:42:01.053]                 }, immediateCondition = function(cond) {
[11:42:01.053]                   sendCondition <- ...future.makeSendCondition()
[11:42:01.053]                   sendCondition(cond)
[11:42:01.053]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:01.053]                   {
[11:42:01.053]                     inherits <- base::inherits
[11:42:01.053]                     invokeRestart <- base::invokeRestart
[11:42:01.053]                     is.null <- base::is.null
[11:42:01.053]                     muffled <- FALSE
[11:42:01.053]                     if (inherits(cond, "message")) {
[11:42:01.053]                       muffled <- grepl(pattern, "muffleMessage")
[11:42:01.053]                       if (muffled) 
[11:42:01.053]                         invokeRestart("muffleMessage")
[11:42:01.053]                     }
[11:42:01.053]                     else if (inherits(cond, "warning")) {
[11:42:01.053]                       muffled <- grepl(pattern, "muffleWarning")
[11:42:01.053]                       if (muffled) 
[11:42:01.053]                         invokeRestart("muffleWarning")
[11:42:01.053]                     }
[11:42:01.053]                     else if (inherits(cond, "condition")) {
[11:42:01.053]                       if (!is.null(pattern)) {
[11:42:01.053]                         computeRestarts <- base::computeRestarts
[11:42:01.053]                         grepl <- base::grepl
[11:42:01.053]                         restarts <- computeRestarts(cond)
[11:42:01.053]                         for (restart in restarts) {
[11:42:01.053]                           name <- restart$name
[11:42:01.053]                           if (is.null(name)) 
[11:42:01.053]                             next
[11:42:01.053]                           if (!grepl(pattern, name)) 
[11:42:01.053]                             next
[11:42:01.053]                           invokeRestart(restart)
[11:42:01.053]                           muffled <- TRUE
[11:42:01.053]                           break
[11:42:01.053]                         }
[11:42:01.053]                       }
[11:42:01.053]                     }
[11:42:01.053]                     invisible(muffled)
[11:42:01.053]                   }
[11:42:01.053]                   muffleCondition(cond)
[11:42:01.053]                 })
[11:42:01.053]             }))
[11:42:01.053]             future::FutureResult(value = ...future.value$value, 
[11:42:01.053]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:42:01.053]                   ...future.rng), globalenv = if (FALSE) 
[11:42:01.053]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:42:01.053]                     ...future.globalenv.names))
[11:42:01.053]                 else NULL, started = ...future.startTime, version = "1.8")
[11:42:01.053]         }, condition = base::local({
[11:42:01.053]             c <- base::c
[11:42:01.053]             inherits <- base::inherits
[11:42:01.053]             invokeRestart <- base::invokeRestart
[11:42:01.053]             length <- base::length
[11:42:01.053]             list <- base::list
[11:42:01.053]             seq.int <- base::seq.int
[11:42:01.053]             signalCondition <- base::signalCondition
[11:42:01.053]             sys.calls <- base::sys.calls
[11:42:01.053]             `[[` <- base::`[[`
[11:42:01.053]             `+` <- base::`+`
[11:42:01.053]             `<<-` <- base::`<<-`
[11:42:01.053]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:42:01.053]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:42:01.053]                   3L)]
[11:42:01.053]             }
[11:42:01.053]             function(cond) {
[11:42:01.053]                 is_error <- inherits(cond, "error")
[11:42:01.053]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:42:01.053]                   NULL)
[11:42:01.053]                 if (is_error) {
[11:42:01.053]                   sessionInformation <- function() {
[11:42:01.053]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:42:01.053]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:42:01.053]                       search = base::search(), system = base::Sys.info())
[11:42:01.053]                   }
[11:42:01.053]                   ...future.conditions[[length(...future.conditions) + 
[11:42:01.053]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:42:01.053]                     cond$call), session = sessionInformation(), 
[11:42:01.053]                     timestamp = base::Sys.time(), signaled = 0L)
[11:42:01.053]                   signalCondition(cond)
[11:42:01.053]                 }
[11:42:01.053]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:42:01.053]                 "immediateCondition"))) {
[11:42:01.053]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:42:01.053]                   ...future.conditions[[length(...future.conditions) + 
[11:42:01.053]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:42:01.053]                   if (TRUE && !signal) {
[11:42:01.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:01.053]                     {
[11:42:01.053]                       inherits <- base::inherits
[11:42:01.053]                       invokeRestart <- base::invokeRestart
[11:42:01.053]                       is.null <- base::is.null
[11:42:01.053]                       muffled <- FALSE
[11:42:01.053]                       if (inherits(cond, "message")) {
[11:42:01.053]                         muffled <- grepl(pattern, "muffleMessage")
[11:42:01.053]                         if (muffled) 
[11:42:01.053]                           invokeRestart("muffleMessage")
[11:42:01.053]                       }
[11:42:01.053]                       else if (inherits(cond, "warning")) {
[11:42:01.053]                         muffled <- grepl(pattern, "muffleWarning")
[11:42:01.053]                         if (muffled) 
[11:42:01.053]                           invokeRestart("muffleWarning")
[11:42:01.053]                       }
[11:42:01.053]                       else if (inherits(cond, "condition")) {
[11:42:01.053]                         if (!is.null(pattern)) {
[11:42:01.053]                           computeRestarts <- base::computeRestarts
[11:42:01.053]                           grepl <- base::grepl
[11:42:01.053]                           restarts <- computeRestarts(cond)
[11:42:01.053]                           for (restart in restarts) {
[11:42:01.053]                             name <- restart$name
[11:42:01.053]                             if (is.null(name)) 
[11:42:01.053]                               next
[11:42:01.053]                             if (!grepl(pattern, name)) 
[11:42:01.053]                               next
[11:42:01.053]                             invokeRestart(restart)
[11:42:01.053]                             muffled <- TRUE
[11:42:01.053]                             break
[11:42:01.053]                           }
[11:42:01.053]                         }
[11:42:01.053]                       }
[11:42:01.053]                       invisible(muffled)
[11:42:01.053]                     }
[11:42:01.053]                     muffleCondition(cond, pattern = "^muffle")
[11:42:01.053]                   }
[11:42:01.053]                 }
[11:42:01.053]                 else {
[11:42:01.053]                   if (TRUE) {
[11:42:01.053]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:01.053]                     {
[11:42:01.053]                       inherits <- base::inherits
[11:42:01.053]                       invokeRestart <- base::invokeRestart
[11:42:01.053]                       is.null <- base::is.null
[11:42:01.053]                       muffled <- FALSE
[11:42:01.053]                       if (inherits(cond, "message")) {
[11:42:01.053]                         muffled <- grepl(pattern, "muffleMessage")
[11:42:01.053]                         if (muffled) 
[11:42:01.053]                           invokeRestart("muffleMessage")
[11:42:01.053]                       }
[11:42:01.053]                       else if (inherits(cond, "warning")) {
[11:42:01.053]                         muffled <- grepl(pattern, "muffleWarning")
[11:42:01.053]                         if (muffled) 
[11:42:01.053]                           invokeRestart("muffleWarning")
[11:42:01.053]                       }
[11:42:01.053]                       else if (inherits(cond, "condition")) {
[11:42:01.053]                         if (!is.null(pattern)) {
[11:42:01.053]                           computeRestarts <- base::computeRestarts
[11:42:01.053]                           grepl <- base::grepl
[11:42:01.053]                           restarts <- computeRestarts(cond)
[11:42:01.053]                           for (restart in restarts) {
[11:42:01.053]                             name <- restart$name
[11:42:01.053]                             if (is.null(name)) 
[11:42:01.053]                               next
[11:42:01.053]                             if (!grepl(pattern, name)) 
[11:42:01.053]                               next
[11:42:01.053]                             invokeRestart(restart)
[11:42:01.053]                             muffled <- TRUE
[11:42:01.053]                             break
[11:42:01.053]                           }
[11:42:01.053]                         }
[11:42:01.053]                       }
[11:42:01.053]                       invisible(muffled)
[11:42:01.053]                     }
[11:42:01.053]                     muffleCondition(cond, pattern = "^muffle")
[11:42:01.053]                   }
[11:42:01.053]                 }
[11:42:01.053]             }
[11:42:01.053]         }))
[11:42:01.053]     }, error = function(ex) {
[11:42:01.053]         base::structure(base::list(value = NULL, visible = NULL, 
[11:42:01.053]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:42:01.053]                 ...future.rng), started = ...future.startTime, 
[11:42:01.053]             finished = Sys.time(), session_uuid = NA_character_, 
[11:42:01.053]             version = "1.8"), class = "FutureResult")
[11:42:01.053]     }, finally = {
[11:42:01.053]         if (!identical(...future.workdir, getwd())) 
[11:42:01.053]             setwd(...future.workdir)
[11:42:01.053]         {
[11:42:01.053]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:42:01.053]                 ...future.oldOptions$nwarnings <- NULL
[11:42:01.053]             }
[11:42:01.053]             base::options(...future.oldOptions)
[11:42:01.053]             if (.Platform$OS.type == "windows") {
[11:42:01.053]                 old_names <- names(...future.oldEnvVars)
[11:42:01.053]                 envs <- base::Sys.getenv()
[11:42:01.053]                 names <- names(envs)
[11:42:01.053]                 common <- intersect(names, old_names)
[11:42:01.053]                 added <- setdiff(names, old_names)
[11:42:01.053]                 removed <- setdiff(old_names, names)
[11:42:01.053]                 changed <- common[...future.oldEnvVars[common] != 
[11:42:01.053]                   envs[common]]
[11:42:01.053]                 NAMES <- toupper(changed)
[11:42:01.053]                 args <- list()
[11:42:01.053]                 for (kk in seq_along(NAMES)) {
[11:42:01.053]                   name <- changed[[kk]]
[11:42:01.053]                   NAME <- NAMES[[kk]]
[11:42:01.053]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:01.053]                     next
[11:42:01.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:42:01.053]                 }
[11:42:01.053]                 NAMES <- toupper(added)
[11:42:01.053]                 for (kk in seq_along(NAMES)) {
[11:42:01.053]                   name <- added[[kk]]
[11:42:01.053]                   NAME <- NAMES[[kk]]
[11:42:01.053]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:01.053]                     next
[11:42:01.053]                   args[[name]] <- ""
[11:42:01.053]                 }
[11:42:01.053]                 NAMES <- toupper(removed)
[11:42:01.053]                 for (kk in seq_along(NAMES)) {
[11:42:01.053]                   name <- removed[[kk]]
[11:42:01.053]                   NAME <- NAMES[[kk]]
[11:42:01.053]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:01.053]                     next
[11:42:01.053]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:42:01.053]                 }
[11:42:01.053]                 if (length(args) > 0) 
[11:42:01.053]                   base::do.call(base::Sys.setenv, args = args)
[11:42:01.053]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:42:01.053]             }
[11:42:01.053]             else {
[11:42:01.053]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:42:01.053]             }
[11:42:01.053]             {
[11:42:01.053]                 if (base::length(...future.futureOptionsAdded) > 
[11:42:01.053]                   0L) {
[11:42:01.053]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:42:01.053]                   base::names(opts) <- ...future.futureOptionsAdded
[11:42:01.053]                   base::options(opts)
[11:42:01.053]                 }
[11:42:01.053]                 {
[11:42:01.053]                   {
[11:42:01.053]                     base::options(mc.cores = ...future.mc.cores.old)
[11:42:01.053]                     NULL
[11:42:01.053]                   }
[11:42:01.053]                   options(future.plan = NULL)
[11:42:01.053]                   if (is.na(NA_character_)) 
[11:42:01.053]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:42:01.053]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:42:01.053]                   future::plan(list(function (..., workers = 2, 
[11:42:01.053]                     envir = parent.frame()) 
[11:42:01.053]                   strategy(..., workers = workers, envir = envir)), 
[11:42:01.053]                     .cleanup = FALSE, .init = FALSE)
[11:42:01.053]                 }
[11:42:01.053]             }
[11:42:01.053]         }
[11:42:01.053]     })
[11:42:01.053]     if (TRUE) {
[11:42:01.053]         base::sink(type = "output", split = FALSE)
[11:42:01.053]         if (TRUE) {
[11:42:01.053]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:42:01.053]         }
[11:42:01.053]         else {
[11:42:01.053]             ...future.result["stdout"] <- base::list(NULL)
[11:42:01.053]         }
[11:42:01.053]         base::close(...future.stdout)
[11:42:01.053]         ...future.stdout <- NULL
[11:42:01.053]     }
[11:42:01.053]     ...future.result$conditions <- ...future.conditions
[11:42:01.053]     ...future.result$finished <- base::Sys.time()
[11:42:01.053]     ...future.result
[11:42:01.053] }
[11:42:01.055] Poll #1 (0): usedNodes() = 2, workers = 2
[11:42:01.065] receiveMessageFromWorker() for ClusterFuture ...
[11:42:01.065] - Validating connection of MultisessionFuture
[11:42:01.065] - received message: FutureResult
[11:42:01.066] - Received FutureResult
[11:42:01.066] - Erased future from FutureRegistry
[11:42:01.066] result() for ClusterFuture ...
[11:42:01.066] - result already collected: FutureResult
[11:42:01.066] result() for ClusterFuture ... done
[11:42:01.066] receiveMessageFromWorker() for ClusterFuture ... done
[11:42:01.066] result() for ClusterFuture ...
[11:42:01.066] - result already collected: FutureResult
[11:42:01.066] result() for ClusterFuture ... done
[11:42:01.066] result() for ClusterFuture ...
[11:42:01.066] - result already collected: FutureResult
[11:42:01.066] result() for ClusterFuture ... done
[11:42:01.067] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:42:01.067] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:42:01.113] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:42:01.116] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:42:01.165] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:42:01.165] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:42:01.209] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:42:01.210] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:42:01.210] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:42:01.211] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:42:01.211] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:42:01.211] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:42:01.212] MultisessionFuture started
[11:42:01.212] - Launch lazy future ... done
[11:42:01.213] run() for ‘MultisessionFuture’ ... done
[11:42:01.213] Created future:
[11:42:01.213] MultisessionFuture:
[11:42:01.213] Label: ‘future_mapply-86’
[11:42:01.213] Expression:
[11:42:01.213] {
[11:42:01.213]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:42:01.213]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:42:01.213]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:42:01.213]         on.exit(options(oopts), add = TRUE)
[11:42:01.213]     }
[11:42:01.213]     {
[11:42:01.213]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:42:01.213]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:42:01.213]                 inherits = FALSE)
[11:42:01.213]             ...future.FUN(...)
[11:42:01.213]         }
[11:42:01.213]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:42:01.213]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:42:01.213]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:42:01.213]         do.call(mapply, args = args)
[11:42:01.213]     }
[11:42:01.213] }
[11:42:01.213] Lazy evaluation: FALSE
[11:42:01.213] Asynchronous evaluation: TRUE
[11:42:01.213] Local evaluation: TRUE
[11:42:01.213] Environment: 0x560ef58e1768
[11:42:01.213] Capture standard output: TRUE
[11:42:01.213] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:42:01.213] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:42:01.213] Packages: 1 packages (‘mlr3’)
[11:42:01.213] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:42:01.213] Resolved: FALSE
[11:42:01.213] Value: <not collected>
[11:42:01.213] Conditions captured: <none>
[11:42:01.213] Early signaling: FALSE
[11:42:01.213] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:42:01.213] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:42:01.228] Chunk #86 of 90 ... DONE
[11:42:01.228] Chunk #87 of 90 ...
[11:42:01.229]  - seeds: [1] <seeds>
[11:42:01.229] getGlobalsAndPackages() ...
[11:42:01.229] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:42:01.229] Resolving globals: FALSE
[11:42:01.229] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:42:01.230] - packages: [1] ‘mlr3’
[11:42:01.230] getGlobalsAndPackages() ... DONE
[11:42:01.230] run() for ‘Future’ ...
[11:42:01.230] - state: ‘created’
[11:42:01.230] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:42:01.246] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:42:01.247] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:42:01.247]   - Field: ‘node’
[11:42:01.247]   - Field: ‘label’
[11:42:01.247]   - Field: ‘local’
[11:42:01.247]   - Field: ‘owner’
[11:42:01.247]   - Field: ‘envir’
[11:42:01.247]   - Field: ‘workers’
[11:42:01.248]   - Field: ‘packages’
[11:42:01.248]   - Field: ‘gc’
[11:42:01.248]   - Field: ‘conditions’
[11:42:01.248]   - Field: ‘persistent’
[11:42:01.248]   - Field: ‘expr’
[11:42:01.248]   - Field: ‘uuid’
[11:42:01.248]   - Field: ‘seed’
[11:42:01.248]   - Field: ‘version’
[11:42:01.248]   - Field: ‘result’
[11:42:01.248]   - Field: ‘asynchronous’
[11:42:01.248]   - Field: ‘calls’
[11:42:01.248]   - Field: ‘globals’
[11:42:01.249]   - Field: ‘stdout’
[11:42:01.249]   - Field: ‘earlySignal’
[11:42:01.249]   - Field: ‘lazy’
[11:42:01.249]   - Field: ‘state’
[11:42:01.249] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:42:01.249] - Launch lazy future ...
[11:42:01.249] Packages needed by the future expression (n = 1): ‘mlr3’
[11:42:01.249] Packages needed by future strategies (n = 0): <none>
[11:42:01.250] {
[11:42:01.250]     {
[11:42:01.250]         {
[11:42:01.250]             ...future.startTime <- base::Sys.time()
[11:42:01.250]             {
[11:42:01.250]                 {
[11:42:01.250]                   {
[11:42:01.250]                     {
[11:42:01.250]                       {
[11:42:01.250]                         base::local({
[11:42:01.250]                           has_future <- base::requireNamespace("future", 
[11:42:01.250]                             quietly = TRUE)
[11:42:01.250]                           if (has_future) {
[11:42:01.250]                             ns <- base::getNamespace("future")
[11:42:01.250]                             version <- ns[[".package"]][["version"]]
[11:42:01.250]                             if (is.null(version)) 
[11:42:01.250]                               version <- utils::packageVersion("future")
[11:42:01.250]                           }
[11:42:01.250]                           else {
[11:42:01.250]                             version <- NULL
[11:42:01.250]                           }
[11:42:01.250]                           if (!has_future || version < "1.8.0") {
[11:42:01.250]                             info <- base::c(r_version = base::gsub("R version ", 
[11:42:01.250]                               "", base::R.version$version.string), 
[11:42:01.250]                               platform = base::sprintf("%s (%s-bit)", 
[11:42:01.250]                                 base::R.version$platform, 8 * 
[11:42:01.250]                                   base::.Machine$sizeof.pointer), 
[11:42:01.250]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:42:01.250]                                 "release", "version")], collapse = " "), 
[11:42:01.250]                               hostname = base::Sys.info()[["nodename"]])
[11:42:01.250]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:42:01.250]                               info)
[11:42:01.250]                             info <- base::paste(info, collapse = "; ")
[11:42:01.250]                             if (!has_future) {
[11:42:01.250]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:42:01.250]                                 info)
[11:42:01.250]                             }
[11:42:01.250]                             else {
[11:42:01.250]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:42:01.250]                                 info, version)
[11:42:01.250]                             }
[11:42:01.250]                             base::stop(msg)
[11:42:01.250]                           }
[11:42:01.250]                         })
[11:42:01.250]                       }
[11:42:01.250]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:42:01.250]                       base::options(mc.cores = 1L)
[11:42:01.250]                     }
[11:42:01.250]                     base::local({
[11:42:01.250]                       for (pkg in "mlr3") {
[11:42:01.250]                         base::loadNamespace(pkg)
[11:42:01.250]                         base::library(pkg, character.only = TRUE)
[11:42:01.250]                       }
[11:42:01.250]                     })
[11:42:01.250]                   }
[11:42:01.250]                   options(future.plan = NULL)
[11:42:01.250]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:42:01.250]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:42:01.250]                 }
[11:42:01.250]                 ...future.workdir <- getwd()
[11:42:01.250]             }
[11:42:01.250]             ...future.oldOptions <- base::as.list(base::.Options)
[11:42:01.250]             ...future.oldEnvVars <- base::Sys.getenv()
[11:42:01.250]         }
[11:42:01.250]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:42:01.250]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:42:01.250]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:42:01.250]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:42:01.250]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:42:01.250]             future.stdout.windows.reencode = NULL, width = 400L)
[11:42:01.250]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:42:01.250]             base::names(...future.oldOptions))
[11:42:01.250]     }
[11:42:01.250]     if (FALSE) {
[11:42:01.250]     }
[11:42:01.250]     else {
[11:42:01.250]         if (TRUE) {
[11:42:01.250]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:42:01.250]                 open = "w")
[11:42:01.250]         }
[11:42:01.250]         else {
[11:42:01.250]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:42:01.250]                 windows = "NUL", "/dev/null"), open = "w")
[11:42:01.250]         }
[11:42:01.250]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:42:01.250]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:42:01.250]             base::sink(type = "output", split = FALSE)
[11:42:01.250]             base::close(...future.stdout)
[11:42:01.250]         }, add = TRUE)
[11:42:01.250]     }
[11:42:01.250]     ...future.frame <- base::sys.nframe()
[11:42:01.250]     ...future.conditions <- base::list()
[11:42:01.250]     ...future.rng <- base::globalenv()$.Random.seed
[11:42:01.250]     if (FALSE) {
[11:42:01.250]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:42:01.250]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:42:01.250]     }
[11:42:01.250]     ...future.result <- base::tryCatch({
[11:42:01.250]         base::withCallingHandlers({
[11:42:01.250]             ...future.value <- base::withVisible(base::local({
[11:42:01.250]                 ...future.makeSendCondition <- local({
[11:42:01.250]                   sendCondition <- NULL
[11:42:01.250]                   function(frame = 1L) {
[11:42:01.250]                     if (is.function(sendCondition)) 
[11:42:01.250]                       return(sendCondition)
[11:42:01.250]                     ns <- getNamespace("parallel")
[11:42:01.250]                     if (exists("sendData", mode = "function", 
[11:42:01.250]                       envir = ns)) {
[11:42:01.250]                       parallel_sendData <- get("sendData", mode = "function", 
[11:42:01.250]                         envir = ns)
[11:42:01.250]                       envir <- sys.frame(frame)
[11:42:01.250]                       master <- NULL
[11:42:01.250]                       while (!identical(envir, .GlobalEnv) && 
[11:42:01.250]                         !identical(envir, emptyenv())) {
[11:42:01.250]                         if (exists("master", mode = "list", envir = envir, 
[11:42:01.250]                           inherits = FALSE)) {
[11:42:01.250]                           master <- get("master", mode = "list", 
[11:42:01.250]                             envir = envir, inherits = FALSE)
[11:42:01.250]                           if (inherits(master, c("SOCKnode", 
[11:42:01.250]                             "SOCK0node"))) {
[11:42:01.250]                             sendCondition <<- function(cond) {
[11:42:01.250]                               data <- list(type = "VALUE", value = cond, 
[11:42:01.250]                                 success = TRUE)
[11:42:01.250]                               parallel_sendData(master, data)
[11:42:01.250]                             }
[11:42:01.250]                             return(sendCondition)
[11:42:01.250]                           }
[11:42:01.250]                         }
[11:42:01.250]                         frame <- frame + 1L
[11:42:01.250]                         envir <- sys.frame(frame)
[11:42:01.250]                       }
[11:42:01.250]                     }
[11:42:01.250]                     sendCondition <<- function(cond) NULL
[11:42:01.250]                   }
[11:42:01.250]                 })
[11:42:01.250]                 withCallingHandlers({
[11:42:01.250]                   {
[11:42:01.250]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:42:01.250]                     if (!identical(...future.globals.maxSize.org, 
[11:42:01.250]                       ...future.globals.maxSize)) {
[11:42:01.250]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:42:01.250]                       on.exit(options(oopts), add = TRUE)
[11:42:01.250]                     }
[11:42:01.250]                     {
[11:42:01.250]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:42:01.250]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:42:01.250]                           envir = globalenv(), inherits = FALSE)
[11:42:01.250]                         ...future.FUN(...)
[11:42:01.250]                       }
[11:42:01.250]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:42:01.250]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:42:01.250]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:42:01.250]                         USE.NAMES = FALSE)
[11:42:01.250]                       do.call(mapply, args = args)
[11:42:01.250]                     }
[11:42:01.250]                   }
[11:42:01.250]                 }, immediateCondition = function(cond) {
[11:42:01.250]                   sendCondition <- ...future.makeSendCondition()
[11:42:01.250]                   sendCondition(cond)
[11:42:01.250]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:01.250]                   {
[11:42:01.250]                     inherits <- base::inherits
[11:42:01.250]                     invokeRestart <- base::invokeRestart
[11:42:01.250]                     is.null <- base::is.null
[11:42:01.250]                     muffled <- FALSE
[11:42:01.250]                     if (inherits(cond, "message")) {
[11:42:01.250]                       muffled <- grepl(pattern, "muffleMessage")
[11:42:01.250]                       if (muffled) 
[11:42:01.250]                         invokeRestart("muffleMessage")
[11:42:01.250]                     }
[11:42:01.250]                     else if (inherits(cond, "warning")) {
[11:42:01.250]                       muffled <- grepl(pattern, "muffleWarning")
[11:42:01.250]                       if (muffled) 
[11:42:01.250]                         invokeRestart("muffleWarning")
[11:42:01.250]                     }
[11:42:01.250]                     else if (inherits(cond, "condition")) {
[11:42:01.250]                       if (!is.null(pattern)) {
[11:42:01.250]                         computeRestarts <- base::computeRestarts
[11:42:01.250]                         grepl <- base::grepl
[11:42:01.250]                         restarts <- computeRestarts(cond)
[11:42:01.250]                         for (restart in restarts) {
[11:42:01.250]                           name <- restart$name
[11:42:01.250]                           if (is.null(name)) 
[11:42:01.250]                             next
[11:42:01.250]                           if (!grepl(pattern, name)) 
[11:42:01.250]                             next
[11:42:01.250]                           invokeRestart(restart)
[11:42:01.250]                           muffled <- TRUE
[11:42:01.250]                           break
[11:42:01.250]                         }
[11:42:01.250]                       }
[11:42:01.250]                     }
[11:42:01.250]                     invisible(muffled)
[11:42:01.250]                   }
[11:42:01.250]                   muffleCondition(cond)
[11:42:01.250]                 })
[11:42:01.250]             }))
[11:42:01.250]             future::FutureResult(value = ...future.value$value, 
[11:42:01.250]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:42:01.250]                   ...future.rng), globalenv = if (FALSE) 
[11:42:01.250]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:42:01.250]                     ...future.globalenv.names))
[11:42:01.250]                 else NULL, started = ...future.startTime, version = "1.8")
[11:42:01.250]         }, condition = base::local({
[11:42:01.250]             c <- base::c
[11:42:01.250]             inherits <- base::inherits
[11:42:01.250]             invokeRestart <- base::invokeRestart
[11:42:01.250]             length <- base::length
[11:42:01.250]             list <- base::list
[11:42:01.250]             seq.int <- base::seq.int
[11:42:01.250]             signalCondition <- base::signalCondition
[11:42:01.250]             sys.calls <- base::sys.calls
[11:42:01.250]             `[[` <- base::`[[`
[11:42:01.250]             `+` <- base::`+`
[11:42:01.250]             `<<-` <- base::`<<-`
[11:42:01.250]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:42:01.250]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:42:01.250]                   3L)]
[11:42:01.250]             }
[11:42:01.250]             function(cond) {
[11:42:01.250]                 is_error <- inherits(cond, "error")
[11:42:01.250]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:42:01.250]                   NULL)
[11:42:01.250]                 if (is_error) {
[11:42:01.250]                   sessionInformation <- function() {
[11:42:01.250]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:42:01.250]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:42:01.250]                       search = base::search(), system = base::Sys.info())
[11:42:01.250]                   }
[11:42:01.250]                   ...future.conditions[[length(...future.conditions) + 
[11:42:01.250]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:42:01.250]                     cond$call), session = sessionInformation(), 
[11:42:01.250]                     timestamp = base::Sys.time(), signaled = 0L)
[11:42:01.250]                   signalCondition(cond)
[11:42:01.250]                 }
[11:42:01.250]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:42:01.250]                 "immediateCondition"))) {
[11:42:01.250]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:42:01.250]                   ...future.conditions[[length(...future.conditions) + 
[11:42:01.250]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:42:01.250]                   if (TRUE && !signal) {
[11:42:01.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:01.250]                     {
[11:42:01.250]                       inherits <- base::inherits
[11:42:01.250]                       invokeRestart <- base::invokeRestart
[11:42:01.250]                       is.null <- base::is.null
[11:42:01.250]                       muffled <- FALSE
[11:42:01.250]                       if (inherits(cond, "message")) {
[11:42:01.250]                         muffled <- grepl(pattern, "muffleMessage")
[11:42:01.250]                         if (muffled) 
[11:42:01.250]                           invokeRestart("muffleMessage")
[11:42:01.250]                       }
[11:42:01.250]                       else if (inherits(cond, "warning")) {
[11:42:01.250]                         muffled <- grepl(pattern, "muffleWarning")
[11:42:01.250]                         if (muffled) 
[11:42:01.250]                           invokeRestart("muffleWarning")
[11:42:01.250]                       }
[11:42:01.250]                       else if (inherits(cond, "condition")) {
[11:42:01.250]                         if (!is.null(pattern)) {
[11:42:01.250]                           computeRestarts <- base::computeRestarts
[11:42:01.250]                           grepl <- base::grepl
[11:42:01.250]                           restarts <- computeRestarts(cond)
[11:42:01.250]                           for (restart in restarts) {
[11:42:01.250]                             name <- restart$name
[11:42:01.250]                             if (is.null(name)) 
[11:42:01.250]                               next
[11:42:01.250]                             if (!grepl(pattern, name)) 
[11:42:01.250]                               next
[11:42:01.250]                             invokeRestart(restart)
[11:42:01.250]                             muffled <- TRUE
[11:42:01.250]                             break
[11:42:01.250]                           }
[11:42:01.250]                         }
[11:42:01.250]                       }
[11:42:01.250]                       invisible(muffled)
[11:42:01.250]                     }
[11:42:01.250]                     muffleCondition(cond, pattern = "^muffle")
[11:42:01.250]                   }
[11:42:01.250]                 }
[11:42:01.250]                 else {
[11:42:01.250]                   if (TRUE) {
[11:42:01.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:01.250]                     {
[11:42:01.250]                       inherits <- base::inherits
[11:42:01.250]                       invokeRestart <- base::invokeRestart
[11:42:01.250]                       is.null <- base::is.null
[11:42:01.250]                       muffled <- FALSE
[11:42:01.250]                       if (inherits(cond, "message")) {
[11:42:01.250]                         muffled <- grepl(pattern, "muffleMessage")
[11:42:01.250]                         if (muffled) 
[11:42:01.250]                           invokeRestart("muffleMessage")
[11:42:01.250]                       }
[11:42:01.250]                       else if (inherits(cond, "warning")) {
[11:42:01.250]                         muffled <- grepl(pattern, "muffleWarning")
[11:42:01.250]                         if (muffled) 
[11:42:01.250]                           invokeRestart("muffleWarning")
[11:42:01.250]                       }
[11:42:01.250]                       else if (inherits(cond, "condition")) {
[11:42:01.250]                         if (!is.null(pattern)) {
[11:42:01.250]                           computeRestarts <- base::computeRestarts
[11:42:01.250]                           grepl <- base::grepl
[11:42:01.250]                           restarts <- computeRestarts(cond)
[11:42:01.250]                           for (restart in restarts) {
[11:42:01.250]                             name <- restart$name
[11:42:01.250]                             if (is.null(name)) 
[11:42:01.250]                               next
[11:42:01.250]                             if (!grepl(pattern, name)) 
[11:42:01.250]                               next
[11:42:01.250]                             invokeRestart(restart)
[11:42:01.250]                             muffled <- TRUE
[11:42:01.250]                             break
[11:42:01.250]                           }
[11:42:01.250]                         }
[11:42:01.250]                       }
[11:42:01.250]                       invisible(muffled)
[11:42:01.250]                     }
[11:42:01.250]                     muffleCondition(cond, pattern = "^muffle")
[11:42:01.250]                   }
[11:42:01.250]                 }
[11:42:01.250]             }
[11:42:01.250]         }))
[11:42:01.250]     }, error = function(ex) {
[11:42:01.250]         base::structure(base::list(value = NULL, visible = NULL, 
[11:42:01.250]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:42:01.250]                 ...future.rng), started = ...future.startTime, 
[11:42:01.250]             finished = Sys.time(), session_uuid = NA_character_, 
[11:42:01.250]             version = "1.8"), class = "FutureResult")
[11:42:01.250]     }, finally = {
[11:42:01.250]         if (!identical(...future.workdir, getwd())) 
[11:42:01.250]             setwd(...future.workdir)
[11:42:01.250]         {
[11:42:01.250]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:42:01.250]                 ...future.oldOptions$nwarnings <- NULL
[11:42:01.250]             }
[11:42:01.250]             base::options(...future.oldOptions)
[11:42:01.250]             if (.Platform$OS.type == "windows") {
[11:42:01.250]                 old_names <- names(...future.oldEnvVars)
[11:42:01.250]                 envs <- base::Sys.getenv()
[11:42:01.250]                 names <- names(envs)
[11:42:01.250]                 common <- intersect(names, old_names)
[11:42:01.250]                 added <- setdiff(names, old_names)
[11:42:01.250]                 removed <- setdiff(old_names, names)
[11:42:01.250]                 changed <- common[...future.oldEnvVars[common] != 
[11:42:01.250]                   envs[common]]
[11:42:01.250]                 NAMES <- toupper(changed)
[11:42:01.250]                 args <- list()
[11:42:01.250]                 for (kk in seq_along(NAMES)) {
[11:42:01.250]                   name <- changed[[kk]]
[11:42:01.250]                   NAME <- NAMES[[kk]]
[11:42:01.250]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:01.250]                     next
[11:42:01.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:42:01.250]                 }
[11:42:01.250]                 NAMES <- toupper(added)
[11:42:01.250]                 for (kk in seq_along(NAMES)) {
[11:42:01.250]                   name <- added[[kk]]
[11:42:01.250]                   NAME <- NAMES[[kk]]
[11:42:01.250]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:01.250]                     next
[11:42:01.250]                   args[[name]] <- ""
[11:42:01.250]                 }
[11:42:01.250]                 NAMES <- toupper(removed)
[11:42:01.250]                 for (kk in seq_along(NAMES)) {
[11:42:01.250]                   name <- removed[[kk]]
[11:42:01.250]                   NAME <- NAMES[[kk]]
[11:42:01.250]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:01.250]                     next
[11:42:01.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:42:01.250]                 }
[11:42:01.250]                 if (length(args) > 0) 
[11:42:01.250]                   base::do.call(base::Sys.setenv, args = args)
[11:42:01.250]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:42:01.250]             }
[11:42:01.250]             else {
[11:42:01.250]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:42:01.250]             }
[11:42:01.250]             {
[11:42:01.250]                 if (base::length(...future.futureOptionsAdded) > 
[11:42:01.250]                   0L) {
[11:42:01.250]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:42:01.250]                   base::names(opts) <- ...future.futureOptionsAdded
[11:42:01.250]                   base::options(opts)
[11:42:01.250]                 }
[11:42:01.250]                 {
[11:42:01.250]                   {
[11:42:01.250]                     base::options(mc.cores = ...future.mc.cores.old)
[11:42:01.250]                     NULL
[11:42:01.250]                   }
[11:42:01.250]                   options(future.plan = NULL)
[11:42:01.250]                   if (is.na(NA_character_)) 
[11:42:01.250]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:42:01.250]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:42:01.250]                   future::plan(list(function (..., workers = 2, 
[11:42:01.250]                     envir = parent.frame()) 
[11:42:01.250]                   strategy(..., workers = workers, envir = envir)), 
[11:42:01.250]                     .cleanup = FALSE, .init = FALSE)
[11:42:01.250]                 }
[11:42:01.250]             }
[11:42:01.250]         }
[11:42:01.250]     })
[11:42:01.250]     if (TRUE) {
[11:42:01.250]         base::sink(type = "output", split = FALSE)
[11:42:01.250]         if (TRUE) {
[11:42:01.250]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:42:01.250]         }
[11:42:01.250]         else {
[11:42:01.250]             ...future.result["stdout"] <- base::list(NULL)
[11:42:01.250]         }
[11:42:01.250]         base::close(...future.stdout)
[11:42:01.250]         ...future.stdout <- NULL
[11:42:01.250]     }
[11:42:01.250]     ...future.result$conditions <- ...future.conditions
[11:42:01.250]     ...future.result$finished <- base::Sys.time()
[11:42:01.250]     ...future.result
[11:42:01.250] }
[11:42:01.252] Poll #1 (0): usedNodes() = 2, workers = 2
[11:42:01.263] receiveMessageFromWorker() for ClusterFuture ...
[11:42:01.263] - Validating connection of MultisessionFuture
[11:42:01.263] - received message: FutureResult
[11:42:01.263] - Received FutureResult
[11:42:01.263] - Erased future from FutureRegistry
[11:42:01.263] result() for ClusterFuture ...
[11:42:01.264] - result already collected: FutureResult
[11:42:01.264] result() for ClusterFuture ... done
[11:42:01.264] receiveMessageFromWorker() for ClusterFuture ... done
[11:42:01.264] result() for ClusterFuture ...
[11:42:01.264] - result already collected: FutureResult
[11:42:01.264] result() for ClusterFuture ... done
[11:42:01.264] result() for ClusterFuture ...
[11:42:01.264] - result already collected: FutureResult
[11:42:01.264] result() for ClusterFuture ... done
[11:42:01.265] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:42:01.265] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:42:01.309] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:42:01.312] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:42:01.314] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:42:01.314] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:42:01.357] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:42:01.358] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:42:01.358] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:42:01.358] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:42:01.359] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:42:01.359] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:42:01.360] MultisessionFuture started
[11:42:01.360] - Launch lazy future ... done
[11:42:01.360] run() for ‘MultisessionFuture’ ... done
[11:42:01.360] Created future:
[11:42:01.360] MultisessionFuture:
[11:42:01.360] Label: ‘future_mapply-87’
[11:42:01.360] Expression:
[11:42:01.360] {
[11:42:01.360]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:42:01.360]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:42:01.360]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:42:01.360]         on.exit(options(oopts), add = TRUE)
[11:42:01.360]     }
[11:42:01.360]     {
[11:42:01.360]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:42:01.360]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:42:01.360]                 inherits = FALSE)
[11:42:01.360]             ...future.FUN(...)
[11:42:01.360]         }
[11:42:01.360]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:42:01.360]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:42:01.360]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:42:01.360]         do.call(mapply, args = args)
[11:42:01.360]     }
[11:42:01.360] }
[11:42:01.360] Lazy evaluation: FALSE
[11:42:01.360] Asynchronous evaluation: TRUE
[11:42:01.360] Local evaluation: TRUE
[11:42:01.360] Environment: 0x560ef58e1768
[11:42:01.360] Capture standard output: TRUE
[11:42:01.360] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:42:01.360] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:42:01.360] Packages: 1 packages (‘mlr3’)
[11:42:01.360] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:42:01.360] Resolved: FALSE
[11:42:01.360] Value: <not collected>
[11:42:01.360] Conditions captured: <none>
[11:42:01.360] Early signaling: FALSE
[11:42:01.360] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:42:01.360] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:42:01.377] Chunk #87 of 90 ... DONE
[11:42:01.377] Chunk #88 of 90 ...
[11:42:01.377]  - seeds: [1] <seeds>
[11:42:01.377] getGlobalsAndPackages() ...
[11:42:01.378] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:42:01.378] Resolving globals: FALSE
[11:42:01.378] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:42:01.378] - packages: [1] ‘mlr3’
[11:42:01.378] getGlobalsAndPackages() ... DONE
[11:42:01.379] run() for ‘Future’ ...
[11:42:01.379] - state: ‘created’
[11:42:01.379] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:42:01.394] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:42:01.395] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:42:01.395]   - Field: ‘node’
[11:42:01.395]   - Field: ‘label’
[11:42:01.395]   - Field: ‘local’
[11:42:01.395]   - Field: ‘owner’
[11:42:01.395]   - Field: ‘envir’
[11:42:01.395]   - Field: ‘workers’
[11:42:01.395]   - Field: ‘packages’
[11:42:01.395]   - Field: ‘gc’
[11:42:01.395]   - Field: ‘conditions’
[11:42:01.395]   - Field: ‘persistent’
[11:42:01.395]   - Field: ‘expr’
[11:42:01.395]   - Field: ‘uuid’
[11:42:01.395]   - Field: ‘seed’
[11:42:01.395]   - Field: ‘version’
[11:42:01.395]   - Field: ‘result’
[11:42:01.395]   - Field: ‘asynchronous’
[11:42:01.395]   - Field: ‘calls’
[11:42:01.396]   - Field: ‘globals’
[11:42:01.396]   - Field: ‘stdout’
[11:42:01.396]   - Field: ‘earlySignal’
[11:42:01.396]   - Field: ‘lazy’
[11:42:01.396]   - Field: ‘state’
[11:42:01.396] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:42:01.396] - Launch lazy future ...
[11:42:01.396] Packages needed by the future expression (n = 1): ‘mlr3’
[11:42:01.396] Packages needed by future strategies (n = 0): <none>
[11:42:01.397] {
[11:42:01.397]     {
[11:42:01.397]         {
[11:42:01.397]             ...future.startTime <- base::Sys.time()
[11:42:01.397]             {
[11:42:01.397]                 {
[11:42:01.397]                   {
[11:42:01.397]                     {
[11:42:01.397]                       {
[11:42:01.397]                         base::local({
[11:42:01.397]                           has_future <- base::requireNamespace("future", 
[11:42:01.397]                             quietly = TRUE)
[11:42:01.397]                           if (has_future) {
[11:42:01.397]                             ns <- base::getNamespace("future")
[11:42:01.397]                             version <- ns[[".package"]][["version"]]
[11:42:01.397]                             if (is.null(version)) 
[11:42:01.397]                               version <- utils::packageVersion("future")
[11:42:01.397]                           }
[11:42:01.397]                           else {
[11:42:01.397]                             version <- NULL
[11:42:01.397]                           }
[11:42:01.397]                           if (!has_future || version < "1.8.0") {
[11:42:01.397]                             info <- base::c(r_version = base::gsub("R version ", 
[11:42:01.397]                               "", base::R.version$version.string), 
[11:42:01.397]                               platform = base::sprintf("%s (%s-bit)", 
[11:42:01.397]                                 base::R.version$platform, 8 * 
[11:42:01.397]                                   base::.Machine$sizeof.pointer), 
[11:42:01.397]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:42:01.397]                                 "release", "version")], collapse = " "), 
[11:42:01.397]                               hostname = base::Sys.info()[["nodename"]])
[11:42:01.397]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:42:01.397]                               info)
[11:42:01.397]                             info <- base::paste(info, collapse = "; ")
[11:42:01.397]                             if (!has_future) {
[11:42:01.397]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:42:01.397]                                 info)
[11:42:01.397]                             }
[11:42:01.397]                             else {
[11:42:01.397]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:42:01.397]                                 info, version)
[11:42:01.397]                             }
[11:42:01.397]                             base::stop(msg)
[11:42:01.397]                           }
[11:42:01.397]                         })
[11:42:01.397]                       }
[11:42:01.397]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:42:01.397]                       base::options(mc.cores = 1L)
[11:42:01.397]                     }
[11:42:01.397]                     base::local({
[11:42:01.397]                       for (pkg in "mlr3") {
[11:42:01.397]                         base::loadNamespace(pkg)
[11:42:01.397]                         base::library(pkg, character.only = TRUE)
[11:42:01.397]                       }
[11:42:01.397]                     })
[11:42:01.397]                   }
[11:42:01.397]                   options(future.plan = NULL)
[11:42:01.397]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:42:01.397]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:42:01.397]                 }
[11:42:01.397]                 ...future.workdir <- getwd()
[11:42:01.397]             }
[11:42:01.397]             ...future.oldOptions <- base::as.list(base::.Options)
[11:42:01.397]             ...future.oldEnvVars <- base::Sys.getenv()
[11:42:01.397]         }
[11:42:01.397]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:42:01.397]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:42:01.397]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:42:01.397]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:42:01.397]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:42:01.397]             future.stdout.windows.reencode = NULL, width = 400L)
[11:42:01.397]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:42:01.397]             base::names(...future.oldOptions))
[11:42:01.397]     }
[11:42:01.397]     if (FALSE) {
[11:42:01.397]     }
[11:42:01.397]     else {
[11:42:01.397]         if (TRUE) {
[11:42:01.397]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:42:01.397]                 open = "w")
[11:42:01.397]         }
[11:42:01.397]         else {
[11:42:01.397]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:42:01.397]                 windows = "NUL", "/dev/null"), open = "w")
[11:42:01.397]         }
[11:42:01.397]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:42:01.397]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:42:01.397]             base::sink(type = "output", split = FALSE)
[11:42:01.397]             base::close(...future.stdout)
[11:42:01.397]         }, add = TRUE)
[11:42:01.397]     }
[11:42:01.397]     ...future.frame <- base::sys.nframe()
[11:42:01.397]     ...future.conditions <- base::list()
[11:42:01.397]     ...future.rng <- base::globalenv()$.Random.seed
[11:42:01.397]     if (FALSE) {
[11:42:01.397]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:42:01.397]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:42:01.397]     }
[11:42:01.397]     ...future.result <- base::tryCatch({
[11:42:01.397]         base::withCallingHandlers({
[11:42:01.397]             ...future.value <- base::withVisible(base::local({
[11:42:01.397]                 ...future.makeSendCondition <- local({
[11:42:01.397]                   sendCondition <- NULL
[11:42:01.397]                   function(frame = 1L) {
[11:42:01.397]                     if (is.function(sendCondition)) 
[11:42:01.397]                       return(sendCondition)
[11:42:01.397]                     ns <- getNamespace("parallel")
[11:42:01.397]                     if (exists("sendData", mode = "function", 
[11:42:01.397]                       envir = ns)) {
[11:42:01.397]                       parallel_sendData <- get("sendData", mode = "function", 
[11:42:01.397]                         envir = ns)
[11:42:01.397]                       envir <- sys.frame(frame)
[11:42:01.397]                       master <- NULL
[11:42:01.397]                       while (!identical(envir, .GlobalEnv) && 
[11:42:01.397]                         !identical(envir, emptyenv())) {
[11:42:01.397]                         if (exists("master", mode = "list", envir = envir, 
[11:42:01.397]                           inherits = FALSE)) {
[11:42:01.397]                           master <- get("master", mode = "list", 
[11:42:01.397]                             envir = envir, inherits = FALSE)
[11:42:01.397]                           if (inherits(master, c("SOCKnode", 
[11:42:01.397]                             "SOCK0node"))) {
[11:42:01.397]                             sendCondition <<- function(cond) {
[11:42:01.397]                               data <- list(type = "VALUE", value = cond, 
[11:42:01.397]                                 success = TRUE)
[11:42:01.397]                               parallel_sendData(master, data)
[11:42:01.397]                             }
[11:42:01.397]                             return(sendCondition)
[11:42:01.397]                           }
[11:42:01.397]                         }
[11:42:01.397]                         frame <- frame + 1L
[11:42:01.397]                         envir <- sys.frame(frame)
[11:42:01.397]                       }
[11:42:01.397]                     }
[11:42:01.397]                     sendCondition <<- function(cond) NULL
[11:42:01.397]                   }
[11:42:01.397]                 })
[11:42:01.397]                 withCallingHandlers({
[11:42:01.397]                   {
[11:42:01.397]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:42:01.397]                     if (!identical(...future.globals.maxSize.org, 
[11:42:01.397]                       ...future.globals.maxSize)) {
[11:42:01.397]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:42:01.397]                       on.exit(options(oopts), add = TRUE)
[11:42:01.397]                     }
[11:42:01.397]                     {
[11:42:01.397]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:42:01.397]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:42:01.397]                           envir = globalenv(), inherits = FALSE)
[11:42:01.397]                         ...future.FUN(...)
[11:42:01.397]                       }
[11:42:01.397]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:42:01.397]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:42:01.397]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:42:01.397]                         USE.NAMES = FALSE)
[11:42:01.397]                       do.call(mapply, args = args)
[11:42:01.397]                     }
[11:42:01.397]                   }
[11:42:01.397]                 }, immediateCondition = function(cond) {
[11:42:01.397]                   sendCondition <- ...future.makeSendCondition()
[11:42:01.397]                   sendCondition(cond)
[11:42:01.397]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:01.397]                   {
[11:42:01.397]                     inherits <- base::inherits
[11:42:01.397]                     invokeRestart <- base::invokeRestart
[11:42:01.397]                     is.null <- base::is.null
[11:42:01.397]                     muffled <- FALSE
[11:42:01.397]                     if (inherits(cond, "message")) {
[11:42:01.397]                       muffled <- grepl(pattern, "muffleMessage")
[11:42:01.397]                       if (muffled) 
[11:42:01.397]                         invokeRestart("muffleMessage")
[11:42:01.397]                     }
[11:42:01.397]                     else if (inherits(cond, "warning")) {
[11:42:01.397]                       muffled <- grepl(pattern, "muffleWarning")
[11:42:01.397]                       if (muffled) 
[11:42:01.397]                         invokeRestart("muffleWarning")
[11:42:01.397]                     }
[11:42:01.397]                     else if (inherits(cond, "condition")) {
[11:42:01.397]                       if (!is.null(pattern)) {
[11:42:01.397]                         computeRestarts <- base::computeRestarts
[11:42:01.397]                         grepl <- base::grepl
[11:42:01.397]                         restarts <- computeRestarts(cond)
[11:42:01.397]                         for (restart in restarts) {
[11:42:01.397]                           name <- restart$name
[11:42:01.397]                           if (is.null(name)) 
[11:42:01.397]                             next
[11:42:01.397]                           if (!grepl(pattern, name)) 
[11:42:01.397]                             next
[11:42:01.397]                           invokeRestart(restart)
[11:42:01.397]                           muffled <- TRUE
[11:42:01.397]                           break
[11:42:01.397]                         }
[11:42:01.397]                       }
[11:42:01.397]                     }
[11:42:01.397]                     invisible(muffled)
[11:42:01.397]                   }
[11:42:01.397]                   muffleCondition(cond)
[11:42:01.397]                 })
[11:42:01.397]             }))
[11:42:01.397]             future::FutureResult(value = ...future.value$value, 
[11:42:01.397]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:42:01.397]                   ...future.rng), globalenv = if (FALSE) 
[11:42:01.397]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:42:01.397]                     ...future.globalenv.names))
[11:42:01.397]                 else NULL, started = ...future.startTime, version = "1.8")
[11:42:01.397]         }, condition = base::local({
[11:42:01.397]             c <- base::c
[11:42:01.397]             inherits <- base::inherits
[11:42:01.397]             invokeRestart <- base::invokeRestart
[11:42:01.397]             length <- base::length
[11:42:01.397]             list <- base::list
[11:42:01.397]             seq.int <- base::seq.int
[11:42:01.397]             signalCondition <- base::signalCondition
[11:42:01.397]             sys.calls <- base::sys.calls
[11:42:01.397]             `[[` <- base::`[[`
[11:42:01.397]             `+` <- base::`+`
[11:42:01.397]             `<<-` <- base::`<<-`
[11:42:01.397]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:42:01.397]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:42:01.397]                   3L)]
[11:42:01.397]             }
[11:42:01.397]             function(cond) {
[11:42:01.397]                 is_error <- inherits(cond, "error")
[11:42:01.397]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:42:01.397]                   NULL)
[11:42:01.397]                 if (is_error) {
[11:42:01.397]                   sessionInformation <- function() {
[11:42:01.397]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:42:01.397]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:42:01.397]                       search = base::search(), system = base::Sys.info())
[11:42:01.397]                   }
[11:42:01.397]                   ...future.conditions[[length(...future.conditions) + 
[11:42:01.397]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:42:01.397]                     cond$call), session = sessionInformation(), 
[11:42:01.397]                     timestamp = base::Sys.time(), signaled = 0L)
[11:42:01.397]                   signalCondition(cond)
[11:42:01.397]                 }
[11:42:01.397]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:42:01.397]                 "immediateCondition"))) {
[11:42:01.397]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:42:01.397]                   ...future.conditions[[length(...future.conditions) + 
[11:42:01.397]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:42:01.397]                   if (TRUE && !signal) {
[11:42:01.397]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:01.397]                     {
[11:42:01.397]                       inherits <- base::inherits
[11:42:01.397]                       invokeRestart <- base::invokeRestart
[11:42:01.397]                       is.null <- base::is.null
[11:42:01.397]                       muffled <- FALSE
[11:42:01.397]                       if (inherits(cond, "message")) {
[11:42:01.397]                         muffled <- grepl(pattern, "muffleMessage")
[11:42:01.397]                         if (muffled) 
[11:42:01.397]                           invokeRestart("muffleMessage")
[11:42:01.397]                       }
[11:42:01.397]                       else if (inherits(cond, "warning")) {
[11:42:01.397]                         muffled <- grepl(pattern, "muffleWarning")
[11:42:01.397]                         if (muffled) 
[11:42:01.397]                           invokeRestart("muffleWarning")
[11:42:01.397]                       }
[11:42:01.397]                       else if (inherits(cond, "condition")) {
[11:42:01.397]                         if (!is.null(pattern)) {
[11:42:01.397]                           computeRestarts <- base::computeRestarts
[11:42:01.397]                           grepl <- base::grepl
[11:42:01.397]                           restarts <- computeRestarts(cond)
[11:42:01.397]                           for (restart in restarts) {
[11:42:01.397]                             name <- restart$name
[11:42:01.397]                             if (is.null(name)) 
[11:42:01.397]                               next
[11:42:01.397]                             if (!grepl(pattern, name)) 
[11:42:01.397]                               next
[11:42:01.397]                             invokeRestart(restart)
[11:42:01.397]                             muffled <- TRUE
[11:42:01.397]                             break
[11:42:01.397]                           }
[11:42:01.397]                         }
[11:42:01.397]                       }
[11:42:01.397]                       invisible(muffled)
[11:42:01.397]                     }
[11:42:01.397]                     muffleCondition(cond, pattern = "^muffle")
[11:42:01.397]                   }
[11:42:01.397]                 }
[11:42:01.397]                 else {
[11:42:01.397]                   if (TRUE) {
[11:42:01.397]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:01.397]                     {
[11:42:01.397]                       inherits <- base::inherits
[11:42:01.397]                       invokeRestart <- base::invokeRestart
[11:42:01.397]                       is.null <- base::is.null
[11:42:01.397]                       muffled <- FALSE
[11:42:01.397]                       if (inherits(cond, "message")) {
[11:42:01.397]                         muffled <- grepl(pattern, "muffleMessage")
[11:42:01.397]                         if (muffled) 
[11:42:01.397]                           invokeRestart("muffleMessage")
[11:42:01.397]                       }
[11:42:01.397]                       else if (inherits(cond, "warning")) {
[11:42:01.397]                         muffled <- grepl(pattern, "muffleWarning")
[11:42:01.397]                         if (muffled) 
[11:42:01.397]                           invokeRestart("muffleWarning")
[11:42:01.397]                       }
[11:42:01.397]                       else if (inherits(cond, "condition")) {
[11:42:01.397]                         if (!is.null(pattern)) {
[11:42:01.397]                           computeRestarts <- base::computeRestarts
[11:42:01.397]                           grepl <- base::grepl
[11:42:01.397]                           restarts <- computeRestarts(cond)
[11:42:01.397]                           for (restart in restarts) {
[11:42:01.397]                             name <- restart$name
[11:42:01.397]                             if (is.null(name)) 
[11:42:01.397]                               next
[11:42:01.397]                             if (!grepl(pattern, name)) 
[11:42:01.397]                               next
[11:42:01.397]                             invokeRestart(restart)
[11:42:01.397]                             muffled <- TRUE
[11:42:01.397]                             break
[11:42:01.397]                           }
[11:42:01.397]                         }
[11:42:01.397]                       }
[11:42:01.397]                       invisible(muffled)
[11:42:01.397]                     }
[11:42:01.397]                     muffleCondition(cond, pattern = "^muffle")
[11:42:01.397]                   }
[11:42:01.397]                 }
[11:42:01.397]             }
[11:42:01.397]         }))
[11:42:01.397]     }, error = function(ex) {
[11:42:01.397]         base::structure(base::list(value = NULL, visible = NULL, 
[11:42:01.397]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:42:01.397]                 ...future.rng), started = ...future.startTime, 
[11:42:01.397]             finished = Sys.time(), session_uuid = NA_character_, 
[11:42:01.397]             version = "1.8"), class = "FutureResult")
[11:42:01.397]     }, finally = {
[11:42:01.397]         if (!identical(...future.workdir, getwd())) 
[11:42:01.397]             setwd(...future.workdir)
[11:42:01.397]         {
[11:42:01.397]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:42:01.397]                 ...future.oldOptions$nwarnings <- NULL
[11:42:01.397]             }
[11:42:01.397]             base::options(...future.oldOptions)
[11:42:01.397]             if (.Platform$OS.type == "windows") {
[11:42:01.397]                 old_names <- names(...future.oldEnvVars)
[11:42:01.397]                 envs <- base::Sys.getenv()
[11:42:01.397]                 names <- names(envs)
[11:42:01.397]                 common <- intersect(names, old_names)
[11:42:01.397]                 added <- setdiff(names, old_names)
[11:42:01.397]                 removed <- setdiff(old_names, names)
[11:42:01.397]                 changed <- common[...future.oldEnvVars[common] != 
[11:42:01.397]                   envs[common]]
[11:42:01.397]                 NAMES <- toupper(changed)
[11:42:01.397]                 args <- list()
[11:42:01.397]                 for (kk in seq_along(NAMES)) {
[11:42:01.397]                   name <- changed[[kk]]
[11:42:01.397]                   NAME <- NAMES[[kk]]
[11:42:01.397]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:01.397]                     next
[11:42:01.397]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:42:01.397]                 }
[11:42:01.397]                 NAMES <- toupper(added)
[11:42:01.397]                 for (kk in seq_along(NAMES)) {
[11:42:01.397]                   name <- added[[kk]]
[11:42:01.397]                   NAME <- NAMES[[kk]]
[11:42:01.397]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:01.397]                     next
[11:42:01.397]                   args[[name]] <- ""
[11:42:01.397]                 }
[11:42:01.397]                 NAMES <- toupper(removed)
[11:42:01.397]                 for (kk in seq_along(NAMES)) {
[11:42:01.397]                   name <- removed[[kk]]
[11:42:01.397]                   NAME <- NAMES[[kk]]
[11:42:01.397]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:01.397]                     next
[11:42:01.397]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:42:01.397]                 }
[11:42:01.397]                 if (length(args) > 0) 
[11:42:01.397]                   base::do.call(base::Sys.setenv, args = args)
[11:42:01.397]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:42:01.397]             }
[11:42:01.397]             else {
[11:42:01.397]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:42:01.397]             }
[11:42:01.397]             {
[11:42:01.397]                 if (base::length(...future.futureOptionsAdded) > 
[11:42:01.397]                   0L) {
[11:42:01.397]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:42:01.397]                   base::names(opts) <- ...future.futureOptionsAdded
[11:42:01.397]                   base::options(opts)
[11:42:01.397]                 }
[11:42:01.397]                 {
[11:42:01.397]                   {
[11:42:01.397]                     base::options(mc.cores = ...future.mc.cores.old)
[11:42:01.397]                     NULL
[11:42:01.397]                   }
[11:42:01.397]                   options(future.plan = NULL)
[11:42:01.397]                   if (is.na(NA_character_)) 
[11:42:01.397]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:42:01.397]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:42:01.397]                   future::plan(list(function (..., workers = 2, 
[11:42:01.397]                     envir = parent.frame()) 
[11:42:01.397]                   strategy(..., workers = workers, envir = envir)), 
[11:42:01.397]                     .cleanup = FALSE, .init = FALSE)
[11:42:01.397]                 }
[11:42:01.397]             }
[11:42:01.397]         }
[11:42:01.397]     })
[11:42:01.397]     if (TRUE) {
[11:42:01.397]         base::sink(type = "output", split = FALSE)
[11:42:01.397]         if (TRUE) {
[11:42:01.397]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:42:01.397]         }
[11:42:01.397]         else {
[11:42:01.397]             ...future.result["stdout"] <- base::list(NULL)
[11:42:01.397]         }
[11:42:01.397]         base::close(...future.stdout)
[11:42:01.397]         ...future.stdout <- NULL
[11:42:01.397]     }
[11:42:01.397]     ...future.result$conditions <- ...future.conditions
[11:42:01.397]     ...future.result$finished <- base::Sys.time()
[11:42:01.397]     ...future.result
[11:42:01.397] }
[11:42:01.399] Poll #1 (0): usedNodes() = 2, workers = 2
[11:42:01.409] receiveMessageFromWorker() for ClusterFuture ...
[11:42:01.410] - Validating connection of MultisessionFuture
[11:42:01.410] - received message: FutureResult
[11:42:01.410] - Received FutureResult
[11:42:01.410] - Erased future from FutureRegistry
[11:42:01.410] result() for ClusterFuture ...
[11:42:01.410] - result already collected: FutureResult
[11:42:01.411] result() for ClusterFuture ... done
[11:42:01.411] receiveMessageFromWorker() for ClusterFuture ... done
[11:42:01.411] result() for ClusterFuture ...
[11:42:01.411] - result already collected: FutureResult
[11:42:01.411] result() for ClusterFuture ... done
[11:42:01.411] result() for ClusterFuture ...
[11:42:01.411] - result already collected: FutureResult
[11:42:01.411] result() for ClusterFuture ... done
[11:42:01.412] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:42:01.412] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:42:01.453] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:42:01.457] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:42:01.459] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:42:01.460] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:42:01.505] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:42:01.506] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:42:01.506] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:42:01.506] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:42:01.507] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:42:01.507] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:42:01.508] MultisessionFuture started
[11:42:01.508] - Launch lazy future ... done
[11:42:01.508] run() for ‘MultisessionFuture’ ... done
[11:42:01.508] Created future:
[11:42:01.508] MultisessionFuture:
[11:42:01.508] Label: ‘future_mapply-88’
[11:42:01.508] Expression:
[11:42:01.508] {
[11:42:01.508]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:42:01.508]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:42:01.508]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:42:01.508]         on.exit(options(oopts), add = TRUE)
[11:42:01.508]     }
[11:42:01.508]     {
[11:42:01.508]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:42:01.508]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:42:01.508]                 inherits = FALSE)
[11:42:01.508]             ...future.FUN(...)
[11:42:01.508]         }
[11:42:01.508]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:42:01.508]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:42:01.508]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:42:01.508]         do.call(mapply, args = args)
[11:42:01.508]     }
[11:42:01.508] }
[11:42:01.508] Lazy evaluation: FALSE
[11:42:01.508] Asynchronous evaluation: TRUE
[11:42:01.508] Local evaluation: TRUE
[11:42:01.508] Environment: 0x560ef58e1768
[11:42:01.508] Capture standard output: TRUE
[11:42:01.508] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:42:01.508] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:42:01.508] Packages: 1 packages (‘mlr3’)
[11:42:01.508] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:42:01.508] Resolved: FALSE
[11:42:01.508] Value: <not collected>
[11:42:01.508] Conditions captured: <none>
[11:42:01.508] Early signaling: FALSE
[11:42:01.508] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:42:01.508] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:42:01.524] Chunk #88 of 90 ... DONE
[11:42:01.524] Chunk #89 of 90 ...
[11:42:01.524]  - seeds: [1] <seeds>
[11:42:01.524] getGlobalsAndPackages() ...
[11:42:01.524] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:42:01.525] Resolving globals: FALSE
[11:42:01.525] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:42:01.525] - packages: [1] ‘mlr3’
[11:42:01.525] getGlobalsAndPackages() ... DONE
[11:42:01.525] run() for ‘Future’ ...
[11:42:01.525] - state: ‘created’
[11:42:01.525] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:42:01.537] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:42:01.537] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:42:01.537]   - Field: ‘node’
[11:42:01.537]   - Field: ‘label’
[11:42:01.537]   - Field: ‘local’
[11:42:01.537]   - Field: ‘owner’
[11:42:01.537]   - Field: ‘envir’
[11:42:01.537]   - Field: ‘workers’
[11:42:01.537]   - Field: ‘packages’
[11:42:01.537]   - Field: ‘gc’
[11:42:01.537]   - Field: ‘conditions’
[11:42:01.537]   - Field: ‘persistent’
[11:42:01.537]   - Field: ‘expr’
[11:42:01.537]   - Field: ‘uuid’
[11:42:01.537]   - Field: ‘seed’
[11:42:01.537]   - Field: ‘version’
[11:42:01.537]   - Field: ‘result’
[11:42:01.538]   - Field: ‘asynchronous’
[11:42:01.538]   - Field: ‘calls’
[11:42:01.538]   - Field: ‘globals’
[11:42:01.538]   - Field: ‘stdout’
[11:42:01.538]   - Field: ‘earlySignal’
[11:42:01.538]   - Field: ‘lazy’
[11:42:01.538]   - Field: ‘state’
[11:42:01.538] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:42:01.538] - Launch lazy future ...
[11:42:01.538] Packages needed by the future expression (n = 1): ‘mlr3’
[11:42:01.538] Packages needed by future strategies (n = 0): <none>
[11:42:01.539] {
[11:42:01.539]     {
[11:42:01.539]         {
[11:42:01.539]             ...future.startTime <- base::Sys.time()
[11:42:01.539]             {
[11:42:01.539]                 {
[11:42:01.539]                   {
[11:42:01.539]                     {
[11:42:01.539]                       {
[11:42:01.539]                         base::local({
[11:42:01.539]                           has_future <- base::requireNamespace("future", 
[11:42:01.539]                             quietly = TRUE)
[11:42:01.539]                           if (has_future) {
[11:42:01.539]                             ns <- base::getNamespace("future")
[11:42:01.539]                             version <- ns[[".package"]][["version"]]
[11:42:01.539]                             if (is.null(version)) 
[11:42:01.539]                               version <- utils::packageVersion("future")
[11:42:01.539]                           }
[11:42:01.539]                           else {
[11:42:01.539]                             version <- NULL
[11:42:01.539]                           }
[11:42:01.539]                           if (!has_future || version < "1.8.0") {
[11:42:01.539]                             info <- base::c(r_version = base::gsub("R version ", 
[11:42:01.539]                               "", base::R.version$version.string), 
[11:42:01.539]                               platform = base::sprintf("%s (%s-bit)", 
[11:42:01.539]                                 base::R.version$platform, 8 * 
[11:42:01.539]                                   base::.Machine$sizeof.pointer), 
[11:42:01.539]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:42:01.539]                                 "release", "version")], collapse = " "), 
[11:42:01.539]                               hostname = base::Sys.info()[["nodename"]])
[11:42:01.539]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:42:01.539]                               info)
[11:42:01.539]                             info <- base::paste(info, collapse = "; ")
[11:42:01.539]                             if (!has_future) {
[11:42:01.539]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:42:01.539]                                 info)
[11:42:01.539]                             }
[11:42:01.539]                             else {
[11:42:01.539]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:42:01.539]                                 info, version)
[11:42:01.539]                             }
[11:42:01.539]                             base::stop(msg)
[11:42:01.539]                           }
[11:42:01.539]                         })
[11:42:01.539]                       }
[11:42:01.539]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:42:01.539]                       base::options(mc.cores = 1L)
[11:42:01.539]                     }
[11:42:01.539]                     base::local({
[11:42:01.539]                       for (pkg in "mlr3") {
[11:42:01.539]                         base::loadNamespace(pkg)
[11:42:01.539]                         base::library(pkg, character.only = TRUE)
[11:42:01.539]                       }
[11:42:01.539]                     })
[11:42:01.539]                   }
[11:42:01.539]                   options(future.plan = NULL)
[11:42:01.539]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:42:01.539]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:42:01.539]                 }
[11:42:01.539]                 ...future.workdir <- getwd()
[11:42:01.539]             }
[11:42:01.539]             ...future.oldOptions <- base::as.list(base::.Options)
[11:42:01.539]             ...future.oldEnvVars <- base::Sys.getenv()
[11:42:01.539]         }
[11:42:01.539]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:42:01.539]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:42:01.539]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:42:01.539]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:42:01.539]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:42:01.539]             future.stdout.windows.reencode = NULL, width = 400L)
[11:42:01.539]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:42:01.539]             base::names(...future.oldOptions))
[11:42:01.539]     }
[11:42:01.539]     if (FALSE) {
[11:42:01.539]     }
[11:42:01.539]     else {
[11:42:01.539]         if (TRUE) {
[11:42:01.539]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:42:01.539]                 open = "w")
[11:42:01.539]         }
[11:42:01.539]         else {
[11:42:01.539]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:42:01.539]                 windows = "NUL", "/dev/null"), open = "w")
[11:42:01.539]         }
[11:42:01.539]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:42:01.539]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:42:01.539]             base::sink(type = "output", split = FALSE)
[11:42:01.539]             base::close(...future.stdout)
[11:42:01.539]         }, add = TRUE)
[11:42:01.539]     }
[11:42:01.539]     ...future.frame <- base::sys.nframe()
[11:42:01.539]     ...future.conditions <- base::list()
[11:42:01.539]     ...future.rng <- base::globalenv()$.Random.seed
[11:42:01.539]     if (FALSE) {
[11:42:01.539]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:42:01.539]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:42:01.539]     }
[11:42:01.539]     ...future.result <- base::tryCatch({
[11:42:01.539]         base::withCallingHandlers({
[11:42:01.539]             ...future.value <- base::withVisible(base::local({
[11:42:01.539]                 ...future.makeSendCondition <- local({
[11:42:01.539]                   sendCondition <- NULL
[11:42:01.539]                   function(frame = 1L) {
[11:42:01.539]                     if (is.function(sendCondition)) 
[11:42:01.539]                       return(sendCondition)
[11:42:01.539]                     ns <- getNamespace("parallel")
[11:42:01.539]                     if (exists("sendData", mode = "function", 
[11:42:01.539]                       envir = ns)) {
[11:42:01.539]                       parallel_sendData <- get("sendData", mode = "function", 
[11:42:01.539]                         envir = ns)
[11:42:01.539]                       envir <- sys.frame(frame)
[11:42:01.539]                       master <- NULL
[11:42:01.539]                       while (!identical(envir, .GlobalEnv) && 
[11:42:01.539]                         !identical(envir, emptyenv())) {
[11:42:01.539]                         if (exists("master", mode = "list", envir = envir, 
[11:42:01.539]                           inherits = FALSE)) {
[11:42:01.539]                           master <- get("master", mode = "list", 
[11:42:01.539]                             envir = envir, inherits = FALSE)
[11:42:01.539]                           if (inherits(master, c("SOCKnode", 
[11:42:01.539]                             "SOCK0node"))) {
[11:42:01.539]                             sendCondition <<- function(cond) {
[11:42:01.539]                               data <- list(type = "VALUE", value = cond, 
[11:42:01.539]                                 success = TRUE)
[11:42:01.539]                               parallel_sendData(master, data)
[11:42:01.539]                             }
[11:42:01.539]                             return(sendCondition)
[11:42:01.539]                           }
[11:42:01.539]                         }
[11:42:01.539]                         frame <- frame + 1L
[11:42:01.539]                         envir <- sys.frame(frame)
[11:42:01.539]                       }
[11:42:01.539]                     }
[11:42:01.539]                     sendCondition <<- function(cond) NULL
[11:42:01.539]                   }
[11:42:01.539]                 })
[11:42:01.539]                 withCallingHandlers({
[11:42:01.539]                   {
[11:42:01.539]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:42:01.539]                     if (!identical(...future.globals.maxSize.org, 
[11:42:01.539]                       ...future.globals.maxSize)) {
[11:42:01.539]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:42:01.539]                       on.exit(options(oopts), add = TRUE)
[11:42:01.539]                     }
[11:42:01.539]                     {
[11:42:01.539]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:42:01.539]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:42:01.539]                           envir = globalenv(), inherits = FALSE)
[11:42:01.539]                         ...future.FUN(...)
[11:42:01.539]                       }
[11:42:01.539]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:42:01.539]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:42:01.539]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:42:01.539]                         USE.NAMES = FALSE)
[11:42:01.539]                       do.call(mapply, args = args)
[11:42:01.539]                     }
[11:42:01.539]                   }
[11:42:01.539]                 }, immediateCondition = function(cond) {
[11:42:01.539]                   sendCondition <- ...future.makeSendCondition()
[11:42:01.539]                   sendCondition(cond)
[11:42:01.539]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:01.539]                   {
[11:42:01.539]                     inherits <- base::inherits
[11:42:01.539]                     invokeRestart <- base::invokeRestart
[11:42:01.539]                     is.null <- base::is.null
[11:42:01.539]                     muffled <- FALSE
[11:42:01.539]                     if (inherits(cond, "message")) {
[11:42:01.539]                       muffled <- grepl(pattern, "muffleMessage")
[11:42:01.539]                       if (muffled) 
[11:42:01.539]                         invokeRestart("muffleMessage")
[11:42:01.539]                     }
[11:42:01.539]                     else if (inherits(cond, "warning")) {
[11:42:01.539]                       muffled <- grepl(pattern, "muffleWarning")
[11:42:01.539]                       if (muffled) 
[11:42:01.539]                         invokeRestart("muffleWarning")
[11:42:01.539]                     }
[11:42:01.539]                     else if (inherits(cond, "condition")) {
[11:42:01.539]                       if (!is.null(pattern)) {
[11:42:01.539]                         computeRestarts <- base::computeRestarts
[11:42:01.539]                         grepl <- base::grepl
[11:42:01.539]                         restarts <- computeRestarts(cond)
[11:42:01.539]                         for (restart in restarts) {
[11:42:01.539]                           name <- restart$name
[11:42:01.539]                           if (is.null(name)) 
[11:42:01.539]                             next
[11:42:01.539]                           if (!grepl(pattern, name)) 
[11:42:01.539]                             next
[11:42:01.539]                           invokeRestart(restart)
[11:42:01.539]                           muffled <- TRUE
[11:42:01.539]                           break
[11:42:01.539]                         }
[11:42:01.539]                       }
[11:42:01.539]                     }
[11:42:01.539]                     invisible(muffled)
[11:42:01.539]                   }
[11:42:01.539]                   muffleCondition(cond)
[11:42:01.539]                 })
[11:42:01.539]             }))
[11:42:01.539]             future::FutureResult(value = ...future.value$value, 
[11:42:01.539]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:42:01.539]                   ...future.rng), globalenv = if (FALSE) 
[11:42:01.539]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:42:01.539]                     ...future.globalenv.names))
[11:42:01.539]                 else NULL, started = ...future.startTime, version = "1.8")
[11:42:01.539]         }, condition = base::local({
[11:42:01.539]             c <- base::c
[11:42:01.539]             inherits <- base::inherits
[11:42:01.539]             invokeRestart <- base::invokeRestart
[11:42:01.539]             length <- base::length
[11:42:01.539]             list <- base::list
[11:42:01.539]             seq.int <- base::seq.int
[11:42:01.539]             signalCondition <- base::signalCondition
[11:42:01.539]             sys.calls <- base::sys.calls
[11:42:01.539]             `[[` <- base::`[[`
[11:42:01.539]             `+` <- base::`+`
[11:42:01.539]             `<<-` <- base::`<<-`
[11:42:01.539]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:42:01.539]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:42:01.539]                   3L)]
[11:42:01.539]             }
[11:42:01.539]             function(cond) {
[11:42:01.539]                 is_error <- inherits(cond, "error")
[11:42:01.539]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:42:01.539]                   NULL)
[11:42:01.539]                 if (is_error) {
[11:42:01.539]                   sessionInformation <- function() {
[11:42:01.539]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:42:01.539]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:42:01.539]                       search = base::search(), system = base::Sys.info())
[11:42:01.539]                   }
[11:42:01.539]                   ...future.conditions[[length(...future.conditions) + 
[11:42:01.539]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:42:01.539]                     cond$call), session = sessionInformation(), 
[11:42:01.539]                     timestamp = base::Sys.time(), signaled = 0L)
[11:42:01.539]                   signalCondition(cond)
[11:42:01.539]                 }
[11:42:01.539]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:42:01.539]                 "immediateCondition"))) {
[11:42:01.539]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:42:01.539]                   ...future.conditions[[length(...future.conditions) + 
[11:42:01.539]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:42:01.539]                   if (TRUE && !signal) {
[11:42:01.539]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:01.539]                     {
[11:42:01.539]                       inherits <- base::inherits
[11:42:01.539]                       invokeRestart <- base::invokeRestart
[11:42:01.539]                       is.null <- base::is.null
[11:42:01.539]                       muffled <- FALSE
[11:42:01.539]                       if (inherits(cond, "message")) {
[11:42:01.539]                         muffled <- grepl(pattern, "muffleMessage")
[11:42:01.539]                         if (muffled) 
[11:42:01.539]                           invokeRestart("muffleMessage")
[11:42:01.539]                       }
[11:42:01.539]                       else if (inherits(cond, "warning")) {
[11:42:01.539]                         muffled <- grepl(pattern, "muffleWarning")
[11:42:01.539]                         if (muffled) 
[11:42:01.539]                           invokeRestart("muffleWarning")
[11:42:01.539]                       }
[11:42:01.539]                       else if (inherits(cond, "condition")) {
[11:42:01.539]                         if (!is.null(pattern)) {
[11:42:01.539]                           computeRestarts <- base::computeRestarts
[11:42:01.539]                           grepl <- base::grepl
[11:42:01.539]                           restarts <- computeRestarts(cond)
[11:42:01.539]                           for (restart in restarts) {
[11:42:01.539]                             name <- restart$name
[11:42:01.539]                             if (is.null(name)) 
[11:42:01.539]                               next
[11:42:01.539]                             if (!grepl(pattern, name)) 
[11:42:01.539]                               next
[11:42:01.539]                             invokeRestart(restart)
[11:42:01.539]                             muffled <- TRUE
[11:42:01.539]                             break
[11:42:01.539]                           }
[11:42:01.539]                         }
[11:42:01.539]                       }
[11:42:01.539]                       invisible(muffled)
[11:42:01.539]                     }
[11:42:01.539]                     muffleCondition(cond, pattern = "^muffle")
[11:42:01.539]                   }
[11:42:01.539]                 }
[11:42:01.539]                 else {
[11:42:01.539]                   if (TRUE) {
[11:42:01.539]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:01.539]                     {
[11:42:01.539]                       inherits <- base::inherits
[11:42:01.539]                       invokeRestart <- base::invokeRestart
[11:42:01.539]                       is.null <- base::is.null
[11:42:01.539]                       muffled <- FALSE
[11:42:01.539]                       if (inherits(cond, "message")) {
[11:42:01.539]                         muffled <- grepl(pattern, "muffleMessage")
[11:42:01.539]                         if (muffled) 
[11:42:01.539]                           invokeRestart("muffleMessage")
[11:42:01.539]                       }
[11:42:01.539]                       else if (inherits(cond, "warning")) {
[11:42:01.539]                         muffled <- grepl(pattern, "muffleWarning")
[11:42:01.539]                         if (muffled) 
[11:42:01.539]                           invokeRestart("muffleWarning")
[11:42:01.539]                       }
[11:42:01.539]                       else if (inherits(cond, "condition")) {
[11:42:01.539]                         if (!is.null(pattern)) {
[11:42:01.539]                           computeRestarts <- base::computeRestarts
[11:42:01.539]                           grepl <- base::grepl
[11:42:01.539]                           restarts <- computeRestarts(cond)
[11:42:01.539]                           for (restart in restarts) {
[11:42:01.539]                             name <- restart$name
[11:42:01.539]                             if (is.null(name)) 
[11:42:01.539]                               next
[11:42:01.539]                             if (!grepl(pattern, name)) 
[11:42:01.539]                               next
[11:42:01.539]                             invokeRestart(restart)
[11:42:01.539]                             muffled <- TRUE
[11:42:01.539]                             break
[11:42:01.539]                           }
[11:42:01.539]                         }
[11:42:01.539]                       }
[11:42:01.539]                       invisible(muffled)
[11:42:01.539]                     }
[11:42:01.539]                     muffleCondition(cond, pattern = "^muffle")
[11:42:01.539]                   }
[11:42:01.539]                 }
[11:42:01.539]             }
[11:42:01.539]         }))
[11:42:01.539]     }, error = function(ex) {
[11:42:01.539]         base::structure(base::list(value = NULL, visible = NULL, 
[11:42:01.539]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:42:01.539]                 ...future.rng), started = ...future.startTime, 
[11:42:01.539]             finished = Sys.time(), session_uuid = NA_character_, 
[11:42:01.539]             version = "1.8"), class = "FutureResult")
[11:42:01.539]     }, finally = {
[11:42:01.539]         if (!identical(...future.workdir, getwd())) 
[11:42:01.539]             setwd(...future.workdir)
[11:42:01.539]         {
[11:42:01.539]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:42:01.539]                 ...future.oldOptions$nwarnings <- NULL
[11:42:01.539]             }
[11:42:01.539]             base::options(...future.oldOptions)
[11:42:01.539]             if (.Platform$OS.type == "windows") {
[11:42:01.539]                 old_names <- names(...future.oldEnvVars)
[11:42:01.539]                 envs <- base::Sys.getenv()
[11:42:01.539]                 names <- names(envs)
[11:42:01.539]                 common <- intersect(names, old_names)
[11:42:01.539]                 added <- setdiff(names, old_names)
[11:42:01.539]                 removed <- setdiff(old_names, names)
[11:42:01.539]                 changed <- common[...future.oldEnvVars[common] != 
[11:42:01.539]                   envs[common]]
[11:42:01.539]                 NAMES <- toupper(changed)
[11:42:01.539]                 args <- list()
[11:42:01.539]                 for (kk in seq_along(NAMES)) {
[11:42:01.539]                   name <- changed[[kk]]
[11:42:01.539]                   NAME <- NAMES[[kk]]
[11:42:01.539]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:01.539]                     next
[11:42:01.539]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:42:01.539]                 }
[11:42:01.539]                 NAMES <- toupper(added)
[11:42:01.539]                 for (kk in seq_along(NAMES)) {
[11:42:01.539]                   name <- added[[kk]]
[11:42:01.539]                   NAME <- NAMES[[kk]]
[11:42:01.539]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:01.539]                     next
[11:42:01.539]                   args[[name]] <- ""
[11:42:01.539]                 }
[11:42:01.539]                 NAMES <- toupper(removed)
[11:42:01.539]                 for (kk in seq_along(NAMES)) {
[11:42:01.539]                   name <- removed[[kk]]
[11:42:01.539]                   NAME <- NAMES[[kk]]
[11:42:01.539]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:01.539]                     next
[11:42:01.539]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:42:01.539]                 }
[11:42:01.539]                 if (length(args) > 0) 
[11:42:01.539]                   base::do.call(base::Sys.setenv, args = args)
[11:42:01.539]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:42:01.539]             }
[11:42:01.539]             else {
[11:42:01.539]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:42:01.539]             }
[11:42:01.539]             {
[11:42:01.539]                 if (base::length(...future.futureOptionsAdded) > 
[11:42:01.539]                   0L) {
[11:42:01.539]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:42:01.539]                   base::names(opts) <- ...future.futureOptionsAdded
[11:42:01.539]                   base::options(opts)
[11:42:01.539]                 }
[11:42:01.539]                 {
[11:42:01.539]                   {
[11:42:01.539]                     base::options(mc.cores = ...future.mc.cores.old)
[11:42:01.539]                     NULL
[11:42:01.539]                   }
[11:42:01.539]                   options(future.plan = NULL)
[11:42:01.539]                   if (is.na(NA_character_)) 
[11:42:01.539]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:42:01.539]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:42:01.539]                   future::plan(list(function (..., workers = 2, 
[11:42:01.539]                     envir = parent.frame()) 
[11:42:01.539]                   strategy(..., workers = workers, envir = envir)), 
[11:42:01.539]                     .cleanup = FALSE, .init = FALSE)
[11:42:01.539]                 }
[11:42:01.539]             }
[11:42:01.539]         }
[11:42:01.539]     })
[11:42:01.539]     if (TRUE) {
[11:42:01.539]         base::sink(type = "output", split = FALSE)
[11:42:01.539]         if (TRUE) {
[11:42:01.539]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:42:01.539]         }
[11:42:01.539]         else {
[11:42:01.539]             ...future.result["stdout"] <- base::list(NULL)
[11:42:01.539]         }
[11:42:01.539]         base::close(...future.stdout)
[11:42:01.539]         ...future.stdout <- NULL
[11:42:01.539]     }
[11:42:01.539]     ...future.result$conditions <- ...future.conditions
[11:42:01.539]     ...future.result$finished <- base::Sys.time()
[11:42:01.539]     ...future.result
[11:42:01.539] }
[11:42:01.540] Poll #1 (0): usedNodes() = 2, workers = 2
[11:42:01.551] receiveMessageFromWorker() for ClusterFuture ...
[11:42:01.551] - Validating connection of MultisessionFuture
[11:42:01.552] - received message: FutureResult
[11:42:01.552] - Received FutureResult
[11:42:01.552] - Erased future from FutureRegistry
[11:42:01.552] result() for ClusterFuture ...
[11:42:01.552] - result already collected: FutureResult
[11:42:01.552] result() for ClusterFuture ... done
[11:42:01.552] receiveMessageFromWorker() for ClusterFuture ... done
[11:42:01.552] result() for ClusterFuture ...
[11:42:01.552] - result already collected: FutureResult
[11:42:01.552] result() for ClusterFuture ... done
[11:42:01.552] result() for ClusterFuture ...
[11:42:01.552] - result already collected: FutureResult
[11:42:01.552] result() for ClusterFuture ... done
[11:42:01.553] Exporting 5 global objects (157.50 KiB) to cluster node #1 ...
[11:42:01.553] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ...
[11:42:01.597] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #1 ... DONE
[11:42:01.602] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ...
[11:42:01.604] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #1 ... DONE
[11:42:01.604] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ...
[11:42:01.649] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #1 ... DONE
[11:42:01.650] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ...
[11:42:01.650] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #1 ... DONE
[11:42:01.650] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ...
[11:42:01.651] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #1 ... DONE
[11:42:01.651] Exporting 5 global objects (157.50 KiB) to cluster node #1 ... DONE
[11:42:01.651] MultisessionFuture started
[11:42:01.651] - Launch lazy future ... done
[11:42:01.651] run() for ‘MultisessionFuture’ ... done
[11:42:01.652] Created future:
[11:42:01.652] MultisessionFuture:
[11:42:01.652] Label: ‘future_mapply-89’
[11:42:01.652] Expression:
[11:42:01.652] {
[11:42:01.652]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:42:01.652]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:42:01.652]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:42:01.652]         on.exit(options(oopts), add = TRUE)
[11:42:01.652]     }
[11:42:01.652]     {
[11:42:01.652]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:42:01.652]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:42:01.652]                 inherits = FALSE)
[11:42:01.652]             ...future.FUN(...)
[11:42:01.652]         }
[11:42:01.652]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:42:01.652]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:42:01.652]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:42:01.652]         do.call(mapply, args = args)
[11:42:01.652]     }
[11:42:01.652] }
[11:42:01.652] Lazy evaluation: FALSE
[11:42:01.652] Asynchronous evaluation: TRUE
[11:42:01.652] Local evaluation: TRUE
[11:42:01.652] Environment: 0x560ef58e1768
[11:42:01.652] Capture standard output: TRUE
[11:42:01.652] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:42:01.652] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:42:01.652] Packages: 1 packages (‘mlr3’)
[11:42:01.652] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:42:01.652] Resolved: FALSE
[11:42:01.652] Value: <not collected>
[11:42:01.652] Conditions captured: <none>
[11:42:01.652] Early signaling: FALSE
[11:42:01.652] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:42:01.652] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:42:01.667] Chunk #89 of 90 ... DONE
[11:42:01.667] Chunk #90 of 90 ...
[11:42:01.667]  - seeds: [1] <seeds>
[11:42:01.667] getGlobalsAndPackages() ...
[11:42:01.667] - globals passed as-is: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:42:01.667] Resolving globals: FALSE
[11:42:01.668] - globals: [5] ‘...future.FUN’, ‘MoreArgs’, ‘...future.elements_ii’, ‘...future.seeds_ii’, ‘...future.globals.maxSize’
[11:42:01.668] - packages: [1] ‘mlr3’
[11:42:01.668] getGlobalsAndPackages() ... DONE
[11:42:01.668] run() for ‘Future’ ...
[11:42:01.668] - state: ‘created’
[11:42:01.668] - Future backend: ‘FutureStrategy’, ‘tweaked’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:42:01.678] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:42:01.678] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:42:01.678]   - Field: ‘node’
[11:42:01.679]   - Field: ‘label’
[11:42:01.679]   - Field: ‘local’
[11:42:01.679]   - Field: ‘owner’
[11:42:01.679]   - Field: ‘envir’
[11:42:01.679]   - Field: ‘workers’
[11:42:01.679]   - Field: ‘packages’
[11:42:01.679]   - Field: ‘gc’
[11:42:01.679]   - Field: ‘conditions’
[11:42:01.679]   - Field: ‘persistent’
[11:42:01.679]   - Field: ‘expr’
[11:42:01.679]   - Field: ‘uuid’
[11:42:01.679]   - Field: ‘seed’
[11:42:01.679]   - Field: ‘version’
[11:42:01.679]   - Field: ‘result’
[11:42:01.679]   - Field: ‘asynchronous’
[11:42:01.679]   - Field: ‘calls’
[11:42:01.679]   - Field: ‘globals’
[11:42:01.679]   - Field: ‘stdout’
[11:42:01.679]   - Field: ‘earlySignal’
[11:42:01.679]   - Field: ‘lazy’
[11:42:01.679]   - Field: ‘state’
[11:42:01.679] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:42:01.680] - Launch lazy future ...
[11:42:01.680] Packages needed by the future expression (n = 1): ‘mlr3’
[11:42:01.680] Packages needed by future strategies (n = 0): <none>
[11:42:01.680] {
[11:42:01.680]     {
[11:42:01.680]         {
[11:42:01.680]             ...future.startTime <- base::Sys.time()
[11:42:01.680]             {
[11:42:01.680]                 {
[11:42:01.680]                   {
[11:42:01.680]                     {
[11:42:01.680]                       {
[11:42:01.680]                         base::local({
[11:42:01.680]                           has_future <- base::requireNamespace("future", 
[11:42:01.680]                             quietly = TRUE)
[11:42:01.680]                           if (has_future) {
[11:42:01.680]                             ns <- base::getNamespace("future")
[11:42:01.680]                             version <- ns[[".package"]][["version"]]
[11:42:01.680]                             if (is.null(version)) 
[11:42:01.680]                               version <- utils::packageVersion("future")
[11:42:01.680]                           }
[11:42:01.680]                           else {
[11:42:01.680]                             version <- NULL
[11:42:01.680]                           }
[11:42:01.680]                           if (!has_future || version < "1.8.0") {
[11:42:01.680]                             info <- base::c(r_version = base::gsub("R version ", 
[11:42:01.680]                               "", base::R.version$version.string), 
[11:42:01.680]                               platform = base::sprintf("%s (%s-bit)", 
[11:42:01.680]                                 base::R.version$platform, 8 * 
[11:42:01.680]                                   base::.Machine$sizeof.pointer), 
[11:42:01.680]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:42:01.680]                                 "release", "version")], collapse = " "), 
[11:42:01.680]                               hostname = base::Sys.info()[["nodename"]])
[11:42:01.680]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:42:01.680]                               info)
[11:42:01.680]                             info <- base::paste(info, collapse = "; ")
[11:42:01.680]                             if (!has_future) {
[11:42:01.680]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:42:01.680]                                 info)
[11:42:01.680]                             }
[11:42:01.680]                             else {
[11:42:01.680]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:42:01.680]                                 info, version)
[11:42:01.680]                             }
[11:42:01.680]                             base::stop(msg)
[11:42:01.680]                           }
[11:42:01.680]                         })
[11:42:01.680]                       }
[11:42:01.680]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:42:01.680]                       base::options(mc.cores = 1L)
[11:42:01.680]                     }
[11:42:01.680]                     base::local({
[11:42:01.680]                       for (pkg in "mlr3") {
[11:42:01.680]                         base::loadNamespace(pkg)
[11:42:01.680]                         base::library(pkg, character.only = TRUE)
[11:42:01.680]                       }
[11:42:01.680]                     })
[11:42:01.680]                   }
[11:42:01.680]                   options(future.plan = NULL)
[11:42:01.680]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:42:01.680]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:42:01.680]                 }
[11:42:01.680]                 ...future.workdir <- getwd()
[11:42:01.680]             }
[11:42:01.680]             ...future.oldOptions <- base::as.list(base::.Options)
[11:42:01.680]             ...future.oldEnvVars <- base::Sys.getenv()
[11:42:01.680]         }
[11:42:01.680]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:42:01.680]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:42:01.680]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:42:01.680]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:42:01.680]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:42:01.680]             future.stdout.windows.reencode = NULL, width = 400L)
[11:42:01.680]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:42:01.680]             base::names(...future.oldOptions))
[11:42:01.680]     }
[11:42:01.680]     if (FALSE) {
[11:42:01.680]     }
[11:42:01.680]     else {
[11:42:01.680]         if (TRUE) {
[11:42:01.680]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:42:01.680]                 open = "w")
[11:42:01.680]         }
[11:42:01.680]         else {
[11:42:01.680]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:42:01.680]                 windows = "NUL", "/dev/null"), open = "w")
[11:42:01.680]         }
[11:42:01.680]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:42:01.680]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:42:01.680]             base::sink(type = "output", split = FALSE)
[11:42:01.680]             base::close(...future.stdout)
[11:42:01.680]         }, add = TRUE)
[11:42:01.680]     }
[11:42:01.680]     ...future.frame <- base::sys.nframe()
[11:42:01.680]     ...future.conditions <- base::list()
[11:42:01.680]     ...future.rng <- base::globalenv()$.Random.seed
[11:42:01.680]     if (FALSE) {
[11:42:01.680]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:42:01.680]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:42:01.680]     }
[11:42:01.680]     ...future.result <- base::tryCatch({
[11:42:01.680]         base::withCallingHandlers({
[11:42:01.680]             ...future.value <- base::withVisible(base::local({
[11:42:01.680]                 ...future.makeSendCondition <- local({
[11:42:01.680]                   sendCondition <- NULL
[11:42:01.680]                   function(frame = 1L) {
[11:42:01.680]                     if (is.function(sendCondition)) 
[11:42:01.680]                       return(sendCondition)
[11:42:01.680]                     ns <- getNamespace("parallel")
[11:42:01.680]                     if (exists("sendData", mode = "function", 
[11:42:01.680]                       envir = ns)) {
[11:42:01.680]                       parallel_sendData <- get("sendData", mode = "function", 
[11:42:01.680]                         envir = ns)
[11:42:01.680]                       envir <- sys.frame(frame)
[11:42:01.680]                       master <- NULL
[11:42:01.680]                       while (!identical(envir, .GlobalEnv) && 
[11:42:01.680]                         !identical(envir, emptyenv())) {
[11:42:01.680]                         if (exists("master", mode = "list", envir = envir, 
[11:42:01.680]                           inherits = FALSE)) {
[11:42:01.680]                           master <- get("master", mode = "list", 
[11:42:01.680]                             envir = envir, inherits = FALSE)
[11:42:01.680]                           if (inherits(master, c("SOCKnode", 
[11:42:01.680]                             "SOCK0node"))) {
[11:42:01.680]                             sendCondition <<- function(cond) {
[11:42:01.680]                               data <- list(type = "VALUE", value = cond, 
[11:42:01.680]                                 success = TRUE)
[11:42:01.680]                               parallel_sendData(master, data)
[11:42:01.680]                             }
[11:42:01.680]                             return(sendCondition)
[11:42:01.680]                           }
[11:42:01.680]                         }
[11:42:01.680]                         frame <- frame + 1L
[11:42:01.680]                         envir <- sys.frame(frame)
[11:42:01.680]                       }
[11:42:01.680]                     }
[11:42:01.680]                     sendCondition <<- function(cond) NULL
[11:42:01.680]                   }
[11:42:01.680]                 })
[11:42:01.680]                 withCallingHandlers({
[11:42:01.680]                   {
[11:42:01.680]                     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:42:01.680]                     if (!identical(...future.globals.maxSize.org, 
[11:42:01.680]                       ...future.globals.maxSize)) {
[11:42:01.680]                       oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:42:01.680]                       on.exit(options(oopts), add = TRUE)
[11:42:01.680]                     }
[11:42:01.680]                     {
[11:42:01.680]                       ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:42:01.680]                         assign(".Random.seed", ...future.seeds_ii_jj, 
[11:42:01.680]                           envir = globalenv(), inherits = FALSE)
[11:42:01.680]                         ...future.FUN(...)
[11:42:01.680]                       }
[11:42:01.680]                       args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:42:01.680]                         list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:42:01.680]                         MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, 
[11:42:01.680]                         USE.NAMES = FALSE)
[11:42:01.680]                       do.call(mapply, args = args)
[11:42:01.680]                     }
[11:42:01.680]                   }
[11:42:01.680]                 }, immediateCondition = function(cond) {
[11:42:01.680]                   sendCondition <- ...future.makeSendCondition()
[11:42:01.680]                   sendCondition(cond)
[11:42:01.680]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:01.680]                   {
[11:42:01.680]                     inherits <- base::inherits
[11:42:01.680]                     invokeRestart <- base::invokeRestart
[11:42:01.680]                     is.null <- base::is.null
[11:42:01.680]                     muffled <- FALSE
[11:42:01.680]                     if (inherits(cond, "message")) {
[11:42:01.680]                       muffled <- grepl(pattern, "muffleMessage")
[11:42:01.680]                       if (muffled) 
[11:42:01.680]                         invokeRestart("muffleMessage")
[11:42:01.680]                     }
[11:42:01.680]                     else if (inherits(cond, "warning")) {
[11:42:01.680]                       muffled <- grepl(pattern, "muffleWarning")
[11:42:01.680]                       if (muffled) 
[11:42:01.680]                         invokeRestart("muffleWarning")
[11:42:01.680]                     }
[11:42:01.680]                     else if (inherits(cond, "condition")) {
[11:42:01.680]                       if (!is.null(pattern)) {
[11:42:01.680]                         computeRestarts <- base::computeRestarts
[11:42:01.680]                         grepl <- base::grepl
[11:42:01.680]                         restarts <- computeRestarts(cond)
[11:42:01.680]                         for (restart in restarts) {
[11:42:01.680]                           name <- restart$name
[11:42:01.680]                           if (is.null(name)) 
[11:42:01.680]                             next
[11:42:01.680]                           if (!grepl(pattern, name)) 
[11:42:01.680]                             next
[11:42:01.680]                           invokeRestart(restart)
[11:42:01.680]                           muffled <- TRUE
[11:42:01.680]                           break
[11:42:01.680]                         }
[11:42:01.680]                       }
[11:42:01.680]                     }
[11:42:01.680]                     invisible(muffled)
[11:42:01.680]                   }
[11:42:01.680]                   muffleCondition(cond)
[11:42:01.680]                 })
[11:42:01.680]             }))
[11:42:01.680]             future::FutureResult(value = ...future.value$value, 
[11:42:01.680]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:42:01.680]                   ...future.rng), globalenv = if (FALSE) 
[11:42:01.680]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:42:01.680]                     ...future.globalenv.names))
[11:42:01.680]                 else NULL, started = ...future.startTime, version = "1.8")
[11:42:01.680]         }, condition = base::local({
[11:42:01.680]             c <- base::c
[11:42:01.680]             inherits <- base::inherits
[11:42:01.680]             invokeRestart <- base::invokeRestart
[11:42:01.680]             length <- base::length
[11:42:01.680]             list <- base::list
[11:42:01.680]             seq.int <- base::seq.int
[11:42:01.680]             signalCondition <- base::signalCondition
[11:42:01.680]             sys.calls <- base::sys.calls
[11:42:01.680]             `[[` <- base::`[[`
[11:42:01.680]             `+` <- base::`+`
[11:42:01.680]             `<<-` <- base::`<<-`
[11:42:01.680]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:42:01.680]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:42:01.680]                   3L)]
[11:42:01.680]             }
[11:42:01.680]             function(cond) {
[11:42:01.680]                 is_error <- inherits(cond, "error")
[11:42:01.680]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:42:01.680]                   NULL)
[11:42:01.680]                 if (is_error) {
[11:42:01.680]                   sessionInformation <- function() {
[11:42:01.680]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:42:01.680]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:42:01.680]                       search = base::search(), system = base::Sys.info())
[11:42:01.680]                   }
[11:42:01.680]                   ...future.conditions[[length(...future.conditions) + 
[11:42:01.680]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:42:01.680]                     cond$call), session = sessionInformation(), 
[11:42:01.680]                     timestamp = base::Sys.time(), signaled = 0L)
[11:42:01.680]                   signalCondition(cond)
[11:42:01.680]                 }
[11:42:01.680]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:42:01.680]                 "immediateCondition"))) {
[11:42:01.680]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:42:01.680]                   ...future.conditions[[length(...future.conditions) + 
[11:42:01.680]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:42:01.680]                   if (TRUE && !signal) {
[11:42:01.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:01.680]                     {
[11:42:01.680]                       inherits <- base::inherits
[11:42:01.680]                       invokeRestart <- base::invokeRestart
[11:42:01.680]                       is.null <- base::is.null
[11:42:01.680]                       muffled <- FALSE
[11:42:01.680]                       if (inherits(cond, "message")) {
[11:42:01.680]                         muffled <- grepl(pattern, "muffleMessage")
[11:42:01.680]                         if (muffled) 
[11:42:01.680]                           invokeRestart("muffleMessage")
[11:42:01.680]                       }
[11:42:01.680]                       else if (inherits(cond, "warning")) {
[11:42:01.680]                         muffled <- grepl(pattern, "muffleWarning")
[11:42:01.680]                         if (muffled) 
[11:42:01.680]                           invokeRestart("muffleWarning")
[11:42:01.680]                       }
[11:42:01.680]                       else if (inherits(cond, "condition")) {
[11:42:01.680]                         if (!is.null(pattern)) {
[11:42:01.680]                           computeRestarts <- base::computeRestarts
[11:42:01.680]                           grepl <- base::grepl
[11:42:01.680]                           restarts <- computeRestarts(cond)
[11:42:01.680]                           for (restart in restarts) {
[11:42:01.680]                             name <- restart$name
[11:42:01.680]                             if (is.null(name)) 
[11:42:01.680]                               next
[11:42:01.680]                             if (!grepl(pattern, name)) 
[11:42:01.680]                               next
[11:42:01.680]                             invokeRestart(restart)
[11:42:01.680]                             muffled <- TRUE
[11:42:01.680]                             break
[11:42:01.680]                           }
[11:42:01.680]                         }
[11:42:01.680]                       }
[11:42:01.680]                       invisible(muffled)
[11:42:01.680]                     }
[11:42:01.680]                     muffleCondition(cond, pattern = "^muffle")
[11:42:01.680]                   }
[11:42:01.680]                 }
[11:42:01.680]                 else {
[11:42:01.680]                   if (TRUE) {
[11:42:01.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:42:01.680]                     {
[11:42:01.680]                       inherits <- base::inherits
[11:42:01.680]                       invokeRestart <- base::invokeRestart
[11:42:01.680]                       is.null <- base::is.null
[11:42:01.680]                       muffled <- FALSE
[11:42:01.680]                       if (inherits(cond, "message")) {
[11:42:01.680]                         muffled <- grepl(pattern, "muffleMessage")
[11:42:01.680]                         if (muffled) 
[11:42:01.680]                           invokeRestart("muffleMessage")
[11:42:01.680]                       }
[11:42:01.680]                       else if (inherits(cond, "warning")) {
[11:42:01.680]                         muffled <- grepl(pattern, "muffleWarning")
[11:42:01.680]                         if (muffled) 
[11:42:01.680]                           invokeRestart("muffleWarning")
[11:42:01.680]                       }
[11:42:01.680]                       else if (inherits(cond, "condition")) {
[11:42:01.680]                         if (!is.null(pattern)) {
[11:42:01.680]                           computeRestarts <- base::computeRestarts
[11:42:01.680]                           grepl <- base::grepl
[11:42:01.680]                           restarts <- computeRestarts(cond)
[11:42:01.680]                           for (restart in restarts) {
[11:42:01.680]                             name <- restart$name
[11:42:01.680]                             if (is.null(name)) 
[11:42:01.680]                               next
[11:42:01.680]                             if (!grepl(pattern, name)) 
[11:42:01.680]                               next
[11:42:01.680]                             invokeRestart(restart)
[11:42:01.680]                             muffled <- TRUE
[11:42:01.680]                             break
[11:42:01.680]                           }
[11:42:01.680]                         }
[11:42:01.680]                       }
[11:42:01.680]                       invisible(muffled)
[11:42:01.680]                     }
[11:42:01.680]                     muffleCondition(cond, pattern = "^muffle")
[11:42:01.680]                   }
[11:42:01.680]                 }
[11:42:01.680]             }
[11:42:01.680]         }))
[11:42:01.680]     }, error = function(ex) {
[11:42:01.680]         base::structure(base::list(value = NULL, visible = NULL, 
[11:42:01.680]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:42:01.680]                 ...future.rng), started = ...future.startTime, 
[11:42:01.680]             finished = Sys.time(), session_uuid = NA_character_, 
[11:42:01.680]             version = "1.8"), class = "FutureResult")
[11:42:01.680]     }, finally = {
[11:42:01.680]         if (!identical(...future.workdir, getwd())) 
[11:42:01.680]             setwd(...future.workdir)
[11:42:01.680]         {
[11:42:01.680]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:42:01.680]                 ...future.oldOptions$nwarnings <- NULL
[11:42:01.680]             }
[11:42:01.680]             base::options(...future.oldOptions)
[11:42:01.680]             if (.Platform$OS.type == "windows") {
[11:42:01.680]                 old_names <- names(...future.oldEnvVars)
[11:42:01.680]                 envs <- base::Sys.getenv()
[11:42:01.680]                 names <- names(envs)
[11:42:01.680]                 common <- intersect(names, old_names)
[11:42:01.680]                 added <- setdiff(names, old_names)
[11:42:01.680]                 removed <- setdiff(old_names, names)
[11:42:01.680]                 changed <- common[...future.oldEnvVars[common] != 
[11:42:01.680]                   envs[common]]
[11:42:01.680]                 NAMES <- toupper(changed)
[11:42:01.680]                 args <- list()
[11:42:01.680]                 for (kk in seq_along(NAMES)) {
[11:42:01.680]                   name <- changed[[kk]]
[11:42:01.680]                   NAME <- NAMES[[kk]]
[11:42:01.680]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:01.680]                     next
[11:42:01.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:42:01.680]                 }
[11:42:01.680]                 NAMES <- toupper(added)
[11:42:01.680]                 for (kk in seq_along(NAMES)) {
[11:42:01.680]                   name <- added[[kk]]
[11:42:01.680]                   NAME <- NAMES[[kk]]
[11:42:01.680]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:01.680]                     next
[11:42:01.680]                   args[[name]] <- ""
[11:42:01.680]                 }
[11:42:01.680]                 NAMES <- toupper(removed)
[11:42:01.680]                 for (kk in seq_along(NAMES)) {
[11:42:01.680]                   name <- removed[[kk]]
[11:42:01.680]                   NAME <- NAMES[[kk]]
[11:42:01.680]                   if (name != NAME && is.element(NAME, old_names)) 
[11:42:01.680]                     next
[11:42:01.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:42:01.680]                 }
[11:42:01.680]                 if (length(args) > 0) 
[11:42:01.680]                   base::do.call(base::Sys.setenv, args = args)
[11:42:01.680]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:42:01.680]             }
[11:42:01.680]             else {
[11:42:01.680]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:42:01.680]             }
[11:42:01.680]             {
[11:42:01.680]                 if (base::length(...future.futureOptionsAdded) > 
[11:42:01.680]                   0L) {
[11:42:01.680]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:42:01.680]                   base::names(opts) <- ...future.futureOptionsAdded
[11:42:01.680]                   base::options(opts)
[11:42:01.680]                 }
[11:42:01.680]                 {
[11:42:01.680]                   {
[11:42:01.680]                     base::options(mc.cores = ...future.mc.cores.old)
[11:42:01.680]                     NULL
[11:42:01.680]                   }
[11:42:01.680]                   options(future.plan = NULL)
[11:42:01.680]                   if (is.na(NA_character_)) 
[11:42:01.680]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:42:01.680]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:42:01.680]                   future::plan(list(function (..., workers = 2, 
[11:42:01.680]                     envir = parent.frame()) 
[11:42:01.680]                   strategy(..., workers = workers, envir = envir)), 
[11:42:01.680]                     .cleanup = FALSE, .init = FALSE)
[11:42:01.680]                 }
[11:42:01.680]             }
[11:42:01.680]         }
[11:42:01.680]     })
[11:42:01.680]     if (TRUE) {
[11:42:01.680]         base::sink(type = "output", split = FALSE)
[11:42:01.680]         if (TRUE) {
[11:42:01.680]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:42:01.680]         }
[11:42:01.680]         else {
[11:42:01.680]             ...future.result["stdout"] <- base::list(NULL)
[11:42:01.680]         }
[11:42:01.680]         base::close(...future.stdout)
[11:42:01.680]         ...future.stdout <- NULL
[11:42:01.680]     }
[11:42:01.680]     ...future.result$conditions <- ...future.conditions
[11:42:01.680]     ...future.result$finished <- base::Sys.time()
[11:42:01.680]     ...future.result
[11:42:01.680] }
[11:42:01.682] Poll #1 (0): usedNodes() = 2, workers = 2
[11:42:01.697] receiveMessageFromWorker() for ClusterFuture ...
[11:42:01.697] - Validating connection of MultisessionFuture
[11:42:01.697] - received message: FutureResult
[11:42:01.698] - Received FutureResult
[11:42:01.698] - Erased future from FutureRegistry
[11:42:01.698] result() for ClusterFuture ...
[11:42:01.698] - result already collected: FutureResult
[11:42:01.698] result() for ClusterFuture ... done
[11:42:01.698] receiveMessageFromWorker() for ClusterFuture ... done
[11:42:01.699] result() for ClusterFuture ...
[11:42:01.699] - result already collected: FutureResult
[11:42:01.699] result() for ClusterFuture ... done
[11:42:01.699] result() for ClusterFuture ...
[11:42:01.699] - result already collected: FutureResult
[11:42:01.699] result() for ClusterFuture ... done
[11:42:01.701] Exporting 5 global objects (157.50 KiB) to cluster node #2 ...
[11:42:01.701] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ...
[11:42:01.746] Exporting ‘...future.FUN’ (114.30 KiB) to cluster node #2 ... DONE
[11:42:01.752] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ...
[11:42:01.798] Exporting ‘MoreArgs’ (43.20 KiB) to cluster node #2 ... DONE
[11:42:01.799] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ...
[11:42:01.842] Exporting ‘...future.elements_ii’ (168 bytes) to cluster node #2 ... DONE
[11:42:01.842] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ...
[11:42:01.844] Exporting ‘...future.seeds_ii’ (80 bytes) to cluster node #2 ... DONE
[11:42:01.844] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ...
[11:42:01.845] Exporting ‘...future.globals.maxSize’ (0 bytes) to cluster node #2 ... DONE
[11:42:01.846] Exporting 5 global objects (157.50 KiB) to cluster node #2 ... DONE
[11:42:01.847] MultisessionFuture started
[11:42:01.847] - Launch lazy future ... done
[11:42:01.847] run() for ‘MultisessionFuture’ ... done
[11:42:01.847] Created future:
[11:42:01.847] MultisessionFuture:
[11:42:01.847] Label: ‘future_mapply-90’
[11:42:01.847] Expression:
[11:42:01.847] {
[11:42:01.847]     ...future.globals.maxSize.org <- getOption("future.globals.maxSize")
[11:42:01.847]     if (!identical(...future.globals.maxSize.org, ...future.globals.maxSize)) {
[11:42:01.847]         oopts <- options(future.globals.maxSize = ...future.globals.maxSize)
[11:42:01.847]         on.exit(options(oopts), add = TRUE)
[11:42:01.847]     }
[11:42:01.847]     {
[11:42:01.847]         ...future.FUN2 <- function(..., ...future.seeds_ii_jj) {
[11:42:01.847]             assign(".Random.seed", ...future.seeds_ii_jj, envir = globalenv(), 
[11:42:01.847]                 inherits = FALSE)
[11:42:01.847]             ...future.FUN(...)
[11:42:01.847]         }
[11:42:01.847]         args <- c(list(FUN = ...future.FUN2), ...future.elements_ii, 
[11:42:01.847]             list(...future.seeds_ii_jj = ...future.seeds_ii), 
[11:42:01.847]             MoreArgs = list(MoreArgs), SIMPLIFY = FALSE, USE.NAMES = FALSE)
[11:42:01.847]         do.call(mapply, args = args)
[11:42:01.847]     }
[11:42:01.847] }
[11:42:01.847] Lazy evaluation: FALSE
[11:42:01.847] Asynchronous evaluation: TRUE
[11:42:01.847] Local evaluation: TRUE
[11:42:01.847] Environment: 0x560ef58e1768
[11:42:01.847] Capture standard output: TRUE
[11:42:01.847] Capture condition classes: ‘condition’ (excluding ‘nothing’)
[11:42:01.847] Globals: 5 objects totaling 157.74 KiB (function ‘...future.FUN’ of 114.30 KiB, list ‘MoreArgs’ of 43.20 KiB, list ‘...future.elements_ii’ of 168 bytes, list ‘...future.seeds_ii’ of 80 bytes, NULL ‘...future.globals.maxSize’ of 0 bytes)
[11:42:01.847] Packages: 1 packages (‘mlr3’)
[11:42:01.847] L'Ecuyer-CMRG RNG seed: <none> (seed = NULL)
[11:42:01.847] Resolved: FALSE
[11:42:01.847] Value: <not collected>
[11:42:01.847] Conditions captured: <none>
[11:42:01.847] Early signaling: FALSE
[11:42:01.847] Owner process: fe295e13-31cb-a1f6-224c-bbcddcc7b6c4
[11:42:01.847] Class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:42:01.864] Chunk #90 of 90 ... DONE
[11:42:01.865] Launching 90 futures (chunks) ... DONE
[11:42:01.865] Resolving 90 futures (chunks) ...
[11:42:01.865] resolve() on list ...
[11:42:01.865]  recursive: 0
[11:42:01.865]  length: 90
[11:42:01.865] 
[11:42:01.865] Future #1
[11:42:01.865] result() for ClusterFuture ...
[11:42:01.866] - result already collected: FutureResult
[11:42:01.866] result() for ClusterFuture ... done
[11:42:01.866] result() for ClusterFuture ...
[11:42:01.866] - result already collected: FutureResult
[11:42:01.866] result() for ClusterFuture ... done
[11:42:01.866] signalConditionsASAP(MultisessionFuture, pos=1) ...
[11:42:01.866] - nx: 90
[11:42:01.866] - relay: TRUE
[11:42:01.866] - stdout: TRUE
[11:42:01.866] - signal: TRUE
[11:42:01.866] - resignal: FALSE
[11:42:01.867] - force: TRUE
[11:42:01.867] - relayed: [n=90] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.867] - queued futures: [n=90] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.867]  - until=1
[11:42:01.867]  - relaying element #1
[11:42:01.867] result() for ClusterFuture ...
[11:42:01.867] - result already collected: FutureResult
[11:42:01.867] result() for ClusterFuture ... done
[11:42:01.867] result() for ClusterFuture ...
[11:42:01.867] - result already collected: FutureResult
[11:42:01.867] result() for ClusterFuture ... done
[11:42:01.868] result() for ClusterFuture ...
[11:42:01.868] - result already collected: FutureResult
[11:42:01.868] result() for ClusterFuture ... done
[11:42:01.868] result() for ClusterFuture ...
[11:42:01.868] - result already collected: FutureResult
[11:42:01.868] result() for ClusterFuture ... done
[11:42:01.868] - relayed: [n=90] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.868] - queued futures: [n=90] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.868] signalConditionsASAP(MultisessionFuture, pos=1) ... done
[11:42:01.868]  length: 89 (resolved future 1)
[11:42:01.868] Future #2
[11:42:01.868] result() for ClusterFuture ...
[11:42:01.869] - result already collected: FutureResult
[11:42:01.869] result() for ClusterFuture ... done
[11:42:01.869] result() for ClusterFuture ...
[11:42:01.869] - result already collected: FutureResult
[11:42:01.869] result() for ClusterFuture ... done
[11:42:01.869] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:42:01.869] - nx: 90
[11:42:01.869] - relay: TRUE
[11:42:01.869] - stdout: TRUE
[11:42:01.869] - signal: TRUE
[11:42:01.869] - resignal: FALSE
[11:42:01.869] - force: TRUE
[11:42:01.869] - relayed: [n=90] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.869] - queued futures: [n=90] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.869]  - until=2
[11:42:01.869]  - relaying element #2
[11:42:01.870] result() for ClusterFuture ...
[11:42:01.870] - result already collected: FutureResult
[11:42:01.870] result() for ClusterFuture ... done
[11:42:01.870] result() for ClusterFuture ...
[11:42:01.870] - result already collected: FutureResult
[11:42:01.870] result() for ClusterFuture ... done
[11:42:01.870] result() for ClusterFuture ...
[11:42:01.870] - result already collected: FutureResult
[11:42:01.870] result() for ClusterFuture ... done
[11:42:01.870] result() for ClusterFuture ...
[11:42:01.870] - result already collected: FutureResult
[11:42:01.870] result() for ClusterFuture ... done
[11:42:01.870] - relayed: [n=90] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.870] - queued futures: [n=90] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.870] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[11:42:01.870]  length: 88 (resolved future 2)
[11:42:01.870] Future #3
[11:42:01.871] result() for ClusterFuture ...
[11:42:01.871] - result already collected: FutureResult
[11:42:01.871] result() for ClusterFuture ... done
[11:42:01.871] result() for ClusterFuture ...
[11:42:01.871] - result already collected: FutureResult
[11:42:01.871] result() for ClusterFuture ... done
[11:42:01.871] signalConditionsASAP(MultisessionFuture, pos=3) ...
[11:42:01.871] - nx: 90
[11:42:01.871] - relay: TRUE
[11:42:01.871] - stdout: TRUE
[11:42:01.871] - signal: TRUE
[11:42:01.871] - resignal: FALSE
[11:42:01.871] - force: TRUE
[11:42:01.871] - relayed: [n=90] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.871] - queued futures: [n=90] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.871]  - until=3
[11:42:01.871]  - relaying element #3
[11:42:01.871] result() for ClusterFuture ...
[11:42:01.871] - result already collected: FutureResult
[11:42:01.871] result() for ClusterFuture ... done
[11:42:01.871] result() for ClusterFuture ...
[11:42:01.871] - result already collected: FutureResult
[11:42:01.872] result() for ClusterFuture ... done
[11:42:01.872] result() for ClusterFuture ...
[11:42:01.872] - result already collected: FutureResult
[11:42:01.872] result() for ClusterFuture ... done
[11:42:01.872] result() for ClusterFuture ...
[11:42:01.872] - result already collected: FutureResult
[11:42:01.872] result() for ClusterFuture ... done
[11:42:01.872] - relayed: [n=90] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.872] - queued futures: [n=90] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.872] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[11:42:01.872]  length: 87 (resolved future 3)
[11:42:01.872] Future #4
[11:42:01.872] result() for ClusterFuture ...
[11:42:01.872] - result already collected: FutureResult
[11:42:01.872] result() for ClusterFuture ... done
[11:42:01.872] result() for ClusterFuture ...
[11:42:01.872] - result already collected: FutureResult
[11:42:01.872] result() for ClusterFuture ... done
[11:42:01.872] signalConditionsASAP(MultisessionFuture, pos=4) ...
[11:42:01.872] - nx: 90
[11:42:01.872] - relay: TRUE
[11:42:01.873] - stdout: TRUE
[11:42:01.873] - signal: TRUE
[11:42:01.873] - resignal: FALSE
[11:42:01.873] - force: TRUE
[11:42:01.873] - relayed: [n=90] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.873] - queued futures: [n=90] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.873]  - until=4
[11:42:01.873]  - relaying element #4
[11:42:01.873] result() for ClusterFuture ...
[11:42:01.873] - result already collected: FutureResult
[11:42:01.873] result() for ClusterFuture ... done
[11:42:01.873] result() for ClusterFuture ...
[11:42:01.873] - result already collected: FutureResult
[11:42:01.873] result() for ClusterFuture ... done
[11:42:01.873] result() for ClusterFuture ...
[11:42:01.873] - result already collected: FutureResult
[11:42:01.873] result() for ClusterFuture ... done
[11:42:01.873] result() for ClusterFuture ...
[11:42:01.873] - result already collected: FutureResult
[11:42:01.873] result() for ClusterFuture ... done
[11:42:01.873] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.874] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.874] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[11:42:01.874]  length: 86 (resolved future 4)
[11:42:01.874] Future #5
[11:42:01.874] result() for ClusterFuture ...
[11:42:01.874] - result already collected: FutureResult
[11:42:01.874] result() for ClusterFuture ... done
[11:42:01.874] result() for ClusterFuture ...
[11:42:01.874] - result already collected: FutureResult
[11:42:01.874] result() for ClusterFuture ... done
[11:42:01.874] signalConditionsASAP(MultisessionFuture, pos=5) ...
[11:42:01.874] - nx: 90
[11:42:01.874] - relay: TRUE
[11:42:01.874] - stdout: TRUE
[11:42:01.874] - signal: TRUE
[11:42:01.874] - resignal: FALSE
[11:42:01.874] - force: TRUE
[11:42:01.874] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.874] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.874]  - until=5
[11:42:01.874]  - relaying element #5
[11:42:01.875] result() for ClusterFuture ...
[11:42:01.875] - result already collected: FutureResult
[11:42:01.875] result() for ClusterFuture ... done
[11:42:01.875] result() for ClusterFuture ...
[11:42:01.875] - result already collected: FutureResult
[11:42:01.875] result() for ClusterFuture ... done
[11:42:01.875] result() for ClusterFuture ...
[11:42:01.875] - result already collected: FutureResult
[11:42:01.875] result() for ClusterFuture ... done
[11:42:01.875] result() for ClusterFuture ...
[11:42:01.875] - result already collected: FutureResult
[11:42:01.875] result() for ClusterFuture ... done
[11:42:01.875] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.875] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.875] signalConditionsASAP(MultisessionFuture, pos=5) ... done
[11:42:01.875]  length: 85 (resolved future 5)
[11:42:01.875] Future #6
[11:42:01.875] result() for ClusterFuture ...
[11:42:01.875] - result already collected: FutureResult
[11:42:01.875] result() for ClusterFuture ... done
[11:42:01.875] result() for ClusterFuture ...
[11:42:01.876] - result already collected: FutureResult
[11:42:01.876] result() for ClusterFuture ... done
[11:42:01.876] signalConditionsASAP(MultisessionFuture, pos=6) ...
[11:42:01.876] - nx: 90
[11:42:01.876] - relay: TRUE
[11:42:01.876] - stdout: TRUE
[11:42:01.876] - signal: TRUE
[11:42:01.876] - resignal: FALSE
[11:42:01.876] - force: TRUE
[11:42:01.876] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.876] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.876]  - until=6
[11:42:01.876]  - relaying element #6
[11:42:01.876] result() for ClusterFuture ...
[11:42:01.876] - result already collected: FutureResult
[11:42:01.876] result() for ClusterFuture ... done
[11:42:01.876] result() for ClusterFuture ...
[11:42:01.876] - result already collected: FutureResult
[11:42:01.876] result() for ClusterFuture ... done
[11:42:01.876] result() for ClusterFuture ...
[11:42:01.876] - result already collected: FutureResult
[11:42:01.876] result() for ClusterFuture ... done
[11:42:01.877] result() for ClusterFuture ...
[11:42:01.877] - result already collected: FutureResult
[11:42:01.877] result() for ClusterFuture ... done
[11:42:01.877] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.877] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.877] signalConditionsASAP(MultisessionFuture, pos=6) ... done
[11:42:01.877]  length: 84 (resolved future 6)
[11:42:01.877] Future #7
[11:42:01.877] result() for ClusterFuture ...
[11:42:01.877] - result already collected: FutureResult
[11:42:01.877] result() for ClusterFuture ... done
[11:42:01.877] result() for ClusterFuture ...
[11:42:01.877] - result already collected: FutureResult
[11:42:01.877] result() for ClusterFuture ... done
[11:42:01.877] signalConditionsASAP(MultisessionFuture, pos=7) ...
[11:42:01.877] - nx: 90
[11:42:01.877] - relay: TRUE
[11:42:01.877] - stdout: TRUE
[11:42:01.877] - signal: TRUE
[11:42:01.877] - resignal: FALSE
[11:42:01.877] - force: TRUE
[11:42:01.877] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.878] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.878]  - until=7
[11:42:01.878]  - relaying element #7
[11:42:01.878] result() for ClusterFuture ...
[11:42:01.878] - result already collected: FutureResult
[11:42:01.878] result() for ClusterFuture ... done
[11:42:01.878] result() for ClusterFuture ...
[11:42:01.878] - result already collected: FutureResult
[11:42:01.878] result() for ClusterFuture ... done
[11:42:01.878] result() for ClusterFuture ...
[11:42:01.878] - result already collected: FutureResult
[11:42:01.878] result() for ClusterFuture ... done
[11:42:01.878] result() for ClusterFuture ...
[11:42:01.878] - result already collected: FutureResult
[11:42:01.878] result() for ClusterFuture ... done
[11:42:01.878] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.878] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.878] signalConditionsASAP(MultisessionFuture, pos=7) ... done
[11:42:01.878]  length: 83 (resolved future 7)
[11:42:01.878] Future #8
[11:42:01.879] result() for ClusterFuture ...
[11:42:01.879] - result already collected: FutureResult
[11:42:01.879] result() for ClusterFuture ... done
[11:42:01.879] result() for ClusterFuture ...
[11:42:01.879] - result already collected: FutureResult
[11:42:01.879] result() for ClusterFuture ... done
[11:42:01.879] signalConditionsASAP(MultisessionFuture, pos=8) ...
[11:42:01.879] - nx: 90
[11:42:01.879] - relay: TRUE
[11:42:01.879] - stdout: TRUE
[11:42:01.879] - signal: TRUE
[11:42:01.879] - resignal: FALSE
[11:42:01.879] - force: TRUE
[11:42:01.879] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.879] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.879]  - until=8
[11:42:01.879]  - relaying element #8
[11:42:01.879] result() for ClusterFuture ...
[11:42:01.879] - result already collected: FutureResult
[11:42:01.879] result() for ClusterFuture ... done
[11:42:01.879] result() for ClusterFuture ...
[11:42:01.879] - result already collected: FutureResult
[11:42:01.879] result() for ClusterFuture ... done
[11:42:01.880] result() for ClusterFuture ...
[11:42:01.880] - result already collected: FutureResult
[11:42:01.880] result() for ClusterFuture ... done
[11:42:01.880] result() for ClusterFuture ...
[11:42:01.880] - result already collected: FutureResult
[11:42:01.880] result() for ClusterFuture ... done
[11:42:01.880] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.880] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.880] signalConditionsASAP(MultisessionFuture, pos=8) ... done
[11:42:01.880]  length: 82 (resolved future 8)
[11:42:01.880] Future #9
[11:42:01.880] result() for ClusterFuture ...
[11:42:01.880] - result already collected: FutureResult
[11:42:01.880] result() for ClusterFuture ... done
[11:42:01.880] result() for ClusterFuture ...
[11:42:01.880] - result already collected: FutureResult
[11:42:01.880] result() for ClusterFuture ... done
[11:42:01.880] signalConditionsASAP(MultisessionFuture, pos=9) ...
[11:42:01.880] - nx: 90
[11:42:01.880] - relay: TRUE
[11:42:01.880] - stdout: TRUE
[11:42:01.880] - signal: TRUE
[11:42:01.880] - resignal: FALSE
[11:42:01.881] - force: TRUE
[11:42:01.881] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.881] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.881]  - until=9
[11:42:01.881]  - relaying element #9
[11:42:01.881] result() for ClusterFuture ...
[11:42:01.881] - result already collected: FutureResult
[11:42:01.881] result() for ClusterFuture ... done
[11:42:01.881] result() for ClusterFuture ...
[11:42:01.881] - result already collected: FutureResult
[11:42:01.881] result() for ClusterFuture ... done
[11:42:01.881] result() for ClusterFuture ...
[11:42:01.881] - result already collected: FutureResult
[11:42:01.881] result() for ClusterFuture ... done
[11:42:01.881] result() for ClusterFuture ...
[11:42:01.881] - result already collected: FutureResult
[11:42:01.881] result() for ClusterFuture ... done
[11:42:01.881] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.881] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.881] signalConditionsASAP(MultisessionFuture, pos=9) ... done
[11:42:01.882]  length: 81 (resolved future 9)
[11:42:01.882] Future #10
[11:42:01.882] result() for ClusterFuture ...
[11:42:01.882] - result already collected: FutureResult
[11:42:01.882] result() for ClusterFuture ... done
[11:42:01.882] result() for ClusterFuture ...
[11:42:01.882] - result already collected: FutureResult
[11:42:01.882] result() for ClusterFuture ... done
[11:42:01.882] signalConditionsASAP(MultisessionFuture, pos=10) ...
[11:42:01.882] - nx: 90
[11:42:01.882] - relay: TRUE
[11:42:01.882] - stdout: TRUE
[11:42:01.882] - signal: TRUE
[11:42:01.882] - resignal: FALSE
[11:42:01.882] - force: TRUE
[11:42:01.882] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.882] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.882]  - until=10
[11:42:01.882]  - relaying element #10
[11:42:01.882] result() for ClusterFuture ...
[11:42:01.882] - result already collected: FutureResult
[11:42:01.882] result() for ClusterFuture ... done
[11:42:01.883] result() for ClusterFuture ...
[11:42:01.883] - result already collected: FutureResult
[11:42:01.883] result() for ClusterFuture ... done
[11:42:01.883] result() for ClusterFuture ...
[11:42:01.883] - result already collected: FutureResult
[11:42:01.883] result() for ClusterFuture ... done
[11:42:01.883] result() for ClusterFuture ...
[11:42:01.883] - result already collected: FutureResult
[11:42:01.883] result() for ClusterFuture ... done
[11:42:01.883] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.883] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.883] signalConditionsASAP(MultisessionFuture, pos=10) ... done
[11:42:01.883]  length: 80 (resolved future 10)
[11:42:01.883] Future #11
[11:42:01.883] result() for ClusterFuture ...
[11:42:01.883] - result already collected: FutureResult
[11:42:01.883] result() for ClusterFuture ... done
[11:42:01.883] result() for ClusterFuture ...
[11:42:01.883] - result already collected: FutureResult
[11:42:01.883] result() for ClusterFuture ... done
[11:42:01.883] signalConditionsASAP(MultisessionFuture, pos=11) ...
[11:42:01.884] - nx: 90
[11:42:01.884] - relay: TRUE
[11:42:01.884] - stdout: TRUE
[11:42:01.884] - signal: TRUE
[11:42:01.884] - resignal: FALSE
[11:42:01.884] - force: TRUE
[11:42:01.884] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.884] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.884]  - until=11
[11:42:01.884]  - relaying element #11
[11:42:01.884] result() for ClusterFuture ...
[11:42:01.884] - result already collected: FutureResult
[11:42:01.884] result() for ClusterFuture ... done
[11:42:01.884] result() for ClusterFuture ...
[11:42:01.884] - result already collected: FutureResult
[11:42:01.884] result() for ClusterFuture ... done
[11:42:01.884] result() for ClusterFuture ...
[11:42:01.884] - result already collected: FutureResult
[11:42:01.884] result() for ClusterFuture ... done
[11:42:01.884] result() for ClusterFuture ...
[11:42:01.885] - result already collected: FutureResult
[11:42:01.885] result() for ClusterFuture ... done
[11:42:01.885] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.885] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.885] signalConditionsASAP(MultisessionFuture, pos=11) ... done
[11:42:01.885]  length: 79 (resolved future 11)
[11:42:01.885] Future #12
[11:42:01.885] result() for ClusterFuture ...
[11:42:01.885] - result already collected: FutureResult
[11:42:01.885] result() for ClusterFuture ... done
[11:42:01.885] result() for ClusterFuture ...
[11:42:01.885] - result already collected: FutureResult
[11:42:01.885] result() for ClusterFuture ... done
[11:42:01.885] signalConditionsASAP(MultisessionFuture, pos=12) ...
[11:42:01.885] - nx: 90
[11:42:01.885] - relay: TRUE
[11:42:01.885] - stdout: TRUE
[11:42:01.885] - signal: TRUE
[11:42:01.885] - resignal: FALSE
[11:42:01.885] - force: TRUE
[11:42:01.885] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.886] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.886]  - until=12
[11:42:01.886]  - relaying element #12
[11:42:01.886] result() for ClusterFuture ...
[11:42:01.886] - result already collected: FutureResult
[11:42:01.886] result() for ClusterFuture ... done
[11:42:01.886] result() for ClusterFuture ...
[11:42:01.886] - result already collected: FutureResult
[11:42:01.886] result() for ClusterFuture ... done
[11:42:01.886] result() for ClusterFuture ...
[11:42:01.886] - result already collected: FutureResult
[11:42:01.886] result() for ClusterFuture ... done
[11:42:01.886] result() for ClusterFuture ...
[11:42:01.886] - result already collected: FutureResult
[11:42:01.886] result() for ClusterFuture ... done
[11:42:01.886] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.886] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.886] signalConditionsASAP(MultisessionFuture, pos=12) ... done
[11:42:01.887]  length: 78 (resolved future 12)
[11:42:01.887] Future #13
[11:42:01.887] result() for ClusterFuture ...
[11:42:01.887] - result already collected: FutureResult
[11:42:01.887] result() for ClusterFuture ... done
[11:42:01.887] result() for ClusterFuture ...
[11:42:01.887] - result already collected: FutureResult
[11:42:01.887] result() for ClusterFuture ... done
[11:42:01.887] signalConditionsASAP(MultisessionFuture, pos=13) ...
[11:42:01.887] - nx: 90
[11:42:01.887] - relay: TRUE
[11:42:01.887] - stdout: TRUE
[11:42:01.887] - signal: TRUE
[11:42:01.887] - resignal: FALSE
[11:42:01.887] - force: TRUE
[11:42:01.887] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.887] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.887]  - until=13
[11:42:01.887]  - relaying element #13
[11:42:01.887] result() for ClusterFuture ...
[11:42:01.888] - result already collected: FutureResult
[11:42:01.888] result() for ClusterFuture ... done
[11:42:01.888] result() for ClusterFuture ...
[11:42:01.888] - result already collected: FutureResult
[11:42:01.888] result() for ClusterFuture ... done
[11:42:01.888] result() for ClusterFuture ...
[11:42:01.888] - result already collected: FutureResult
[11:42:01.888] result() for ClusterFuture ... done
[11:42:01.888] result() for ClusterFuture ...
[11:42:01.888] - result already collected: FutureResult
[11:42:01.888] result() for ClusterFuture ... done
[11:42:01.888] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.888] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.888] signalConditionsASAP(MultisessionFuture, pos=13) ... done
[11:42:01.888]  length: 77 (resolved future 13)
[11:42:01.888] Future #14
[11:42:01.888] result() for ClusterFuture ...
[11:42:01.888] - result already collected: FutureResult
[11:42:01.888] result() for ClusterFuture ... done
[11:42:01.889] result() for ClusterFuture ...
[11:42:01.889] - result already collected: FutureResult
[11:42:01.889] result() for ClusterFuture ... done
[11:42:01.892] signalConditionsASAP(MultisessionFuture, pos=14) ...
[11:42:01.893] - nx: 90
[11:42:01.893] - relay: TRUE
[11:42:01.893] - stdout: TRUE
[11:42:01.893] - signal: TRUE
[11:42:01.893] - resignal: FALSE
[11:42:01.893] - force: TRUE
[11:42:01.893] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.893] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.893]  - until=14
[11:42:01.894]  - relaying element #14
[11:42:01.894] result() for ClusterFuture ...
[11:42:01.894] - result already collected: FutureResult
[11:42:01.894] result() for ClusterFuture ... done
[11:42:01.894] result() for ClusterFuture ...
[11:42:01.894] - result already collected: FutureResult
[11:42:01.894] result() for ClusterFuture ... done
[11:42:01.894] result() for ClusterFuture ...
[11:42:01.894] - result already collected: FutureResult
[11:42:01.894] result() for ClusterFuture ... done
[11:42:01.894] result() for ClusterFuture ...
[11:42:01.895] - result already collected: FutureResult
[11:42:01.895] result() for ClusterFuture ... done
[11:42:01.895] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.895] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.895] signalConditionsASAP(MultisessionFuture, pos=14) ... done
[11:42:01.895]  length: 76 (resolved future 14)
[11:42:01.895] Future #15
[11:42:01.895] result() for ClusterFuture ...
[11:42:01.895] - result already collected: FutureResult
[11:42:01.895] result() for ClusterFuture ... done
[11:42:01.895] result() for ClusterFuture ...
[11:42:01.896] - result already collected: FutureResult
[11:42:01.896] result() for ClusterFuture ... done
[11:42:01.896] signalConditionsASAP(MultisessionFuture, pos=15) ...
[11:42:01.896] - nx: 90
[11:42:01.896] - relay: TRUE
[11:42:01.896] - stdout: TRUE
[11:42:01.896] - signal: TRUE
[11:42:01.896] - resignal: FALSE
[11:42:01.896] - force: TRUE
[11:42:01.896] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.896] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.896]  - until=15
[11:42:01.896]  - relaying element #15
[11:42:01.896] result() for ClusterFuture ...
[11:42:01.897] - result already collected: FutureResult
[11:42:01.897] result() for ClusterFuture ... done
[11:42:01.897] result() for ClusterFuture ...
[11:42:01.897] - result already collected: FutureResult
[11:42:01.897] result() for ClusterFuture ... done
[11:42:01.897] result() for ClusterFuture ...
[11:42:01.897] - result already collected: FutureResult
[11:42:01.897] result() for ClusterFuture ... done
[11:42:01.897] result() for ClusterFuture ...
[11:42:01.897] - result already collected: FutureResult
[11:42:01.897] result() for ClusterFuture ... done
[11:42:01.897] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.897] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.897] signalConditionsASAP(MultisessionFuture, pos=15) ... done
[11:42:01.897]  length: 75 (resolved future 15)
[11:42:01.897] Future #16
[11:42:01.897] result() for ClusterFuture ...
[11:42:01.898] - result already collected: FutureResult
[11:42:01.898] result() for ClusterFuture ... done
[11:42:01.898] result() for ClusterFuture ...
[11:42:01.898] - result already collected: FutureResult
[11:42:01.898] result() for ClusterFuture ... done
[11:42:01.898] signalConditionsASAP(MultisessionFuture, pos=16) ...
[11:42:01.898] - nx: 90
[11:42:01.898] - relay: TRUE
[11:42:01.898] - stdout: TRUE
[11:42:01.898] - signal: TRUE
[11:42:01.898] - resignal: FALSE
[11:42:01.898] - force: TRUE
[11:42:01.898] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.898] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.898]  - until=16
[11:42:01.898]  - relaying element #16
[11:42:01.898] result() for ClusterFuture ...
[11:42:01.898] - result already collected: FutureResult
[11:42:01.898] result() for ClusterFuture ... done
[11:42:01.899] result() for ClusterFuture ...
[11:42:01.899] - result already collected: FutureResult
[11:42:01.899] result() for ClusterFuture ... done
[11:42:01.899] result() for ClusterFuture ...
[11:42:01.899] - result already collected: FutureResult
[11:42:01.899] result() for ClusterFuture ... done
[11:42:01.899] result() for ClusterFuture ...
[11:42:01.899] - result already collected: FutureResult
[11:42:01.899] result() for ClusterFuture ... done
[11:42:01.899] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.899] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.899] signalConditionsASAP(MultisessionFuture, pos=16) ... done
[11:42:01.899]  length: 74 (resolved future 16)
[11:42:01.899] Future #17
[11:42:01.900] result() for ClusterFuture ...
[11:42:01.900] - result already collected: FutureResult
[11:42:01.900] result() for ClusterFuture ... done
[11:42:01.900] result() for ClusterFuture ...
[11:42:01.900] - result already collected: FutureResult
[11:42:01.900] result() for ClusterFuture ... done
[11:42:01.900] signalConditionsASAP(MultisessionFuture, pos=17) ...
[11:42:01.900] - nx: 90
[11:42:01.900] - relay: TRUE
[11:42:01.900] - stdout: TRUE
[11:42:01.900] - signal: TRUE
[11:42:01.900] - resignal: FALSE
[11:42:01.900] - force: TRUE
[11:42:01.900] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.900] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.900]  - until=17
[11:42:01.900]  - relaying element #17
[11:42:01.900] result() for ClusterFuture ...
[11:42:01.901] - result already collected: FutureResult
[11:42:01.901] result() for ClusterFuture ... done
[11:42:01.901] result() for ClusterFuture ...
[11:42:01.901] - result already collected: FutureResult
[11:42:01.901] result() for ClusterFuture ... done
[11:42:01.901] result() for ClusterFuture ...
[11:42:01.901] - result already collected: FutureResult
[11:42:01.901] result() for ClusterFuture ... done
[11:42:01.901] result() for ClusterFuture ...
[11:42:01.901] - result already collected: FutureResult
[11:42:01.901] result() for ClusterFuture ... done
[11:42:01.901] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.901] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.901] signalConditionsASAP(MultisessionFuture, pos=17) ... done
[11:42:01.901]  length: 73 (resolved future 17)
[11:42:01.901] Future #18
[11:42:01.902] result() for ClusterFuture ...
[11:42:01.902] - result already collected: FutureResult
[11:42:01.902] result() for ClusterFuture ... done
[11:42:01.902] result() for ClusterFuture ...
[11:42:01.902] - result already collected: FutureResult
[11:42:01.902] result() for ClusterFuture ... done
[11:42:01.902] signalConditionsASAP(MultisessionFuture, pos=18) ...
[11:42:01.902] - nx: 90
[11:42:01.902] - relay: TRUE
[11:42:01.902] - stdout: TRUE
[11:42:01.902] - signal: TRUE
[11:42:01.902] - resignal: FALSE
[11:42:01.902] - force: TRUE
[11:42:01.902] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.902] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.902]  - until=18
[11:42:01.902]  - relaying element #18
[11:42:01.902] result() for ClusterFuture ...
[11:42:01.902] - result already collected: FutureResult
[11:42:01.903] result() for ClusterFuture ... done
[11:42:01.903] result() for ClusterFuture ...
[11:42:01.903] - result already collected: FutureResult
[11:42:01.903] result() for ClusterFuture ... done
[11:42:01.903] result() for ClusterFuture ...
[11:42:01.903] - result already collected: FutureResult
[11:42:01.903] result() for ClusterFuture ... done
[11:42:01.903] result() for ClusterFuture ...
[11:42:01.903] - result already collected: FutureResult
[11:42:01.903] result() for ClusterFuture ... done
[11:42:01.903] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.903] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.903] signalConditionsASAP(MultisessionFuture, pos=18) ... done
[11:42:01.903]  length: 72 (resolved future 18)
[11:42:01.903] Future #19
[11:42:01.903] result() for ClusterFuture ...
[11:42:01.904] - result already collected: FutureResult
[11:42:01.904] result() for ClusterFuture ... done
[11:42:01.904] result() for ClusterFuture ...
[11:42:01.904] - result already collected: FutureResult
[11:42:01.904] result() for ClusterFuture ... done
[11:42:01.904] signalConditionsASAP(MultisessionFuture, pos=19) ...
[11:42:01.904] - nx: 90
[11:42:01.904] - relay: TRUE
[11:42:01.904] - stdout: TRUE
[11:42:01.904] - signal: TRUE
[11:42:01.904] - resignal: FALSE
[11:42:01.904] - force: TRUE
[11:42:01.904] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.904] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.904]  - until=19
[11:42:01.904]  - relaying element #19
[11:42:01.904] result() for ClusterFuture ...
[11:42:01.904] - result already collected: FutureResult
[11:42:01.904] result() for ClusterFuture ... done
[11:42:01.905] result() for ClusterFuture ...
[11:42:01.905] - result already collected: FutureResult
[11:42:01.905] result() for ClusterFuture ... done
[11:42:01.905] result() for ClusterFuture ...
[11:42:01.905] - result already collected: FutureResult
[11:42:01.905] result() for ClusterFuture ... done
[11:42:01.905] result() for ClusterFuture ...
[11:42:01.905] - result already collected: FutureResult
[11:42:01.905] result() for ClusterFuture ... done
[11:42:01.905] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.905] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.905] signalConditionsASAP(MultisessionFuture, pos=19) ... done
[11:42:01.905]  length: 71 (resolved future 19)
[11:42:01.905] Future #20
[11:42:01.905] result() for ClusterFuture ...
[11:42:01.905] - result already collected: FutureResult
[11:42:01.906] result() for ClusterFuture ... done
[11:42:01.906] result() for ClusterFuture ...
[11:42:01.906] - result already collected: FutureResult
[11:42:01.906] result() for ClusterFuture ... done
[11:42:01.906] signalConditionsASAP(MultisessionFuture, pos=20) ...
[11:42:01.906] - nx: 90
[11:42:01.906] - relay: TRUE
[11:42:01.906] - stdout: TRUE
[11:42:01.906] - signal: TRUE
[11:42:01.906] - resignal: FALSE
[11:42:01.906] - force: TRUE
[11:42:01.906] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.906] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.906]  - until=20
[11:42:01.906]  - relaying element #20
[11:42:01.906] result() for ClusterFuture ...
[11:42:01.906] - result already collected: FutureResult
[11:42:01.906] result() for ClusterFuture ... done
[11:42:01.906] result() for ClusterFuture ...
[11:42:01.906] - result already collected: FutureResult
[11:42:01.906] result() for ClusterFuture ... done
[11:42:01.907] result() for ClusterFuture ...
[11:42:01.907] - result already collected: FutureResult
[11:42:01.907] result() for ClusterFuture ... done
[11:42:01.907] result() for ClusterFuture ...
[11:42:01.907] - result already collected: FutureResult
[11:42:01.907] result() for ClusterFuture ... done
[11:42:01.907] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.907] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.907] signalConditionsASAP(MultisessionFuture, pos=20) ... done
[11:42:01.907]  length: 70 (resolved future 20)
[11:42:01.907] Future #21
[11:42:01.907] result() for ClusterFuture ...
[11:42:01.907] - result already collected: FutureResult
[11:42:01.907] result() for ClusterFuture ... done
[11:42:01.907] result() for ClusterFuture ...
[11:42:01.907] - result already collected: FutureResult
[11:42:01.907] result() for ClusterFuture ... done
[11:42:01.907] signalConditionsASAP(MultisessionFuture, pos=21) ...
[11:42:01.907] - nx: 90
[11:42:01.907] - relay: TRUE
[11:42:01.908] - stdout: TRUE
[11:42:01.908] - signal: TRUE
[11:42:01.908] - resignal: FALSE
[11:42:01.908] - force: TRUE
[11:42:01.908] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.908] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.908]  - until=21
[11:42:01.908]  - relaying element #21
[11:42:01.908] result() for ClusterFuture ...
[11:42:01.908] - result already collected: FutureResult
[11:42:01.908] result() for ClusterFuture ... done
[11:42:01.908] result() for ClusterFuture ...
[11:42:01.908] - result already collected: FutureResult
[11:42:01.908] result() for ClusterFuture ... done
[11:42:01.908] result() for ClusterFuture ...
[11:42:01.908] - result already collected: FutureResult
[11:42:01.908] result() for ClusterFuture ... done
[11:42:01.908] result() for ClusterFuture ...
[11:42:01.908] - result already collected: FutureResult
[11:42:01.908] result() for ClusterFuture ... done
[11:42:01.908] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.909] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.909] signalConditionsASAP(MultisessionFuture, pos=21) ... done
[11:42:01.909]  length: 69 (resolved future 21)
[11:42:01.909] Future #22
[11:42:01.909] result() for ClusterFuture ...
[11:42:01.909] - result already collected: FutureResult
[11:42:01.909] result() for ClusterFuture ... done
[11:42:01.909] result() for ClusterFuture ...
[11:42:01.909] - result already collected: FutureResult
[11:42:01.909] result() for ClusterFuture ... done
[11:42:01.909] signalConditionsASAP(MultisessionFuture, pos=22) ...
[11:42:01.909] - nx: 90
[11:42:01.909] - relay: TRUE
[11:42:01.909] - stdout: TRUE
[11:42:01.909] - signal: TRUE
[11:42:01.909] - resignal: FALSE
[11:42:01.909] - force: TRUE
[11:42:01.909] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.909] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.910]  - until=22
[11:42:01.910]  - relaying element #22
[11:42:01.910] result() for ClusterFuture ...
[11:42:01.910] - result already collected: FutureResult
[11:42:01.910] result() for ClusterFuture ... done
[11:42:01.910] result() for ClusterFuture ...
[11:42:01.910] - result already collected: FutureResult
[11:42:01.910] result() for ClusterFuture ... done
[11:42:01.910] result() for ClusterFuture ...
[11:42:01.910] - result already collected: FutureResult
[11:42:01.910] result() for ClusterFuture ... done
[11:42:01.910] result() for ClusterFuture ...
[11:42:01.910] - result already collected: FutureResult
[11:42:01.910] result() for ClusterFuture ... done
[11:42:01.910] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.910] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.910] signalConditionsASAP(MultisessionFuture, pos=22) ... done
[11:42:01.911]  length: 68 (resolved future 22)
[11:42:01.911] Future #23
[11:42:01.911] result() for ClusterFuture ...
[11:42:01.911] - result already collected: FutureResult
[11:42:01.911] result() for ClusterFuture ... done
[11:42:01.911] result() for ClusterFuture ...
[11:42:01.911] - result already collected: FutureResult
[11:42:01.911] result() for ClusterFuture ... done
[11:42:01.911] signalConditionsASAP(MultisessionFuture, pos=23) ...
[11:42:01.911] - nx: 90
[11:42:01.911] - relay: TRUE
[11:42:01.911] - stdout: TRUE
[11:42:01.911] - signal: TRUE
[11:42:01.911] - resignal: FALSE
[11:42:01.911] - force: TRUE
[11:42:01.911] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.911] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.911]  - until=23
[11:42:01.911]  - relaying element #23
[11:42:01.912] result() for ClusterFuture ...
[11:42:01.912] - result already collected: FutureResult
[11:42:01.912] result() for ClusterFuture ... done
[11:42:01.912] result() for ClusterFuture ...
[11:42:01.912] - result already collected: FutureResult
[11:42:01.912] result() for ClusterFuture ... done
[11:42:01.912] result() for ClusterFuture ...
[11:42:01.912] - result already collected: FutureResult
[11:42:01.912] result() for ClusterFuture ... done
[11:42:01.912] result() for ClusterFuture ...
[11:42:01.912] - result already collected: FutureResult
[11:42:01.912] result() for ClusterFuture ... done
[11:42:01.912] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.912] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.912] signalConditionsASAP(MultisessionFuture, pos=23) ... done
[11:42:01.912]  length: 67 (resolved future 23)
[11:42:01.912] Future #24
[11:42:01.912] result() for ClusterFuture ...
[11:42:01.913] - result already collected: FutureResult
[11:42:01.913] result() for ClusterFuture ... done
[11:42:01.913] result() for ClusterFuture ...
[11:42:01.913] - result already collected: FutureResult
[11:42:01.913] result() for ClusterFuture ... done
[11:42:01.913] signalConditionsASAP(MultisessionFuture, pos=24) ...
[11:42:01.913] - nx: 90
[11:42:01.913] - relay: TRUE
[11:42:01.913] - stdout: TRUE
[11:42:01.913] - signal: TRUE
[11:42:01.913] - resignal: FALSE
[11:42:01.913] - force: TRUE
[11:42:01.913] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.913] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.913]  - until=24
[11:42:01.913]  - relaying element #24
[11:42:01.913] result() for ClusterFuture ...
[11:42:01.914] - result already collected: FutureResult
[11:42:01.914] result() for ClusterFuture ... done
[11:42:01.914] result() for ClusterFuture ...
[11:42:01.914] - result already collected: FutureResult
[11:42:01.914] result() for ClusterFuture ... done
[11:42:01.914] result() for ClusterFuture ...
[11:42:01.914] - result already collected: FutureResult
[11:42:01.914] result() for ClusterFuture ... done
[11:42:01.914] result() for ClusterFuture ...
[11:42:01.914] - result already collected: FutureResult
[11:42:01.914] result() for ClusterFuture ... done
[11:42:01.914] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.914] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.914] signalConditionsASAP(MultisessionFuture, pos=24) ... done
[11:42:01.914]  length: 66 (resolved future 24)
[11:42:01.914] Future #25
[11:42:01.914] result() for ClusterFuture ...
[11:42:01.914] - result already collected: FutureResult
[11:42:01.914] result() for ClusterFuture ... done
[11:42:01.915] result() for ClusterFuture ...
[11:42:01.915] - result already collected: FutureResult
[11:42:01.915] result() for ClusterFuture ... done
[11:42:01.915] signalConditionsASAP(MultisessionFuture, pos=25) ...
[11:42:01.915] - nx: 90
[11:42:01.915] - relay: TRUE
[11:42:01.915] - stdout: TRUE
[11:42:01.915] - signal: TRUE
[11:42:01.915] - resignal: FALSE
[11:42:01.915] - force: TRUE
[11:42:01.915] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.915] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.915]  - until=25
[11:42:01.915]  - relaying element #25
[11:42:01.915] result() for ClusterFuture ...
[11:42:01.915] - result already collected: FutureResult
[11:42:01.915] result() for ClusterFuture ... done
[11:42:01.915] result() for ClusterFuture ...
[11:42:01.915] - result already collected: FutureResult
[11:42:01.916] result() for ClusterFuture ... done
[11:42:01.916] result() for ClusterFuture ...
[11:42:01.916] - result already collected: FutureResult
[11:42:01.916] result() for ClusterFuture ... done
[11:42:01.916] result() for ClusterFuture ...
[11:42:01.916] - result already collected: FutureResult
[11:42:01.916] result() for ClusterFuture ... done
[11:42:01.916] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.916] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.916] signalConditionsASAP(MultisessionFuture, pos=25) ... done
[11:42:01.916]  length: 65 (resolved future 25)
[11:42:01.916] Future #26
[11:42:01.916] result() for ClusterFuture ...
[11:42:01.916] - result already collected: FutureResult
[11:42:01.916] result() for ClusterFuture ... done
[11:42:01.916] result() for ClusterFuture ...
[11:42:01.916] - result already collected: FutureResult
[11:42:01.916] result() for ClusterFuture ... done
[11:42:01.917] signalConditionsASAP(MultisessionFuture, pos=26) ...
[11:42:01.917] - nx: 90
[11:42:01.917] - relay: TRUE
[11:42:01.917] - stdout: TRUE
[11:42:01.917] - signal: TRUE
[11:42:01.917] - resignal: FALSE
[11:42:01.917] - force: TRUE
[11:42:01.917] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.917] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.917]  - until=26
[11:42:01.917]  - relaying element #26
[11:42:01.917] result() for ClusterFuture ...
[11:42:01.917] - result already collected: FutureResult
[11:42:01.917] result() for ClusterFuture ... done
[11:42:01.917] result() for ClusterFuture ...
[11:42:01.917] - result already collected: FutureResult
[11:42:01.917] result() for ClusterFuture ... done
[11:42:01.917] result() for ClusterFuture ...
[11:42:01.917] - result already collected: FutureResult
[11:42:01.917] result() for ClusterFuture ... done
[11:42:01.918] result() for ClusterFuture ...
[11:42:01.918] - result already collected: FutureResult
[11:42:01.918] result() for ClusterFuture ... done
[11:42:01.918] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.918] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.918] signalConditionsASAP(MultisessionFuture, pos=26) ... done
[11:42:01.918]  length: 64 (resolved future 26)
[11:42:01.918] Future #27
[11:42:01.918] result() for ClusterFuture ...
[11:42:01.918] - result already collected: FutureResult
[11:42:01.918] result() for ClusterFuture ... done
[11:42:01.918] result() for ClusterFuture ...
[11:42:01.918] - result already collected: FutureResult
[11:42:01.918] result() for ClusterFuture ... done
[11:42:01.918] signalConditionsASAP(MultisessionFuture, pos=27) ...
[11:42:01.918] - nx: 90
[11:42:01.918] - relay: TRUE
[11:42:01.918] - stdout: TRUE
[11:42:01.918] - signal: TRUE
[11:42:01.918] - resignal: FALSE
[11:42:01.919] - force: TRUE
[11:42:01.919] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.919] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.919]  - until=27
[11:42:01.919]  - relaying element #27
[11:42:01.919] result() for ClusterFuture ...
[11:42:01.919] - result already collected: FutureResult
[11:42:01.919] result() for ClusterFuture ... done
[11:42:01.919] result() for ClusterFuture ...
[11:42:01.919] - result already collected: FutureResult
[11:42:01.919] result() for ClusterFuture ... done
[11:42:01.919] result() for ClusterFuture ...
[11:42:01.919] - result already collected: FutureResult
[11:42:01.920] result() for ClusterFuture ... done
[11:42:01.920] result() for ClusterFuture ...
[11:42:01.920] - result already collected: FutureResult
[11:42:01.920] result() for ClusterFuture ... done
[11:42:01.920] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.920] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.920] signalConditionsASAP(MultisessionFuture, pos=27) ... done
[11:42:01.920]  length: 63 (resolved future 27)
[11:42:01.920] Future #28
[11:42:01.920] result() for ClusterFuture ...
[11:42:01.920] - result already collected: FutureResult
[11:42:01.920] result() for ClusterFuture ... done
[11:42:01.920] result() for ClusterFuture ...
[11:42:01.920] - result already collected: FutureResult
[11:42:01.920] result() for ClusterFuture ... done
[11:42:01.920] signalConditionsASAP(MultisessionFuture, pos=28) ...
[11:42:01.920] - nx: 90
[11:42:01.921] - relay: TRUE
[11:42:01.921] - stdout: TRUE
[11:42:01.921] - signal: TRUE
[11:42:01.921] - resignal: FALSE
[11:42:01.921] - force: TRUE
[11:42:01.921] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.921] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.921]  - until=28
[11:42:01.921]  - relaying element #28
[11:42:01.921] result() for ClusterFuture ...
[11:42:01.921] - result already collected: FutureResult
[11:42:01.921] result() for ClusterFuture ... done
[11:42:01.921] result() for ClusterFuture ...
[11:42:01.921] - result already collected: FutureResult
[11:42:01.921] result() for ClusterFuture ... done
[11:42:01.921] result() for ClusterFuture ...
[11:42:01.921] - result already collected: FutureResult
[11:42:01.921] result() for ClusterFuture ... done
[11:42:01.921] result() for ClusterFuture ...
[11:42:01.922] - result already collected: FutureResult
[11:42:01.922] result() for ClusterFuture ... done
[11:42:01.922] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.922] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.922] signalConditionsASAP(MultisessionFuture, pos=28) ... done
[11:42:01.922]  length: 62 (resolved future 28)
[11:42:01.922] Future #29
[11:42:01.922] result() for ClusterFuture ...
[11:42:01.922] - result already collected: FutureResult
[11:42:01.922] result() for ClusterFuture ... done
[11:42:01.922] result() for ClusterFuture ...
[11:42:01.922] - result already collected: FutureResult
[11:42:01.922] result() for ClusterFuture ... done
[11:42:01.922] signalConditionsASAP(MultisessionFuture, pos=29) ...
[11:42:01.922] - nx: 90
[11:42:01.922] - relay: TRUE
[11:42:01.922] - stdout: TRUE
[11:42:01.923] - signal: TRUE
[11:42:01.923] - resignal: FALSE
[11:42:01.923] - force: TRUE
[11:42:01.923] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.923] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.923]  - until=29
[11:42:01.923]  - relaying element #29
[11:42:01.923] result() for ClusterFuture ...
[11:42:01.923] - result already collected: FutureResult
[11:42:01.923] result() for ClusterFuture ... done
[11:42:01.923] result() for ClusterFuture ...
[11:42:01.923] - result already collected: FutureResult
[11:42:01.923] result() for ClusterFuture ... done
[11:42:01.923] result() for ClusterFuture ...
[11:42:01.923] - result already collected: FutureResult
[11:42:01.923] result() for ClusterFuture ... done
[11:42:01.924] result() for ClusterFuture ...
[11:42:01.924] - result already collected: FutureResult
[11:42:01.924] result() for ClusterFuture ... done
[11:42:01.924] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.924] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.924] signalConditionsASAP(MultisessionFuture, pos=29) ... done
[11:42:01.924]  length: 61 (resolved future 29)
[11:42:01.924] Future #30
[11:42:01.924] result() for ClusterFuture ...
[11:42:01.924] - result already collected: FutureResult
[11:42:01.924] result() for ClusterFuture ... done
[11:42:01.924] result() for ClusterFuture ...
[11:42:01.924] - result already collected: FutureResult
[11:42:01.924] result() for ClusterFuture ... done
[11:42:01.924] signalConditionsASAP(MultisessionFuture, pos=30) ...
[11:42:01.924] - nx: 90
[11:42:01.924] - relay: TRUE
[11:42:01.924] - stdout: TRUE
[11:42:01.925] - signal: TRUE
[11:42:01.925] - resignal: FALSE
[11:42:01.925] - force: TRUE
[11:42:01.925] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.925] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.925]  - until=30
[11:42:01.925]  - relaying element #30
[11:42:01.925] result() for ClusterFuture ...
[11:42:01.925] - result already collected: FutureResult
[11:42:01.925] result() for ClusterFuture ... done
[11:42:01.925] result() for ClusterFuture ...
[11:42:01.925] - result already collected: FutureResult
[11:42:01.925] result() for ClusterFuture ... done
[11:42:01.929] result() for ClusterFuture ...
[11:42:01.930] - result already collected: FutureResult
[11:42:01.930] result() for ClusterFuture ... done
[11:42:01.930] result() for ClusterFuture ...
[11:42:01.930] - result already collected: FutureResult
[11:42:01.930] result() for ClusterFuture ... done
[11:42:01.930] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.930] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.931] signalConditionsASAP(MultisessionFuture, pos=30) ... done
[11:42:01.931]  length: 60 (resolved future 30)
[11:42:01.931] Future #31
[11:42:01.931] result() for ClusterFuture ...
[11:42:01.931] - result already collected: FutureResult
[11:42:01.931] result() for ClusterFuture ... done
[11:42:01.931] result() for ClusterFuture ...
[11:42:01.931] - result already collected: FutureResult
[11:42:01.932] result() for ClusterFuture ... done
[11:42:01.932] signalConditionsASAP(MultisessionFuture, pos=31) ...
[11:42:01.932] - nx: 90
[11:42:01.932] - relay: TRUE
[11:42:01.932] - stdout: TRUE
[11:42:01.932] - signal: TRUE
[11:42:01.932] - resignal: FALSE
[11:42:01.932] - force: TRUE
[11:42:01.933] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.933] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.933]  - until=31
[11:42:01.933]  - relaying element #31
[11:42:01.933] result() for ClusterFuture ...
[11:42:01.933] - result already collected: FutureResult
[11:42:01.933] result() for ClusterFuture ... done
[11:42:01.934] result() for ClusterFuture ...
[11:42:01.934] - result already collected: FutureResult
[11:42:01.934] result() for ClusterFuture ... done
[11:42:01.934] result() for ClusterFuture ...
[11:42:01.934] - result already collected: FutureResult
[11:42:01.934] result() for ClusterFuture ... done
[11:42:01.934] result() for ClusterFuture ...
[11:42:01.934] - result already collected: FutureResult
[11:42:01.934] result() for ClusterFuture ... done
[11:42:01.934] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.934] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.935] signalConditionsASAP(MultisessionFuture, pos=31) ... done
[11:42:01.935]  length: 59 (resolved future 31)
[11:42:01.935] Future #32
[11:42:01.935] result() for ClusterFuture ...
[11:42:01.935] - result already collected: FutureResult
[11:42:01.935] result() for ClusterFuture ... done
[11:42:01.935] result() for ClusterFuture ...
[11:42:01.935] - result already collected: FutureResult
[11:42:01.935] result() for ClusterFuture ... done
[11:42:01.935] signalConditionsASAP(MultisessionFuture, pos=32) ...
[11:42:01.935] - nx: 90
[11:42:01.935] - relay: TRUE
[11:42:01.936] - stdout: TRUE
[11:42:01.936] - signal: TRUE
[11:42:01.936] - resignal: FALSE
[11:42:01.936] - force: TRUE
[11:42:01.936] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.936] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.936]  - until=32
[11:42:01.936]  - relaying element #32
[11:42:01.936] result() for ClusterFuture ...
[11:42:01.936] - result already collected: FutureResult
[11:42:01.936] result() for ClusterFuture ... done
[11:42:01.936] result() for ClusterFuture ...
[11:42:01.936] - result already collected: FutureResult
[11:42:01.936] result() for ClusterFuture ... done
[11:42:01.936] result() for ClusterFuture ...
[11:42:01.936] - result already collected: FutureResult
[11:42:01.937] result() for ClusterFuture ... done
[11:42:01.937] result() for ClusterFuture ...
[11:42:01.937] - result already collected: FutureResult
[11:42:01.937] result() for ClusterFuture ... done
[11:42:01.937] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.937] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.937] signalConditionsASAP(MultisessionFuture, pos=32) ... done
[11:42:01.937]  length: 58 (resolved future 32)
[11:42:01.937] Future #33
[11:42:01.937] result() for ClusterFuture ...
[11:42:01.937] - result already collected: FutureResult
[11:42:01.937] result() for ClusterFuture ... done
[11:42:01.937] result() for ClusterFuture ...
[11:42:01.937] - result already collected: FutureResult
[11:42:01.937] result() for ClusterFuture ... done
[11:42:01.937] signalConditionsASAP(MultisessionFuture, pos=33) ...
[11:42:01.937] - nx: 90
[11:42:01.938] - relay: TRUE
[11:42:01.938] - stdout: TRUE
[11:42:01.938] - signal: TRUE
[11:42:01.938] - resignal: FALSE
[11:42:01.938] - force: TRUE
[11:42:01.938] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.938] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.938]  - until=33
[11:42:01.938]  - relaying element #33
[11:42:01.938] result() for ClusterFuture ...
[11:42:01.938] - result already collected: FutureResult
[11:42:01.938] result() for ClusterFuture ... done
[11:42:01.938] result() for ClusterFuture ...
[11:42:01.938] - result already collected: FutureResult
[11:42:01.938] result() for ClusterFuture ... done
[11:42:01.938] result() for ClusterFuture ...
[11:42:01.938] - result already collected: FutureResult
[11:42:01.938] result() for ClusterFuture ... done
[11:42:01.939] result() for ClusterFuture ...
[11:42:01.939] - result already collected: FutureResult
[11:42:01.939] result() for ClusterFuture ... done
[11:42:01.939] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.939] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.939] signalConditionsASAP(MultisessionFuture, pos=33) ... done
[11:42:01.939]  length: 57 (resolved future 33)
[11:42:01.939] Future #34
[11:42:01.939] result() for ClusterFuture ...
[11:42:01.939] - result already collected: FutureResult
[11:42:01.939] result() for ClusterFuture ... done
[11:42:01.939] result() for ClusterFuture ...
[11:42:01.939] - result already collected: FutureResult
[11:42:01.939] result() for ClusterFuture ... done
[11:42:01.939] signalConditionsASAP(MultisessionFuture, pos=34) ...
[11:42:01.939] - nx: 90
[11:42:01.939] - relay: TRUE
[11:42:01.939] - stdout: TRUE
[11:42:01.939] - signal: TRUE
[11:42:01.940] - resignal: FALSE
[11:42:01.940] - force: TRUE
[11:42:01.940] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.940] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.940]  - until=34
[11:42:01.940]  - relaying element #34
[11:42:01.940] result() for ClusterFuture ...
[11:42:01.940] - result already collected: FutureResult
[11:42:01.940] result() for ClusterFuture ... done
[11:42:01.940] result() for ClusterFuture ...
[11:42:01.940] - result already collected: FutureResult
[11:42:01.940] result() for ClusterFuture ... done
[11:42:01.940] result() for ClusterFuture ...
[11:42:01.940] - result already collected: FutureResult
[11:42:01.940] result() for ClusterFuture ... done
[11:42:01.940] result() for ClusterFuture ...
[11:42:01.940] - result already collected: FutureResult
[11:42:01.940] result() for ClusterFuture ... done
[11:42:01.941] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.941] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.941] signalConditionsASAP(MultisessionFuture, pos=34) ... done
[11:42:01.941]  length: 56 (resolved future 34)
[11:42:01.941] Future #35
[11:42:01.941] result() for ClusterFuture ...
[11:42:01.941] - result already collected: FutureResult
[11:42:01.941] result() for ClusterFuture ... done
[11:42:01.941] result() for ClusterFuture ...
[11:42:01.941] - result already collected: FutureResult
[11:42:01.941] result() for ClusterFuture ... done
[11:42:01.941] signalConditionsASAP(MultisessionFuture, pos=35) ...
[11:42:01.941] - nx: 90
[11:42:01.941] - relay: TRUE
[11:42:01.942] - stdout: TRUE
[11:42:01.942] - signal: TRUE
[11:42:01.942] - resignal: FALSE
[11:42:01.942] - force: TRUE
[11:42:01.942] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.942] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.942]  - until=35
[11:42:01.942]  - relaying element #35
[11:42:01.942] result() for ClusterFuture ...
[11:42:01.942] - result already collected: FutureResult
[11:42:01.942] result() for ClusterFuture ... done
[11:42:01.942] result() for ClusterFuture ...
[11:42:01.942] - result already collected: FutureResult
[11:42:01.942] result() for ClusterFuture ... done
[11:42:01.942] result() for ClusterFuture ...
[11:42:01.942] - result already collected: FutureResult
[11:42:01.942] result() for ClusterFuture ... done
[11:42:01.943] result() for ClusterFuture ...
[11:42:01.943] - result already collected: FutureResult
[11:42:01.943] result() for ClusterFuture ... done
[11:42:01.943] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.943] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.943] signalConditionsASAP(MultisessionFuture, pos=35) ... done
[11:42:01.943]  length: 55 (resolved future 35)
[11:42:01.943] Future #36
[11:42:01.943] result() for ClusterFuture ...
[11:42:01.943] - result already collected: FutureResult
[11:42:01.943] result() for ClusterFuture ... done
[11:42:01.943] result() for ClusterFuture ...
[11:42:01.943] - result already collected: FutureResult
[11:42:01.943] result() for ClusterFuture ... done
[11:42:01.943] signalConditionsASAP(MultisessionFuture, pos=36) ...
[11:42:01.943] - nx: 90
[11:42:01.943] - relay: TRUE
[11:42:01.943] - stdout: TRUE
[11:42:01.943] - signal: TRUE
[11:42:01.944] - resignal: FALSE
[11:42:01.944] - force: TRUE
[11:42:01.944] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.944] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.944]  - until=36
[11:42:01.944]  - relaying element #36
[11:42:01.944] result() for ClusterFuture ...
[11:42:01.944] - result already collected: FutureResult
[11:42:01.944] result() for ClusterFuture ... done
[11:42:01.944] result() for ClusterFuture ...
[11:42:01.944] - result already collected: FutureResult
[11:42:01.944] result() for ClusterFuture ... done
[11:42:01.944] result() for ClusterFuture ...
[11:42:01.944] - result already collected: FutureResult
[11:42:01.944] result() for ClusterFuture ... done
[11:42:01.944] result() for ClusterFuture ...
[11:42:01.944] - result already collected: FutureResult
[11:42:01.944] result() for ClusterFuture ... done
[11:42:01.944] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.944] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.945] signalConditionsASAP(MultisessionFuture, pos=36) ... done
[11:42:01.945]  length: 54 (resolved future 36)
[11:42:01.945] Future #37
[11:42:01.945] result() for ClusterFuture ...
[11:42:01.945] - result already collected: FutureResult
[11:42:01.945] result() for ClusterFuture ... done
[11:42:01.945] result() for ClusterFuture ...
[11:42:01.945] - result already collected: FutureResult
[11:42:01.945] result() for ClusterFuture ... done
[11:42:01.945] signalConditionsASAP(MultisessionFuture, pos=37) ...
[11:42:01.945] - nx: 90
[11:42:01.945] - relay: TRUE
[11:42:01.945] - stdout: TRUE
[11:42:01.945] - signal: TRUE
[11:42:01.945] - resignal: FALSE
[11:42:01.945] - force: TRUE
[11:42:01.945] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.945] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.946]  - until=37
[11:42:01.946]  - relaying element #37
[11:42:01.946] result() for ClusterFuture ...
[11:42:01.946] - result already collected: FutureResult
[11:42:01.946] result() for ClusterFuture ... done
[11:42:01.946] result() for ClusterFuture ...
[11:42:01.946] - result already collected: FutureResult
[11:42:01.946] result() for ClusterFuture ... done
[11:42:01.946] result() for ClusterFuture ...
[11:42:01.946] - result already collected: FutureResult
[11:42:01.946] result() for ClusterFuture ... done
[11:42:01.946] result() for ClusterFuture ...
[11:42:01.946] - result already collected: FutureResult
[11:42:01.946] result() for ClusterFuture ... done
[11:42:01.946] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.946] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.946] signalConditionsASAP(MultisessionFuture, pos=37) ... done
[11:42:01.946]  length: 53 (resolved future 37)
[11:42:01.946] Future #38
[11:42:01.947] result() for ClusterFuture ...
[11:42:01.947] - result already collected: FutureResult
[11:42:01.947] result() for ClusterFuture ... done
[11:42:01.947] result() for ClusterFuture ...
[11:42:01.947] - result already collected: FutureResult
[11:42:01.947] result() for ClusterFuture ... done
[11:42:01.947] signalConditionsASAP(MultisessionFuture, pos=38) ...
[11:42:01.947] - nx: 90
[11:42:01.947] - relay: TRUE
[11:42:01.947] - stdout: TRUE
[11:42:01.947] - signal: TRUE
[11:42:01.947] - resignal: FALSE
[11:42:01.947] - force: TRUE
[11:42:01.947] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.947] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.947]  - until=38
[11:42:01.947]  - relaying element #38
[11:42:01.947] result() for ClusterFuture ...
[11:42:01.947] - result already collected: FutureResult
[11:42:01.947] result() for ClusterFuture ... done
[11:42:01.948] result() for ClusterFuture ...
[11:42:01.948] - result already collected: FutureResult
[11:42:01.948] result() for ClusterFuture ... done
[11:42:01.948] result() for ClusterFuture ...
[11:42:01.948] - result already collected: FutureResult
[11:42:01.948] result() for ClusterFuture ... done
[11:42:01.948] result() for ClusterFuture ...
[11:42:01.948] - result already collected: FutureResult
[11:42:01.948] result() for ClusterFuture ... done
[11:42:01.948] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.948] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.948] signalConditionsASAP(MultisessionFuture, pos=38) ... done
[11:42:01.948]  length: 52 (resolved future 38)
[11:42:01.948] Future #39
[11:42:01.948] result() for ClusterFuture ...
[11:42:01.949] - result already collected: FutureResult
[11:42:01.949] result() for ClusterFuture ... done
[11:42:01.949] result() for ClusterFuture ...
[11:42:01.949] - result already collected: FutureResult
[11:42:01.949] result() for ClusterFuture ... done
[11:42:01.949] signalConditionsASAP(MultisessionFuture, pos=39) ...
[11:42:01.949] - nx: 90
[11:42:01.949] - relay: TRUE
[11:42:01.949] - stdout: TRUE
[11:42:01.949] - signal: TRUE
[11:42:01.949] - resignal: FALSE
[11:42:01.949] - force: TRUE
[11:42:01.949] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.949] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.949]  - until=39
[11:42:01.950]  - relaying element #39
[11:42:01.950] result() for ClusterFuture ...
[11:42:01.950] - result already collected: FutureResult
[11:42:01.950] result() for ClusterFuture ... done
[11:42:01.950] result() for ClusterFuture ...
[11:42:01.950] - result already collected: FutureResult
[11:42:01.950] result() for ClusterFuture ... done
[11:42:01.950] result() for ClusterFuture ...
[11:42:01.950] - result already collected: FutureResult
[11:42:01.950] result() for ClusterFuture ... done
[11:42:01.950] result() for ClusterFuture ...
[11:42:01.950] - result already collected: FutureResult
[11:42:01.950] result() for ClusterFuture ... done
[11:42:01.950] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.950] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.950] signalConditionsASAP(MultisessionFuture, pos=39) ... done
[11:42:01.950]  length: 51 (resolved future 39)
[11:42:01.950] Future #40
[11:42:01.951] result() for ClusterFuture ...
[11:42:01.951] - result already collected: FutureResult
[11:42:01.951] result() for ClusterFuture ... done
[11:42:01.951] result() for ClusterFuture ...
[11:42:01.951] - result already collected: FutureResult
[11:42:01.951] result() for ClusterFuture ... done
[11:42:01.951] signalConditionsASAP(MultisessionFuture, pos=40) ...
[11:42:01.951] - nx: 90
[11:42:01.951] - relay: TRUE
[11:42:01.951] - stdout: TRUE
[11:42:01.951] - signal: TRUE
[11:42:01.951] - resignal: FALSE
[11:42:01.951] - force: TRUE
[11:42:01.951] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.951] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.951]  - until=40
[11:42:01.951]  - relaying element #40
[11:42:01.951] result() for ClusterFuture ...
[11:42:01.951] - result already collected: FutureResult
[11:42:01.951] result() for ClusterFuture ... done
[11:42:01.951] result() for ClusterFuture ...
[11:42:01.952] - result already collected: FutureResult
[11:42:01.952] result() for ClusterFuture ... done
[11:42:01.952] result() for ClusterFuture ...
[11:42:01.952] - result already collected: FutureResult
[11:42:01.952] result() for ClusterFuture ... done
[11:42:01.952] result() for ClusterFuture ...
[11:42:01.952] - result already collected: FutureResult
[11:42:01.952] result() for ClusterFuture ... done
[11:42:01.952] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.952] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.952] signalConditionsASAP(MultisessionFuture, pos=40) ... done
[11:42:01.952]  length: 50 (resolved future 40)
[11:42:01.952] Future #41
[11:42:01.952] result() for ClusterFuture ...
[11:42:01.952] - result already collected: FutureResult
[11:42:01.952] result() for ClusterFuture ... done
[11:42:01.952] result() for ClusterFuture ...
[11:42:01.952] - result already collected: FutureResult
[11:42:01.952] result() for ClusterFuture ... done
[11:42:01.953] signalConditionsASAP(MultisessionFuture, pos=41) ...
[11:42:01.953] - nx: 90
[11:42:01.953] - relay: TRUE
[11:42:01.953] - stdout: TRUE
[11:42:01.953] - signal: TRUE
[11:42:01.953] - resignal: FALSE
[11:42:01.953] - force: TRUE
[11:42:01.953] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.953] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.953]  - until=41
[11:42:01.953]  - relaying element #41
[11:42:01.953] result() for ClusterFuture ...
[11:42:01.953] - result already collected: FutureResult
[11:42:01.953] result() for ClusterFuture ... done
[11:42:01.953] result() for ClusterFuture ...
[11:42:01.953] - result already collected: FutureResult
[11:42:01.953] result() for ClusterFuture ... done
[11:42:01.953] result() for ClusterFuture ...
[11:42:01.953] - result already collected: FutureResult
[11:42:01.953] result() for ClusterFuture ... done
[11:42:01.954] result() for ClusterFuture ...
[11:42:01.954] - result already collected: FutureResult
[11:42:01.954] result() for ClusterFuture ... done
[11:42:01.954] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.954] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.954] signalConditionsASAP(MultisessionFuture, pos=41) ... done
[11:42:01.954]  length: 49 (resolved future 41)
[11:42:01.954] Future #42
[11:42:01.954] result() for ClusterFuture ...
[11:42:01.954] - result already collected: FutureResult
[11:42:01.954] result() for ClusterFuture ... done
[11:42:01.954] result() for ClusterFuture ...
[11:42:01.954] - result already collected: FutureResult
[11:42:01.954] result() for ClusterFuture ... done
[11:42:01.954] signalConditionsASAP(MultisessionFuture, pos=42) ...
[11:42:01.954] - nx: 90
[11:42:01.954] - relay: TRUE
[11:42:01.954] - stdout: TRUE
[11:42:01.954] - signal: TRUE
[11:42:01.954] - resignal: FALSE
[11:42:01.955] - force: TRUE
[11:42:01.955] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.955] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.955]  - until=42
[11:42:01.955]  - relaying element #42
[11:42:01.955] result() for ClusterFuture ...
[11:42:01.955] - result already collected: FutureResult
[11:42:01.955] result() for ClusterFuture ... done
[11:42:01.955] result() for ClusterFuture ...
[11:42:01.955] - result already collected: FutureResult
[11:42:01.955] result() for ClusterFuture ... done
[11:42:01.955] result() for ClusterFuture ...
[11:42:01.955] - result already collected: FutureResult
[11:42:01.955] result() for ClusterFuture ... done
[11:42:01.955] result() for ClusterFuture ...
[11:42:01.955] - result already collected: FutureResult
[11:42:01.955] result() for ClusterFuture ... done
[11:42:01.955] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.955] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.956] signalConditionsASAP(MultisessionFuture, pos=42) ... done
[11:42:01.956]  length: 48 (resolved future 42)
[11:42:01.956] Future #43
[11:42:01.956] result() for ClusterFuture ...
[11:42:01.956] - result already collected: FutureResult
[11:42:01.956] result() for ClusterFuture ... done
[11:42:01.956] result() for ClusterFuture ...
[11:42:01.956] - result already collected: FutureResult
[11:42:01.956] result() for ClusterFuture ... done
[11:42:01.956] signalConditionsASAP(MultisessionFuture, pos=43) ...
[11:42:01.956] - nx: 90
[11:42:01.956] - relay: TRUE
[11:42:01.956] - stdout: TRUE
[11:42:01.956] - signal: TRUE
[11:42:01.956] - resignal: FALSE
[11:42:01.957] - force: TRUE
[11:42:01.957] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.957] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.957]  - until=43
[11:42:01.957]  - relaying element #43
[11:42:01.957] result() for ClusterFuture ...
[11:42:01.957] - result already collected: FutureResult
[11:42:01.957] result() for ClusterFuture ... done
[11:42:01.957] result() for ClusterFuture ...
[11:42:01.957] - result already collected: FutureResult
[11:42:01.957] result() for ClusterFuture ... done
[11:42:01.957] result() for ClusterFuture ...
[11:42:01.957] - result already collected: FutureResult
[11:42:01.957] result() for ClusterFuture ... done
[11:42:01.957] result() for ClusterFuture ...
[11:42:01.957] - result already collected: FutureResult
[11:42:01.957] result() for ClusterFuture ... done
[11:42:01.957] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.958] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.958] signalConditionsASAP(MultisessionFuture, pos=43) ... done
[11:42:01.958]  length: 47 (resolved future 43)
[11:42:01.958] Future #44
[11:42:01.958] result() for ClusterFuture ...
[11:42:01.958] - result already collected: FutureResult
[11:42:01.958] result() for ClusterFuture ... done
[11:42:01.958] result() for ClusterFuture ...
[11:42:01.958] - result already collected: FutureResult
[11:42:01.958] result() for ClusterFuture ... done
[11:42:01.958] signalConditionsASAP(MultisessionFuture, pos=44) ...
[11:42:01.958] - nx: 90
[11:42:01.958] - relay: TRUE
[11:42:01.958] - stdout: TRUE
[11:42:01.958] - signal: TRUE
[11:42:01.958] - resignal: FALSE
[11:42:01.958] - force: TRUE
[11:42:01.958] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.958] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.959]  - until=44
[11:42:01.959]  - relaying element #44
[11:42:01.959] result() for ClusterFuture ...
[11:42:01.959] - result already collected: FutureResult
[11:42:01.959] result() for ClusterFuture ... done
[11:42:01.959] result() for ClusterFuture ...
[11:42:01.959] - result already collected: FutureResult
[11:42:01.959] result() for ClusterFuture ... done
[11:42:01.959] result() for ClusterFuture ...
[11:42:01.959] - result already collected: FutureResult
[11:42:01.959] result() for ClusterFuture ... done
[11:42:01.959] result() for ClusterFuture ...
[11:42:01.959] - result already collected: FutureResult
[11:42:01.959] result() for ClusterFuture ... done
[11:42:01.959] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.959] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.959] signalConditionsASAP(MultisessionFuture, pos=44) ... done
[11:42:01.960]  length: 46 (resolved future 44)
[11:42:01.960] Future #45
[11:42:01.960] result() for ClusterFuture ...
[11:42:01.960] - result already collected: FutureResult
[11:42:01.960] result() for ClusterFuture ... done
[11:42:01.960] result() for ClusterFuture ...
[11:42:01.960] - result already collected: FutureResult
[11:42:01.960] result() for ClusterFuture ... done
[11:42:01.960] signalConditionsASAP(MultisessionFuture, pos=45) ...
[11:42:01.960] - nx: 90
[11:42:01.960] - relay: TRUE
[11:42:01.960] - stdout: TRUE
[11:42:01.960] - signal: TRUE
[11:42:01.960] - resignal: FALSE
[11:42:01.960] - force: TRUE
[11:42:01.960] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.960] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.960]  - until=45
[11:42:01.960]  - relaying element #45
[11:42:01.961] result() for ClusterFuture ...
[11:42:01.961] - result already collected: FutureResult
[11:42:01.961] result() for ClusterFuture ... done
[11:42:01.961] result() for ClusterFuture ...
[11:42:01.961] - result already collected: FutureResult
[11:42:01.961] result() for ClusterFuture ... done
[11:42:01.961] result() for ClusterFuture ...
[11:42:01.961] - result already collected: FutureResult
[11:42:01.961] result() for ClusterFuture ... done
[11:42:01.961] result() for ClusterFuture ...
[11:42:01.961] - result already collected: FutureResult
[11:42:01.961] result() for ClusterFuture ... done
[11:42:01.961] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.961] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.961] signalConditionsASAP(MultisessionFuture, pos=45) ... done
[11:42:01.961]  length: 45 (resolved future 45)
[11:42:01.962] Future #46
[11:42:01.962] result() for ClusterFuture ...
[11:42:01.962] - result already collected: FutureResult
[11:42:01.962] result() for ClusterFuture ... done
[11:42:01.962] result() for ClusterFuture ...
[11:42:01.962] - result already collected: FutureResult
[11:42:01.962] result() for ClusterFuture ... done
[11:42:01.962] signalConditionsASAP(MultisessionFuture, pos=46) ...
[11:42:01.962] - nx: 90
[11:42:01.962] - relay: TRUE
[11:42:01.962] - stdout: TRUE
[11:42:01.962] - signal: TRUE
[11:42:01.962] - resignal: FALSE
[11:42:01.962] - force: TRUE
[11:42:01.962] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.962] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.962]  - until=46
[11:42:01.962]  - relaying element #46
[11:42:01.962] result() for ClusterFuture ...
[11:42:01.962] - result already collected: FutureResult
[11:42:01.963] result() for ClusterFuture ... done
[11:42:01.963] result() for ClusterFuture ...
[11:42:01.963] - result already collected: FutureResult
[11:42:01.963] result() for ClusterFuture ... done
[11:42:01.963] result() for ClusterFuture ...
[11:42:01.963] - result already collected: FutureResult
[11:42:01.963] result() for ClusterFuture ... done
[11:42:01.963] result() for ClusterFuture ...
[11:42:01.963] - result already collected: FutureResult
[11:42:01.963] result() for ClusterFuture ... done
[11:42:01.963] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.963] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.963] signalConditionsASAP(MultisessionFuture, pos=46) ... done
[11:42:01.963]  length: 44 (resolved future 46)
[11:42:01.963] Future #47
[11:42:01.963] result() for ClusterFuture ...
[11:42:01.964] - result already collected: FutureResult
[11:42:01.964] result() for ClusterFuture ... done
[11:42:01.964] result() for ClusterFuture ...
[11:42:01.964] - result already collected: FutureResult
[11:42:01.964] result() for ClusterFuture ... done
[11:42:01.968] signalConditionsASAP(MultisessionFuture, pos=47) ...
[11:42:01.968] - nx: 90
[11:42:01.969] - relay: TRUE
[11:42:01.969] - stdout: TRUE
[11:42:01.969] - signal: TRUE
[11:42:01.969] - resignal: FALSE
[11:42:01.969] - force: TRUE
[11:42:01.969] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.969] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.970]  - until=47
[11:42:01.970]  - relaying element #47
[11:42:01.970] result() for ClusterFuture ...
[11:42:01.970] - result already collected: FutureResult
[11:42:01.970] result() for ClusterFuture ... done
[11:42:01.970] result() for ClusterFuture ...
[11:42:01.970] - result already collected: FutureResult
[11:42:01.970] result() for ClusterFuture ... done
[11:42:01.971] result() for ClusterFuture ...
[11:42:01.971] - result already collected: FutureResult
[11:42:01.971] result() for ClusterFuture ... done
[11:42:01.971] result() for ClusterFuture ...
[11:42:01.971] - result already collected: FutureResult
[11:42:01.971] result() for ClusterFuture ... done
[11:42:01.972] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.972] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.972] signalConditionsASAP(MultisessionFuture, pos=47) ... done
[11:42:01.972]  length: 43 (resolved future 47)
[11:42:01.972] Future #48
[11:42:01.972] result() for ClusterFuture ...
[11:42:01.972] - result already collected: FutureResult
[11:42:01.973] result() for ClusterFuture ... done
[11:42:01.973] result() for ClusterFuture ...
[11:42:01.973] - result already collected: FutureResult
[11:42:01.973] result() for ClusterFuture ... done
[11:42:01.973] signalConditionsASAP(MultisessionFuture, pos=48) ...
[11:42:01.973] - nx: 90
[11:42:01.973] - relay: TRUE
[11:42:01.973] - stdout: TRUE
[11:42:01.973] - signal: TRUE
[11:42:01.973] - resignal: FALSE
[11:42:01.973] - force: TRUE
[11:42:01.973] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.973] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.974]  - until=48
[11:42:01.974]  - relaying element #48
[11:42:01.974] result() for ClusterFuture ...
[11:42:01.974] - result already collected: FutureResult
[11:42:01.974] result() for ClusterFuture ... done
[11:42:01.974] result() for ClusterFuture ...
[11:42:01.974] - result already collected: FutureResult
[11:42:01.974] result() for ClusterFuture ... done
[11:42:01.974] result() for ClusterFuture ...
[11:42:01.974] - result already collected: FutureResult
[11:42:01.974] result() for ClusterFuture ... done
[11:42:01.974] result() for ClusterFuture ...
[11:42:01.974] - result already collected: FutureResult
[11:42:01.974] result() for ClusterFuture ... done
[11:42:01.975] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.975] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.975] signalConditionsASAP(MultisessionFuture, pos=48) ... done
[11:42:01.975]  length: 42 (resolved future 48)
[11:42:01.975] Future #49
[11:42:01.975] result() for ClusterFuture ...
[11:42:01.975] - result already collected: FutureResult
[11:42:01.975] result() for ClusterFuture ... done
[11:42:01.975] result() for ClusterFuture ...
[11:42:01.975] - result already collected: FutureResult
[11:42:01.975] result() for ClusterFuture ... done
[11:42:01.975] signalConditionsASAP(MultisessionFuture, pos=49) ...
[11:42:01.975] - nx: 90
[11:42:01.975] - relay: TRUE
[11:42:01.975] - stdout: TRUE
[11:42:01.975] - signal: TRUE
[11:42:01.975] - resignal: FALSE
[11:42:01.975] - force: TRUE
[11:42:01.976] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.976] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.976]  - until=49
[11:42:01.976]  - relaying element #49
[11:42:01.976] result() for ClusterFuture ...
[11:42:01.976] - result already collected: FutureResult
[11:42:01.976] result() for ClusterFuture ... done
[11:42:01.976] result() for ClusterFuture ...
[11:42:01.976] - result already collected: FutureResult
[11:42:01.976] result() for ClusterFuture ... done
[11:42:01.976] result() for ClusterFuture ...
[11:42:01.976] - result already collected: FutureResult
[11:42:01.976] result() for ClusterFuture ... done
[11:42:01.976] result() for ClusterFuture ...
[11:42:01.976] - result already collected: FutureResult
[11:42:01.976] result() for ClusterFuture ... done
[11:42:01.976] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.976] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.977] signalConditionsASAP(MultisessionFuture, pos=49) ... done
[11:42:01.977]  length: 41 (resolved future 49)
[11:42:01.977] Future #50
[11:42:01.977] result() for ClusterFuture ...
[11:42:01.977] - result already collected: FutureResult
[11:42:01.977] result() for ClusterFuture ... done
[11:42:01.977] result() for ClusterFuture ...
[11:42:01.977] - result already collected: FutureResult
[11:42:01.977] result() for ClusterFuture ... done
[11:42:01.977] signalConditionsASAP(MultisessionFuture, pos=50) ...
[11:42:01.977] - nx: 90
[11:42:01.977] - relay: TRUE
[11:42:01.977] - stdout: TRUE
[11:42:01.977] - signal: TRUE
[11:42:01.977] - resignal: FALSE
[11:42:01.977] - force: TRUE
[11:42:01.977] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.977] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.978]  - until=50
[11:42:01.978]  - relaying element #50
[11:42:01.978] result() for ClusterFuture ...
[11:42:01.978] - result already collected: FutureResult
[11:42:01.978] result() for ClusterFuture ... done
[11:42:01.978] result() for ClusterFuture ...
[11:42:01.978] - result already collected: FutureResult
[11:42:01.978] result() for ClusterFuture ... done
[11:42:01.978] result() for ClusterFuture ...
[11:42:01.978] - result already collected: FutureResult
[11:42:01.978] result() for ClusterFuture ... done
[11:42:01.978] result() for ClusterFuture ...
[11:42:01.978] - result already collected: FutureResult
[11:42:01.978] result() for ClusterFuture ... done
[11:42:01.978] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.978] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.979] signalConditionsASAP(MultisessionFuture, pos=50) ... done
[11:42:01.979]  length: 40 (resolved future 50)
[11:42:01.979] Future #51
[11:42:01.979] result() for ClusterFuture ...
[11:42:01.979] - result already collected: FutureResult
[11:42:01.979] result() for ClusterFuture ... done
[11:42:01.979] result() for ClusterFuture ...
[11:42:01.979] - result already collected: FutureResult
[11:42:01.979] result() for ClusterFuture ... done
[11:42:01.979] signalConditionsASAP(MultisessionFuture, pos=51) ...
[11:42:01.979] - nx: 90
[11:42:01.979] - relay: TRUE
[11:42:01.979] - stdout: TRUE
[11:42:01.979] - signal: TRUE
[11:42:01.979] - resignal: FALSE
[11:42:01.979] - force: TRUE
[11:42:01.979] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.980] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.980]  - until=51
[11:42:01.980]  - relaying element #51
[11:42:01.980] result() for ClusterFuture ...
[11:42:01.980] - result already collected: FutureResult
[11:42:01.980] result() for ClusterFuture ... done
[11:42:01.980] result() for ClusterFuture ...
[11:42:01.980] - result already collected: FutureResult
[11:42:01.980] result() for ClusterFuture ... done
[11:42:01.980] result() for ClusterFuture ...
[11:42:01.980] - result already collected: FutureResult
[11:42:01.980] result() for ClusterFuture ... done
[11:42:01.980] result() for ClusterFuture ...
[11:42:01.980] - result already collected: FutureResult
[11:42:01.980] result() for ClusterFuture ... done
[11:42:01.980] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.981] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.981] signalConditionsASAP(MultisessionFuture, pos=51) ... done
[11:42:01.981]  length: 39 (resolved future 51)
[11:42:01.981] Future #52
[11:42:01.981] result() for ClusterFuture ...
[11:42:01.981] - result already collected: FutureResult
[11:42:01.981] result() for ClusterFuture ... done
[11:42:01.981] result() for ClusterFuture ...
[11:42:01.981] - result already collected: FutureResult
[11:42:01.981] result() for ClusterFuture ... done
[11:42:01.981] signalConditionsASAP(MultisessionFuture, pos=52) ...
[11:42:01.981] - nx: 90
[11:42:01.981] - relay: TRUE
[11:42:01.981] - stdout: TRUE
[11:42:01.981] - signal: TRUE
[11:42:01.981] - resignal: FALSE
[11:42:01.981] - force: TRUE
[11:42:01.981] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.982] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.982]  - until=52
[11:42:01.982]  - relaying element #52
[11:42:01.982] result() for ClusterFuture ...
[11:42:01.982] - result already collected: FutureResult
[11:42:01.982] result() for ClusterFuture ... done
[11:42:01.982] result() for ClusterFuture ...
[11:42:01.982] - result already collected: FutureResult
[11:42:01.982] result() for ClusterFuture ... done
[11:42:01.982] result() for ClusterFuture ...
[11:42:01.982] - result already collected: FutureResult
[11:42:01.982] result() for ClusterFuture ... done
[11:42:01.982] result() for ClusterFuture ...
[11:42:01.982] - result already collected: FutureResult
[11:42:01.982] result() for ClusterFuture ... done
[11:42:01.982] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.982] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.983] signalConditionsASAP(MultisessionFuture, pos=52) ... done
[11:42:01.983]  length: 38 (resolved future 52)
[11:42:01.983] Future #53
[11:42:01.983] result() for ClusterFuture ...
[11:42:01.983] - result already collected: FutureResult
[11:42:01.983] result() for ClusterFuture ... done
[11:42:01.983] result() for ClusterFuture ...
[11:42:01.983] - result already collected: FutureResult
[11:42:01.983] result() for ClusterFuture ... done
[11:42:01.983] signalConditionsASAP(MultisessionFuture, pos=53) ...
[11:42:01.983] - nx: 90
[11:42:01.983] - relay: TRUE
[11:42:01.983] - stdout: TRUE
[11:42:01.983] - signal: TRUE
[11:42:01.983] - resignal: FALSE
[11:42:01.983] - force: TRUE
[11:42:01.984] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.984] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.984]  - until=53
[11:42:01.984]  - relaying element #53
[11:42:01.984] result() for ClusterFuture ...
[11:42:01.984] - result already collected: FutureResult
[11:42:01.984] result() for ClusterFuture ... done
[11:42:01.984] result() for ClusterFuture ...
[11:42:01.984] - result already collected: FutureResult
[11:42:01.984] result() for ClusterFuture ... done
[11:42:01.984] result() for ClusterFuture ...
[11:42:01.984] - result already collected: FutureResult
[11:42:01.984] result() for ClusterFuture ... done
[11:42:01.984] result() for ClusterFuture ...
[11:42:01.984] - result already collected: FutureResult
[11:42:01.985] result() for ClusterFuture ... done
[11:42:01.985] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.985] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.985] signalConditionsASAP(MultisessionFuture, pos=53) ... done
[11:42:01.985]  length: 37 (resolved future 53)
[11:42:01.985] Future #54
[11:42:01.985] result() for ClusterFuture ...
[11:42:01.985] - result already collected: FutureResult
[11:42:01.985] result() for ClusterFuture ... done
[11:42:01.985] result() for ClusterFuture ...
[11:42:01.985] - result already collected: FutureResult
[11:42:01.985] result() for ClusterFuture ... done
[11:42:01.985] signalConditionsASAP(MultisessionFuture, pos=54) ...
[11:42:01.985] - nx: 90
[11:42:01.985] - relay: TRUE
[11:42:01.986] - stdout: TRUE
[11:42:01.986] - signal: TRUE
[11:42:01.986] - resignal: FALSE
[11:42:01.986] - force: TRUE
[11:42:01.986] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.986] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.986]  - until=54
[11:42:01.986]  - relaying element #54
[11:42:01.986] result() for ClusterFuture ...
[11:42:01.986] - result already collected: FutureResult
[11:42:01.986] result() for ClusterFuture ... done
[11:42:01.986] result() for ClusterFuture ...
[11:42:01.987] - result already collected: FutureResult
[11:42:01.987] result() for ClusterFuture ... done
[11:42:01.987] result() for ClusterFuture ...
[11:42:01.987] - result already collected: FutureResult
[11:42:01.987] result() for ClusterFuture ... done
[11:42:01.987] result() for ClusterFuture ...
[11:42:01.987] - result already collected: FutureResult
[11:42:01.987] result() for ClusterFuture ... done
[11:42:01.987] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.987] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.987] signalConditionsASAP(MultisessionFuture, pos=54) ... done
[11:42:01.987]  length: 36 (resolved future 54)
[11:42:01.987] Future #55
[11:42:01.987] result() for ClusterFuture ...
[11:42:01.987] - result already collected: FutureResult
[11:42:01.988] result() for ClusterFuture ... done
[11:42:01.988] result() for ClusterFuture ...
[11:42:01.988] - result already collected: FutureResult
[11:42:01.988] result() for ClusterFuture ... done
[11:42:01.988] signalConditionsASAP(MultisessionFuture, pos=55) ...
[11:42:01.988] - nx: 90
[11:42:01.988] - relay: TRUE
[11:42:01.988] - stdout: TRUE
[11:42:01.988] - signal: TRUE
[11:42:01.988] - resignal: FALSE
[11:42:01.988] - force: TRUE
[11:42:01.988] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.988] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.988]  - until=55
[11:42:01.988]  - relaying element #55
[11:42:01.988] result() for ClusterFuture ...
[11:42:01.988] - result already collected: FutureResult
[11:42:01.988] result() for ClusterFuture ... done
[11:42:01.989] result() for ClusterFuture ...
[11:42:01.989] - result already collected: FutureResult
[11:42:01.989] result() for ClusterFuture ... done
[11:42:01.989] result() for ClusterFuture ...
[11:42:01.989] - result already collected: FutureResult
[11:42:01.989] result() for ClusterFuture ... done
[11:42:01.989] result() for ClusterFuture ...
[11:42:01.989] - result already collected: FutureResult
[11:42:01.989] result() for ClusterFuture ... done
[11:42:01.989] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.989] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.989] signalConditionsASAP(MultisessionFuture, pos=55) ... done
[11:42:01.989]  length: 35 (resolved future 55)
[11:42:01.989] Future #56
[11:42:01.989] result() for ClusterFuture ...
[11:42:01.989] - result already collected: FutureResult
[11:42:01.989] result() for ClusterFuture ... done
[11:42:01.990] result() for ClusterFuture ...
[11:42:01.990] - result already collected: FutureResult
[11:42:01.990] result() for ClusterFuture ... done
[11:42:01.990] signalConditionsASAP(MultisessionFuture, pos=56) ...
[11:42:01.990] - nx: 90
[11:42:01.990] - relay: TRUE
[11:42:01.990] - stdout: TRUE
[11:42:01.990] - signal: TRUE
[11:42:01.990] - resignal: FALSE
[11:42:01.990] - force: TRUE
[11:42:01.990] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.990] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.990]  - until=56
[11:42:01.990]  - relaying element #56
[11:42:01.990] result() for ClusterFuture ...
[11:42:01.990] - result already collected: FutureResult
[11:42:01.990] result() for ClusterFuture ... done
[11:42:01.990] result() for ClusterFuture ...
[11:42:01.990] - result already collected: FutureResult
[11:42:01.991] result() for ClusterFuture ... done
[11:42:01.991] result() for ClusterFuture ...
[11:42:01.991] - result already collected: FutureResult
[11:42:01.991] result() for ClusterFuture ... done
[11:42:01.991] result() for ClusterFuture ...
[11:42:01.991] - result already collected: FutureResult
[11:42:01.991] result() for ClusterFuture ... done
[11:42:01.991] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.991] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.991] signalConditionsASAP(MultisessionFuture, pos=56) ... done
[11:42:01.991]  length: 34 (resolved future 56)
[11:42:01.991] Future #57
[11:42:01.991] result() for ClusterFuture ...
[11:42:01.991] - result already collected: FutureResult
[11:42:01.991] result() for ClusterFuture ... done
[11:42:01.991] result() for ClusterFuture ...
[11:42:01.991] - result already collected: FutureResult
[11:42:01.992] result() for ClusterFuture ... done
[11:42:01.992] signalConditionsASAP(MultisessionFuture, pos=57) ...
[11:42:01.992] - nx: 90
[11:42:01.992] - relay: TRUE
[11:42:01.992] - stdout: TRUE
[11:42:01.992] - signal: TRUE
[11:42:01.992] - resignal: FALSE
[11:42:01.992] - force: TRUE
[11:42:01.992] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.992] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.992]  - until=57
[11:42:01.992]  - relaying element #57
[11:42:01.992] result() for ClusterFuture ...
[11:42:01.992] - result already collected: FutureResult
[11:42:01.992] result() for ClusterFuture ... done
[11:42:01.992] result() for ClusterFuture ...
[11:42:01.992] - result already collected: FutureResult
[11:42:01.992] result() for ClusterFuture ... done
[11:42:01.993] result() for ClusterFuture ...
[11:42:01.993] - result already collected: FutureResult
[11:42:01.993] result() for ClusterFuture ... done
[11:42:01.993] result() for ClusterFuture ...
[11:42:01.993] - result already collected: FutureResult
[11:42:01.993] result() for ClusterFuture ... done
[11:42:01.993] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.993] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.993] signalConditionsASAP(MultisessionFuture, pos=57) ... done
[11:42:01.993]  length: 33 (resolved future 57)
[11:42:01.993] Future #58
[11:42:01.993] result() for ClusterFuture ...
[11:42:01.993] - result already collected: FutureResult
[11:42:01.993] result() for ClusterFuture ... done
[11:42:01.993] result() for ClusterFuture ...
[11:42:01.994] - result already collected: FutureResult
[11:42:01.994] result() for ClusterFuture ... done
[11:42:01.994] signalConditionsASAP(MultisessionFuture, pos=58) ...
[11:42:01.994] - nx: 90
[11:42:01.994] - relay: TRUE
[11:42:01.994] - stdout: TRUE
[11:42:01.994] - signal: TRUE
[11:42:01.994] - resignal: FALSE
[11:42:01.994] - force: TRUE
[11:42:01.994] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.994] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.994]  - until=58
[11:42:01.994]  - relaying element #58
[11:42:01.994] result() for ClusterFuture ...
[11:42:01.994] - result already collected: FutureResult
[11:42:01.995] result() for ClusterFuture ... done
[11:42:01.995] result() for ClusterFuture ...
[11:42:01.995] - result already collected: FutureResult
[11:42:01.995] result() for ClusterFuture ... done
[11:42:01.995] result() for ClusterFuture ...
[11:42:01.995] - result already collected: FutureResult
[11:42:01.995] result() for ClusterFuture ... done
[11:42:01.995] result() for ClusterFuture ...
[11:42:01.995] - result already collected: FutureResult
[11:42:01.995] result() for ClusterFuture ... done
[11:42:01.995] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.995] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.995] signalConditionsASAP(MultisessionFuture, pos=58) ... done
[11:42:01.995]  length: 32 (resolved future 58)
[11:42:01.995] Future #59
[11:42:01.995] result() for ClusterFuture ...
[11:42:01.995] - result already collected: FutureResult
[11:42:01.996] result() for ClusterFuture ... done
[11:42:01.996] result() for ClusterFuture ...
[11:42:01.996] - result already collected: FutureResult
[11:42:01.996] result() for ClusterFuture ... done
[11:42:01.996] signalConditionsASAP(MultisessionFuture, pos=59) ...
[11:42:01.996] - nx: 90
[11:42:01.996] - relay: TRUE
[11:42:01.996] - stdout: TRUE
[11:42:01.996] - signal: TRUE
[11:42:01.996] - resignal: FALSE
[11:42:01.996] - force: TRUE
[11:42:01.996] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.996] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.996]  - until=59
[11:42:01.996]  - relaying element #59
[11:42:01.996] result() for ClusterFuture ...
[11:42:01.996] - result already collected: FutureResult
[11:42:01.996] result() for ClusterFuture ... done
[11:42:01.996] result() for ClusterFuture ...
[11:42:01.996] - result already collected: FutureResult
[11:42:01.997] result() for ClusterFuture ... done
[11:42:01.997] result() for ClusterFuture ...
[11:42:01.997] - result already collected: FutureResult
[11:42:01.997] result() for ClusterFuture ... done
[11:42:01.997] result() for ClusterFuture ...
[11:42:01.997] - result already collected: FutureResult
[11:42:01.997] result() for ClusterFuture ... done
[11:42:01.997] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.997] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.997] signalConditionsASAP(MultisessionFuture, pos=59) ... done
[11:42:01.997]  length: 31 (resolved future 59)
[11:42:01.997] Future #60
[11:42:01.997] result() for ClusterFuture ...
[11:42:01.997] - result already collected: FutureResult
[11:42:01.997] result() for ClusterFuture ... done
[11:42:01.997] result() for ClusterFuture ...
[11:42:01.997] - result already collected: FutureResult
[11:42:01.997] result() for ClusterFuture ... done
[11:42:01.998] signalConditionsASAP(MultisessionFuture, pos=60) ...
[11:42:01.998] - nx: 90
[11:42:01.998] - relay: TRUE
[11:42:01.998] - stdout: TRUE
[11:42:01.998] - signal: TRUE
[11:42:01.998] - resignal: FALSE
[11:42:01.998] - force: TRUE
[11:42:01.998] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.998] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.998]  - until=60
[11:42:01.998]  - relaying element #60
[11:42:01.998] result() for ClusterFuture ...
[11:42:01.998] - result already collected: FutureResult
[11:42:01.998] result() for ClusterFuture ... done
[11:42:01.998] result() for ClusterFuture ...
[11:42:01.998] - result already collected: FutureResult
[11:42:01.998] result() for ClusterFuture ... done
[11:42:01.998] result() for ClusterFuture ...
[11:42:01.998] - result already collected: FutureResult
[11:42:01.999] result() for ClusterFuture ... done
[11:42:01.999] result() for ClusterFuture ...
[11:42:01.999] - result already collected: FutureResult
[11:42:01.999] result() for ClusterFuture ... done
[11:42:01.999] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.999] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:01.999] signalConditionsASAP(MultisessionFuture, pos=60) ... done
[11:42:01.999]  length: 30 (resolved future 60)
[11:42:01.999] Future #61
[11:42:01.999] result() for ClusterFuture ...
[11:42:01.999] - result already collected: FutureResult
[11:42:01.999] result() for ClusterFuture ... done
[11:42:02.000] result() for ClusterFuture ...
[11:42:02.000] - result already collected: FutureResult
[11:42:02.000] result() for ClusterFuture ... done
[11:42:02.000] signalConditionsASAP(MultisessionFuture, pos=61) ...
[11:42:02.000] - nx: 90
[11:42:02.000] - relay: TRUE
[11:42:02.000] - stdout: TRUE
[11:42:02.000] - signal: TRUE
[11:42:02.000] - resignal: FALSE
[11:42:02.000] - force: TRUE
[11:42:02.000] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.000] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.001]  - until=61
[11:42:02.001]  - relaying element #61
[11:42:02.001] result() for ClusterFuture ...
[11:42:02.001] - result already collected: FutureResult
[11:42:02.001] result() for ClusterFuture ... done
[11:42:02.001] result() for ClusterFuture ...
[11:42:02.001] - result already collected: FutureResult
[11:42:02.001] result() for ClusterFuture ... done
[11:42:02.001] result() for ClusterFuture ...
[11:42:02.002] - result already collected: FutureResult
[11:42:02.002] result() for ClusterFuture ... done
[11:42:02.002] result() for ClusterFuture ...
[11:42:02.002] - result already collected: FutureResult
[11:42:02.002] result() for ClusterFuture ... done
[11:42:02.002] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.002] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.002] signalConditionsASAP(MultisessionFuture, pos=61) ... done
[11:42:02.002]  length: 29 (resolved future 61)
[11:42:02.002] Future #62
[11:42:02.002] result() for ClusterFuture ...
[11:42:02.002] - result already collected: FutureResult
[11:42:02.003] result() for ClusterFuture ... done
[11:42:02.003] result() for ClusterFuture ...
[11:42:02.003] - result already collected: FutureResult
[11:42:02.003] result() for ClusterFuture ... done
[11:42:02.003] signalConditionsASAP(MultisessionFuture, pos=62) ...
[11:42:02.003] - nx: 90
[11:42:02.003] - relay: TRUE
[11:42:02.003] - stdout: TRUE
[11:42:02.003] - signal: TRUE
[11:42:02.003] - resignal: FALSE
[11:42:02.003] - force: TRUE
[11:42:02.003] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.003] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.003]  - until=62
[11:42:02.004]  - relaying element #62
[11:42:02.004] result() for ClusterFuture ...
[11:42:02.004] - result already collected: FutureResult
[11:42:02.004] result() for ClusterFuture ... done
[11:42:02.004] result() for ClusterFuture ...
[11:42:02.004] - result already collected: FutureResult
[11:42:02.004] result() for ClusterFuture ... done
[11:42:02.004] result() for ClusterFuture ...
[11:42:02.004] - result already collected: FutureResult
[11:42:02.004] result() for ClusterFuture ... done
[11:42:02.004] result() for ClusterFuture ...
[11:42:02.004] - result already collected: FutureResult
[11:42:02.004] result() for ClusterFuture ... done
[11:42:02.005] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.005] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.005] signalConditionsASAP(MultisessionFuture, pos=62) ... done
[11:42:02.005]  length: 28 (resolved future 62)
[11:42:02.005] Future #63
[11:42:02.005] result() for ClusterFuture ...
[11:42:02.005] - result already collected: FutureResult
[11:42:02.005] result() for ClusterFuture ... done
[11:42:02.005] result() for ClusterFuture ...
[11:42:02.005] - result already collected: FutureResult
[11:42:02.005] result() for ClusterFuture ... done
[11:42:02.005] signalConditionsASAP(MultisessionFuture, pos=63) ...
[11:42:02.005] - nx: 90
[11:42:02.006] - relay: TRUE
[11:42:02.006] - stdout: TRUE
[11:42:02.006] - signal: TRUE
[11:42:02.006] - resignal: FALSE
[11:42:02.006] - force: TRUE
[11:42:02.006] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.006] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.006]  - until=63
[11:42:02.006]  - relaying element #63
[11:42:02.006] result() for ClusterFuture ...
[11:42:02.006] - result already collected: FutureResult
[11:42:02.006] result() for ClusterFuture ... done
[11:42:02.006] result() for ClusterFuture ...
[11:42:02.006] - result already collected: FutureResult
[11:42:02.011] result() for ClusterFuture ... done
[11:42:02.011] result() for ClusterFuture ...
[11:42:02.011] - result already collected: FutureResult
[11:42:02.011] result() for ClusterFuture ... done
[11:42:02.011] result() for ClusterFuture ...
[11:42:02.012] - result already collected: FutureResult
[11:42:02.012] result() for ClusterFuture ... done
[11:42:02.012] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.012] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.012] signalConditionsASAP(MultisessionFuture, pos=63) ... done
[11:42:02.012]  length: 27 (resolved future 63)
[11:42:02.012] Future #64
[11:42:02.012] result() for ClusterFuture ...
[11:42:02.013] - result already collected: FutureResult
[11:42:02.013] result() for ClusterFuture ... done
[11:42:02.013] result() for ClusterFuture ...
[11:42:02.013] - result already collected: FutureResult
[11:42:02.013] result() for ClusterFuture ... done
[11:42:02.013] signalConditionsASAP(MultisessionFuture, pos=64) ...
[11:42:02.013] - nx: 90
[11:42:02.013] - relay: TRUE
[11:42:02.013] - stdout: TRUE
[11:42:02.013] - signal: TRUE
[11:42:02.013] - resignal: FALSE
[11:42:02.013] - force: TRUE
[11:42:02.014] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.014] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.014]  - until=64
[11:42:02.014]  - relaying element #64
[11:42:02.014] result() for ClusterFuture ...
[11:42:02.014] - result already collected: FutureResult
[11:42:02.014] result() for ClusterFuture ... done
[11:42:02.014] result() for ClusterFuture ...
[11:42:02.014] - result already collected: FutureResult
[11:42:02.014] result() for ClusterFuture ... done
[11:42:02.014] result() for ClusterFuture ...
[11:42:02.015] - result already collected: FutureResult
[11:42:02.015] result() for ClusterFuture ... done
[11:42:02.015] result() for ClusterFuture ...
[11:42:02.015] - result already collected: FutureResult
[11:42:02.015] result() for ClusterFuture ... done
[11:42:02.015] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.015] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.015] signalConditionsASAP(MultisessionFuture, pos=64) ... done
[11:42:02.015]  length: 26 (resolved future 64)
[11:42:02.015] Future #65
[11:42:02.015] result() for ClusterFuture ...
[11:42:02.015] - result already collected: FutureResult
[11:42:02.015] result() for ClusterFuture ... done
[11:42:02.015] result() for ClusterFuture ...
[11:42:02.016] - result already collected: FutureResult
[11:42:02.016] result() for ClusterFuture ... done
[11:42:02.016] signalConditionsASAP(MultisessionFuture, pos=65) ...
[11:42:02.016] - nx: 90
[11:42:02.016] - relay: TRUE
[11:42:02.016] - stdout: TRUE
[11:42:02.016] - signal: TRUE
[11:42:02.016] - resignal: FALSE
[11:42:02.016] - force: TRUE
[11:42:02.016] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.016] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.016]  - until=65
[11:42:02.016]  - relaying element #65
[11:42:02.017] result() for ClusterFuture ...
[11:42:02.017] - result already collected: FutureResult
[11:42:02.017] result() for ClusterFuture ... done
[11:42:02.017] result() for ClusterFuture ...
[11:42:02.017] - result already collected: FutureResult
[11:42:02.017] result() for ClusterFuture ... done
[11:42:02.017] result() for ClusterFuture ...
[11:42:02.017] - result already collected: FutureResult
[11:42:02.017] result() for ClusterFuture ... done
[11:42:02.017] result() for ClusterFuture ...
[11:42:02.017] - result already collected: FutureResult
[11:42:02.017] result() for ClusterFuture ... done
[11:42:02.017] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.017] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.017] signalConditionsASAP(MultisessionFuture, pos=65) ... done
[11:42:02.017]  length: 25 (resolved future 65)
[11:42:02.018] Future #66
[11:42:02.018] result() for ClusterFuture ...
[11:42:02.018] - result already collected: FutureResult
[11:42:02.018] result() for ClusterFuture ... done
[11:42:02.018] result() for ClusterFuture ...
[11:42:02.018] - result already collected: FutureResult
[11:42:02.018] result() for ClusterFuture ... done
[11:42:02.018] signalConditionsASAP(MultisessionFuture, pos=66) ...
[11:42:02.018] - nx: 90
[11:42:02.018] - relay: TRUE
[11:42:02.018] - stdout: TRUE
[11:42:02.018] - signal: TRUE
[11:42:02.018] - resignal: FALSE
[11:42:02.018] - force: TRUE
[11:42:02.018] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.018] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.018]  - until=66
[11:42:02.018]  - relaying element #66
[11:42:02.019] result() for ClusterFuture ...
[11:42:02.019] - result already collected: FutureResult
[11:42:02.019] result() for ClusterFuture ... done
[11:42:02.019] result() for ClusterFuture ...
[11:42:02.019] - result already collected: FutureResult
[11:42:02.019] result() for ClusterFuture ... done
[11:42:02.019] result() for ClusterFuture ...
[11:42:02.019] - result already collected: FutureResult
[11:42:02.019] result() for ClusterFuture ... done
[11:42:02.019] result() for ClusterFuture ...
[11:42:02.019] - result already collected: FutureResult
[11:42:02.019] result() for ClusterFuture ... done
[11:42:02.019] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.019] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.019] signalConditionsASAP(MultisessionFuture, pos=66) ... done
[11:42:02.019]  length: 24 (resolved future 66)
[11:42:02.020] Future #67
[11:42:02.020] result() for ClusterFuture ...
[11:42:02.020] - result already collected: FutureResult
[11:42:02.020] result() for ClusterFuture ... done
[11:42:02.020] result() for ClusterFuture ...
[11:42:02.020] - result already collected: FutureResult
[11:42:02.020] result() for ClusterFuture ... done
[11:42:02.020] signalConditionsASAP(MultisessionFuture, pos=67) ...
[11:42:02.020] - nx: 90
[11:42:02.020] - relay: TRUE
[11:42:02.020] - stdout: TRUE
[11:42:02.020] - signal: TRUE
[11:42:02.020] - resignal: FALSE
[11:42:02.020] - force: TRUE
[11:42:02.020] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.020] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.021]  - until=67
[11:42:02.021]  - relaying element #67
[11:42:02.021] result() for ClusterFuture ...
[11:42:02.021] - result already collected: FutureResult
[11:42:02.021] result() for ClusterFuture ... done
[11:42:02.021] result() for ClusterFuture ...
[11:42:02.021] - result already collected: FutureResult
[11:42:02.021] result() for ClusterFuture ... done
[11:42:02.021] result() for ClusterFuture ...
[11:42:02.021] - result already collected: FutureResult
[11:42:02.021] result() for ClusterFuture ... done
[11:42:02.021] result() for ClusterFuture ...
[11:42:02.021] - result already collected: FutureResult
[11:42:02.021] result() for ClusterFuture ... done
[11:42:02.021] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.022] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.022] signalConditionsASAP(MultisessionFuture, pos=67) ... done
[11:42:02.022]  length: 23 (resolved future 67)
[11:42:02.022] Future #68
[11:42:02.022] result() for ClusterFuture ...
[11:42:02.022] - result already collected: FutureResult
[11:42:02.022] result() for ClusterFuture ... done
[11:42:02.022] result() for ClusterFuture ...
[11:42:02.022] - result already collected: FutureResult
[11:42:02.022] result() for ClusterFuture ... done
[11:42:02.022] signalConditionsASAP(MultisessionFuture, pos=68) ...
[11:42:02.022] - nx: 90
[11:42:02.022] - relay: TRUE
[11:42:02.022] - stdout: TRUE
[11:42:02.022] - signal: TRUE
[11:42:02.022] - resignal: FALSE
[11:42:02.022] - force: TRUE
[11:42:02.022] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.023] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.023]  - until=68
[11:42:02.023]  - relaying element #68
[11:42:02.023] result() for ClusterFuture ...
[11:42:02.023] - result already collected: FutureResult
[11:42:02.023] result() for ClusterFuture ... done
[11:42:02.023] result() for ClusterFuture ...
[11:42:02.023] - result already collected: FutureResult
[11:42:02.023] result() for ClusterFuture ... done
[11:42:02.023] result() for ClusterFuture ...
[11:42:02.023] - result already collected: FutureResult
[11:42:02.023] result() for ClusterFuture ... done
[11:42:02.023] result() for ClusterFuture ...
[11:42:02.023] - result already collected: FutureResult
[11:42:02.023] result() for ClusterFuture ... done
[11:42:02.023] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.023] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.024] signalConditionsASAP(MultisessionFuture, pos=68) ... done
[11:42:02.024]  length: 22 (resolved future 68)
[11:42:02.024] Future #69
[11:42:02.024] result() for ClusterFuture ...
[11:42:02.024] - result already collected: FutureResult
[11:42:02.024] result() for ClusterFuture ... done
[11:42:02.024] result() for ClusterFuture ...
[11:42:02.024] - result already collected: FutureResult
[11:42:02.024] result() for ClusterFuture ... done
[11:42:02.024] signalConditionsASAP(MultisessionFuture, pos=69) ...
[11:42:02.024] - nx: 90
[11:42:02.024] - relay: TRUE
[11:42:02.024] - stdout: TRUE
[11:42:02.024] - signal: TRUE
[11:42:02.024] - resignal: FALSE
[11:42:02.024] - force: TRUE
[11:42:02.024] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.024] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.025]  - until=69
[11:42:02.025]  - relaying element #69
[11:42:02.025] result() for ClusterFuture ...
[11:42:02.025] - result already collected: FutureResult
[11:42:02.025] result() for ClusterFuture ... done
[11:42:02.025] result() for ClusterFuture ...
[11:42:02.025] - result already collected: FutureResult
[11:42:02.025] result() for ClusterFuture ... done
[11:42:02.025] result() for ClusterFuture ...
[11:42:02.025] - result already collected: FutureResult
[11:42:02.025] result() for ClusterFuture ... done
[11:42:02.025] result() for ClusterFuture ...
[11:42:02.025] - result already collected: FutureResult
[11:42:02.025] result() for ClusterFuture ... done
[11:42:02.025] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.025] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.026] signalConditionsASAP(MultisessionFuture, pos=69) ... done
[11:42:02.026]  length: 21 (resolved future 69)
[11:42:02.026] Future #70
[11:42:02.026] result() for ClusterFuture ...
[11:42:02.026] - result already collected: FutureResult
[11:42:02.026] result() for ClusterFuture ... done
[11:42:02.026] result() for ClusterFuture ...
[11:42:02.026] - result already collected: FutureResult
[11:42:02.026] result() for ClusterFuture ... done
[11:42:02.026] signalConditionsASAP(MultisessionFuture, pos=70) ...
[11:42:02.026] - nx: 90
[11:42:02.026] - relay: TRUE
[11:42:02.026] - stdout: TRUE
[11:42:02.026] - signal: TRUE
[11:42:02.026] - resignal: FALSE
[11:42:02.026] - force: TRUE
[11:42:02.026] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.026] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.026]  - until=70
[11:42:02.027]  - relaying element #70
[11:42:02.027] result() for ClusterFuture ...
[11:42:02.027] - result already collected: FutureResult
[11:42:02.027] result() for ClusterFuture ... done
[11:42:02.027] result() for ClusterFuture ...
[11:42:02.027] - result already collected: FutureResult
[11:42:02.027] result() for ClusterFuture ... done
[11:42:02.027] result() for ClusterFuture ...
[11:42:02.027] - result already collected: FutureResult
[11:42:02.027] result() for ClusterFuture ... done
[11:42:02.027] result() for ClusterFuture ...
[11:42:02.027] - result already collected: FutureResult
[11:42:02.027] result() for ClusterFuture ... done
[11:42:02.027] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.027] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.027] signalConditionsASAP(MultisessionFuture, pos=70) ... done
[11:42:02.028]  length: 20 (resolved future 70)
[11:42:02.028] Future #71
[11:42:02.028] result() for ClusterFuture ...
[11:42:02.028] - result already collected: FutureResult
[11:42:02.028] result() for ClusterFuture ... done
[11:42:02.028] result() for ClusterFuture ...
[11:42:02.028] - result already collected: FutureResult
[11:42:02.028] result() for ClusterFuture ... done
[11:42:02.028] signalConditionsASAP(MultisessionFuture, pos=71) ...
[11:42:02.028] - nx: 90
[11:42:02.028] - relay: TRUE
[11:42:02.028] - stdout: TRUE
[11:42:02.028] - signal: TRUE
[11:42:02.028] - resignal: FALSE
[11:42:02.028] - force: TRUE
[11:42:02.028] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.028] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.029]  - until=71
[11:42:02.029]  - relaying element #71
[11:42:02.029] result() for ClusterFuture ...
[11:42:02.029] - result already collected: FutureResult
[11:42:02.029] result() for ClusterFuture ... done
[11:42:02.029] result() for ClusterFuture ...
[11:42:02.029] - result already collected: FutureResult
[11:42:02.029] result() for ClusterFuture ... done
[11:42:02.029] result() for ClusterFuture ...
[11:42:02.029] - result already collected: FutureResult
[11:42:02.029] result() for ClusterFuture ... done
[11:42:02.029] result() for ClusterFuture ...
[11:42:02.029] - result already collected: FutureResult
[11:42:02.029] result() for ClusterFuture ... done
[11:42:02.029] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.029] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.030] signalConditionsASAP(MultisessionFuture, pos=71) ... done
[11:42:02.030]  length: 19 (resolved future 71)
[11:42:02.030] Future #72
[11:42:02.030] result() for ClusterFuture ...
[11:42:02.030] - result already collected: FutureResult
[11:42:02.030] result() for ClusterFuture ... done
[11:42:02.030] result() for ClusterFuture ...
[11:42:02.030] - result already collected: FutureResult
[11:42:02.030] result() for ClusterFuture ... done
[11:42:02.030] signalConditionsASAP(MultisessionFuture, pos=72) ...
[11:42:02.030] - nx: 90
[11:42:02.030] - relay: TRUE
[11:42:02.030] - stdout: TRUE
[11:42:02.030] - signal: TRUE
[11:42:02.030] - resignal: FALSE
[11:42:02.030] - force: TRUE
[11:42:02.030] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.030] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.031]  - until=72
[11:42:02.031]  - relaying element #72
[11:42:02.031] result() for ClusterFuture ...
[11:42:02.031] - result already collected: FutureResult
[11:42:02.031] result() for ClusterFuture ... done
[11:42:02.031] result() for ClusterFuture ...
[11:42:02.031] - result already collected: FutureResult
[11:42:02.031] result() for ClusterFuture ... done
[11:42:02.031] result() for ClusterFuture ...
[11:42:02.031] - result already collected: FutureResult
[11:42:02.031] result() for ClusterFuture ... done
[11:42:02.031] result() for ClusterFuture ...
[11:42:02.031] - result already collected: FutureResult
[11:42:02.031] result() for ClusterFuture ... done
[11:42:02.031] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.031] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.032] signalConditionsASAP(MultisessionFuture, pos=72) ... done
[11:42:02.032]  length: 18 (resolved future 72)
[11:42:02.032] Future #73
[11:42:02.032] result() for ClusterFuture ...
[11:42:02.032] - result already collected: FutureResult
[11:42:02.032] result() for ClusterFuture ... done
[11:42:02.032] result() for ClusterFuture ...
[11:42:02.032] - result already collected: FutureResult
[11:42:02.032] result() for ClusterFuture ... done
[11:42:02.032] signalConditionsASAP(MultisessionFuture, pos=73) ...
[11:42:02.032] - nx: 90
[11:42:02.032] - relay: TRUE
[11:42:02.032] - stdout: TRUE
[11:42:02.032] - signal: TRUE
[11:42:02.032] - resignal: FALSE
[11:42:02.032] - force: TRUE
[11:42:02.032] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.032] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.033]  - until=73
[11:42:02.033]  - relaying element #73
[11:42:02.033] result() for ClusterFuture ...
[11:42:02.033] - result already collected: FutureResult
[11:42:02.033] result() for ClusterFuture ... done
[11:42:02.033] result() for ClusterFuture ...
[11:42:02.033] - result already collected: FutureResult
[11:42:02.033] result() for ClusterFuture ... done
[11:42:02.033] result() for ClusterFuture ...
[11:42:02.033] - result already collected: FutureResult
[11:42:02.033] result() for ClusterFuture ... done
[11:42:02.033] result() for ClusterFuture ...
[11:42:02.033] - result already collected: FutureResult
[11:42:02.033] result() for ClusterFuture ... done
[11:42:02.033] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.033] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.033] signalConditionsASAP(MultisessionFuture, pos=73) ... done
[11:42:02.033]  length: 17 (resolved future 73)
[11:42:02.034] Future #74
[11:42:02.034] result() for ClusterFuture ...
[11:42:02.034] - result already collected: FutureResult
[11:42:02.034] result() for ClusterFuture ... done
[11:42:02.034] result() for ClusterFuture ...
[11:42:02.034] - result already collected: FutureResult
[11:42:02.034] result() for ClusterFuture ... done
[11:42:02.034] signalConditionsASAP(MultisessionFuture, pos=74) ...
[11:42:02.034] - nx: 90
[11:42:02.034] - relay: TRUE
[11:42:02.034] - stdout: TRUE
[11:42:02.034] - signal: TRUE
[11:42:02.034] - resignal: FALSE
[11:42:02.034] - force: TRUE
[11:42:02.034] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.034] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.034]  - until=74
[11:42:02.034]  - relaying element #74
[11:42:02.035] result() for ClusterFuture ...
[11:42:02.035] - result already collected: FutureResult
[11:42:02.035] result() for ClusterFuture ... done
[11:42:02.035] result() for ClusterFuture ...
[11:42:02.035] - result already collected: FutureResult
[11:42:02.035] result() for ClusterFuture ... done
[11:42:02.035] result() for ClusterFuture ...
[11:42:02.035] - result already collected: FutureResult
[11:42:02.035] result() for ClusterFuture ... done
[11:42:02.035] result() for ClusterFuture ...
[11:42:02.035] - result already collected: FutureResult
[11:42:02.035] result() for ClusterFuture ... done
[11:42:02.035] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.035] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.035] signalConditionsASAP(MultisessionFuture, pos=74) ... done
[11:42:02.035]  length: 16 (resolved future 74)
[11:42:02.036] Future #75
[11:42:02.036] result() for ClusterFuture ...
[11:42:02.036] - result already collected: FutureResult
[11:42:02.036] result() for ClusterFuture ... done
[11:42:02.036] result() for ClusterFuture ...
[11:42:02.036] - result already collected: FutureResult
[11:42:02.036] result() for ClusterFuture ... done
[11:42:02.036] signalConditionsASAP(MultisessionFuture, pos=75) ...
[11:42:02.036] - nx: 90
[11:42:02.036] - relay: TRUE
[11:42:02.036] - stdout: TRUE
[11:42:02.037] - signal: TRUE
[11:42:02.037] - resignal: FALSE
[11:42:02.037] - force: TRUE
[11:42:02.037] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.037] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.037]  - until=75
[11:42:02.037]  - relaying element #75
[11:42:02.037] result() for ClusterFuture ...
[11:42:02.037] - result already collected: FutureResult
[11:42:02.037] result() for ClusterFuture ... done
[11:42:02.037] result() for ClusterFuture ...
[11:42:02.038] - result already collected: FutureResult
[11:42:02.038] result() for ClusterFuture ... done
[11:42:02.038] result() for ClusterFuture ...
[11:42:02.038] - result already collected: FutureResult
[11:42:02.038] result() for ClusterFuture ... done
[11:42:02.038] result() for ClusterFuture ...
[11:42:02.038] - result already collected: FutureResult
[11:42:02.038] result() for ClusterFuture ... done
[11:42:02.038] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.038] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.038] signalConditionsASAP(MultisessionFuture, pos=75) ... done
[11:42:02.038]  length: 15 (resolved future 75)
[11:42:02.038] Future #76
[11:42:02.038] result() for ClusterFuture ...
[11:42:02.039] - result already collected: FutureResult
[11:42:02.039] result() for ClusterFuture ... done
[11:42:02.039] result() for ClusterFuture ...
[11:42:02.039] - result already collected: FutureResult
[11:42:02.039] result() for ClusterFuture ... done
[11:42:02.039] signalConditionsASAP(MultisessionFuture, pos=76) ...
[11:42:02.039] - nx: 90
[11:42:02.039] - relay: TRUE
[11:42:02.039] - stdout: TRUE
[11:42:02.039] - signal: TRUE
[11:42:02.039] - resignal: FALSE
[11:42:02.039] - force: TRUE
[11:42:02.039] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.039] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.040]  - until=76
[11:42:02.040]  - relaying element #76
[11:42:02.040] result() for ClusterFuture ...
[11:42:02.040] - result already collected: FutureResult
[11:42:02.040] result() for ClusterFuture ... done
[11:42:02.040] result() for ClusterFuture ...
[11:42:02.040] - result already collected: FutureResult
[11:42:02.040] result() for ClusterFuture ... done
[11:42:02.040] result() for ClusterFuture ...
[11:42:02.040] - result already collected: FutureResult
[11:42:02.040] result() for ClusterFuture ... done
[11:42:02.040] result() for ClusterFuture ...
[11:42:02.040] - result already collected: FutureResult
[11:42:02.040] result() for ClusterFuture ... done
[11:42:02.040] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.040] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.041] signalConditionsASAP(MultisessionFuture, pos=76) ... done
[11:42:02.041]  length: 14 (resolved future 76)
[11:42:02.041] Future #77
[11:42:02.041] result() for ClusterFuture ...
[11:42:02.041] - result already collected: FutureResult
[11:42:02.041] result() for ClusterFuture ... done
[11:42:02.041] result() for ClusterFuture ...
[11:42:02.041] - result already collected: FutureResult
[11:42:02.041] result() for ClusterFuture ... done
[11:42:02.041] signalConditionsASAP(MultisessionFuture, pos=77) ...
[11:42:02.041] - nx: 90
[11:42:02.041] - relay: TRUE
[11:42:02.041] - stdout: TRUE
[11:42:02.041] - signal: TRUE
[11:42:02.041] - resignal: FALSE
[11:42:02.041] - force: TRUE
[11:42:02.042] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.042] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.042]  - until=77
[11:42:02.042]  - relaying element #77
[11:42:02.042] result() for ClusterFuture ...
[11:42:02.042] - result already collected: FutureResult
[11:42:02.042] result() for ClusterFuture ... done
[11:42:02.042] result() for ClusterFuture ...
[11:42:02.042] - result already collected: FutureResult
[11:42:02.042] result() for ClusterFuture ... done
[11:42:02.042] result() for ClusterFuture ...
[11:42:02.042] - result already collected: FutureResult
[11:42:02.042] result() for ClusterFuture ... done
[11:42:02.042] result() for ClusterFuture ...
[11:42:02.042] - result already collected: FutureResult
[11:42:02.042] result() for ClusterFuture ... done
[11:42:02.042] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.043] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.043] signalConditionsASAP(MultisessionFuture, pos=77) ... done
[11:42:02.043]  length: 13 (resolved future 77)
[11:42:02.043] Future #78
[11:42:02.043] result() for ClusterFuture ...
[11:42:02.043] - result already collected: FutureResult
[11:42:02.043] result() for ClusterFuture ... done
[11:42:02.043] result() for ClusterFuture ...
[11:42:02.043] - result already collected: FutureResult
[11:42:02.043] result() for ClusterFuture ... done
[11:42:02.043] signalConditionsASAP(MultisessionFuture, pos=78) ...
[11:42:02.043] - nx: 90
[11:42:02.043] - relay: TRUE
[11:42:02.043] - stdout: TRUE
[11:42:02.044] - signal: TRUE
[11:42:02.044] - resignal: FALSE
[11:42:02.044] - force: TRUE
[11:42:02.044] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.044] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.044]  - until=78
[11:42:02.044]  - relaying element #78
[11:42:02.044] result() for ClusterFuture ...
[11:42:02.044] - result already collected: FutureResult
[11:42:02.044] result() for ClusterFuture ... done
[11:42:02.044] result() for ClusterFuture ...
[11:42:02.044] - result already collected: FutureResult
[11:42:02.044] result() for ClusterFuture ... done
[11:42:02.044] result() for ClusterFuture ...
[11:42:02.044] - result already collected: FutureResult
[11:42:02.044] result() for ClusterFuture ... done
[11:42:02.044] result() for ClusterFuture ...
[11:42:02.045] - result already collected: FutureResult
[11:42:02.045] result() for ClusterFuture ... done
[11:42:02.045] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.045] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.045] signalConditionsASAP(MultisessionFuture, pos=78) ... done
[11:42:02.045]  length: 12 (resolved future 78)
[11:42:02.045] Future #79
[11:42:02.045] result() for ClusterFuture ...
[11:42:02.045] - result already collected: FutureResult
[11:42:02.045] result() for ClusterFuture ... done
[11:42:02.045] result() for ClusterFuture ...
[11:42:02.045] - result already collected: FutureResult
[11:42:02.045] result() for ClusterFuture ... done
[11:42:02.045] signalConditionsASAP(MultisessionFuture, pos=79) ...
[11:42:02.045] - nx: 90
[11:42:02.045] - relay: TRUE
[11:42:02.046] - stdout: TRUE
[11:42:02.046] - signal: TRUE
[11:42:02.046] - resignal: FALSE
[11:42:02.046] - force: TRUE
[11:42:02.046] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.046] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.046]  - until=79
[11:42:02.046]  - relaying element #79
[11:42:02.046] result() for ClusterFuture ...
[11:42:02.046] - result already collected: FutureResult
[11:42:02.046] result() for ClusterFuture ... done
[11:42:02.046] result() for ClusterFuture ...
[11:42:02.046] - result already collected: FutureResult
[11:42:02.046] result() for ClusterFuture ... done
[11:42:02.046] result() for ClusterFuture ...
[11:42:02.046] - result already collected: FutureResult
[11:42:02.046] result() for ClusterFuture ... done
[11:42:02.046] result() for ClusterFuture ...
[11:42:02.047] - result already collected: FutureResult
[11:42:02.047] result() for ClusterFuture ... done
[11:42:02.047] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.047] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.047] signalConditionsASAP(MultisessionFuture, pos=79) ... done
[11:42:02.047]  length: 11 (resolved future 79)
[11:42:02.047] Future #80
[11:42:02.047] result() for ClusterFuture ...
[11:42:02.047] - result already collected: FutureResult
[11:42:02.047] result() for ClusterFuture ... done
[11:42:02.051] result() for ClusterFuture ...
[11:42:02.051] - result already collected: FutureResult
[11:42:02.052] result() for ClusterFuture ... done
[11:42:02.052] signalConditionsASAP(MultisessionFuture, pos=80) ...
[11:42:02.052] - nx: 90
[11:42:02.052] - relay: TRUE
[11:42:02.052] - stdout: TRUE
[11:42:02.052] - signal: TRUE
[11:42:02.052] - resignal: FALSE
[11:42:02.052] - force: TRUE
[11:42:02.052] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.052] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.053]  - until=80
[11:42:02.053]  - relaying element #80
[11:42:02.053] result() for ClusterFuture ...
[11:42:02.053] - result already collected: FutureResult
[11:42:02.053] result() for ClusterFuture ... done
[11:42:02.053] result() for ClusterFuture ...
[11:42:02.053] - result already collected: FutureResult
[11:42:02.053] result() for ClusterFuture ... done
[11:42:02.053] result() for ClusterFuture ...
[11:42:02.054] - result already collected: FutureResult
[11:42:02.054] result() for ClusterFuture ... done
[11:42:02.054] result() for ClusterFuture ...
[11:42:02.054] - result already collected: FutureResult
[11:42:02.054] result() for ClusterFuture ... done
[11:42:02.054] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.054] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.055] signalConditionsASAP(MultisessionFuture, pos=80) ... done
[11:42:02.055]  length: 10 (resolved future 80)
[11:42:02.055] Future #81
[11:42:02.055] result() for ClusterFuture ...
[11:42:02.055] - result already collected: FutureResult
[11:42:02.055] result() for ClusterFuture ... done
[11:42:02.055] result() for ClusterFuture ...
[11:42:02.055] - result already collected: FutureResult
[11:42:02.055] result() for ClusterFuture ... done
[11:42:02.055] signalConditionsASAP(MultisessionFuture, pos=81) ...
[11:42:02.055] - nx: 90
[11:42:02.055] - relay: TRUE
[11:42:02.055] - stdout: TRUE
[11:42:02.056] - signal: TRUE
[11:42:02.056] - resignal: FALSE
[11:42:02.056] - force: TRUE
[11:42:02.056] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.056] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.056]  - until=81
[11:42:02.056]  - relaying element #81
[11:42:02.056] result() for ClusterFuture ...
[11:42:02.056] - result already collected: FutureResult
[11:42:02.056] result() for ClusterFuture ... done
[11:42:02.056] result() for ClusterFuture ...
[11:42:02.056] - result already collected: FutureResult
[11:42:02.056] result() for ClusterFuture ... done
[11:42:02.056] result() for ClusterFuture ...
[11:42:02.057] - result already collected: FutureResult
[11:42:02.057] result() for ClusterFuture ... done
[11:42:02.057] result() for ClusterFuture ...
[11:42:02.057] - result already collected: FutureResult
[11:42:02.057] result() for ClusterFuture ... done
[11:42:02.057] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.057] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.057] signalConditionsASAP(MultisessionFuture, pos=81) ... done
[11:42:02.057]  length: 9 (resolved future 81)
[11:42:02.057] Future #82
[11:42:02.057] result() for ClusterFuture ...
[11:42:02.057] - result already collected: FutureResult
[11:42:02.057] result() for ClusterFuture ... done
[11:42:02.057] result() for ClusterFuture ...
[11:42:02.057] - result already collected: FutureResult
[11:42:02.058] result() for ClusterFuture ... done
[11:42:02.058] signalConditionsASAP(MultisessionFuture, pos=82) ...
[11:42:02.058] - nx: 90
[11:42:02.058] - relay: TRUE
[11:42:02.058] - stdout: TRUE
[11:42:02.058] - signal: TRUE
[11:42:02.058] - resignal: FALSE
[11:42:02.058] - force: TRUE
[11:42:02.058] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.058] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.058]  - until=82
[11:42:02.058]  - relaying element #82
[11:42:02.058] result() for ClusterFuture ...
[11:42:02.058] - result already collected: FutureResult
[11:42:02.058] result() for ClusterFuture ... done
[11:42:02.058] result() for ClusterFuture ...
[11:42:02.058] - result already collected: FutureResult
[11:42:02.058] result() for ClusterFuture ... done
[11:42:02.059] result() for ClusterFuture ...
[11:42:02.059] - result already collected: FutureResult
[11:42:02.059] result() for ClusterFuture ... done
[11:42:02.059] result() for ClusterFuture ...
[11:42:02.059] - result already collected: FutureResult
[11:42:02.059] result() for ClusterFuture ... done
[11:42:02.059] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.059] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.059] signalConditionsASAP(MultisessionFuture, pos=82) ... done
[11:42:02.059]  length: 8 (resolved future 82)
[11:42:02.059] Future #83
[11:42:02.059] result() for ClusterFuture ...
[11:42:02.059] - result already collected: FutureResult
[11:42:02.059] result() for ClusterFuture ... done
[11:42:02.059] result() for ClusterFuture ...
[11:42:02.059] - result already collected: FutureResult
[11:42:02.059] result() for ClusterFuture ... done
[11:42:02.059] signalConditionsASAP(MultisessionFuture, pos=83) ...
[11:42:02.060] - nx: 90
[11:42:02.060] - relay: TRUE
[11:42:02.060] - stdout: TRUE
[11:42:02.060] - signal: TRUE
[11:42:02.060] - resignal: FALSE
[11:42:02.060] - force: TRUE
[11:42:02.060] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.060] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.060]  - until=83
[11:42:02.060]  - relaying element #83
[11:42:02.060] result() for ClusterFuture ...
[11:42:02.060] - result already collected: FutureResult
[11:42:02.060] result() for ClusterFuture ... done
[11:42:02.060] result() for ClusterFuture ...
[11:42:02.060] - result already collected: FutureResult
[11:42:02.060] result() for ClusterFuture ... done
[11:42:02.060] result() for ClusterFuture ...
[11:42:02.060] - result already collected: FutureResult
[11:42:02.060] result() for ClusterFuture ... done
[11:42:02.061] result() for ClusterFuture ...
[11:42:02.061] - result already collected: FutureResult
[11:42:02.061] result() for ClusterFuture ... done
[11:42:02.061] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.061] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.061] signalConditionsASAP(MultisessionFuture, pos=83) ... done
[11:42:02.061]  length: 7 (resolved future 83)
[11:42:02.061] Future #84
[11:42:02.061] result() for ClusterFuture ...
[11:42:02.061] - result already collected: FutureResult
[11:42:02.061] result() for ClusterFuture ... done
[11:42:02.061] result() for ClusterFuture ...
[11:42:02.061] - result already collected: FutureResult
[11:42:02.061] result() for ClusterFuture ... done
[11:42:02.061] signalConditionsASAP(MultisessionFuture, pos=84) ...
[11:42:02.062] - nx: 90
[11:42:02.062] - relay: TRUE
[11:42:02.062] - stdout: TRUE
[11:42:02.062] - signal: TRUE
[11:42:02.062] - resignal: FALSE
[11:42:02.062] - force: TRUE
[11:42:02.062] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.062] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.062]  - until=84
[11:42:02.062]  - relaying element #84
[11:42:02.062] result() for ClusterFuture ...
[11:42:02.062] - result already collected: FutureResult
[11:42:02.062] result() for ClusterFuture ... done
[11:42:02.062] result() for ClusterFuture ...
[11:42:02.062] - result already collected: FutureResult
[11:42:02.062] result() for ClusterFuture ... done
[11:42:02.062] result() for ClusterFuture ...
[11:42:02.062] - result already collected: FutureResult
[11:42:02.062] result() for ClusterFuture ... done
[11:42:02.063] result() for ClusterFuture ...
[11:42:02.063] - result already collected: FutureResult
[11:42:02.063] result() for ClusterFuture ... done
[11:42:02.063] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.063] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.063] signalConditionsASAP(MultisessionFuture, pos=84) ... done
[11:42:02.063]  length: 6 (resolved future 84)
[11:42:02.063] Future #85
[11:42:02.063] result() for ClusterFuture ...
[11:42:02.063] - result already collected: FutureResult
[11:42:02.063] result() for ClusterFuture ... done
[11:42:02.063] result() for ClusterFuture ...
[11:42:02.063] - result already collected: FutureResult
[11:42:02.063] result() for ClusterFuture ... done
[11:42:02.063] signalConditionsASAP(MultisessionFuture, pos=85) ...
[11:42:02.063] - nx: 90
[11:42:02.063] - relay: TRUE
[11:42:02.063] - stdout: TRUE
[11:42:02.063] - signal: TRUE
[11:42:02.064] - resignal: FALSE
[11:42:02.064] - force: TRUE
[11:42:02.064] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.064] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.064]  - until=85
[11:42:02.064]  - relaying element #85
[11:42:02.064] result() for ClusterFuture ...
[11:42:02.064] - result already collected: FutureResult
[11:42:02.064] result() for ClusterFuture ... done
[11:42:02.064] result() for ClusterFuture ...
[11:42:02.064] - result already collected: FutureResult
[11:42:02.064] result() for ClusterFuture ... done
[11:42:02.064] result() for ClusterFuture ...
[11:42:02.064] - result already collected: FutureResult
[11:42:02.064] result() for ClusterFuture ... done
[11:42:02.064] result() for ClusterFuture ...
[11:42:02.064] - result already collected: FutureResult
[11:42:02.064] result() for ClusterFuture ... done
[11:42:02.064] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.064] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.065] signalConditionsASAP(MultisessionFuture, pos=85) ... done
[11:42:02.065]  length: 5 (resolved future 85)
[11:42:02.065] Future #86
[11:42:02.065] result() for ClusterFuture ...
[11:42:02.065] - result already collected: FutureResult
[11:42:02.065] result() for ClusterFuture ... done
[11:42:02.065] result() for ClusterFuture ...
[11:42:02.065] - result already collected: FutureResult
[11:42:02.065] result() for ClusterFuture ... done
[11:42:02.065] signalConditionsASAP(MultisessionFuture, pos=86) ...
[11:42:02.065] - nx: 90
[11:42:02.065] - relay: TRUE
[11:42:02.065] - stdout: TRUE
[11:42:02.065] - signal: TRUE
[11:42:02.065] - resignal: FALSE
[11:42:02.065] - force: TRUE
[11:42:02.065] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.065] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:42:02.066]  - until=86
[11:42:02.066]  - relaying element #86
[11:42:02.066] result() for ClusterFuture ...
[11:42:02.066] - result already collected: FutureResult
[11:42:02.066] result() for ClusterFuture ... done
[11:42:02.066] result() for ClusterFuture ...
[11:42:02.066] - result already collected: FutureResult
[11:42:02.066] result() for ClusterFuture ... done
[11:42:02.066] result() for ClusterFuture ...
[11:42:02.066] - result already collected: FutureResult
[11:42:02.066] result() for ClusterFuture ... done
[11:42:02.066] result() for ClusterFuture ...
[11:42:02.066] - result already collected: FutureResult
[11:42:02.066] result() for ClusterFuture ... done
[11:42:02.066] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:42:02.066] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:42:02.066] signalConditionsASAP(MultisessionFuture, pos=86) ... done
[11:42:02.066]  length: 4 (resolved future 86)
[11:42:02.067] Future #87
[11:42:02.067] result() for ClusterFuture ...
[11:42:02.067] - result already collected: FutureResult
[11:42:02.067] result() for ClusterFuture ... done
[11:42:02.067] result() for ClusterFuture ...
[11:42:02.067] - result already collected: FutureResult
[11:42:02.067] result() for ClusterFuture ... done
[11:42:02.067] signalConditionsASAP(MultisessionFuture, pos=87) ...
[11:42:02.067] - nx: 90
[11:42:02.067] - relay: TRUE
[11:42:02.067] - stdout: TRUE
[11:42:02.067] - signal: TRUE
[11:42:02.067] - resignal: FALSE
[11:42:02.067] - force: TRUE
[11:42:02.067] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:42:02.067] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:42:02.067]  - until=87
[11:42:02.067]  - relaying element #87
[11:42:02.068] result() for ClusterFuture ...
[11:42:02.068] - result already collected: FutureResult
[11:42:02.068] result() for ClusterFuture ... done
[11:42:02.068] result() for ClusterFuture ...
[11:42:02.068] - result already collected: FutureResult
[11:42:02.068] result() for ClusterFuture ... done
[11:42:02.068] result() for ClusterFuture ...
[11:42:02.068] - result already collected: FutureResult
[11:42:02.068] result() for ClusterFuture ... done
[11:42:02.068] result() for ClusterFuture ...
[11:42:02.068] - result already collected: FutureResult
[11:42:02.068] result() for ClusterFuture ... done
[11:42:02.068] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:42:02.068] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:42:02.068] signalConditionsASAP(MultisessionFuture, pos=87) ... done
[11:42:02.068]  length: 3 (resolved future 87)
[11:42:02.069] Future #88
[11:42:02.069] result() for ClusterFuture ...
[11:42:02.069] - result already collected: FutureResult
[11:42:02.069] result() for ClusterFuture ... done
[11:42:02.069] result() for ClusterFuture ...
[11:42:02.069] - result already collected: FutureResult
[11:42:02.069] result() for ClusterFuture ... done
[11:42:02.069] signalConditionsASAP(MultisessionFuture, pos=88) ...
[11:42:02.069] - nx: 90
[11:42:02.069] - relay: TRUE
[11:42:02.069] - stdout: TRUE
[11:42:02.069] - signal: TRUE
[11:42:02.069] - resignal: FALSE
[11:42:02.069] - force: TRUE
[11:42:02.069] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:42:02.070] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:42:02.070]  - until=88
[11:42:02.070]  - relaying element #88
[11:42:02.070] result() for ClusterFuture ...
[11:42:02.070] - result already collected: FutureResult
[11:42:02.070] result() for ClusterFuture ... done
[11:42:02.070] result() for ClusterFuture ...
[11:42:02.070] - result already collected: FutureResult
[11:42:02.070] result() for ClusterFuture ... done
[11:42:02.070] result() for ClusterFuture ...
[11:42:02.070] - result already collected: FutureResult
[11:42:02.070] result() for ClusterFuture ... done
[11:42:02.070] result() for ClusterFuture ...
[11:42:02.070] - result already collected: FutureResult
[11:42:02.070] result() for ClusterFuture ... done
[11:42:02.070] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:42:02.071] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:42:02.071] signalConditionsASAP(MultisessionFuture, pos=88) ... done
[11:42:02.071]  length: 2 (resolved future 88)
[11:42:02.071] receiveMessageFromWorker() for ClusterFuture ...
[11:42:02.071] - Validating connection of MultisessionFuture
[11:42:02.072] - received message: FutureResult
[11:42:02.072] - Received FutureResult
[11:42:02.072] - Erased future from FutureRegistry
[11:42:02.072] result() for ClusterFuture ...
[11:42:02.072] - result already collected: FutureResult
[11:42:02.072] result() for ClusterFuture ... done
[11:42:02.072] receiveMessageFromWorker() for ClusterFuture ... done
[11:42:02.072] Future #89
[11:42:02.072] result() for ClusterFuture ...
[11:42:02.072] - result already collected: FutureResult
[11:42:02.072] result() for ClusterFuture ... done
[11:42:02.072] result() for ClusterFuture ...
[11:42:02.072] - result already collected: FutureResult
[11:42:02.072] result() for ClusterFuture ... done
[11:42:02.072] signalConditionsASAP(MultisessionFuture, pos=89) ...
[11:42:02.072] - nx: 90
[11:42:02.072] - relay: TRUE
[11:42:02.072] - stdout: TRUE
[11:42:02.073] - signal: TRUE
[11:42:02.073] - resignal: FALSE
[11:42:02.073] - force: TRUE
[11:42:02.073] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:42:02.073] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:42:02.073]  - until=89
[11:42:02.073]  - relaying element #89
[11:42:02.073] result() for ClusterFuture ...
[11:42:02.073] - result already collected: FutureResult
[11:42:02.073] result() for ClusterFuture ... done
[11:42:02.073] result() for ClusterFuture ...
[11:42:02.073] - result already collected: FutureResult
[11:42:02.073] result() for ClusterFuture ... done
[11:42:02.073] result() for ClusterFuture ...
[11:42:02.073] - result already collected: FutureResult
[11:42:02.073] result() for ClusterFuture ... done
[11:42:02.074] result() for ClusterFuture ...
[11:42:02.074] - result already collected: FutureResult
[11:42:02.074] result() for ClusterFuture ... done
[11:42:02.074] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:42:02.074] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:42:02.074] signalConditionsASAP(MultisessionFuture, pos=89) ... done
[11:42:02.074]  length: 1 (resolved future 89)
[11:42:02.074] receiveMessageFromWorker() for ClusterFuture ...
[11:42:02.075] - Validating connection of MultisessionFuture
[11:42:02.075] - received message: FutureResult
[11:42:02.075] - Received FutureResult
[11:42:02.075] - Erased future from FutureRegistry
[11:42:02.075] result() for ClusterFuture ...
[11:42:02.075] - result already collected: FutureResult
[11:42:02.075] result() for ClusterFuture ... done
[11:42:02.075] receiveMessageFromWorker() for ClusterFuture ... done
[11:42:02.075] Future #90
[11:42:02.075] result() for ClusterFuture ...
[11:42:02.075] - result already collected: FutureResult
[11:42:02.075] result() for ClusterFuture ... done
[11:42:02.075] result() for ClusterFuture ...
[11:42:02.075] - result already collected: FutureResult
[11:42:02.075] result() for ClusterFuture ... done
[11:42:02.076] signalConditionsASAP(MultisessionFuture, pos=90) ...
[11:42:02.076] - nx: 90
[11:42:02.076] - relay: TRUE
[11:42:02.076] - stdout: TRUE
[11:42:02.076] - signal: TRUE
[11:42:02.076] - resignal: FALSE
[11:42:02.076] - force: TRUE
[11:42:02.076] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:42:02.076] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:42:02.076]  - until=90
[11:42:02.076]  - relaying element #90
[11:42:02.076] result() for ClusterFuture ...
[11:42:02.076] - result already collected: FutureResult
[11:42:02.076] result() for ClusterFuture ... done
[11:42:02.076] result() for ClusterFuture ...
[11:42:02.076] - result already collected: FutureResult
[11:42:02.076] result() for ClusterFuture ... done
[11:42:02.077] result() for ClusterFuture ...
[11:42:02.077] - result already collected: FutureResult
[11:42:02.077] result() for ClusterFuture ... done
[11:42:02.077] result() for ClusterFuture ...
[11:42:02.077] - result already collected: FutureResult
[11:42:02.077] result() for ClusterFuture ... done
[11:42:02.077] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:42:02.077] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:42:02.077] signalConditionsASAP(MultisessionFuture, pos=90) ... done
[11:42:02.077]  length: 0 (resolved future 90)
[11:42:02.077] Relaying remaining futures
[11:42:02.077] signalConditionsASAP(NULL, pos=0) ...
[11:42:02.077] - nx: 90
[11:42:02.077] - relay: TRUE
[11:42:02.077] - stdout: TRUE
[11:42:02.077] - signal: TRUE
[11:42:02.077] - resignal: FALSE
[11:42:02.077] - force: TRUE
[11:42:02.078] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:42:02.078] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
 - flush all
[11:42:02.078] - relayed: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:42:02.078] - queued futures: [n=90] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:42:02.078] signalConditionsASAP(NULL, pos=0) ... done
[11:42:02.078] resolve() on list ... DONE
[11:42:02.078] result() for ClusterFuture ...
[11:42:02.078] - result already collected: FutureResult
[11:42:02.078] result() for ClusterFuture ... done
[11:42:02.078] result() for ClusterFuture ...
[11:42:02.078] - result already collected: FutureResult
[11:42:02.078] result() for ClusterFuture ... done
[11:42:02.078] result() for ClusterFuture ...
[11:42:02.078] - result already collected: FutureResult
[11:42:02.078] result() for ClusterFuture ... done
[11:42:02.078] result() for ClusterFuture ...
[11:42:02.079] - result already collected: FutureResult
[11:42:02.079] result() for ClusterFuture ... done
[11:42:02.079] result() for ClusterFuture ...
[11:42:02.079] - result already collected: FutureResult
[11:42:02.079] result() for ClusterFuture ... done
[11:42:02.079] result() for ClusterFuture ...
[11:42:02.079] - result already collected: FutureResult
[11:42:02.079] result() for ClusterFuture ... done
[11:42:02.079] result() for ClusterFuture ...
[11:42:02.079] - result already collected: FutureResult
[11:42:02.079] result() for ClusterFuture ... done
[11:42:02.079] result() for ClusterFuture ...
[11:42:02.079] - result already collected: FutureResult
[11:42:02.079] result() for ClusterFuture ... done
[11:42:02.079] result() for ClusterFuture ...
[11:42:02.079] - result already collected: FutureResult
[11:42:02.079] result() for ClusterFuture ... done
[11:42:02.079] result() for ClusterFuture ...
[11:42:02.079] - result already collected: FutureResult
[11:42:02.079] result() for ClusterFuture ... done
[11:42:02.079] result() for ClusterFuture ...
[11:42:02.080] - result already collected: FutureResult
[11:42:02.080] result() for ClusterFuture ... done
[11:42:02.080] result() for ClusterFuture ...
[11:42:02.080] - result already collected: FutureResult
[11:42:02.080] result() for ClusterFuture ... done
[11:42:02.080] result() for ClusterFuture ...
[11:42:02.080] - result already collected: FutureResult
[11:42:02.080] result() for ClusterFuture ... done
[11:42:02.080] result() for ClusterFuture ...
[11:42:02.080] - result already collected: FutureResult
[11:42:02.080] result() for ClusterFuture ... done
[11:42:02.080] result() for ClusterFuture ...
[11:42:02.080] - result already collected: FutureResult
[11:42:02.080] result() for ClusterFuture ... done
[11:42:02.080] result() for ClusterFuture ...
[11:42:02.080] - result already collected: FutureResult
[11:42:02.080] result() for ClusterFuture ... done
[11:42:02.080] result() for ClusterFuture ...
[11:42:02.080] - result already collected: FutureResult
[11:42:02.080] result() for ClusterFuture ... done
[11:42:02.080] result() for ClusterFuture ...
[11:42:02.080] - result already collected: FutureResult
[11:42:02.080] result() for ClusterFuture ... done
[11:42:02.081] result() for ClusterFuture ...
[11:42:02.081] - result already collected: FutureResult
[11:42:02.081] result() for ClusterFuture ... done
[11:42:02.081] result() for ClusterFuture ...
[11:42:02.081] - result already collected: FutureResult
[11:42:02.081] result() for ClusterFuture ... done
[11:42:02.081] result() for ClusterFuture ...
[11:42:02.081] - result already collected: FutureResult
[11:42:02.081] result() for ClusterFuture ... done
[11:42:02.081] result() for ClusterFuture ...
[11:42:02.081] - result already collected: FutureResult
[11:42:02.081] result() for ClusterFuture ... done
[11:42:02.081] result() for ClusterFuture ...
[11:42:02.081] - result already collected: FutureResult
[11:42:02.081] result() for ClusterFuture ... done
[11:42:02.081] result() for ClusterFuture ...
[11:42:02.081] - result already collected: FutureResult
[11:42:02.081] result() for ClusterFuture ... done
[11:42:02.081] result() for ClusterFuture ...
[11:42:02.081] - result already collected: FutureResult
[11:42:02.081] result() for ClusterFuture ... done
[11:42:02.082] result() for ClusterFuture ...
[11:42:02.082] - result already collected: FutureResult
[11:42:02.082] result() for ClusterFuture ... done
[11:42:02.082] result() for ClusterFuture ...
[11:42:02.082] - result already collected: FutureResult
[11:42:02.082] result() for ClusterFuture ... done
[11:42:02.082] result() for ClusterFuture ...
[11:42:02.082] - result already collected: FutureResult
[11:42:02.082] result() for ClusterFuture ... done
[11:42:02.082] result() for ClusterFuture ...
[11:42:02.082] - result already collected: FutureResult
[11:42:02.082] result() for ClusterFuture ... done
[11:42:02.082] result() for ClusterFuture ...
[11:42:02.082] - result already collected: FutureResult
[11:42:02.082] result() for ClusterFuture ... done
[11:42:02.082] result() for ClusterFuture ...
[11:42:02.082] - result already collected: FutureResult
[11:42:02.082] result() for ClusterFuture ... done
[11:42:02.082] result() for ClusterFuture ...
[11:42:02.082] - result already collected: FutureResult
[11:42:02.082] result() for ClusterFuture ... done
[11:42:02.083] result() for ClusterFuture ...
[11:42:02.083] - result already collected: FutureResult
[11:42:02.083] result() for ClusterFuture ... done
[11:42:02.083] result() for ClusterFuture ...
[11:42:02.083] - result already collected: FutureResult
[11:42:02.083] result() for ClusterFuture ... done
[11:42:02.083] result() for ClusterFuture ...
[11:42:02.083] - result already collected: FutureResult
[11:42:02.083] result() for ClusterFuture ... done
[11:42:02.083] result() for ClusterFuture ...
[11:42:02.083] - result already collected: FutureResult
[11:42:02.083] result() for ClusterFuture ... done
[11:42:02.083] result() for ClusterFuture ...
[11:42:02.083] - result already collected: FutureResult
[11:42:02.083] result() for ClusterFuture ... done
[11:42:02.083] result() for ClusterFuture ...
[11:42:02.083] - result already collected: FutureResult
[11:42:02.083] result() for ClusterFuture ... done
[11:42:02.083] result() for ClusterFuture ...
[11:42:02.083] - result already collected: FutureResult
[11:42:02.084] result() for ClusterFuture ... done
[11:42:02.084] result() for ClusterFuture ...
[11:42:02.084] - result already collected: FutureResult
[11:42:02.084] result() for ClusterFuture ... done
[11:42:02.084] result() for ClusterFuture ...
[11:42:02.084] - result already collected: FutureResult
[11:42:02.084] result() for ClusterFuture ... done
[11:42:02.084] result() for ClusterFuture ...
[11:42:02.084] - result already collected: FutureResult
[11:42:02.084] result() for ClusterFuture ... done
[11:42:02.084] result() for ClusterFuture ...
[11:42:02.084] - result already collected: FutureResult
[11:42:02.084] result() for ClusterFuture ... done
[11:42:02.085] result() for ClusterFuture ...
[11:42:02.085] - result already collected: FutureResult
[11:42:02.085] result() for ClusterFuture ... done
[11:42:02.085] result() for ClusterFuture ...
[11:42:02.085] - result already collected: FutureResult
[11:42:02.085] result() for ClusterFuture ... done
[11:42:02.085] result() for ClusterFuture ...
[11:42:02.085] - result already collected: FutureResult
[11:42:02.085] result() for ClusterFuture ... done
[11:42:02.085] result() for ClusterFuture ...
[11:42:02.085] - result already collected: FutureResult
[11:42:02.085] result() for ClusterFuture ... done
[11:42:02.085] result() for ClusterFuture ...
[11:42:02.085] - result already collected: FutureResult
[11:42:02.085] result() for ClusterFuture ... done
[11:42:02.085] result() for ClusterFuture ...
[11:42:02.085] - result already collected: FutureResult
[11:42:02.085] result() for ClusterFuture ... done
[11:42:02.086] result() for ClusterFuture ...
[11:42:02.086] - result already collected: FutureResult
[11:42:02.086] result() for ClusterFuture ... done
[11:42:02.086] result() for ClusterFuture ...
[11:42:02.086] - result already collected: FutureResult
[11:42:02.086] result() for ClusterFuture ... done
[11:42:02.086] result() for ClusterFuture ...
[11:42:02.086] - result already collected: FutureResult
[11:42:02.086] result() for ClusterFuture ... done
[11:42:02.086] result() for ClusterFuture ...
[11:42:02.086] - result already collected: FutureResult
[11:42:02.086] result() for ClusterFuture ... done
[11:42:02.086] result() for ClusterFuture ...
[11:42:02.086] - result already collected: FutureResult
[11:42:02.086] result() for ClusterFuture ... done
[11:42:02.086] result() for ClusterFuture ...
[11:42:02.090] - result already collected: FutureResult
[11:42:02.091] result() for ClusterFuture ... done
[11:42:02.091] result() for ClusterFuture ...
[11:42:02.091] - result already collected: FutureResult
[11:42:02.091] result() for ClusterFuture ... done
[11:42:02.091] result() for ClusterFuture ...
[11:42:02.091] - result already collected: FutureResult
[11:42:02.091] result() for ClusterFuture ... done
[11:42:02.092] result() for ClusterFuture ...
[11:42:02.092] - result already collected: FutureResult
[11:42:02.092] result() for ClusterFuture ... done
[11:42:02.092] result() for ClusterFuture ...
[11:42:02.092] - result already collected: FutureResult
[11:42:02.092] result() for ClusterFuture ... done
[11:42:02.092] result() for ClusterFuture ...
[11:42:02.092] - result already collected: FutureResult
[11:42:02.092] result() for ClusterFuture ... done
[11:42:02.092] result() for ClusterFuture ...
[11:42:02.092] - result already collected: FutureResult
[11:42:02.092] result() for ClusterFuture ... done
[11:42:02.093] result() for ClusterFuture ...
[11:42:02.093] - result already collected: FutureResult
[11:42:02.093] result() for ClusterFuture ... done
[11:42:02.093] result() for ClusterFuture ...
[11:42:02.093] - result already collected: FutureResult
[11:42:02.093] result() for ClusterFuture ... done
[11:42:02.093] result() for ClusterFuture ...
[11:42:02.093] - result already collected: FutureResult
[11:42:02.093] result() for ClusterFuture ... done
[11:42:02.093] result() for ClusterFuture ...
[11:42:02.094] - result already collected: FutureResult
[11:42:02.094] result() for ClusterFuture ... done
[11:42:02.094] result() for ClusterFuture ...
[11:42:02.094] - result already collected: FutureResult
[11:42:02.094] result() for ClusterFuture ... done
[11:42:02.094] result() for ClusterFuture ...
[11:42:02.094] - result already collected: FutureResult
[11:42:02.094] result() for ClusterFuture ... done
[11:42:02.094] result() for ClusterFuture ...
[11:42:02.094] - result already collected: FutureResult
[11:42:02.094] result() for ClusterFuture ... done
[11:42:02.094] result() for ClusterFuture ...
[11:42:02.094] - result already collected: FutureResult
[11:42:02.095] result() for ClusterFuture ... done
[11:42:02.095] result() for ClusterFuture ...
[11:42:02.095] - result already collected: FutureResult
[11:42:02.095] result() for ClusterFuture ... done
[11:42:02.095] result() for ClusterFuture ...
[11:42:02.095] - result already collected: FutureResult
[11:42:02.095] result() for ClusterFuture ... done
[11:42:02.095] result() for ClusterFuture ...
[11:42:02.095] - result already collected: FutureResult
[11:42:02.095] result() for ClusterFuture ... done
[11:42:02.095] result() for ClusterFuture ...
[11:42:02.095] - result already collected: FutureResult
[11:42:02.095] result() for ClusterFuture ... done
[11:42:02.095] result() for ClusterFuture ...
[11:42:02.095] - result already collected: FutureResult
[11:42:02.095] result() for ClusterFuture ... done
[11:42:02.095] result() for ClusterFuture ...
[11:42:02.095] - result already collected: FutureResult
[11:42:02.096] result() for ClusterFuture ... done
[11:42:02.096] result() for ClusterFuture ...
[11:42:02.096] - result already collected: FutureResult
[11:42:02.096] result() for ClusterFuture ... done
[11:42:02.096] result() for ClusterFuture ...
[11:42:02.096] - result already collected: FutureResult
[11:42:02.096] result() for ClusterFuture ... done
[11:42:02.096] result() for ClusterFuture ...
[11:42:02.096] - result already collected: FutureResult
[11:42:02.096] result() for ClusterFuture ... done
[11:42:02.096] result() for ClusterFuture ...
[11:42:02.096] - result already collected: FutureResult
[11:42:02.096] result() for ClusterFuture ... done
[11:42:02.096] result() for ClusterFuture ...
[11:42:02.096] - result already collected: FutureResult
[11:42:02.096] result() for ClusterFuture ... done
[11:42:02.096] result() for ClusterFuture ...
[11:42:02.096] - result already collected: FutureResult
[11:42:02.096] result() for ClusterFuture ... done
[11:42:02.096] result() for ClusterFuture ...
[11:42:02.096] - result already collected: FutureResult
[11:42:02.096] result() for ClusterFuture ... done
[11:42:02.096] result() for ClusterFuture ...
[11:42:02.097] - result already collected: FutureResult
[11:42:02.097] result() for ClusterFuture ... done
[11:42:02.097] result() for ClusterFuture ...
[11:42:02.097] - result already collected: FutureResult
[11:42:02.097] result() for ClusterFuture ... done
[11:42:02.097] result() for ClusterFuture ...
[11:42:02.097] - result already collected: FutureResult
[11:42:02.097] result() for ClusterFuture ... done
[11:42:02.097] result() for ClusterFuture ...
[11:42:02.097] - result already collected: FutureResult
[11:42:02.097] result() for ClusterFuture ... done
[11:42:02.097] result() for ClusterFuture ...
[11:42:02.097] - result already collected: FutureResult
[11:42:02.097] result() for ClusterFuture ... done
[11:42:02.097] result() for ClusterFuture ...
[11:42:02.097] - result already collected: FutureResult
[11:42:02.097] result() for ClusterFuture ... done
[11:42:02.097] result() for ClusterFuture ...
[11:42:02.097] - result already collected: FutureResult
[11:42:02.097] result() for ClusterFuture ... done
[11:42:02.097] result() for ClusterFuture ...
[11:42:02.097] - result already collected: FutureResult
[11:42:02.097] result() for ClusterFuture ... done
[11:42:02.098] result() for ClusterFuture ...
[11:42:02.098] - result already collected: FutureResult
[11:42:02.098] result() for ClusterFuture ... done
[11:42:02.098] result() for ClusterFuture ...
[11:42:02.098] - result already collected: FutureResult
[11:42:02.098] result() for ClusterFuture ... done
[11:42:02.098] result() for ClusterFuture ...
[11:42:02.098] - result already collected: FutureResult
[11:42:02.098] result() for ClusterFuture ... done
[11:42:02.098] result() for ClusterFuture ...
[11:42:02.098] - result already collected: FutureResult
[11:42:02.098] result() for ClusterFuture ... done
[11:42:02.098] result() for ClusterFuture ...
[11:42:02.098] - result already collected: FutureResult
[11:42:02.098] result() for ClusterFuture ... done
[11:42:02.098] result() for ClusterFuture ...
[11:42:02.098] - result already collected: FutureResult
[11:42:02.098] result() for ClusterFuture ... done
[11:42:02.098] result() for ClusterFuture ...
[11:42:02.098] - result already collected: FutureResult
[11:42:02.098] result() for ClusterFuture ... done
[11:42:02.099] result() for ClusterFuture ...
[11:42:02.099] - result already collected: FutureResult
[11:42:02.099] result() for ClusterFuture ... done
[11:42:02.099] result() for ClusterFuture ...
[11:42:02.099] - result already collected: FutureResult
[11:42:02.099] result() for ClusterFuture ... done
[11:42:02.099] result() for ClusterFuture ...
[11:42:02.099] - result already collected: FutureResult
[11:42:02.099] result() for ClusterFuture ... done
[11:42:02.099] result() for ClusterFuture ...
[11:42:02.099] - result already collected: FutureResult
[11:42:02.099] result() for ClusterFuture ... done
[11:42:02.099] result() for ClusterFuture ...
[11:42:02.099] - result already collected: FutureResult
[11:42:02.099] result() for ClusterFuture ... done
[11:42:02.099] result() for ClusterFuture ...
[11:42:02.099] - result already collected: FutureResult
[11:42:02.099] result() for ClusterFuture ... done
[11:42:02.099] result() for ClusterFuture ...
[11:42:02.100] - result already collected: FutureResult
[11:42:02.100] result() for ClusterFuture ... done
[11:42:02.100] result() for ClusterFuture ...
[11:42:02.100] - result already collected: FutureResult
[11:42:02.100] result() for ClusterFuture ... done
[11:42:02.100] result() for ClusterFuture ...
[11:42:02.100] - result already collected: FutureResult
[11:42:02.100] result() for ClusterFuture ... done
[11:42:02.100] result() for ClusterFuture ...
[11:42:02.100] - result already collected: FutureResult
[11:42:02.100] result() for ClusterFuture ... done
[11:42:02.100] result() for ClusterFuture ...
[11:42:02.100] - result already collected: FutureResult
[11:42:02.100] result() for ClusterFuture ... done
[11:42:02.100] result() for ClusterFuture ...
[11:42:02.100] - result already collected: FutureResult
[11:42:02.100] result() for ClusterFuture ... done
[11:42:02.100] result() for ClusterFuture ...
[11:42:02.100] - result already collected: FutureResult
[11:42:02.100] result() for ClusterFuture ... done
[11:42:02.100] result() for ClusterFuture ...
[11:42:02.101] - result already collected: FutureResult
[11:42:02.101] result() for ClusterFuture ... done
[11:42:02.101] result() for ClusterFuture ...
[11:42:02.101] - result already collected: FutureResult
[11:42:02.101] result() for ClusterFuture ... done
[11:42:02.101] result() for ClusterFuture ...
[11:42:02.101] - result already collected: FutureResult
[11:42:02.101] result() for ClusterFuture ... done
[11:42:02.101] result() for ClusterFuture ...
[11:42:02.101] - result already collected: FutureResult
[11:42:02.101] result() for ClusterFuture ... done
[11:42:02.101] result() for ClusterFuture ...
[11:42:02.101] - result already collected: FutureResult
[11:42:02.101] result() for ClusterFuture ... done
[11:42:02.101] result() for ClusterFuture ...
[11:42:02.101] - result already collected: FutureResult
[11:42:02.101] result() for ClusterFuture ... done
[11:42:02.101] result() for ClusterFuture ...
[11:42:02.101] - result already collected: FutureResult
[11:42:02.101] result() for ClusterFuture ... done
[11:42:02.101] result() for ClusterFuture ...
[11:42:02.101] - result already collected: FutureResult
[11:42:02.102] result() for ClusterFuture ... done
[11:42:02.102] result() for ClusterFuture ...
[11:42:02.102] - result already collected: FutureResult
[11:42:02.102] result() for ClusterFuture ... done
[11:42:02.102] result() for ClusterFuture ...
[11:42:02.102] - result already collected: FutureResult
[11:42:02.102] result() for ClusterFuture ... done
[11:42:02.102] result() for ClusterFuture ...
[11:42:02.102] - result already collected: FutureResult
[11:42:02.102] result() for ClusterFuture ... done
[11:42:02.102] result() for ClusterFuture ...
[11:42:02.102] - result already collected: FutureResult
[11:42:02.102] result() for ClusterFuture ... done
[11:42:02.102] result() for ClusterFuture ...
[11:42:02.102] - result already collected: FutureResult
[11:42:02.102] result() for ClusterFuture ... done
[11:42:02.102] result() for ClusterFuture ...
[11:42:02.102] - result already collected: FutureResult
[11:42:02.102] result() for ClusterFuture ... done
[11:42:02.103] result() for ClusterFuture ...
[11:42:02.103] - result already collected: FutureResult
[11:42:02.103] result() for ClusterFuture ... done
[11:42:02.103] result() for ClusterFuture ...
[11:42:02.103] - result already collected: FutureResult
[11:42:02.103] result() for ClusterFuture ... done
[11:42:02.103] result() for ClusterFuture ...
[11:42:02.103] - result already collected: FutureResult
[11:42:02.103] result() for ClusterFuture ... done
[11:42:02.103] result() for ClusterFuture ...
[11:42:02.103] - result already collected: FutureResult
[11:42:02.103] result() for ClusterFuture ... done
[11:42:02.103] result() for ClusterFuture ...
[11:42:02.103] - result already collected: FutureResult
[11:42:02.103] result() for ClusterFuture ... done
[11:42:02.103] result() for ClusterFuture ...
[11:42:02.103] - result already collected: FutureResult
[11:42:02.103] result() for ClusterFuture ... done
[11:42:02.104] result() for ClusterFuture ...
[11:42:02.104] - result already collected: FutureResult
[11:42:02.104] result() for ClusterFuture ... done
[11:42:02.104] result() for ClusterFuture ...
[11:42:02.104] - result already collected: FutureResult
[11:42:02.104] result() for ClusterFuture ... done
[11:42:02.104] result() for ClusterFuture ...
[11:42:02.104] - result already collected: FutureResult
[11:42:02.104] result() for ClusterFuture ... done
[11:42:02.104] result() for ClusterFuture ...
[11:42:02.104] - result already collected: FutureResult
[11:42:02.104] result() for ClusterFuture ... done
[11:42:02.104] result() for ClusterFuture ...
[11:42:02.104] - result already collected: FutureResult
[11:42:02.104] result() for ClusterFuture ... done
[11:42:02.104] result() for ClusterFuture ...
[11:42:02.104] - result already collected: FutureResult
[11:42:02.104] result() for ClusterFuture ... done
[11:42:02.104] result() for ClusterFuture ...
[11:42:02.105] - result already collected: FutureResult
[11:42:02.105] result() for ClusterFuture ... done
[11:42:02.105] result() for ClusterFuture ...
[11:42:02.105] - result already collected: FutureResult
[11:42:02.105] result() for ClusterFuture ... done
[11:42:02.105] result() for ClusterFuture ...
[11:42:02.105] - result already collected: FutureResult
[11:42:02.105] result() for ClusterFuture ... done
[11:42:02.105] result() for ClusterFuture ...
[11:42:02.105] - result already collected: FutureResult
[11:42:02.105] result() for ClusterFuture ... done
[11:42:02.105] result() for ClusterFuture ...
[11:42:02.105] - result already collected: FutureResult
[11:42:02.105] result() for ClusterFuture ... done
[11:42:02.105] result() for ClusterFuture ...
[11:42:02.105] - result already collected: FutureResult
[11:42:02.105] result() for ClusterFuture ... done
[11:42:02.105] result() for ClusterFuture ...
[11:42:02.105] - result already collected: FutureResult
[11:42:02.105] result() for ClusterFuture ... done
[11:42:02.105] result() for ClusterFuture ...
[11:42:02.106] - result already collected: FutureResult
[11:42:02.106] result() for ClusterFuture ... done
[11:42:02.106] result() for ClusterFuture ...
[11:42:02.106] - result already collected: FutureResult
[11:42:02.106] result() for ClusterFuture ... done
[11:42:02.106] result() for ClusterFuture ...
[11:42:02.106] - result already collected: FutureResult
[11:42:02.106] result() for ClusterFuture ... done
[11:42:02.106] result() for ClusterFuture ...
[11:42:02.106] - result already collected: FutureResult
[11:42:02.106] result() for ClusterFuture ... done
[11:42:02.106] result() for ClusterFuture ...
[11:42:02.106] - result already collected: FutureResult
[11:42:02.106] result() for ClusterFuture ... done
[11:42:02.106] result() for ClusterFuture ...
[11:42:02.106] - result already collected: FutureResult
[11:42:02.106] result() for ClusterFuture ... done
[11:42:02.106] result() for ClusterFuture ...
[11:42:02.106] - result already collected: FutureResult
[11:42:02.106] result() for ClusterFuture ... done
[11:42:02.107] result() for ClusterFuture ...
[11:42:02.107] - result already collected: FutureResult
[11:42:02.107] result() for ClusterFuture ... done
[11:42:02.107] result() for ClusterFuture ...
[11:42:02.107] - result already collected: FutureResult
[11:42:02.107] result() for ClusterFuture ... done
[11:42:02.107] result() for ClusterFuture ...
[11:42:02.107] - result already collected: FutureResult
[11:42:02.107] result() for ClusterFuture ... done
[11:42:02.107] result() for ClusterFuture ...
[11:42:02.107] - result already collected: FutureResult
[11:42:02.107] result() for ClusterFuture ... done
[11:42:02.107] result() for ClusterFuture ...
[11:42:02.107] - result already collected: FutureResult
[11:42:02.107] result() for ClusterFuture ... done
[11:42:02.107] result() for ClusterFuture ...
[11:42:02.107] - result already collected: FutureResult
[11:42:02.107] result() for ClusterFuture ... done
[11:42:02.107] result() for ClusterFuture ...
[11:42:02.107] - result already collected: FutureResult
[11:42:02.108] result() for ClusterFuture ... done
[11:42:02.108] result() for ClusterFuture ...
[11:42:02.108] - result already collected: FutureResult
[11:42:02.108] result() for ClusterFuture ... done
[11:42:02.108] result() for ClusterFuture ...
[11:42:02.108] - result already collected: FutureResult
[11:42:02.108] result() for ClusterFuture ... done
[11:42:02.108] result() for ClusterFuture ...
[11:42:02.108] - result already collected: FutureResult
[11:42:02.108] result() for ClusterFuture ... done
[11:42:02.108] result() for ClusterFuture ...
[11:42:02.108] - result already collected: FutureResult
[11:42:02.108] result() for ClusterFuture ... done
[11:42:02.108] result() for ClusterFuture ...
[11:42:02.108] - result already collected: FutureResult
[11:42:02.108] result() for ClusterFuture ... done
[11:42:02.108] result() for ClusterFuture ...
[11:42:02.108] - result already collected: FutureResult
[11:42:02.108] result() for ClusterFuture ... done
[11:42:02.108] result() for ClusterFuture ...
[11:42:02.108] - result already collected: FutureResult
[11:42:02.109] result() for ClusterFuture ... done
[11:42:02.109] result() for ClusterFuture ...
[11:42:02.109] - result already collected: FutureResult
[11:42:02.109] result() for ClusterFuture ... done
[11:42:02.109] result() for ClusterFuture ...
[11:42:02.109] - result already collected: FutureResult
[11:42:02.109] result() for ClusterFuture ... done
[11:42:02.109] result() for ClusterFuture ...
[11:42:02.109] - result already collected: FutureResult
[11:42:02.109] result() for ClusterFuture ... done
[11:42:02.109] result() for ClusterFuture ...
[11:42:02.109] - result already collected: FutureResult
[11:42:02.109] result() for ClusterFuture ... done
[11:42:02.109] result() for ClusterFuture ...
[11:42:02.109] - result already collected: FutureResult
[11:42:02.109] result() for ClusterFuture ... done
[11:42:02.109] result() for ClusterFuture ...
[11:42:02.109] - result already collected: FutureResult
[11:42:02.109] result() for ClusterFuture ... done
[11:42:02.110] result() for ClusterFuture ...
[11:42:02.110] - result already collected: FutureResult
[11:42:02.110] result() for ClusterFuture ... done
[11:42:02.110] result() for ClusterFuture ...
[11:42:02.110] - result already collected: FutureResult
[11:42:02.110] result() for ClusterFuture ... done
[11:42:02.110] result() for ClusterFuture ...
[11:42:02.110] - result already collected: FutureResult
[11:42:02.110] result() for ClusterFuture ... done
[11:42:02.110] result() for ClusterFuture ...
[11:42:02.110] - result already collected: FutureResult
[11:42:02.110] result() for ClusterFuture ... done
[11:42:02.110] result() for ClusterFuture ...
[11:42:02.110] - result already collected: FutureResult
[11:42:02.110] result() for ClusterFuture ... done
[11:42:02.110] result() for ClusterFuture ...
[11:42:02.110] - result already collected: FutureResult
[11:42:02.110] result() for ClusterFuture ... done
[11:42:02.110] result() for ClusterFuture ...
[11:42:02.110] - result already collected: FutureResult
[11:42:02.110] result() for ClusterFuture ... done
[11:42:02.111] result() for ClusterFuture ...
[11:42:02.111] - result already collected: FutureResult
[11:42:02.111] result() for ClusterFuture ... done
[11:42:02.111] result() for ClusterFuture ...
[11:42:02.111] - result already collected: FutureResult
[11:42:02.111] result() for ClusterFuture ... done
[11:42:02.111] result() for ClusterFuture ...
[11:42:02.111] - result already collected: FutureResult
[11:42:02.111] result() for ClusterFuture ... done
[11:42:02.111]  - Number of value chunks collected: 90
[11:42:02.111] Resolving 90 futures (chunks) ... DONE
[11:42:02.111] Reducing values from 90 chunks ...
[11:42:02.111]  - Number of values collected after concatenation: 90
[11:42:02.111]  - Number of values expected: 90
[11:42:02.111] Reducing values from 90 chunks ... DONE
[11:42:02.111] future_mapply() ... DONE
<ResampleResult> with 90 resampling iterations
 task_id    learner_id resampling_id iteration warnings errors
    pima classif.rpart   repeated_cv         1        0      0
    pima classif.rpart   repeated_cv         2        0      0
    pima classif.rpart   repeated_cv         3        0      0
    pima classif.rpart   repeated_cv         4        0      0
    pima classif.rpart   repeated_cv         5        0      0
    pima classif.rpart   repeated_cv         6        0      0
    pima classif.rpart   repeated_cv         7        0      0
    pima classif.rpart   repeated_cv         8        0      0
    pima classif.rpart   repeated_cv         9        0      0
    pima classif.rpart   repeated_cv        10        0      0
    pima classif.rpart   repeated_cv        11        0      0
    pima classif.rpart   repeated_cv        12        0      0
    pima classif.rpart   repeated_cv        13        0      0
    pima classif.rpart   repeated_cv        14        0      0
    pima classif.rpart   repeated_cv        15        0      0
    pima classif.rpart   repeated_cv        16        0      0
    pima classif.rpart   repeated_cv        17        0      0
    pima classif.rpart   repeated_cv        18        0      0
    pima classif.rpart   repeated_cv        19        0      0
    pima classif.rpart   repeated_cv        20        0      0
    pima classif.rpart   repeated_cv        21        0      0
    pima classif.rpart   repeated_cv        22        0      0
    pima classif.rpart   repeated_cv        23        0      0
    pima classif.rpart   repeated_cv        24        0      0
    pima classif.rpart   repeated_cv        25        0      0
    pima classif.rpart   repeated_cv        26        0      0
    pima classif.rpart   repeated_cv        27        0      0
    pima classif.rpart   repeated_cv        28        0      0
    pima classif.rpart   repeated_cv        29        0      0
    pima classif.rpart   repeated_cv        30        0      0
    pima classif.rpart   repeated_cv        31        0      0
    pima classif.rpart   repeated_cv        32        0      0
    pima classif.rpart   repeated_cv        33        0      0
    pima classif.rpart   repeated_cv        34        0      0
    pima classif.rpart   repeated_cv        35        0      0
    pima classif.rpart   repeated_cv        36        0      0
    pima classif.rpart   repeated_cv        37        0      0
    pima classif.rpart   repeated_cv        38        0      0
    pima classif.rpart   repeated_cv        39        0      0
    pima classif.rpart   repeated_cv        40        0      0
    pima classif.rpart   repeated_cv        41        0      0
    pima classif.rpart   repeated_cv        42        0      0
    pima classif.rpart   repeated_cv        43        0      0
    pima classif.rpart   repeated_cv        44        0      0
    pima classif.rpart   repeated_cv        45        0      0
    pima classif.rpart   repeated_cv        46        0      0
    pima classif.rpart   repeated_cv        47        0      0
    pima classif.rpart   repeated_cv        48        0      0
    pima classif.rpart   repeated_cv        49        0      0
    pima classif.rpart   repeated_cv        50        0      0
    pima classif.rpart   repeated_cv        51        0      0
    pima classif.rpart   repeated_cv        52        0      0
    pima classif.rpart   repeated_cv        53        0      0
    pima classif.rpart   repeated_cv        54        0      0
    pima classif.rpart   repeated_cv        55        0      0
    pima classif.rpart   repeated_cv        56        0      0
    pima classif.rpart   repeated_cv        57        0      0
    pima classif.rpart   repeated_cv        58        0      0
    pima classif.rpart   repeated_cv        59        0      0
    pima classif.rpart   repeated_cv        60        0      0
    pima classif.rpart   repeated_cv        61        0      0
    pima classif.rpart   repeated_cv        62        0      0
    pima classif.rpart   repeated_cv        63        0      0
    pima classif.rpart   repeated_cv        64        0      0
    pima classif.rpart   repeated_cv        65        0      0
    pima classif.rpart   repeated_cv        66        0      0
    pima classif.rpart   repeated_cv        67        0      0
    pima classif.rpart   repeated_cv        68        0      0
    pima classif.rpart   repeated_cv        69        0      0
    pima classif.rpart   repeated_cv        70        0      0
    pima classif.rpart   repeated_cv        71        0      0
    pima classif.rpart   repeated_cv        72        0      0
    pima classif.rpart   repeated_cv        73        0      0
    pima classif.rpart   repeated_cv        74        0      0
    pima classif.rpart   repeated_cv        75        0      0
    pima classif.rpart   repeated_cv        76        0      0
    pima classif.rpart   repeated_cv        77        0      0
    pima classif.rpart   repeated_cv        78        0      0
    pima classif.rpart   repeated_cv        79        0      0
    pima classif.rpart   repeated_cv        80        0      0
    pima classif.rpart   repeated_cv        81        0      0
    pima classif.rpart   repeated_cv        82        0      0
    pima classif.rpart   repeated_cv        83        0      0
    pima classif.rpart   repeated_cv        84        0      0
    pima classif.rpart   repeated_cv        85        0      0
    pima classif.rpart   repeated_cv        86        0      0
    pima classif.rpart   repeated_cv        87        0      0
    pima classif.rpart   repeated_cv        88        0      0
    pima classif.rpart   repeated_cv        89        0      0
    pima classif.rpart   repeated_cv        90        0      0
 task_id    learner_id resampling_id iteration warnings errors
data.table 1.14.8 using 6 threads (see ?getDTthreads).  Latest news: r-datatable.com
INFO  [11:47:07.829] [rush] Sending 2 tasks(s)
   user  system elapsed 
  0.002   0.000   0.002 
INFO  [11:47:10.487] [rush] Sending 2 tasks(s)
   user  system elapsed 
  0.002   0.000   0.003 

